% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Apply.R
\name{interpolateArguments}
\alias{interpolateArguments}
\title{Change or insert values in an expression}
\usage{
interpolateArguments(quo, namedArgs)
}
\arguments{
\item{namedArgs}{A list of named arguments. Unnamed arguments are simply ignored.}

\item{expr}{A unevaluated expression object.}
}
\description{
This function can be used to modify arguments to a functions
within an existing expression (or quosure/formula).
}
\details{
\code{interpolateArguments} inteprets named value in its \code{namedArgs}
argument in one of two ways: If the named value is a list, it interprets
the name of the list as a function call, and inserts/swaps any arguments
in that list into any instances of that function call within the \code{expr}.
Named arguments are inserted or substituted if already present in expression.
Unnamed argmuments are simply added to the call.
Examples:\preformatted{myexpr <- quote(dnorm(x, mean = 5))
interpolateArguments(myexpr, list(dnorm = list(mean = 2, sd = 5, TRUE)))

# result is new expresson: dnorm(x, mean = 2, sd = 5, TRUE)
}

If a named valued in the \code{namedArgs} argument is not a list,
that name/value pair is substituted anywhere it is present in the expression.
This approach is often more conscise, but arguments cannot be added to an
expression this way, only substituted if already present.
Examples:\preformatted{myexpr <- quote(dnorm(x, mean = 5))
interpolateArguments(myexpr, mean = 2)

# result is new expression: dnorm(x, mean = 2)
\}
}
}
\examples{
myexpr2 <- quote(A + b*x + rnorm(length(a), mean(Z), sd = 2))

interpolateArguments(myexpr2,
                     list(sd = 10, mean = list(na.rm = TRUE)))
                       
# result is new expression: 
# a + b*x + rnorm(length(a), mean(Z, na.rm = TRUE), sd = 10)


}
