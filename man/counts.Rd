% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Analysis.R
\name{show,counts-method}
\alias{show,counts-method}
\alias{merge.counts}
\alias{+,counts,counts-method}
\alias{-,counts,counts-method}
\alias{Ops,counts,counts-method}
\alias{sort.counts}
\alias{as.data.table.counts}
\alias{as.data.frame.counts}
\alias{counts}
\alias{count.humdrumR}
\alias{count.default}
\alias{count.table}
\alias{table}
\alias{table,token-method}
\alias{table,humdrumR-method}
\alias{as.table.counts}
\alias{table,counts-method}
\alias{as.data.frame.probabilityDistribution}
\title{Tabulate and/or cross-tabulate data}
\usage{
\S4method{show}{counts}(object)

\method{merge}{counts}(x, y)

\S4method{+}{counts,counts}(e1, e2)

\S4method{-}{counts,counts}(e1, e2)

\S4method{Ops}{counts,counts}(e1, e2)

sort.counts(x, decreasing = TRUE)

\method{as.data.table}{counts}(x)

as.data.frame.counts(x)

\method{count}{humdrumR}(x, ..., sort = FALSE, na.rm = FALSE, exclude = NULL, .drop = FALSE)

\method{count}{default}(..., sort = FALSE, na.rm = FALSE, exclude = NULL, .drop = FALSE)

\method{count}{table}(..., sort = FALSE, na.rm = FALSE, exclude = NULL, .drop = FALSE)

table(
  ...,
  exclude = if (useNA == "no") c(NA, NaN),
  useNA = c("no", "ifany", "always"),
  dnn = list.names(...),
  deparse.level = 1
)

\S4method{table}{token}(
  ...,
  exclude = if (useNA == "no") c(NA, NaN),
  useNA = "no",
  dnn = names(list(...)),
  deparse.level = 1
)

\S4method{table}{humdrumR}(
  ...,
  exclude = if (useNA == "no") c(NA, NaN),
  useNA = "no",
  dnn = names(list(...)),
  deparse.level = 1
)

\method{as.table}{counts}(x)

\S4method{table}{counts}(
  ...,
  exclude = if (useNA == "no") c(NA, NaN),
  useNA = c("no", "ifany", "always"),
  dnn = list.names(...),
  deparse.level = 1
)

as.data.frame.probabilityDistribution(x, ...)
}
\description{
The \code{count()} function is exactly like R's fundamental \link[base:table]{table()} function,
except that 1) will give special treatment to humdrumR \code{\link[=token]{token()}} data 2)
has more intuitive/simple argument names 3) makes it easier to combine/manipulate
disparate output tables.
}
\details{
The \code{count()} function is essentially a wrapper
around \link[base:table]{base::table()} function.
However, any \code{\link[=token]{token()}} class arguments are treated like \code{\link[=factors]{factors()}},
calling generating their own levels.
This assures that, for example, pitch data is tabulated in order of pitch height,
and "missing" pitches are counted as zero.

\code{count()} will, by default, count \code{NA} values if they are present---if you don't want
to count \code{NA}s, specify \code{na.rm = TRUE}.
You can also tell \code{count()} to exclude (not count) any other arbitrary values you
provide as a vector to the \code{exclude} argument.

\code{count()} will always give names to the dimensions of the table it creates.
You can specify these names directly as argument names, like \code{count(Kern = kern(Token))};
if you don't specify a name, \code{count()} will make up a name(s) based on expression(s) it is tallying.
(Note that \code{count()} does not copy \code{\link[base:table]{base::table()}}'s obtusely-named \code{dnn} or \code{deparse.level} arguments.)
}
\section{Manipulating humdrum tables}{


The output of \code{count()} is a special form of R \code{table}, a \code{counts}.
Given two or more \code{counts}s, if you apply basic R operators
(e.g., arithmetic, comparisons) or row/column binding (\code{cbind}/\code{rbind})
\code{humdrumR} will align the tables by their dimension-names before
doing the operation.
This means, that if you have two tables of pitch data, but one table includes specific pitch and other doesn't,
you can still add them together or bind them into a matrix.
See the examples!
}

\examples{

generic <- c('c', 'c', 'e', 'g', 'a', 'b', 'b', 'b')
complex <- c('c', 'c#', 'e', 'f', 'g','g#', 'g#', 'a')

genericTable   <- count(generic)
complexTable <- count(complex)

genericTable
complexTable

genericTable + complexTable

cbind(genericTable, complexTable)

}
