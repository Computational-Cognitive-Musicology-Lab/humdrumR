% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Interpretations.R, R/Read.R
\docType{data}
\name{knownInterpretations}
\alias{knownInterpretations}
\alias{readHumdrum}
\alias{findHumdrum}
\title{Find and read humdrum files into R}
\format{

}
\usage{
knownInterpretations

findHumdrum(
  ...,
  contains = NULL,
  recursive = FALSE,
  allowDuplicates = FALSE,
  verbose = FALSE
)

readHumdrum(
  ...,
  recursive = FALSE,
  contains = NULL,
  allowDuplicates = FALSE,
  verbose = FALSE,
  tandems = "known",
  reference = "all"
)
}
\arguments{
\item{...}{\code{character}: One or more regex search patterns used to identify files on the local machine. read.
For details: see the "Regex file-path matching" section below.}

\item{contains}{(\code{character}) If \code{!is.null(contains)}, the \code{contains} argument is
is treated as regular expressions: only files which contain matches to
\emph{all} of these regular expressions are matched.}

\item{recursive}{(\code{logical}, \code{length == 1}) If \code{TRUE}, the final part of
the search pattern (i.e., the file search) is searched for
recursively through all sub directories.}

\item{allowDuplicates}{(\code{logical}, \code{length == 1}) Indicates what should happen if multiple
search patterns match the same files. If \code{allowDuplicates = TRUE},
any such files are read multiple times, grouped into their respective corpora by the \code{Label} field.
If \code{allowDuplicates = FALSE}, any redundant files are only read into the corpus of the first pattern they
match.}

\item{verbose}{(\code{logical}, \verb{length == 1)} If \code{TRUE}, the names of matching files are
printed before parsing begins. This is very
useful as a check to make sure you aren't reading the wrong files!}

\item{tandems}{(\code{character}) This argument controls which, if any, tandem interpretations
are parsed into their own fields. The default value is \code{"known"}.}

\item{reference}{(\code{character}) This argument controls which, if any, reference records
are parsed into their own fields. The default value is \code{"all"}.}
}
\description{
\code{findHumdrum} does the work of finding and reading valid text files into \code{R}.
\code{readHumdrum} utilizes \code{findHumdrum} to read files, then parses them to
create a \link[=humdrumRclass]{humdrumR data object}.
}
\details{
\code{findHumdrum} searches for matching files (details in next section) on your machine and returns a "file info" \code{data.table}.
The file-info table has one row for each matched file, and six columns:
\itemize{
\item \code{Filepath} (\code{character}): The complete file path.
\item \code{Pattern} (\code{character}): The search pattern (details below) which matched the file.
\item \code{Label} (\code{character}): The "subcorpora" label identified with the search pattern. (Used as the \code{Label} field
in a \link[=humTable]{humdrum table}.)
\item \code{Files} (\code{character}): The file contents themselves, in a single string.
\item \code{FileLines} (\code{list} of \code{character}): The file contents themselves, divided into lines.
\item \code{File} (\code{integer}): A integer enumerating the files. (Used as the \code{File} field in a \link[=humTable]{humdrum table}.)
If two or more files in different directories share the same name, a unique name is created for
each file by appending the names of the directories they occupy, recursively
until the names are unique.
}

\code{readHumdrum} uses \code{findHumdrum} to identify humdrum files, then parses each file
and assembles them all into a \link[=humTable]{humdrum table} which is in turn wrapped in
a \link[=humdrumRclass]{humdrumR data object} (the final output).
The output's \code{Filepath}, \code{File}, and \code{Label} fields are taken directly from \code{findHumdrum}'s "file info" table.
If a single humdrum file has multiple pieces in it---meaning that all spine paths close with \verb{*-}, then
open again with \verb{**}---then they are parsed separately, and labeled separately in the \code{Piece} field.
If there are no multi-piece files, the \code{Piece} and \code{File} will be identical.
\subsection{Validity}{

\code{findHumdrum} and \code{readHumdrum} automatically ignore non-text files and
files that contain humdrum syntax errors.
When calling either command, messages will print in the terminal informing you about invalid files, if any.
Validity checking is performed by the separate \code{\link[=validateHumdrum]{validateHumdrum()}} function.
If you want to see specifically what errors occurred, call \code{\link[=validateHumdrum]{validateHumdrum()}}
directly.
}
}
\section{Regex file-path matching}{


Files on your local machine can be concisely identified using
\link[=https://en.wikipedia.org/wiki/Regular_expression]{regular-expression}
pattern matching.
To find/read humdrum files,
one or more \code{character} search patterns must be specified as \code{...} arguments;
A search pattern is a file-path like string, with strings separated by zero or more delimiters
(\code{/} or \verb{\\}, depending on your operating system).
Each delimited part of the string to the left of a delimiter (if any) is treated as a regular expression
matched against \emph{directories}, recursively.
The right-most part of the string (or the whole string if there are no delimiters), is matched
as a regular expression against \emph{files} in the matched directories.
The left-most directory pattern (if any) can be either relative (to \code{R}'s \link[base:getwd]{working directory}) or absolute.
(Unix-like systems can use \code{~} for home. All systems use \code{.} for the current working directory
and \code{..} for its parent.
These special keys are \emph{not} treated like regular expressions.)

Let's consider some examples:
\itemize{
\item With no delimiters (relative):
\itemize{
\item \code{readHumdrum('.*krn$')} will match all files in the current working directory which match the \verb{.*krn$} regex.
(This would be all files ending the \code{krn}.)
}
\item With one directory pattern (relative):
\itemize{
\item \code{readHumdrum('[A-G]/.*krn$')} will first match any subdirectories of the working directory which match the \verb{[A-G]} regex.
If there are any such directories, it will then search the files in \emph{all} of these matching directories for matches to \verb{.*krn$}.
}
\item Two directory patterns (absolute):
\itemize{
\item On Unix-like systems \code{readHumdrum('~/[A-G]/.*krn$')} will perform the same search as above, but in the
\emph{home} directory (\code{~}) instead of the \code{R} working directory.
}
\item With two directory patterns (relative):
\itemize{
\item \code{readHumdrum('^Krn$/[A-G]/.*krn$')} will first match the directory \code{Krn} in the working directory,
search all the subdirectories of \code{Krn} for matches to \verb{[A-G]}.
Finally, if there are any matching directories, they will \emph{all} be searched for files matching \verb{.*krn$}.
\item Note that the pattern \code{"^Krn$"} is needed to match exactly the \code{Krn} directory, and no other directory.
If used \code{"Krn"} instead, \emph{any} directory containing the string \code{Krn} would be matched; for example, \code{NoKrn} would be a match.
}
}

If you provide multiple \code{...} arguments, they are pasted together (left-to-right), separated by the system delimiter,
to create a single complete regex search pattern.
Thus, \code{readHumdrum('^Krn$', '[A-G]', '.*krn$')} is identical to \code{readHumdrum('^Krn$/[A-G]/.*krn$')}.

If you don't specify \emph{any} \code{...} arguments,
\code{findHumdrum} (or \code{readHumdrum}) will default to \code{""}, the empty regex pattern \code{""} which matches any file.
Thus, \code{readHumdrum()} will read any humdrum files in the \link[base:getwd]{working directory}.
\subsection{Multiple patterns}{

If you want to search for \emph{more than one} pattern, you can input them as a \code{character} vector:
For instance, \code{readHumdrum(c("Mozart", "Beethoven"))} will search for files
(in the working directory) matching the regexes \code{Mozart} \strong{OR} \code{Beethoven}.
This works for directories too: \code{readHumdrum(c('Mozart/.*krn', 'Beethoven/.*krn'))} will
search for files matching \code{.*krn} in directories matching \code{Mozart} or \code{Beethoven}.
For this sort of call, it can be convenient to break the search across arguments:
\code{readHumdrum(c("Mozart", "Beethoven"), ".*krn")} will give the same result.
When the multiple \code{...} arguments are appended, every possible combination of arguments is
used to create search patterns.
Thus, a call like \verb{readHumdrum(c('[A-G]', '[a-g]), c('Mozart', 'Beethoven'), '.*krn')} will search all the following
patterns:
\itemize{
\item \verb{[A-G]/Mozart/.*krn}
\item \verb{[a-g]/Mozart/.*krn}
\item \verb{[A-G]/Beethoven/.*krn}
\item \verb{[a-g]/Beethoven/.*krn}
}

When reading humdrum data, we refer to files matched from different regex patterns to be "subcorpora" of the total corpus.
The last search above would create a dataset with four subcorpora, which are tracked in the \link[=humdrumRclass]{humdrumR object's}
\code{Label} field.
By default, subcorpora are simply numbered: \code{"_1"}, \code{"_2"}, etc.
However, if pattern arguments are named, these names will show up in the \code{Label} field instead.
}

\subsection{Filter files by content}{

The \code{contains} argument can be a \code{character} vector of regular expressions
to search in the \emph{contents} of matched files (as opposed to matching the file name/path).
Is \code{contains} is not \code{NULL} (which is the default),
\code{humdrumR} searches all files matched by the regex search pattern(s) for
any matches to the \code{contains} regexes.
Files which match \strong{all} the \code{contains} regexes are read, others are discarded.

For example, the command \verb{readHumdrum(./.*krn$, contains = c('[Ee]-', '[Aa]-'))} will
read all \code{krn}-extension files in the working directory which contain E-flat \emph{and} a A-flat tokens.
}
}

\section{Tandem Interpretations}{


All tandem interpretations in a humdrum dataset are summarized in the \link[=humTable]{humdrum table's}
\code{Tandem} field, which is described in detail \link[=extractTandem]{here}.
In addition, certain "known" tandem interpretations are parsed into their \emph{own} fields automatically.
For example, \verb{*clefG4} and "\verb{*clefF2} are parsed into a \code{Clef} field,
while \verb{*k[b-]} is parsed into a \code{KeySignature} field.
The "known" tandem interpretations that \code{humdrumR} recognizes are encoded in a built-in
table called \code{knownInterpretations}, which contains five \code{character} columns:
\itemize{
\item \code{Name}: A code name \code{humdrumR} uses (e.g., \code{Clef} or \code{TimeSignatue}).
\item \code{Exclusive}: Zero or more (comma-separated) exclusive interpretations associated with the tandem interpretation.
\item \code{RE}: A regular expression which matches instances of the tandem interpretation.
\item \code{Pretty}: A readable shorthand of the tandem interpretation's pattern.
\item \code{Type}: One of three types: \code{"Tandem"}, \code{"Exclusive"}, or \code{"Atomic"}.
}

The \code{tandems} argument to \code{readHumdrum} controls which tandem interpretations are
parsed into their own fields. This can be helpful to either save processing time and memory
by \emph{not} parsing interpretations you won't need, or to parse interpretations that
\code{humdrumR} doesn't recognize.
The default value for the \code{tandems} argument is \code{"known"}. If the \code{tandems} argument
contains \code{"known"} \emph{all} tandem interpretations in the built-in \code{knownInterpretations}
table are parsed.
If you want to limit the number of interpretations that are parsed,
you may explicitly indicate known interpretations to parse by giving their \code{Name} (matching
\code{knownInterprations$Name}) in the \code{tandems} argument.
For instance, if you specify \code{tandems = c('Clef', 'TimeSignature')}, only clef (e.g., \code{"*clefG2"}),
and time signature (e.g., \code{"*M3/4"}) interpretations will be parsed.

If you want to parse novel interpreations that aren't known to \code{humdrumR},
you can alternatively specify an arbitrary regular expressions in the \code{tandem} argument.
(So long as they don't exactly match a \code{Name} from \code{knownInterpretations}.)
These regular expressions are matched against the \link[=extractTandem]{Tandem field}
and used to generate new fields for the \link[=humTable]{humdrum table}.
If any values in \code{tandems} are named, these names will be used for the resulting fields.
If no matches to an given interpretation are found, no field is created for that interpretation.
If \code{tandems = NULL}, then no tandem interpretations are parsed.
}

\section{Reference Records}{


By default (\code{reference = "all"}), humdrumR reads all reference records in the data.
The reference code for each record (e.g, the \code{"OTL"}, in \code{"!!!OTL: xxx"}) is used as the name of
an associated field.
If a reference record has no reference code (i.e., it lacks a colon), the field is called \code{"Unkeyed."}
If there are more than one reference records with the same reference code,
either explicitly numbered (e.g., \code{"!!!COM1:"}, \code{"!!!COM2:"}) or not,
a single field is created (\code{COM} in this case) with the multiple values separated by \code{";"}.
\subsection{Controlling reference parsing}{

The \code{reference} argument can be used to control which reference codes are parsed by \code{readHumdrum},
and/or rename their resulting fields.
Unless \code{reference == "all"}, only referene codes specifically indicated in \code{reference} are parsed;
For example, \verb{readHumdrum(_, reference = "OTL")} will \emph{only} parse OTL reference records.
By naming the values of \code{reference}, the resulting field name can be controled:
If we specify \code{reference = c(Title = 'OTL')}, the \code{OTL} reference records will be placed in
a field called \code{Title}.
If \code{reference = NULL}, no reference records are parsed.

In large datasets with many reference records, the reference data can actually make up a large portion
of the humdrum table, using up a lot of memory. In these cases, simply
not reading reference records (\code{reference = NULL}) or selectively reading only the reference records
that we are planning to use in our analyses can be quick and easy way to reduce memory consumption.
}
}

\section{Spines and Paths}{


At first glance, humdrum data looks like a simple two-dimensional, tab-delineated table structure.
However, the \href{http://www.humdrum.org/guide/ch05/}{humdrum syntax} is bit more complicated than that.
Wheres as two-dimensional table has stable "columns",
humdrum data has "\emph{spines}":
"Spines" \emph{can} be a single column, or they may (at any time) split into multiple "spine \emph{paths}",
which can in turn split again, using the \code{"*^"} interpretation token. The reverse can happen as well,
with two or more paths merging into a single spine, using the \code{"v"} token.
Thus the humdrum syntax is actually a flexible tree structure; As spines split and merge, the total number of "columns"
can change during a piece.
A related issue is that a "corpus" (collection) of humdrum files may have varying numbers of spines/columns between pieces.
Finally, \emph{global} comment records are also a special case, as that are always a single value, even though
they are interspersed with multi-spine \emph{local} records.)

To make parsing and manipulating humdrum data data simpler,
\code{readHumdrum} assumes a slightly restricted version of the humdrum syntax:
namely, that spines which appear at the beginning of a file (headed with exclusive interpretations
like \code{"**kern"}) can never merge into each other.
Spine merges (\code{"*v"}) can only happen within spine paths that originally split off the same spine, which means
that a humdrum file read into \code{humdrumR}
must not end with fewer columns than it starts.
This extra-strict specification of spine paths in the humdrum syntax is, fortunately, something that has been
informally followed in most humdrum data sets.

Our strict spine-path definition makes parsing humdrum data into a uniform structure possible:
Within a piece, the spines which appear at the beginning of the piece are the "true" spines throughout the piece, numbered
from left to right, starting from \code{1}.
For each \emph{local} token, the value in the \code{Spine} field is an integer indicating which of these
"true" spines it belongs to---global tokens have a \code{NA} value in their \code{Spine} field, because they do not belong to any spine.
Any spine path splits (\code{"*^"}) from the main spines form \strong{spine paths}.
Every spine's paths are numbered in the \code{Path} field, from right to left, starting from \code{0}.
A spine with no splits will have all \code{0}s in its \code{Path} field.
}

\examples{

readHumdrum() # loads all valid humdrum files in the current directory.

readHumdrum(".*krn$") # loads all files ending with "krn" in the currect directory

readHumdrum("^Composers$/^Be|^Mo/.*/^Joined$/.*krn$") 
# Goes inside the directory "Composers".
# Inside "Composers" looks for directories that start with "Be" or "Mo".
# If there are any "Be|Mo" matching directories within "Composers", matches all directories within them.
# Within these directories, looks for directories called "Joined".
# If there are any directories called "Joined", loads all files (if any) that end with "krn".

readHumdrum("^Composers$", "^Be|^Mo", ".*", "^Joined$", ".*krn$")
# exactly the same as the previous!

readHumdrum("^Composers$", c(Beethoven = "^Be", Mozart = "^Mo"), ".*", "^Joined$", ".*krn$") 
# exactly the same as the previous, except now the two matching patterns ("^Be", or "^Mo") will be grouped
# in the Label field as "Beethoven" and "Mozart" respectively.

}
\keyword{datasets}
