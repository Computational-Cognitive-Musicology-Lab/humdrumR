% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Interpretations.R, R/Read.R
\docType{data}
\name{knownInterpretations}
\alias{knownInterpretations}
\alias{readHumdrum}
\alias{findHumdrum}
\title{Find and read humdrum files into R}
\format{

}
\usage{
knownInterpretations

findHumdrum(
  ...,
  contains = NULL,
  recursive = FALSE,
  allowDuplicates = FALSE,
  verbose = FALSE
)

readHumdrum(
  ...,
  recursive = FALSE,
  contains = NULL,
  allowDuplicates = FALSE,
  verbose = FALSE,
  tandems = "known",
  reference = "all"
)
}
\arguments{
\item{...}{character: One or more patterns used to identify files to read.
For details: see the "REpath-patterns" section below.}

\item{contains}{\code{character}. If \code{!is.null(contains)}, the \code{contains} argument is
is treated as regular expressions: only files which contain matches to
\emph{all} of these regular expressions are read.
Thus, \code{readHumdrum('.*krn$', contains = "EEE")} will only read kern files which contain matches
to \code{"EE"}---which is kern for the E two octaves below middle C (or lower).}

\item{recursive}{logical: If \code{TRUE}, the final part of the search pattern (i.e., the file search) is searched for
recursively through all sub directories.}

\item{allowDuplicates}{\code{logical} of length one, indicating what should happen if multiple search patterns match the same files.
If \code{allowDuplicates = TRUE},
any such files are read multiple times, grouped into their respective corpora by the \code{Label} field.
If \code{allowDuplicates = FALSE}, any redundant files are only read into the corpus of the first pattern they
match.}

\item{verbose}{logical: If \code{TRUE}, the names of matching files are printed before parsing begins. This is very
useful as a check to make sure you aren't reading the wrong files!}

\item{tandems}{\code{character}. This argument controls which, if any, tandem interpretations
are parsed into their own fields. The default value is \code{"known"}.}

\item{reference}{\code{character}. This argument controls which, if any, reference records
are parsed into their own fields. The default value is \code{"all"}.}
}
\description{
These functions find valid humdrum files on your local machine and read them into \code{humdrumR}.
}
\details{
\code{findHumdrum} does the work of finding and reading the text files into \code{R}.
\code{readHumdrum} utilizes \code{findHumdrum} to read files, then parses them to
create a \link[=humTable]{humdrum table} and build
a \link[=humdrumRclass]{humdrumR data object} around the table.
}
\section{REpath-patterns}{


"REpath-patterns" are specified using \code{...} arguments.
In combination, all the \code{...} arguments are used to search for file paths.
Each part of the search path you specify (\code{"dirpart/dirpart/filepart"}, etc) are matched as regular expressions
against directories/files on your disc.
Thus, we can say things like \code{findHumdrum("../^A.*/.*krn$")}, which would
match any kern files in any directory beginning with a capital \code{"A"} in the
directory above the current working directory.
For conveniance, you can break the path across multiple arguments instead of using delimited strings: For example, the code
\code{findHumdrum("..", "^A.*", ".*krn$")} will give an identical result as the previous example
(\code{findHumdrum("../^A.*/,*krn$")}).
This is useful when searching for more than one pattern (see next paragraph) in the same directory.

If you want to search for \emph{more than one} pattern, you can input them as a character vector:
For instance, \verb{readHumdrum(c("mozart", "beethoven")}---this command will search for
filenames containing "mozart" OR "beethoven."
This works for directories too: \code{readHumdrum(c("Mozart", "Beethoven"), ".*krn$")} will
look for any kern files in directories containing "Mozart" OR "Beethoven."
If patterns are named, these names will show up as identifying patterns in the \verb{[humdrumR][humdrumR]} object's
\code{Label} field. Unnamed patterns are simply labeled with numbers.
We refer to files matched from regex patterns to be "subcorpora" of the total corpus.

Normal (system appropriate) conventions (i.e., directories separated by \code{"/"},
\code{'~'} at beginning to indicate home, \code{".."} to indicate directory above working directory, etc.)
are followed.
If a pattern contains a solo dot followed by a file sep---e.g., \code{"./"}, \code{"x/./y"}---this is
treated as the current directory, not a regular expression.
If a pattern contains two dots---e.g., \code{"../"}---this is treated as the directory above, not a regular expression.
If you want to create a regular expression to match any directory, use \code{".*/"}.

The regex pattern \code{""} matches any file (it is changed to \code{".*"}). If you don't specifiy any \code{...} argument,
\code{findHumdrum} (or \code{readHumdrum}) will default to \code{".*"} as well.
Thus, \code{readHumdrum()} will read any humdrum files in the working directory.

(If two or more files in different directories share the same name, a unique name is created for
each file by appending the names of the directories they occupy, recursively
until the names are unique.)

If a single humdrum file has multiple pieces in it---meaning that all spine paths close with \verb{*-}, then
open again with \verb{**}---then they are parsed separately.
They are distinguished in the \code{Piece} field.
If there are no multi-piece files, \code{Piece} and \code{File} will be identical.
}

\section{Validity}{


\code{findHumdrum} and \code{readHumdrum} automatically ignore non-text files.
What's more, any files which contain humdrum syntax errors (checked by \code{\link[=validateHumdrum]{validateHumdrum()}}) are automatically
skipped. If you want to see specifically what errors occurred, call \code{\link[=validateHumdrum]{validateHumdrum()}}
directly and use its \code{errorReport.path} argument.
}

\section{Tandem Interpretations}{


All tandem interpretations in a humdrum dataset are summarized in the \link[=humTable]{humdrum table's}
\code{Tandem} field, which is described in detail \link[=extractTandem]{here}.
In addition, certain "known" tandem interpretations are parsed into their \emph{own} fields automatically.
For example, \verb{*clefG4} and "\verb{*clefF2} are parsed as \code{Clef} data, while \verb{*k[b-]} is parsed as a \code{KeySignature}.
The "known" tandem interpretations that \code{humdrumR} recognizes are encoded in a built-in
table called \code{knownInterpretations}.
Each interpretation has a humdrumR name (\code{"Clef"}, \code{"TimeSignature"}, etc.) as well as a regular expression
associated with it.

The \code{tandems} argument to \code{readHumdrum} controls which tandem interpretations are
parsed into their own fields. This can be helpful to either save processing time and memory
by \emph{not} parsing interpretations you won't need, or to parse interpretations that
humdrumR doesn't recognize.
The default value for the \code{tandems} argument is \code{"known"}. If the \code{tandems} argument
contains \code{"known"} \emph{all} tandem interpretations in the built-in \code{knownInterpretations}
table are parsed.
Users may specify different interpretations to parse in two ways:
\enumerate{
\item character strings
matching one of the name values from the \code{Name} column of \code{knownInterpretations}.
For instance, if you specify \code{tandems = c('Clef', 'TimeSignature')}, only clef (e.g., \code{"*clefG2"}),
and time signature (e.g., \code{"*M3/4"}) intepretations will be parsed.
\item if the character string(s) in \code{tandem} do not exactly match one of the names in
\code{knownInterpretations$Name}, they are treated as regular expressions and used to match
tandem interpretations in the data. This allows users to parse non-standard tandem interpretations
that humdrumR doesn't already know about.
}

If any values in \code{tandems} are named, these names will be used for resulting fields.
If no matches to an given interpretation are found, no field is created for that interpretation.
If \code{tandems = NULL}, then no tandem interpretations are parsed.
}

\section{Reference Records}{


By default (\code{reference = "all"}), humdrumR reads all reference records in the data.
The reference code for each record (e.g, the "OTL", in "!!!OTL: xxx") is used as the name of
an associated field.
(If a reference record has no reference code (i.e., it lacks a colon), the field is called "Unkeyed.")
In large datasets with many reference records, the reference data can actually make up a large portion
of the humdrum table, and eat up a lot of memory. In these cases, we might not want to read
all (or any) reference records---we can instead read only the reference records that we are planning to use
in our analyses (if any).
If \code{reference = NULL}, no reference records are parsed.
Otherwise, the character values of \code{reference} are treated as reference codes and only
matching reference records are parsed.
For instance, \verb{readHumdrum(_, reference = "OTL")} will \emph{only} parse OTL reference records.
If the values of \code{reference} are named, these names are used to name associated fields.
Thus, by specifing \code{reference = c(Title = 'OTL')}, you can use "OTL" reference records to populate
a field called "Title".

If there are more than one reference records with the same reference code,
either explicitely numbered (e.g., "!!!COM1:", "!!!COM2:") all are read and rather than making two
or more fields, a single field is created ("COM" in this) with the multiple values separated by ";".
}

\section{Spines and Paths}{


In the \href{http://www.humdrum.org/guide/ch05/}{humdrum syntax}, data is placed in "spines,"
which are not the same as "columns" in a spreadsheet. A "column" refers to a
tab-delineated group of values.
"Spines" can be a single column, or they may (at any time) split into multiple columns,
which can in turn split again, using the \code{"*^"} interpretation token. The reverse can happen as well,
with two or more columns merging into a single column, using the \code{"v"} token.
This means that, while humdrum data at first glance looks like a simple two-dimensional table,
it is actually a flexible tree structure. As spines split and merge, the total number of columns
can change during a piece, creating a "ragged" edge.
Another similar issue is that a corpus of humdrum files may have varying numbers of spines/columns, between pieces.
("Global" comment/reference records are also a special case, as that are always a single value, even if interspersed with
multi-column local records.)
\code{readHumdrum} assumes a slightly more strict version of the humdrum syntax:
that all the spines which appear at the beginning of a file (headed with exclusive interpretations
like \code{"**kern"}) can never merge into each other. Thus, a humdrum file read into \code{humdrumR}
must not end with fewer columns than it starts.
Spine merges (\code{"*v"}) can only happen within spine paths that originally split off the same spine.
This extra-strict specification of spine paths in the humdrum syntax is, fortunately, something that has been
informally followed in most humdrum datasets.

Our strict spine-path definition makes everything work fairly simply:
Within a piece, the spines which appear at the beginning of the piece are the "true" spines throughout the piece, numbered
from left to right, starting from \code{1L}.
For each local token, the value in the \code{Spine} field is an integer indicating which of these
"true" spines it belongs to---global tokens have a \code{NA} value in their \code{Spine} field, because they do not belong to any spine.
Any spine path splits (\code{"*^"}) from the main spines form \strong{spine paths}.
Every spine's paths are numbered in the \code{Path} field, from right to left, starting from \code{0L}.
A spine with no splits will have all \code{0L}s in its \code{Path} field.
}

\section{Result}{


\code{findHumdrum} returns a "fileFrame" (\code{data.table}), listing all file names,
the patterns they match, the directories they were found in, \emph{and} the raw text content of these files.

\code{readHumdrum} returns a fully parsed \link[=humdrumRclass]{humdrumR object}.
}

\examples{

readHumdrum() # loads all valid humdrum files in the current directory.

readHumdrum(".*krn$") # loads all files ending with "krn" in the currect directory

readHumdrum("^Composers$/^Be|^Mo/.*/^Joined$/.*krn$") 
# Goes inside the directory "Composers".
# Inside "Composers" looks for directories that start with "Be" or "Mo".
# If there are any "Be|Mo" matching directories within "Composers", matches all directories within them.
# Within these directories, looks for directories called "Joined".
# If there are any directories called "Joined", loads all files (if any) that end with "krn".

readHumdrum("^Composers$", "^Be|^Mo", ".*", "^Joined$", ".*krn$")
# exactly the same as the previous!

readHumdrum("^Composers$", c(Beethoven = "^Be", Mozart = "^Mo"), ".*", "^Joined$", ".*krn$") 
# exactly the same as the previous, except now the two matching patterns ("^Be", or "^Mo") will be grouped
# in the Label field as "Beethoven" and "Mozart" respectively.

}
\keyword{datasets}
