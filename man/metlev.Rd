% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Metric.R
\name{metlev}
\alias{metlev}
\alias{metcount}
\alias{metsubpos}
\title{Count or measure metric position}
\usage{
metlev(
  dur,
  meter = duple(5),
  pickup = NULL,
  value = TRUE,
  offBeats = TRUE,
  remainderSubdivides = FALSE,
  deparser = recip,
  groupby = list(),
  ...,
  parseArgs = list()
)

metcount(
  dur,
  meter = duple(5),
  level = tactus(meter),
  pickup = NULL,
  ...,
  offBeats = TRUE,
  remainderSubdivides = FALSE,
  groupby = list(),
  parseArgs = list()
)

metsubpos(
  dur,
  meter = duple(5),
  pickup = NULL,
  deparser = duration,
  ...,
  remainderSubdivides = TRUE,
  groupby = list(),
  parseArgs = list()
)
}
\arguments{
\item{dur}{\emph{\strong{An input vector of rhythmic durations.}}

Must be a \code{character} or \code{numeric} vector.

Is parsed using \code{\link[=rhythmInterval]{rhythmInterval()}};
Wherever the input can't be parsed as a duration,
that element is treated as a duration of zero.}

\item{meter}{\emph{\strong{The meter(s) to compute levels from.}}

Defaults to a standard, five-level duple (4/4) meter.

Must be a \code{\link[=meter]{meter()}} object or a \code{character} vector.

For \code{character} input, the string is parsed using \code{\link[=meter]{meter()}}; a
failure to parse will result in an error.}

\item{pickup}{\emph{\strong{Where is there a pickup (anacrusis)?}}

Defaults to \code{NULL}

Must be \code{logical} of same \code{length(x)}, Or \code{NULL}.
See "Pickups" section below.}

\item{value}{\emph{\strong{Should the output levels be represented as rhythmic duration values?}}

Defaults to \code{TRUE}.

Must be a singleton \code{logical} value: an on/off switch.}

\item{offBeats}{\emph{\strong{Should off-beat onsets be numbered in the output, or \code{NA}?}}

Defaults to \code{TRUE}.

Must be a single \code{logical} value: an on/off switch.}

\item{remainderSubdivides}{\emph{\strong{Should off-beat onsets only be associated with beat levels that they evenly subdivide?}}

Defaults to \code{FALSE}.

A singleton \code{logical} value: an on/off switch.}

\item{groupby}{\emph{\strong{A \code{list} of vectors to group \code{x}.}}

Defaults to \code{list()}.

Must be a \code{list}; every element of the list must be length \code{length(x)}.

To function as a by-record timeline, the \code{groupby} list music include a \emph{named} \code{Piece} and \code{Record} fields.
Luckily, these are automatically passed by \link[=withinHumdrum]{with(in).humdrumR}, so you won't need to worry about it!}

\item{parseArgs}{\emph{\strong{An optional list of arguments passed to the \link[=rhythmParsing]{rhythm parser}.}}

Defaults to an empty \code{list()}.

Must be a \code{list} of named arguments to the \link[=rhythmParsing]{rhythm parser}.}

\item{level}{\emph{\strong{Which metric level should be counted?}}

Defaults to the tactus of the \code{meter}.

A single \code{character} value or positive natural number.

A \code{character} string input must be a \code{\link[=recip]{recip()}} value, matching a beat level in the meter.
A numeric input directly indicates a level in the meter, starting from the highest level (\code{1}).}
}
\description{
These functions take vectors of rhythmic duration values and
compute the metric position of each rhythmic onset.
\code{metlev()} identifies the metric \emph{level} of each onset;
\code{metcount()} counts beats within a measure;
\code{metsubpos()} measures the distance
between an onset and the nearest metric beat.
\code{metcount()} and \code{metsubpos()} parallel the more general \code{timecount()} and \code{subpos()} functions.
}
\details{
Watch out! These \code{met...()} functions require \emph{meter} information and their output is
highly dependent on how you interpret meter from scores.
For a full discussion of how meter can represented, parsed, and created in \code{humdrumR},
see the \code{\link[=meter]{meter()}} manual.
Effective use of the \code{\link[=meter]{meter()}} function is essential to use of \code{metlev()}, \code{metcount()}, and \code{metsubpos()}.
\subsection{Metric levels}{

\code{metlev()} identifies the "highest" (longest) metric level that each onset lands in/on:
For example, in 4/4 time:
\itemize{
\item An onset on the downbeat is at the highest level of all, the whole-note level;
\item An onset on beat three of the 4/4 measure is on the half-note level;
\item Onsets on the backbeats (beats two and two) fall on the quarter-note level;
\item The next level down is the eighth-note level, in between each quarter-note beat;
\item etc.
}

The \code{metlev()} output expresses beat levels as the duration of
the the level, in \code{\link[=recip]{recip()}} format by default.
So the whole-note level is \code{"1"} and the quarter-note level (backbeats) is \code{"4"}.
You can specify a different \link[=rhythmDeparsing]{deparsing} function
(like \code{duration()}) using the \code{deparser} argument.
(If \code{deparser} is \code{NULL}, \code{\link[=rational]{rational()}} numbers are returned.)

Another option is to express the metric levels simply as natural numbers, which you can achieve
with the argument \code{value = FALSE}.
In this case, the top level of the meter is \code{1}, which each next lower-level incrementing up:
i.e., the quarter-note level (of 4/4) would be \code{3}, while the sixteenth-note level would be \code{5}.
\subsection{(Full) 4/4 meter levels}{\tabular{lllllllll}{
    \tab 1 \tab & \tab 2 \tab & \tab 3 \tab & \tab 4 \tab & \cr
   Level (\code{\link[=recip]{recip()}}) \tab \code{"1"} \tab \code{"8"} \tab \code{"4"} \tab \code{"8"} \tab \code{"2"} \tab \code{"8"} \tab \code{"4"} \tab \code{"8"} \cr
   Level (\code{value = FALSE}) \tab \code{1} \tab \code{4} \tab \code{3} \tab \code{4} \tab \code{2} \tab \code{4} \tab \code{3} \tab \code{4} \cr
}

}

\subsection{3/4 meter levels}{\tabular{lllllll}{
    \tab 1 \tab & \tab 2 \tab & \tab 3 \tab & \cr
   Level (\code{\link[=recip]{recip()}}) \tab \code{"1"} \tab \code{"8"} \tab \code{"4"} \tab \code{"8"} \tab \code{"4"} \tab \code{"8"} \cr
   Level (\code{value = FALSE}) \tab \code{1} \tab \code{3} \tab \code{2} \tab \code{3} \tab \code{2} \tab \code{3} \cr
}

}

\subsection{6/8 meter levels}{\tabular{lllllll}{
    \tab 1 \tab & \tab a \tab 2 \tab & \tab a \cr
   Level (\code{\link[=recip]{recip()}}) \tab \code{"1"} \tab \code{"8"} \tab \code{"8"} \tab \code{"4."} \tab \code{"8"} \tab \code{"8"} \cr
   Level (\code{value = FALSE}) \tab \code{1} \tab \code{3} \tab \code{3} \tab \code{2} \tab \code{3} \tab \code{3} \cr
}

}

}

\subsection{Metric counts}{

The \code{metcount()} function counts one beat level in a metric hierarchy, \emph{within} the next highest level.
In a full duple meter, the counts are always simply \code{1}, \code{2}, \code{1}, \code{2}, etc.
Meters with a triple level will get \code{1}, \code{2}, \code{3}, etc.
Why level you want to count is controlled by the \code{level} argument, which can be either a \code{character} string
in \code{\link[=recip]{recip()}} format or a natural number (\code{1} is top level, \code{2} is next lowest level, etc.).
\subsection{(Full) 4/4 meter counts:}{\tabular{lllllllll}{
    \tab 1 \tab & \tab 2 \tab & \tab 3 \tab & \tab 4 \tab & \cr
   \code{"1"} (whole) \tab 1 \tab 1 \tab 1 \tab 1 \tab 1 \tab 1 \tab 1 \tab 1 \cr
   \code{"2"} (half) \tab 1 \tab 1 \tab 1 \tab 1 \tab 2 \tab 2 \tab 2 \tab 2 \cr
   \code{"4"} (quarter) \tab 1 \tab 1 \tab 2 \tab 2 \tab 1 \tab 1 \tab 2 \tab 2 \cr
   \code{"8"} (eighth) \tab 1 \tab 2 \tab 1 \tab 2 \tab 1 \tab 2 \tab 1 \tab 2 \cr
}

}

\subsection{3/4 meter counts:}{\tabular{lllllll}{
    \tab 1 \tab & \tab 2 \tab & \tab 3 \tab & \cr
   \code{"2."} (dotted-half) \tab 1 \tab 1 \tab 1 \tab 1 \tab 1 \tab 1 \cr
   \code{"4"} (quarter) \tab 1 \tab 1 \tab 2 \tab 2 \tab 3 \tab 3 \cr
   \code{"8"} (eighth) \tab 1 \tab 2 \tab 1 \tab 2 \tab 1 \tab 2 \cr
}

}

\subsection{6/8 meter counts:}{\tabular{lllllll}{
    \tab 1 \tab & \tab a \tab 2 \tab & \tab a \cr
   \code{"2."} (dotted-half) \tab 1 \tab 1 \tab 1 \tab 1 \tab 1 \tab 1 \cr
   \code{"4."} (dotted-quarter) \tab 1 \tab 1 \tab 1 \tab 2 \tab 2 \tab 2 \cr
   \code{"8"} (eighth) \tab 1 \tab 2 \tab 3 \tab 1 \tab 2 \tab 3 \cr
}


In the case of 4/4, if you want to count \code{1}, \code{2}, \code{3}, \code{4}, you'll need to make your \code{\link[=meter]{meter()}} object
\emph{not} include a half-note level.
}

\subsection{4/4 meter with no half-note level:}{\tabular{lllllllll}{
    \tab 1 \tab & \tab 2 \tab & \tab 3 \tab & \tab 4 \tab & \cr
   \code{"1"} (whole) \tab 1 \tab 1 \tab 1 \tab 1 \tab 1 \tab 1 \tab 1 \tab 1 \cr
   \code{"4"} (quarter) \tab 1 \tab 1 \tab 2 \tab 2 \tab 3 \tab 3 \tab 4 \tab 4 \cr
   \code{"8"} (eighth) \tab 1 \tab 2 \tab 1 \tab 2 \tab 1 \tab 2 \tab 1 \tab 2 \cr
}


You can do this with \code{meter('M4/4', fill.levels = 'below')}.
}

}

\subsection{Metric subpositions}{

In some cases, onsets may occur which do not land on any beat specified in the meter.
This could be very fast beat levels (e.g., 32nd notes), triplets, or other tuplets.
In these cases, you might consider adding these levels to the \code{\link[=meter]{meter()}}; for example,
if you want to have a 32nd-note level in 4/4, you could use \code{meter('M4/4', tick = '32')}.
For \code{metlev()} and \code{metcount()}, the \code{offBeats} argument can be set to \code{FALSE} to cause
offbeat onsets to return \code{NA}.
Another option is to use \code{metsubpos()}, which measures how far an onset is from the nearest
associated beat in the meter.

By default, off-beat onsets are always associated with the closets previous position in any level in the meter.
If the \code{remainderSubdivides} argument is \code{TRUE}, off-beat onsets are associated with the previous metric level
which the subposition makes an even subdivision of.
}
}
\section{Pickups}{


Another option is to pass the \code{pickup} argument a logical vector of the same length as the input \code{x}.
Within each piece/group, any block of \code{TRUE} values at the \emph{beginning} of the \code{pickup} vector
indicate a pickup.
The \emph{first} index where the \code{pickup} logical is \code{FALSE} is used as the starting point of the timeline/timecount;
All the earlier (\code{pickup == TRUE}) points will be negative numbers, measured backwards from the start index.
In \code{humdrumR}, and datapoints before the first barline record (\code{=}) are labeled \code{Bar == 0} in the \code{Bar} \link[=fields]{field}.
Thus, a common use for the \code{pickup} argument is \verb{within(humData, timeline(Token, pickup = Bar < 1)}, which makes the downbeat of
the first complete bar \code{1} the starting point of the timeline---any notes in pickup bars are negative on the timeline.
}

\examples{

rhythm <- c('4', '8', '8', '4', '8', '16', '16','4.', '8','2')

metlev(rhythm)
metlev(rhythm, meter = 'M6/8')

metcount(rhythm)
metcount(rhythm, offBeats = FALSE)
metcount(rhythm, meter = 'M6/8', offBeats = FALSE)

# chorales
chorales <- readHumdrum(humdrumRroot, 'HumdrumData/BachChorales/.*krn') 

within(chorales, metlev(Token, pickup = Bar < 1))

within(chorales, metcount(Token, pickup = Bar < 1, fill.levels = 'below'))

}
\seealso{
{The \code{\link[=timecount]{timecount()}} and \code{\link[=subpos]{subpos()}} functions are more basic versions of \code{metcount()} and \code{metsubpos()},
based only on counting a \emph{single} beat level, rather then a hierarchy of beat levels.}
}
