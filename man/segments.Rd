% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tools.R
\name{segments}
\alias{segments}
\alias{changes}
\title{Identify contiguous segments of data in a vector}
\usage{
segments(..., first = TRUE, any = TRUE, reverse = FALSE)

changes(..., first = TRUE, value = FALSE, any = TRUE, reverse = FALSE)
}
\arguments{
\item{...}{\emph{\strong{A list of atomic vectors.}}

If the vectors differ in length, they are all recycled to match the length of the longest vector.}

\item{first}{\emph{\strong{Is the first index (or last index if \code{reverse == TRUE}) marked as a "change."}}

Defaults to \code{TRUE}.

Must be a singleton \code{logical} value: an on/off switch.}

\item{any}{\emph{\strong{Whether to mark changes any or all input vectors.}}

Defaults to \code{TRUE}.

Must be a singleton \code{logical} value: an on/off switch.

If \code{TRUE}, a change in \emph{any} input vector
is marked a change. If \code{FALSE}, changes must occur in \emph{all} input vectors to be marked as a change.}

\item{reverse}{\emph{\strong{Whether the excecution order is reversed.}}

Defaults to \code{FALSE}.

Must be a singleton \code{logical} value: an on/off switch.

If \code{TRUE} the function is excecuted backwards through the input vector(s).}

\item{value}{\emph{\strong{Whether to return the changed value matrix.}}

Defaults to \code{FALSE}.

Must be a singleton \code{logical} value: an on/off switch.

If \code{TRUE}, the input values where changes occur
are returned in a matrix, with each row matching a change and each column containing the
value from the associated input vector.}
}
\description{
\code{segments} and \code{changes} are extremely useful functions for finding
contiguous "segments" indicated in a vector.
}
\section{Changes}{


\code{changes} takes and input vector and finds all indices \code{i}
where the value of \code{x[i] != x[i-1]}---i.e., where the value at one index
has "changed" since the last index.
By default, \code{changes} returns a \code{logical} vector the same length as the input,
with \code{TRUE} only at indices where a change occured.
The \code{first} argument indicates whether the first index (\code{i == 1})
is marked \code{TRUE}.

\code{changes} can accept more than one input vector.
If the \code{any} argument is set to \code{TRUE} (the default),
a change in \emph{any} input is marked as a change (\code{TRUE}) in the output.
If \code{any == FALSE}, changes must happen in \emph{all} vectors to be marked in the output.

Finally, the \code{reverse} argument reverses the behavior of \code{changes},
checkig instead if \code{x[i] != x[i + 1]}.
\subsection{Values}{

By default, the values of the input vector(s) where a change occurs
are placed in a matrix and put in the \code{values} attribute of the \code{logical} output.
However, if the \code{value} argument is set to \code{TRUE}, the values themselves are returned.
}
}

\section{Segments}{


The \code{segments} builds off of the \code{changes} function.
The segments function takes a \code{logical} input and \emph{cummulatively} tallies each
\code{TRUE} value in the vector, from left to right (or right to left, if \code{reverse == TRUE}).
Thus, the input \code{c(TRUE, FALSE, TRUE, FALSE, FALSE, TRUE, TRUE, FALSE)}
would return \code{c(1, 1, 2, 2, 2, 3, 4, 4)}.
This creates contiguous blocks of values which can be used for a \code{groupby} argument in a call
to \code{\link[=within.humdrumR]{within.humdrumR()}}, or similar functions like \code{\link[base:tapply]{base::tapply()}}.

Any input vector(s) to \code{segments} which are not \code{logical}, are first fed to
\code{changes} to create a \code{logical} input.
}

\examples{

segments(letters \%~\% '[aeiou]')

changes(c(1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4), 
        c(1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3),
        any = TRUE)
# result is T,F,F,T,T,F,T,F,T,T,F,F

}
\concept{{Window functions}}
