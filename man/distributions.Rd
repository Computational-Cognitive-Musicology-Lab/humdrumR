% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Distributions.R
\name{distributions}
\alias{distributions}
\alias{show,distribution-method}
\alias{print.distribution}
\alias{sort,distribution-method}
\alias{count.default}
\alias{count.humdrumR}
\alias{count.table}
\alias{count.pdist}
\alias{pdist.count}
\alias{pdist.probability}
\alias{pdist.default}
\alias{pdist.data.frame}
\alias{pdist.humdrumR}
\alias{pdist.table}
\alias{table}
\alias{table,humdrumR-method}
\alias{table,distribution-method}
\title{Distributions}
\usage{
\S4method{show}{distribution}(object)

\method{print}{distribution}(
  dist,
  digits = 3,
  syntaxHighlight = humdrumRoption("syntaxHighlight"),
  wide = TRUE,
  printZeros = TRUE,
  zeros = "."
)

\S4method{sort}{distribution}(x, decreasing = TRUE)

\method{count}{default}(..., sort = FALSE, na.rm = FALSE, .drop = FALSE, binArgs = list())

\method{count}{humdrumR}(x, ..., sort = FALSE, na.rm = FALSE, .drop = FALSE, binArgs = list())

\method{count}{table}(..., sort = FALSE, na.rm = FALSE, .drop = FALSE)

\method{count}{pdist}(x, ..., sort = FALSE, na.rm = FALSE, .drop = FALSE)

\method{pdist}{count}(
  x,
  ...,
  condition = NULL,
  na.rm = FALSE,
  sort = FALSE,
  .drop = FALSE,
  binArgs = list()
)

\method{pdist}{probability}(
  x,
  ...,
  condition = NULL,
  na.rm = FALSE,
  sort = FALSE,
  .drop = FALSE,
  binArgs = list()
)

\method{pdist}{default}(
  ...,
  condition = NULL,
  na.rm = FALSE,
  sort = FALSE,
  .drop = FALSE,
  binArgs = list()
)

\method{pdist}{data.frame}(
  x,
  ...,
  condition = NULL,
  na.rm = FALSE,
  sort = FALSE,
  .drop = FALSE,
  binArgs = list()
)

\method{pdist}{humdrumR}(
  x,
  ...,
  condition = NULL,
  na.rm = FALSE,
  sort = FALSE,
  .drop = FALSE,
  binArgs = list()
)

\method{pdist}{table}(x, ..., condition = NULL, na.rm = FALSE, sort = FALSE)

table(
  x,
  ...,
  exclude = if (useNA == "no") c(NA, NaN),
  useNA = "no",
  dnn = NULL,
  deparse.level = 1
)

\S4method{table}{humdrumR}(
  x,
  ...,
  exclude = if (useNA == "no") c(NA, NaN),
  useNA = "no",
  dnn = NULL,
  deparse.level = 1
)

\S4method{table}{distribution}(x)
}
\description{
HUmdrumR has ways to...

The \code{count()} function is exactly like R's fundamental \link[base:table]{table()} function,
except that 1) will give special treatment to humdrumR \code{\link[=token]{token()}} data 2)
has more intuitive/simple argument names 3) makes it easier to combine/manipulate
disparate output tables.
}
\details{
The \code{count()} function is essentially a wrapper
around \link[base:table]{base::table()} function.
However, any \code{\link[=token]{token()}} class arguments are treated like \code{\link[=factors]{factors()}},
calling generating their own levels.
This assures that, for example, pitch data is tabulated in order of pitch height,
and "missing" pitches are counted as zero.

\code{count()} will, by default, count \code{NA} values if they are present---if you don't want
to count \code{NA}s, specify \code{na.rm = TRUE}.
You can also tell \code{count()} to exclude (not count) any other arbitrary values you
provide as a vector to the \code{exclude} argument.

\code{count()} will always give names to the dimensions of the table it creates.
You can specify these names directly as argument names, like \code{count(Kern = kern(Token))};
if you don't specify a name, \code{count()} will make up a name(s) based on expression(s) it is tallying.
(Note that \code{count()} does not copy \code{\link[base:table]{base::table()}}'s obtusely-named \code{dnn} or \code{deparse.level} arguments.)
}
\section{Counting numeric values}{


For numeric values, if there are many unique numbers to count we often want to count ranges of numbers in bins,
like in a histrogram.
By default, if you pass a vector of numbers to \code{count()} which has more than \code{20} unique values,
\code{count()} will bin the values using the same algorithm as \code{\link[graphics:hist]{graphics::hist()}}.
This process can be controlled using the \code{binArgs} argument, which is itself a list of control arguments.
\code{binArgs = list(maxN = N)} controls the number of unique numbers needed before binning occurs,
and \code{binArgs = list(right = FALSE)} (default is \code{TRUE}) can be used to make bins that are closed on the right instead of the left.
Finally, any arguments to \code{\link[graphics:hist]{graphics::hist()}} can be passed via \code{binArgs}, controlling how binning occurs: notably,
you can use the \verb{binArgs = list(breaks = _)} to control exactly where boundaries should occur, or the number of bins you want.
For example, \code{binArgs = list(breaks = 10)} will make \code{count()} bin the input numbers into twelve bins (see \code{\link[=hist]{hist()}}
for details).

Alternatively, you can tell \code{count()} to divy up (bin) the input numbers into quantiles by
passing \code{binArgs = list(quantiles = N)}.
For example, \code{binArgs = list(quantiles = 4)} will divide the data into four equal quantiles (0\%-25\%, 25\%-50\%, 50\%-75\%, 75\%-100\%).
}

\section{Manipulating humdrum tables}{


The output of \code{count()} is a special form of R \code{table}, a \code{humdrumR.table}.
Given two or more \code{humdrumR.table}s, if you apply basic R operators
(e.g., arithmetic, comparisons) or row/column binding (\code{cbind}/\code{rbind})
\code{humdrumR} will align the tables by their dimension-names before
doing the operation.
This means, that if you have two tables of pitch data, but one table includes specific pitch and other doesn't,
you can still add them together or bind them into a matrix.
See the examples!
}

\examples{

generic <- c('c', 'c', 'e', 'g', 'a', 'b', 'b', 'b')
complex <- c('c', 'c#', 'e', 'f', 'g','g#', 'g#', 'a')

genericTable   <- count(generic)
complexTable <- count(complex)

genericTable
complexTable

genericTable + complexTable

cbind(genericTable, complexTable)

}
