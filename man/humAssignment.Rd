% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/humdrumR-class.R
\name{humAssignment}
\alias{humAssignment}
\title{Assigning new fields}
\description{
R objects often have ways of assigning new values to
\emph{part} of the object using \link[base:Extract]{indexing operators}.
\link[=humdrumR:humdrumRclass]{HumdrumR objects} objects are no different, as they allow us to insert
new fields into them!
}
\details{
A new field can be inserted into a \code{humdrumR} object in two ways:
\enumerate{
\item A field can be copied from one humdrumR object to another if their
internal \link[=humTable]{humdrum tables} have the exact same number of data tokens (i.e., rows).
It might not seem obvious, but this mechanism is very useful because it can be used to \emph{rename} existing fields
within a humdrumR object (explained below).
\item A \link[base:vector]{vector} or \link[base:list]{list of vectors} can be inserted as
new fields in a humdrumR object.
}

Fields can be assigned using two syntaxes:\preformatted{humdata['fieldname'] <- x
# or
humdata[c('fieldname1', 'fieldname2')] <- x
}

or\preformatted{humdata$fieldname <- x
}

where "fieldname" can be whatever you want it to be, of course!
\subsection{\code{humdrumR -> humdrumR} assignment:}{

Assigning a field from one \link[=humdrumR:humdrumRclass]{humdrumR object}
to another works like this:
(Recall that the two objects must have the exact same numbers of data tokens.)
The name(s) given in the indexing expression on the left side of the assignment (i.e., \code{humdata[c('name1', 'name2')]} or
\code{humdata$name}) are used as new field names.
How fields are extracted from the right side of the assignment is a little trickier:
Any fields in the right-side \code{humdrumR} object which are named $PipeN$ (where $N$ is an integer) are copied
in descending order into the named fields on the left side.
If there are no $PipeN$ fields on the right side, any fields used in the current Active formula (on the right side)
are copied instead.
This system might seem odd at first, but it is very useful in combination with the \link{withinHumdrum} function,
or its convenient pipe operator \link[=humPipe]{\%hum>\%}
When \code{withinHumdrum} creates new fields, it calls them $Pipe1 \ldots Pipe2 \ldots PipeN$.
Since the output of \code{withinHumdrum} is always the same as the input except with these new "Pipe" fields,
Byou can use \code{humdrumR <- humdrumR} assignment to immediately assign these pipe fields more meaningful names in the original object.
This makes the most sense with an example:\preformatted{humdata$Semits <- humdata \%hum>\% ~semits(Token) 
}

In humdrumR, we actually favor the left-to-right "piping" style.
Luckily, R allows you to assign left-to-right, so the proper humdrumR style is actually:\preformatted{humdata \%hum>\% ~semits(Token) -> humdata$Semits
}

Calls to \code{withinHumdrum} (or \verb{\%hum>\%}) keep producing new pipe fields.
If there are more than one pipe fields, you can assign multiple fields at once using the \verb{[]<-} syntax:\preformatted{
humdata \%hum>\% ~semits(Token) \%hum>\% ~pitch(Token) -> humdata[c('semits', 'pitch')]

}

#' \strong{IMPORTANT NOTE!}: Any "PipeN" fields in the humdrumR object you assign from
that you don't assign field names are simply dropped.
This is nice, because often you might proceed through a serious of piped steps, but you only
want the last one (or two).
If you want to keep all your pipe fields either don't re-assign them at all (i.e., keep the "PipeN" names)
or assign them all names using the \verb{->[c("name1", "name2", "name3", ...)]} syntax.
}

\subsection{\code{humdrumR -> vector} assignment:}{

You can assign vectors or lists of vectors straight into a \link[=humdrumR:humdrumRclass]{humdrumR object}.
All vectors must be the same length as the number of data tokens
in the target object.
If you provide multiple vectors to assign (as a \code{list} or \code{data.frame} of vectors)
you must provide the same number of fieldnames using the \verb{->[c('name1', 'name2', ...)]} syntax.
You can use the \code{ntokens} command to determine the right length of vectors you need!
}
}
