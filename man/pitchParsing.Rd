% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tonalInterval.R
\name{pitchParsing}
\alias{pitchParsing}
\alias{tonalInterval}
\alias{tonalInterval.tonalInterval}
\alias{tonalInterval.logical}
\alias{tonalInterval.NULL}
\alias{tonalInterval.numeric}
\alias{tonalInterval.character}
\title{Parsing pitch information}
\usage{
tonalInterval(...)

\method{tonalInterval}{tonalInterval}(x, ...)

\method{tonalInterval}{logical}(x, ...)

\method{tonalInterval}{`NULL`}(x, ...)

\method{tonalInterval}{numeric}(x, Exclusive = NULL, ..., multiDispatch = FALSE)

\method{tonalInterval}{character}(x, Exclusive = NULL, str, ..., multiDispatch = FALSE)
}
\arguments{
\item{Exclusive}{(\code{character},  \code{length == 1 | length == length(x)})}

\item{str}{(\code{character} or \code{numeric}) The input vector.}

\item{Key}{(a \link{diatonicSet} or something coercable to \code{diatonicSet}, \code{length == 1 | length == length(x)}) The input \code{Key} is used
to interpret pitch representations.
For example, use of \code{implicitSpecies} (see advanced parsing section) is dependent on the \code{Key}.
The output \code{tonalInterval} is output \emph{within the key}: thus, \code{tonalInterval('C#', Key = "A:")}
returns the tint representing a \strong{Major 3rd}, because \emph{C#} is the major third of A major.}
}
\description{
\link{humdrumR} includes a easy-to-use but powerful system for \emph{parsing} pitch information:
various basic pitch representations (including \code{numeric} and \code{character}-string representations) can be "parsed"---read
and interpreted by \code{humdrumR}.
For the most part, parsing automatically happens "behind the scenes" whenever you use any humdrumR \link[=pitchFunctions]{pitch function}, like \code{\link[=kern]{kern()}}
\code{\link[=semit]{semit()}}, or \code{\link[=solfa]{solfa()}}.
}
\details{
The underlying parser used by all \code{humdrumR} \link[=pitchFunctions]{pitch functions} can be called explicitly using the function \code{tonalInterval()}.
The \code{tonalInterval} parser will attempt to parse any input information into a \link[=tonalIntervalS4]{tonalInterval} object---a back-end pitch representation
that you probably don't need to care about!
When you use one of the main \link[=pitchFunctions]{pitch functions}, like \code{\link[=kern]{kern()}} or \code{\link[=semits]{semits()}},
the input is parsed into a \link[=tonalIntervalS4]{tonalInterval} object, then immediately \link[=pitchDeparsing]{deparsed}
to the representation you asked for (e.g., \verb{**kern} or \verb{**semits}).
Thus, the underlying pipeline for \code{humdrumR} \link[=pitchFunctions]{pitch functions} looks something like:
\itemize{
\item \strong{Input} representation (e.g., \verb{**pitch} or \verb{**semits}) \verb{|>}
\itemize{
\item \emph{Parsing} (done by \code{tonalInterval()}) \verb{|>}
\itemize{
\item \strong{Intermediate} (\link[=tonalIntervalS4]{tonalInterval}) representation \verb{|>}
}
\item \emph{Deparsing} \verb{|>}
}
\item \strong{Output} representation (e.g. \verb{**kern} or \verb{**solfa})
}

\emph{This} documentation talks about the parsing step.
For an overview of the "deparsing" process, look \link[=pitchDeparsing]{here}.
To learn about the "deparsing" of specific representations, \link[=pitchFunctions]{start here} or go straight to the docs for specific functions---
for example, call \code{?kern} to learn about \code{\link[=kern]{kern()}}.
}
\section{Dispatch}{
The pitch parser (\code{tonalInterval}) is a generic function, meaning it can accepts a variety of inputs
and automatically "dispatches" the appropriate method for parsing the input.
R's standard \code{S3} system is used to dispatch for either \code{numeric} or \code{character}-string input:
Generally, \code{numeric} (or \code{integer}) inputs are interpreted as various \emph{atonal} pitch representations while
\code{character} strings are interpreted as various \emph{tonal} pitch representations.
Given either a \code{character} string or a number, \code{humdrumR} then uses either regular-expression matching or humdrum
exclusive interpretation matching to dispatch specific parsing methods.
}

\section{Tonal Parsing (\code{character}-string inputs)}{
Since humdrum data is inherently string-based, the most powerful part of the \code{humdrumR} pitch-parser
is its system for parsing pitch (mostly tonal) information from character strings.
(This includes character tokens with pitch information embedded alongside other information; Details below.)
The pitch parser (\code{tonalInterval}) uses a combination of regular-expressions and exclusive interpretations to decide how to
parse an input string.
There are twelve regular-expression patterns for pitch that \code{tonalInterval} knows how to parse automatically:\tabular{lrr}{
   Representation \tab Exclusive \tab Example \cr
   \href{https://www.humdrum.org/rep/kern/index.html}{Kern} \tab **kern \tab \verb{ee-} \cr
   \href{https://en.wikipedia.org/wiki/Scientific_pitch}{Scientific Pitch} \tab **pitch \tab \code{Eb5} \cr
   \href{https://en.wikipedia.org/wiki/Solf\%C3\%A8ge}{Helmholtz pitch} \tab none \tab \verb{eb'} \cr
   \href{https://lilypond.org/doc/v2.22/Documentation/notation/pitches}{Lilypond pitch} \tab none \tab \verb{ees'} \cr
   \href{https://www.humdrum.org/rep/Tonh/index.html}{German pitch} notation \tab **Tonh \tab \code{S5} \cr
   \href{https://en.wikipedia.org/wiki/Interval_(music)}{Interval} \tab **hint/**mint/**int \tab \code{+m3} \cr
   \href{https://en.wikipedia.org/wiki/Degree_(music)}{Scale degree} \tab **deg or **degree \tab \verb{^^3-} or \verb{3-/5} \cr
   \href{https://en.wikipedia.org/wiki/Pitch_class#Integer_notation}{Pitch Class} \tab **pc \tab \code{3} \cr
   Relative-do \href{https://en.wikipedia.org/wiki/Solf\%C3\%A8ge}{Solfege} \tab **solfa \tab \verb{^me} \cr
   Fixed-do \href{https://en.wikipedia.org/wiki/Solf\%C3\%A8ge}{Solfege} \tab **solfg \tab \code{mi~b5} \cr
   \href{https://en.wikipedia.org/wiki/Svara}{Swara} \tab **bhatk \tab \code{g} \cr
}

\subsection{Exclusive Dispatch}{

If you call \code{tonalInterval} (or \emph{any} \link[=pitchFunctions]{pitch function}) on a \code{character}-string vector, with a non-\code{NULL} \code{Exclusive} argument,
that \code{Exclusive} argument will be used to choose the input interpretation you want, based on the "Exclusive" column in the
table above.
For example, \code{kern(x, Exclusive = 'solfa')} will force the parser to interpret \code{x} as \verb{**solfa} data.
Similarly, \code{solfa(x, Exclusive = 'kern')} will force the parser to interpret \code{x} as \verb{**kern} data.
If you use any \link[=pitchFunctions]{pitch function} within a special call to \link{withinHumdrum},
\code{humdrumR} will automatically pass the \code{Exclusive} field from the humdrum data to the function---this means, that in most cases,
you don't need to explicitly do anything with the \code{Exclusive} argument!
(If you want this \emph{not} to happen, you need to explicitly specify your own \code{Exclusive} argument, or \code{Exclusive = NULL}.)
}

\subsection{Regex Dispatch}{

If you call \code{tonalInterval} (or \emph{any} \link[=pitchFunctions]{pitch function}) on a \code{character}-string vector, but the \code{Exclusive} argument is missing
or \code{NULL}, \code{humdrumR} will instead use regular-expression patterns to select a known interpretation.
For example, \code{pitch('so')} will automatically recognize that \code{'so'} is solfege, and will interpret the data accordingly (the output should be G4).
If there are more than one matches, \code{humdrumR} will use the longest match, and if they tie, pick based on the order in the table above (topmost first).

If there is no match, \code{tonalInterval} (and all other \link[=pitchFunctions]{pitch function}) return \code{NA} values.
Remember, if \code{Exclusive} is specified, it overrides the regex-based dispatch, which means that \code{pitch('so', Exclusive = 'kern')} will return \code{NA}, because
\code{'so'} can't be interpreted as a \verb{**kern} value.
\subsection{"In place" parsing}{

In lots of humdrum data, character strings are encoded with multiple pieces of musical information right besides each other:
for example, \verb{**kern} data might include tokens like \verb{"4.ee-[}.
The \code{humdrumR} parser (\code{tonalInterval}) will automatically "pull out" pitch information from within strings, if it can find any,
using the appropriate known regular expressions.
Various \link[=pitchFunctions]{pitch parsing functions} have an option to keep the original "extra" data, using their \code{inPlace} argument.
}

}

\subsection{Advanced Tonal Parsing Options}{

The eleven tonal representations listed above are parsed through a common intesrface.
By using "advanced" parsing arguments, you can tweak how this parsing is done, so as to accommodate even more input representations!
This means we are controlling the behavior of \code{tonalInterval()}, in the second step of our pipeline:
\itemize{
\item \strong{Input} representation \verb{|>}
\itemize{
\item \emph{Parsing} (done by \verb{tonalInterval(PARSE ARGS GO IN HERE!)}) \verb{|>}
\itemize{
\item \strong{Intermediate} (\link[=tonalIntervalS4]{tonalInterval}) representation \verb{|>}
}
\item \emph{Deparsing} \verb{|>}
}
\item \strong{Output} representation
}

Note that these arguments are similar or identical to parallel "advanced" deparsing arguments used by various \link[=pitchFunctions]{pitch functions}.
The following "advanced" parsing arguments are available (read all the details about them further down):
\itemize{
\item \strong{Steps}
\itemize{
\item \code{step.labels}
\item \code{step.signed}
}
\item \strong{Species} (accidentals or qualities)
\itemize{
\item \code{qualities}
\item \code{specifier.maximum}
\item \emph{Accidentals}
\itemize{
\item \code{natural}, \code{flat}, \code{sharp}, \code{doubleflat}, \code{doublesharp}
}
\item \emph{Qualities}
\itemize{
\item \code{perfect}, \code{major}, \code{minor}, \code{augment}, \code{diminish}
}
\item \emph{Implicit vs Explicit Species}
\itemize{
\item \code{implicitSpecies}
\item \code{absoluteSpecies}
\item \code{memory}, \code{memoryWindows}
}
}
\item \strong{Octave}
\itemize{
\item \code{octave.integer}
\item \code{up}, \code{down}, \code{same}
\item \code{octave.offset}
\item \code{octave.round}
\item \code{octave.relative}, \code{octave.absolute}
}
\item \strong{String parsing}
\itemize{
\item \code{parts}
\item \code{sep}
}
}

These "advanced" arguments can be used directly in \emph{any} \link[=pitchFunctions]{pitch function}, or in a call to \code{tonalInterval} itself.
To use them with \code{tonalInterval} just specify them directly as arguments: for example, \code{tonalInterval(x, qualities = TRUE)}.
To use them with other \link[=pitchFunctions]{pitch functions}, you can either...
\itemize{
\item Put them in the \code{parseArgs} argument:
\itemize{
\item \code{kern(x, parseArgs = list(qualities = TRUE))}
}
\item Or use the "syntactic sugar" short-hand form:
\itemize{
\item \code{kern(x, parse(qualities = TRUE))}
}
}

Each of the known Exclusive/Regex-dispatch combo (see the table above) is associated with default parsing arguments.
For example, if you set \code{Exclusive = 'kern'} or just use data that \emph{look} like \verb{**kern}, the \code{flat} argument is set to \code{"-"},
However, if you had, for example, input data that looked like \verb{**kern} \strong{except} it used a different flat symbol, like \code{"_"}, you could modify the parser:
\code{kern("EE_", parse(flat = "_"))}
This overrides the default value for \verb{**kern}---notice, that it \emph{also} updates the \verb{**kern} regular expression accordingly, so it works exactly the same as the standard \code{\link[=kern]{kern()}} function.
}

\subsection{Steps}{

Any representation of "tonal" pitch information will include a representation of \emph{diatonic steps}.
You can control how the parser reads diatonic steps from a pitch representation using the \code{step.labels} argument.
The \code{step.labels} argument must be an atomic vector of unique values, with a length which is a positive multiple of seven.
Examples of \code{step.labels} arguments that are currently used by preset \code{humdrumR} pitch parsers include:
\itemize{
\item \code{parse(step.labels = c('A', 'B', 'C', 'D', 'E', 'F', 'G'))} --- (\verb{**Tonh})
\item \code{parse(step.labels = c('d', 'r', 'm', 'f', 's', 'l', 't'))} --- (\verb{**solfa})
\item \code{parse(step.labels = c('I', 'II', 'III', 'IV', 'V', 'VI', 'VII'))} --- (roman numerals)
}

If \code{step.labels} is \code{NULL}, steps are assumed to be represented by integers, including negative integers representing downward steps.

There is also a \code{step.signed} (\code{logical}, \code{length == 1}) argument: if \code{step.signed = TRUE}, lowercase versions of \code{step.labels} are interpreted as negative (downward) steps and
uppercase versions of \code{step.labels} are interpreted as positive (upwards) steps.
This option is used, for example, by the default \code{\link[=kern]{kern()}} and \code{\link[=helmholtz]{helmholtz()}} parsers.
}

\subsection{Species}{

In tonal pitch representations, "\emph{specific}" versions of tonal pitches---the tonal "species"---are indicated by "specifiers":
either \emph{accidentals} or \emph{qualities}.
The \code{qualities} (\code{logical}, \code{length == 1}) argument indicates whether accidentals are used (\code{qualities = FALSE}) or qualities (\code{qualities = TRUE}).
Some specifiers can be repeated any number of times, like "triple sharps" or "doubly augmented";
The \code{specifier.maximum} (\code{integer}, \code{length == 1}) argument sets a maximum limit on the number of specifiers to read.
For example, you could force all triple sharps (\code{"###"}) or double sharps (\code{"##"}) to parse as just \code{"#"}, by specifying \code{specifier.maximum = 1L}.
\subsection{Accidentals}{

If \code{qualities = FALSE} the parser will look for accidentals in the input, recognizing three types: naturals, flats, and sharps.
The \code{natural}, \code{flat}, and/or \code{sharp} (\code{character}, \code{length == 1}) arguments can be used to indicate how accidentals are represented in the input.
For example, if the input strings look like \code{c("Eflat", "C")}, you could set the argument \code{flat = "flat"}.

Examples of accidental argument combinations that are currently used by preset \code{humdrumR} pitch parsers include:
\itemize{
\item \code{parse(flat = "b", sharp = "#")} -> \verb{**pitch}
\item \code{parse(flat = "-", sharp = "#")} -> \verb{**kern}
\item \code{parse(flat = "-", sharp = "+")} -> \verb{**degree}
}

The \code{doubleflat}, and \code{doublesharp} (\code{character}, \code{length == 1}) arguments are \code{NULL} by default, but can be set if a special symbol is used
to represent two sharps or flats. For example, you might have an input which represents double sharps as \code{"x"}.
You could call \code{kern("Fx", parse(doublesharp = "x"))} and the output will be \code{"F##"}.
}

\subsection{Qualities}{

If \code{qualities = TRUE} the parser will look for qualities in the input, recognizing five types: perfect, minor, major, augmented, and diminished.
The \code{perfect}, \code{major}, \code{minor}, \code{diminish}, and/or \code{augment} (\code{character}, \code{length == 1}) arguments can be used to indicate how qualities
are represented in the input.
(Note: we are talking about interval/degree qualities here, not chord qualities!)
For example, if the input strings look like \code{c("maj3", "p4")}, you could set the arguments \code{major = "maj"} and \code{perfect = "p"}.
Examples of quality argument combinations that are currently used by \code{humdrumR} \link[=pitchFunctions]{pitch functions} include:
\itemize{
\item \code{parse(major = "M", minor = "m", perfect = "P", diminish = "d", augment = "A")}
\item \code{parse(diminish = "o", augment = "+")}
}
}

\subsection{Implicit vs Explicit Species}{

In some musical data, specifiers (e.g., accidentals or qualities) are not explicitly indicated; instead,
you must infer the species of each pitch from the context---like the key signature!.
\subsection{From the Key}{

The most important argument here is \code{implicitSpecies} (\code{logical}, \code{length == 1}):
if \code{implicitSpecies = TRUE}, the species of input without an explicit species indicated is interpreted using the \code{Key}.
For example,
\itemize{
\item \code{kern('C', Key = 'A:', parse(implicitSpecies = TRUE))} is parsed as \code{"C#"}
\itemize{
\item C is sharp in A major.
}
\item \code{kern('C', Key = 'a:', parse(implicitSpecies = TRUE))} is parsed as \code{"C"}
\itemize{
\item C is natural in A minor.
}
\item \code{kern('C', Key = 'a-:', parse(implicitSpecies = TRUE))} is parsed as \code{"C-"}
\itemize{
\item C is flat in A-flat minor.
}
}

By default, if you input \emph{already has} specifiers, they are interpreted absolutely---overriding the "implicit" \code{Key}---,
even if \code{implicitSpecies = TRUE}.
Thus, if we are in A major:
\itemize{
\item \code{kern("C#", Key = 'A:', parse(implicitSpecies = TRUE))} is parsed as \code{"C#"}.
\itemize{
\item The \code{"#"} is unnecessary.
}
\item \code{kern("Cn", Key = 'A:', parse(implicitSpecies = TRUE))} is parsed as \code{"C"}.
\itemize{
\item The \code{"n"} overrides the \code{Key}.
}
\item \code{kern("C#", Key = 'a:', parse(implicitSpecies = TRUE))} is parsed as \code{"C#"}.
\itemize{
\item The \code{"#"} overrides the \code{Key}.
}
}

However! You can also change this behavior by setting the \code{absoluteSpecies} (\code{logical}, \code{length == 1}) argument to \code{FALSE}.
If you do so, the specifiers in the input are interpreted "on top of" the key accidental:
\itemize{
\item \code{kern("C#", Key = 'A:', parse(implicitSpecies = TRUE, absoluteSpecies = FALSE))} is parsed as \code{"C##"}.
\itemize{
\item The \code{"#"} from the input is added to the \code{"#"} from the \code{Key}, resulting in double sharp!
}
}

This is an unusual behavior, for absolute pitch representations like \verb{**kern}.
However, for use with scale or chord degrees, \code{absoluteSpecies = FALSE} might be appropriate.
For example, if we are reading a \href{https://en.wikipedia.org/wiki/Figured_bass}{figured bass} in the key of E minor,
a \code{"b7"} figure above an E in the bass should be interpreted as a \emph{double flat} (diminished) 7th (Db over E)!
If this is how your data is encoded, use \code{absoluteSpecies = FALSE}.
}

\subsection{Memory}{

In some musical data, it is assume that a accidental on a note "stays in effect" on that scale step until the next bar,
or until a different accidental replaces it.
Fortunately, the \code{humdrumR} parser (\code{tonalInterval()}) also knows how to parse data encoded with "memory" this way.
If \code{memory = TRUE}, the accidental (or quality) of each input note is "remembered" from previous appearances of that scale step.
For example,
\itemize{
\item \code{kern(c("D#", "E", "D", "E", "Dn", "C", "D"), parse(memory = TRUE))}
\itemize{
\item is parsed as \code{c("D#", "E", "D#", "E", "D", "C", "D")}
}
}

If we want the "memory" to only last when specific time windows (like bars), we can also specify a
\code{memoryWindows} argument. \code{memoryWindows} must be an atomic vector which is the same length as the input (\code{x} argument).
Each unique value within the \code{memoryWindows} vector is treated as a "window" within which \code{memory} operates.
The most common use case would be to pass the \code{Bar} field from a \code{humdrumR} dataset to \code{memoryWindows}!

The \code{memory} and \code{memoryWindows} argument work whatever values of \code{implicitSpecies} or \code{absoluteSpecies} are specified!
Though all the examples here use accidentals, these arguments all have the same effect if parsing qualities (\code{qualities = TRUE}).
}

}

}

\subsection{Octave}{

The final piece of information encoded in most (but not) all pitch representations is an indication of the "compound pitch"---
incorporating octave information.
In \code{humdrumR} octaves are \emph{always} defined in terms of scale steps: so two notes with the same scale degree/letter name will always be the same octave.
This mainly comes up with regards to Cb and B#: Cb4 is a semitone below ; B#3 is enharmonically the same as middle-\strong{C}.
\subsection{Integer Octaves}{

The simplest way octave information can be encoded is as an integer value, as in \href{https://en.wikipedia.org/wiki/Scientific_pitch}{Scientific Pitch}.
If you need to parse integer-encoded octaves, set the \code{octave.integer} (\code{logical}, \code{length == 1}) argument to \code{TRUE}.
By default, \code{humdrumR} considers the "central" octave (\code{octave == 0}) to be the octave of , or equivalently, a unison.
However, if a different octave is used as the central octave, you can specify the \code{octave.offset} (\code{integer}, \code{length == 1}) argument.

To illustrate, the default \href{https://en.wikipedia.org/wiki/Scientific_pitch}{Scientific Pitch} parser used the arguments:
\itemize{
\item \verb{kern('C5', parse(octave.integer = TRUE, octave.offset = 4)}
\itemize{
\item Returns \code{"cc"} (the octave above middle C).
}
}
}

\subsection{Non-integer Octave Markers}{

If \code{octave.integer = FALSE}, the \code{humdrumR} parser instead looks for three possible symbols to indicate octave information.
These symbols are controlled using the \code{up}, \code{down}, and \code{same} (\code{character}, \code{length == 1}) arguments.
A \code{same} symbol, or no symbol, is interpreted as the "central" octave; repeating strings of the \code{up} or \code{down} symbols indicate
increasing positive (\code{up}) or negative (\code{down}) octaves.
For example, in \code{lilypond} notation, \verb{,} represents lower octaves, and \verb{'} (single apostrophe) represents upper octaves.
So the default \code{\link[=lilypond]{lilypond()}} parser uses these arguments:
\itemize{
\item \code{pitch(c("c", "c", "c'"), parse(octave.integer = FALSE, up = "'", down = ",", octave.offset = 1))}
\itemize{
\item Returns \code{c("C2", "C3", "C4")}.
}
}

(Note that lilypond makes the octave \emph{below}  the central octave, using \code{octave.offset = 1}.)
}

\subsection{Octave "Rounding"}{

In some situations, pitch data might interpret the "boundaries" between octaves a little differently.
In most absolute pitch representations (e.g., \code{\link[=kern]{kern()}}, \code{\link[=pitch]{pitch()}}), the "boundary" between one octave and the next is
between B (degree 7) and C (degree 1).
However, if for example, we are working with data representing intervals, we might think of an "octave" as spanning the range \code{-P4} (\code{G}) to \code{+P4} (\code{f}).
In this case, the "octave boundary" is \emph{centered} around the unison (or ), rather than starting \emph{at} middle-\strong{C}/unison.
If our data was represented this way, we could use the \code{octave.round} argument; \code{octave.round} must be a rounding \emph{function},
either \link[base:Round]{round, floor, ceiling, trunc}, or \link{expand}.
These functions indicate how we interpret simple pitches "rounding" to the nearest C/unison.
The default behavior for most pitch representations is \code{octave.round = floor}: each scale step is rounded downwards to the nearest C.
So B is associated with the C 7 steps below it.
If, on the other hand, \code{octave.round = round}, then scale-steps are "rounded" to the closest C, so B and A are associated with the closer C \emph{above} them.
Indeed, \code{octave.round = round} gets us the \code{-P4} <-> \code{+P4} behavior we mentioned earlier!

When working parsing \link[=interval]{intervals}, the \code{octave.round} option allows you to control how the "simple part" (less than an octave) of a compound interval is represented.
For example, we might think of a ascending major 12th as being an ascending octave \emph{plus} a ascending perfect 5th: ** +P8 + P5**.
\strong{Or} we could encode that same interval as \emph{two} ascending octaves \emph{minus} a perfect fourth: \strong{+ P15 - P4}.
The following table illustrates how different \code{octave.round} arguments "partition" compound intervals into simple parts and octaves:\tabular{llllll}{
    \tab round \tab floor \tab ceiling \tab trunc \tab expand \cr
   -P12: \tab -P15 + P4 \tab -P15 + P4 \tab -P8  - P5 \tab -P8  - P5 \tab -P15 + P4 \cr
   -P11: \tab -P8  - P4 \tab -P15 + P5 \tab -P8  - P4 \tab -P8  - P4 \tab -P15 + P5 \cr
   -P8: \tab -P8  + P1 \tab -P8  + P1 \tab -P8  + P1 \tab -P8  + P1 \tab -P8  + P1 \cr
   -P5: \tab -P8  + P4 \tab -P8  + P4 \tab +P1  - P5 \tab +P1  - P5 \tab -P8  + P4 \cr
   -P4: \tab +P1  - P4 \tab -P8  + P5 \tab +P1  - P4 \tab +P1  - P4 \tab -P8  + P5 \cr
   P1: \tab +P1  + P1 \tab +P1  + P1 \tab +P1  + P1 \tab +P1  + P1 \tab +P1  + P1 \cr
   +P4: \tab +P1  + P4 \tab +P1  + P4 \tab +P8  - P5 \tab +P1  + P4 \tab +P8  - P5 \cr
   +P5: \tab +P8  - P4 \tab +P1  + P5 \tab +P8  - P4 \tab +P1  + P5 \tab +P8  - P4 \cr
   +P8: \tab +P8  + P1 \tab +P8  + P1 \tab +P8  + P1 \tab +P8  + P1 \tab +P8  + P1 \cr
   +P11: \tab +P8  + P4 \tab +P8  + P4 \tab +P15 - P5 \tab +P8  + P4 \tab +P15 - P5 \cr
   +P12: \tab +P15 - P4 \tab +P8  + P5 \tab +P15 - P4 \tab +P8  + P5 \tab +P15 - P4 \cr
   +P15: \tab +P15 + P1 \tab +P15 + P1 \tab +P15 + P1 \tab +P15 + P1 \tab +P15 + P1 \cr
   +P18: \tab +P15 + P4 \tab +P15 + P4 \tab +P22 - P5 \tab +P15 + P4 \tab +P22 - P5 \cr
   +P19: \tab +P22 - P4 \tab +P15 + P5 \tab +P22 - P4 \tab +P15 + P5 \tab +P22 - P4 \cr
}


Notice that, if \code{octave.floor} is being used, all simple intervals are represented as ascending.

When parsing \link[=pitch]{"absolute" pitch} representations, the \code{octave.round} option allows you to control which octave notes are associated with.
The following table illustrates:\tabular{llllll}{
    \tab round \tab floor \tab ceiling \tab trunc \tab expand \cr
   FF: \tab F2 \tab F2 \tab F3 \tab F3 \tab F2 \cr
   GG: \tab G3 \tab G2 \tab G3 \tab G3 \tab G2 \cr
   C: \tab C3 \tab C3 \tab C3 \tab C3 \tab C3 \cr
   F: \tab F3 \tab F3 \tab F4 \tab F4 \tab F3 \cr
   G: \tab G4 \tab G3 \tab G4 \tab G4 \tab G3 \cr
   c: \tab C4 \tab C4 \tab C4 \tab C4 \tab C4 \cr
   f: \tab F4 \tab F4 \tab F5 \tab F4 \tab F5 \cr
   g: \tab G5 \tab G4 \tab G5 \tab G4 \tab G5 \cr
   cc: \tab C5 \tab C5 \tab C5 \tab C5 \tab C5 \cr
   ff: \tab F5 \tab F5 \tab F6 \tab F5 \tab F6 \cr
   gg: \tab G6 \tab G5 \tab G6 \tab G5 \tab G6 \cr
   ccc: \tab C6 \tab C6 \tab C6 \tab C6 \tab C6 \cr
   fff: \tab F6 \tab F6 \tab F7 \tab F6 \tab F7 \cr
   ggg: \tab G7 \tab G6 \tab G7 \tab G6 \tab G7 \cr
}

}

\subsection{Absolute or Relative (contour) Octave}{

In some notation encoding schemes, the "octave" of each note is interpreted \emph{relative} the previous note, rather than any absolute reference.
The most prominent system is Lilypond's \href{https://lilypond.org/doc/v2.22/Documentation/notation/writing-pitches#relative-octave-entry}{relative octave entry} style.
This style is often used in combination with scale degree representations---as in the \href{http://rockcorpus.midside.com/melodic_transcriptions.html}{RS200} corpus.
For example, a data set might say \verb{Do Re Mi vSo La Ti Do}, with the \code{"v"} indicating a jump down to \code{So}.
To activate relative-octave parsing, set \code{octave.relative = TRUE}---alternatively, you can use \code{octave.absolute = FALSE}, which is equivalent.

In a relative-octave data, we assume that octave indications indicate a shift relative to the previous note.
This would usually be used in combination with octave markers like \code{"^"} (up) or \code{"v"} (down).
Different combinations of \code{octave.round} allow us to parse different behaviors:
\itemize{
\item If \code{octave.round = round}, a \code{same} marker (or no marker) indicates that the note is the pitch \emph{closest} to the previous pitch.
Octave markers indicate alterations to this assumption.
As always, this is based on scale steps, not semitones!
Any fourth is "closer" than any fifth, regardless of their quality: So \emph{C F#} is ascending and \emph{C Gb} is descending!
A ascending diminished 5th would be written \code{C ^Gb}---with \verb{up = ^}.
\item If \code{octave.round = floor}, a \code{same} marker (or no marker) indicates that the note is in the octave above the previous pitch.
Octave markers indicate alterations to this assumption.
With this setting, going from \emph{C} down to \emph{B} always requires a \code{down} mark.
}
}

}

\subsection{String Parsing}{

In addition to the three types of \emph{musical} parsing considerations reviewed above (steps, species, and octaves), there are also some general
string-parsing issues that we can consider/control.
\subsection{Parts and Order}{

So far (above) we've discussed various ways that tonal pitch information (step, species, and octave) can be encoded, and how
the \code{humdrumR} parser can be modified to handle different options.
However, there are two general parsing issues/options to consider: what information is encoded, and in \emph{what order}?
The \code{parts} argument can be specifyied to indicate this.
The \code{parts} argument must be a \code{character} vector of length 1--3.
The characters in the must \link[base:pmatch]{partial match} either \code{"step"}, \code{"species"}, or \code{"octave"}.
The presense of any of these strings in the \code{parts} vector indicate that that information should be parsed.
The \emph{order} of the strings indicates what order the pieces of pitch information are encoded in input strings.

To illustrate, imagine that we had input data which was identical to a standard interval representation---e.g., \code{M2} and \code{P5}---except the
quality appears \emph{after} the step---e.g., \verb{2M} and \verb{5P}.
We could call \code{interval(c("2M", "5P"), parse(parts = c("step", "species")))} and sure enough we'd get the correct parse!

One final string-parsing argument is \code{sep}, which indicates if there is a character string separating the pitch information components:
The most common case would be a comma or space.
For example, we could use a parse command like this: \code{kern("E flat 5", parse(flat = "flat", sep = " "))}.
}

}
}

\section{Atonal Parsing (\code{numeric} inputs)}{
The \code{humdrumR} pitch parser (\code{tonalInterval()}) will interpret numeric inputs as atonal pitch information.
By default, numbers are interpreted as semitones.
However, parses for \code{\link[=midi]{midi()}}, \code{\link[=cents]{cents()}},  and \link[=freq]{frequencies} are also defined.
Dispatch to these different parsers is controlled by the \code{Exclusive} argument.\tabular{lrr}{
   Representation \tab Exclusive \tab Example \cr
   Semitones \tab **semits (or \code{NULL}) \tab \code{3} -> \verb{e-} \cr
   MIDI \tab **midi \tab \code{63} -> \verb{e-} \cr
   Cents \tab **cents \tab \code{300} -> \verb{e-} \cr
   Frequency (Hz) \tab  \tab  \cr
}

\subsection{Enharmonic Interpretation}{

When converting from an atonal representation to a tonal one, we must decide how to interpret the tonality
of the input---specifically, which \href{https://en.wikipedia.org/wiki/Enharmonic}{enharmonic spelling} of notes to use.
The  \code{humdrumR} numeric parser interprets atonal pitches in a "enharmonic window" of 12 steps on the line-of-fifths.
The position of this window is set with the \code{enharmonic.center} (\code{integer}, \code{length == 1}) argument.
By default, \code{enharmonic.center = 0}, which creates a window from a \code{-5} (\emph{b2}) to \code{+6}) (\emph{#4}).
If you prefer \emph{#1} instead of \emph{b2}, set \code{enharmonic.center = 1}.
For all flats, set \code{enharmonic.center = -1}.
For all sharps, set \code{enharmonic.center = 4}.\tabular{rllllllllllll}{
   \code{enharmonic.center} \tab 0 \tab 1 \tab 2 \tab 3 \tab 4 \tab 5 \tab 6 \tab 7 \tab 8 \tab 9 \tab 10 \tab 11 \cr
   \code{-2} \tab 1 \tab b2 \tab 2 \tab b3 \tab 3 \tab 4 \tab b5 \tab 5 \tab b6 \tab 6 \tab b7 \tab b1 \cr
   \code{-1} \tab 1 \tab b2 \tab 2 \tab b3 \tab 3 \tab 4 \tab b5 \tab 5 \tab b6 \tab 6 \tab b7 \tab 7 \cr
   \code{0} \tab 1 \tab b2 \tab 2 \tab b3 \tab 3 \tab 4 \tab #4 \tab 5 \tab b6 \tab 6 \tab b7 \tab 7 \cr
   \code{1} \tab 1 \tab #1 \tab 2 \tab b3 \tab 3 \tab 4 \tab #4 \tab 5 \tab b6 \tab 6 \tab b7 \tab 7 \cr
   \code{2} \tab 1 \tab #1 \tab 2 \tab b3 \tab 3 \tab 4 \tab #4 \tab 5 \tab #5 \tab 6 \tab b7 \tab 7 \cr
   \code{3} \tab 1 \tab #1 \tab 2 \tab #2 \tab 3 \tab 4 \tab #4 \tab 5 \tab #5 \tab 6 \tab b7 \tab 7 \cr
   \code{4} \tab 1 \tab #1 \tab 2 \tab #2 \tab 3 \tab 4 \tab #4 \tab 5 \tab #5 \tab 6 \tab #6 \tab 7 \cr
}


The \code{enharmonic.center} argument will work the same when translating to any pitch representation, like \code{\link[=kern]{kern()}}.
However, we present the table above in terms of scale degrees because the \emph{atonal -> enharmonic} calculation
is centered on a key.
So, if \code{Key} argument is specified, the "enharmonic window" is centered around that key.
So if you are translating to \code{kern} and the \code{Key = F#:}, the output will range from \code{Gn} to \code{B#}.
If you don't want this, set \code{Key = NULL}.
\subsection{Melodic Interpretation of Chromatic Notes}{

It is very common for chromatic notes in melodic passages to be labeled based on their melodic contour:
i.e., ascending chromatic notes labeled sharp and descending chromatic notes labeled flat.
This behavior can be engaged by setting the \code{accidental.melodic} (\code{logical}, \code{length == 1}) argument.
When \code{accidental.melodic = TRUE}, the input is first centered in the enharmonic window (above), but then
any places where a chromatic alteration proceeds upwards to a non-chromatic note will be altered (if necessary) to a
sharp, and vice verse for a descending notes and flats.
For example, while \code{kern(0:2)} returns \code{c("c", "d-", "d")}, \code{kern(0:2, parse(accidental.melodic = TRUE))} returns \code{c("c", "c#", "d")}.
}

}
}

\examples{

tonalInterval('II#', step.labels =c('I', 'II', 'III','IV','V','VI','VII'))

kern('E x 5', parse(doublesharp = 'x', sep = ' '))

#' @returns 

`tonalInterval()` returns a [tonalInterval][tonalIntervalS4] object of the same
length and dimensions as `x`.
`NULL` inputs (`x` argument) return a `NULL` output.
`NA` values in the input `x` are propagated to the output.

}
