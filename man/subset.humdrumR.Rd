% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Subset.R
\name{subset.humdrumR}
\alias{subset.humdrumR}
\alias{subset}
\alias{clearFilter}
\alias{removeEmptyFiles}
\alias{removeEmptySpines}
\alias{removeEmptyPaths}
\alias{removeEmptyRecords}
\alias{removeEmptyStops}
\title{Filter humdrum data}
\usage{
\method{subset}{humdrumR}(x, ...)

clearFilter(humdrumR)

removeEmptyFiles(humdrumR)

removeEmptySpines(humdrumR)

removeEmptyPaths(humdrumR)

removeEmptyRecords(humdrumR)

removeEmptyStops(humdrumR)
}
\description{
\code{subset.humdrumR} is a command used to filter a \link[=humdrumRclass]{humdrumR corpus}.
The standard indexing operators (\verb{[]} and \verb{[[]]}) actually work by calling \code{subset} under-the-hood;
you can read about these indexing options \link[=indexHumdrum]{here}.
However, using \code{subset} directly can accomplish much more sophisticated filtering commands than the indexing
methods.
}
\details{
\code{subset.humdrumR} is used in a similar manner to \link{withinHumdrum},
taking any number of "do expressions" (or functions) as arguments.
In fact, do expressions/function arguments are passed directly to an internal call to \code{withinHumdrum}, and
other control expressions (like \code{by} or \code{where}) can be used as well.
The only requirement is that the expressions/functions fed to \code{subset.humdrumR}
\emph{must} be \href{https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)}{predicate} expressions
which return a logical (\code{TRUE}/\code{FALSE}) vector.
The returned vector must also be the same length as the input data (the number
of rows in the \link[=humTable]{humdrum table}).
(You can use a \code{dofill} expression if you want to "expand" shorter outputs for filtering pusposes.)
}
\section{Filter field}{


When using \code{subset}, \code{humdrumR} doesn't necessarily delete the data you filter out.
Rather, there is a \code{logical} field in the \link[=humTable]{humdrum table} called \code{Filter}.
\code{subset.humdrumR} updates the humdrum table's \code{Filter} field using an logical OR (\code{|}) between the
existing \code{Filter} field and the negation of your predicate: \code{Filter | !Predicate}.
HumdrumR functions (mostly) ignore all data points where \code{Filter == TRUE}, treating them like \code{NULL} data.
For example, when you print a
filtered \code{humdrumR} you'll see all the filtered data points turned to null data (\code{.}), and
any calls to \link[=with(in)Humdrum]{withinHumdrum} will ignore the filtered data.
This means that you can, recover the filtered data by calling \code{clearFilter} on your dataset.

In some cases you might filter out large parts of your data, which will leave a bunch of empty null
data points (\code{"."}).
If you \emph{want} to remove these filtered data points, you can call \code{removeEmptyFiles}, \code{removeEmptySpines},
\code{removeEmptyPaths}, \code{removeEmptyRecords}, or \code{removeEmptyStops}.
These functions go through each piece/spine/path/record and check if \emph{all} the data in that region
is null or filtered (i.e., \code{Null == TRUE | Filter == TRUE}); if so, that data will be removed.
You can only remove the data if \emph{all} of it is null (within a region) because otherwise the humdrum syntax is broken.

By default, \code{subset.humdrumR} automatically calls \code{removeEmptyFiles} at the end.
However, you can stop this by specifying  \code{removeEmptyFiles == FALSE}.
}

\section{Renumbering}{


If filtered files are removed from a corpus (using \code{removeEmptyFiles} or \code{removeEmptySpines}, in combination with \code{subset})
the \code{File} and/or \code{Spine} fields are renumbered to represented the remaining regions,
starting from \code{1}.
For example, if you have a corpus of 10 files and remove the first file (\code{File == 1}),
the remaining files are renumbered from \code{2:10} to \code{1:9}.
Spine renumbering works the same, except it is done independently \emph{within} each file
(\link[=humColumns]{columns} are also renumbered accordingly).
}

