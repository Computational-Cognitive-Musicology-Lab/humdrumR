% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/humdrumR-package.R
\name{groupingFactors}
\alias{groupingFactors}
\title{What are "grouping factors"?}
\description{
What are "grouping factors"?
}
\section{Grouping and "split-apply-combine" explained}{


The concept of "grouping factors" is widely used in R, allowing
us to quickly \emph{split} datasets (\link{vector}s or \link{data.frame}s) into subgroups,
work with the subgroups independent (\emph{apply} functions to them),
and then re\emph{combine} them as needed.
Various R functions specify "grouping factors" in a confusing
variety of subtly different ways, usually as function arguments named
things like \code{INDEX}, \code{INDICES}, \code{f}, \code{by}, or \code{groupby}.
In \code{humdrumR}, we adopt the tidyverse \link{dplyr} approach, using the
\code{group_by()} function (and/or the \code{.by} argument).

Any \link[=vector]{atomic vector} with at least two
unique values, or "levels", can be used as a grouping factor---generally,
grouping vectors are coerced into \link{factor}s.
Each unique level in a grouping vector/factor represents a single group.
Any vector, or \link{data.frame} that is \emph{the same length/height} as the grouping factor
can then be broken into these groups, taking all the indices where the grouping factor
equals each group in turn.
Since we generally try to work with data.frames, which by definition contain a bunch
of vectors that are the same length, we can use any vector/column in a data.frame
to group any of the other vectors, or the rows of the whole data.frame.

Most functions allow you to specifiy multiple grouping factors/vectors (so long as they are all
the same length).
The groups are then defined by every \emph{unique combination} of elements in the vectors.
So, for example, if we use the vectors \code{c('A', 'A', 'A', 'B', 'B', 'B')} and
\code{c(1, 1, 2, 2, 3, 3)} as grouping factors, we'll get four groups with levels \verb{1A}, \verb{2A}, \verb{2B}, and \verb{3B}.

Note that groups created by grouping factors are \emph{not} neccessarily contiguous.
If we use a vector like \code{c(1, 1, 2, 2, 1, 1)} as grouping factor, we get two groups: \code{1} and \code{2}.
The \code{1} group would include the 1st, 2nd, 5th, and 6th indices, even though they are
separated in the grouping factor.
If you \emph{want} contiguous groups you must make them.
The \code{humdrumR} function \code{\link[=segments]{segments()}} can be used to generate strictly contiguous grouping factors.
For example, \code{segments(c(1, 1, 2, 2, 1, 1))} will return \code{c(1, 1, 2, 2, 3, 3)}.
}

\seealso{
Other {R lessons.}: 
\code{\link{evaluatingExpressions}},
\code{\link{partialMatching}},
\code{\link{recycling}},
\code{\link{vectorization}}
}
\concept{{R lessons.}}
