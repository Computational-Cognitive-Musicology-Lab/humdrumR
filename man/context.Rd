% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Context.R
\name{context}
\alias{context}
\alias{uncontext}
\title{Create arbitrary "context" across vectors.}
\usage{
context(x, open, close, ...)

uncontext(humdrumR)
}
\arguments{
\item{x}{\emph{\strong{Input data to group into windows.}}

Must be an atomic vector.}

\item{open}{\emph{\strong{Where to "open" (start) windows.}}

Can be natural numbers, \code{logical} vectors (of the same length as \code{x}),
a single \code{character} string (interpreted as a regular expression).
May also be an arbitrary expression which returns natural numbers;
the expression can refer to named elements of \code{reference}, to \code{end} (last index),
to \code{close}, or to \code{prevclose} (the previous close).}

\item{close}{\emph{\strong{Where to "close" (end) windows.}}

Can be natural numbers, \code{logical} vectors (of the same length as \code{x}),
a single \code{character} string (interpreted as a regular expression).
May also be an arbitrary expression which returns natural numbers;
the expression can refer to named elements of \code{reference}, to \code{end} (previous index),
to \code{open}, or to \code{nextopen} (the next open).}

\item{reference}{\emph{\strong{Vector(s) to use to identify window open/closes.}}

Defaults to \code{x}.

Must be either an atomic vector of the same length as \code{x}, or a \code{list()}/\code{data.frame}
of such vectors, all \link[=names]{named}.}

\item{overlap}{\emph{\strong{How are overlapping windows treated/created?}}

Defaults to \code{'paired'}.

Must be a single \code{character}, \link[=partialMatching]{partially matching}
either \code{"paired"}, \code{"nested"}, \code{"edge"}, or \code{"none"}.}

\item{depth}{\emph{\strong{How "deep" can windows overlap?}}

Defaults to \code{NULL}.

Must be \code{NULL}, or a vector of non-zero whole numbers.}

\item{rightward}{\emph{\strong{Should window alignment/overlap be determined from left to right?}}

Defaults to \code{TRUE}.

Must be a singleton \code{logical} value: an on/off switch.}

\item{duplicate_indices}{\emph{\strong{Can the same index open/close multiple windows?}}

Defaults to \code{TRUE}.

Must be a singleton \code{logical} value: an on/off switch.}

\item{min_length, max_length}{\emph{\strong{The minimum/maximum lengths of output windows.}}

Default to two and infinity (no maximum) respectively.

Must be single, positive whole numbers.}

\item{inPlace}{\emph{\strong{Should output be padded to same length as input?}}

Defaults to \code{FALSE}.

Must be a singleton \code{logical} value: an on/off switch.}

\item{complement}{\emph{\strong{Should input "outside" any windows, be output?}}

Defaults to \code{FALSE}.

Must be a singleton \code{logical} value: an on/off switch.}

\item{alignToOpen}{\emph{\strong{Should '\code{inPlace}' output be aligned to the open of each window?}}

Defaults to \code{TRUE}.

Must be a singleton \code{logical} value: an on/off switch.}

\item{collapse}{\emph{\strong{Should output windows be collapsed to single \code{character} strings?}}

Defaults to \code{TRUE}.

Must be a singleton \code{logical} value: an on/off switch.}

\item{sep}{\emph{\strong{Separator for collapsed output.}}

Defaults to a comma (\code{","}).

Must be a single \code{character} string.}

\item{stripRegex}{\emph{\strong{Should regular expressions matched by the \code{open}/\code{close} arguments be removed from the output?}}

Defaults to \code{FALSE}.

Must be a singleton \code{logical} value: an on/off switch.}

\item{groupby}{\emph{\strong{Optional vectors to group windows within.}}

Defaults to empty \code{list()}.

Must be a \code{\link[=list]{list()}}, which is either empty or contains vectors which are all the same length as \code{x}.
In calls to \link[=withinHumdrum]{with/within.humdrumR}, \code{groupby} is passed \code{list(Piece, Spine, Path)} by default.

Windows cannot cross group boundaries.}
}
\description{
The \code{context()} command can be used to group input data (vectors)
into arbitrary contextual windows.
Unlike the contextual-grouping you can achieve with \code{group_by},
\code{context()} can produce windows that \emph{overlap} or, the opposite case, that don't exhaustively
divide the data.
The \code{context()} function should generally be call on
\link[=humdrumRclass]{humdrumR data}, but it can also be called directly on vectors.
}
\details{
\code{context()} takes an input vector (\code{x}) and divides it into windows based on
the content of the \code{reference} vector, which must be the same length as \code{x}---
by default, \code{x} is reused as \code{reference}, so windows are based on the input \code{x} itself.
As a more complex option, \code{reference} can be a named \code{list()} or \code{data.frame} (\code{nrow == length(x)})---
the (named) elements of \code{reference} are then visible to the \code{open} and \code{close} arguments (see below).

The \code{collapse}, \code{inPlace}, and \code{complement} arguments how windows are output.
\itemize{
\item The "complement" refers to elements of the input vector that don't fall inside
any indicated windows: if \code{complement = FALSE} (the default), these "outside" values are
dropped; if \code{complement = TRUE}, they are retained.
\item If \code{inPlace = TRUE}, windows are output in a vector of the same length as the input,
padded with \code{NA} as needed---otherwise (the default), only the windows are returned
\item If \code{collapse = TRUE}, the windows are collapsed to strings (separated by \code{sep}), otherwise,
a \code{list()} of windows is returned.
}
}
\section{Defining windows}{


The system \code{context()} uses to define/identify windows in the data is quite sophisticated,
and can take some time to master!
The basic idea is that you must indicate where you want windows to start ("\emph{open}") and
where you want them to end ("\emph{close}"):
you indicate this using the \code{open} and \code{close} arguments.
These arguments simple indicate indices in the input vector;
For example, if we want a window to open at the 4th and 11th indices,
and close at the 15th and 24th index,
we can write (using the built-in \code{letters} vector for practice):

\if{html}{\out{<div class="sourceCode">}}\preformatted{context(letters, open = c(4, 11), close = c(15, 24))

}\if{html}{\out{</div>}}

This is quite trivial.
However, the \code{open} and \code{close} arguments can actually be arbitary expressions
which do a number of special tricks, including refering to each other.
For example, if either argument includes a call to \code{\link[=hop]{hop()}},
\code{hop()} will automatically be applied along the input vector.
Consider this example:

\if{html}{\out{<div class="sourceCode">}}\preformatted{context(letters, open = hop(2), close = open + 3)
}\if{html}{\out{</div>}}

In this example, the \code{hop()} command generates \code{open} indices for every odd
number from \code{1} to \code{25}.
The \code{close} argument then references these \code{open} indices, and adds \code{3} to each---
the result is the pairs like \code{1:4}, \code{2:5}, \code{3:6}, \code{4:7}, etc.
If we give \code{hop()} different arguments (like \code{by} or \code{from}), we can modify this process.
In fact, if we use the default \code{by} value for \code{hop()} (\code{1}), we can use this approach to
create standard N-grams.

The minimum and maximum length of windows can be controlled using the \code{min_length} and \code{max_length} arguments.
We can also indicate open/closes by providing \code{logical} vectors (the same length as \code{x}).

As mentioned above, if \code{reference} is a named \code{list()} or \code{data.frame()}, \code{open} and
\code{close} and refer to the elements of \code{reference}.
This is useful if you want to open/close windows in reference to multiple vectors:

\if{html}{\out{<div class="sourceCode">}}\preformatted{context(letters, 
        reference = data.frame(Threes = rep(1:3, length.out = 26), 
                               Fours = rep(4:1, length.out = 26)),
        open = Threes == Fours, close = Fours == 1)
}\if{html}{\out{</div>}}
\subsection{Regular Expressions}{

If either \code{open} or \code{close} are provided a \code{character} string, this string is treated
as a regular expression and is matched against the \code{reference} vector.
For exaple, we could make windows in the alphabet starting or ending on each vowel:

\if{html}{\out{<div class="sourceCode">}}\preformatted{context(letters, open = '[aeiou]', close = open + 4)
context(letters, open = close - 4, close = '[aeiou]', alignToOpen = FALSE)

}\if{html}{\out{</div>}}

(Notice that we can use the \code{alignToOpen} argument to change how the output is aligned.)

If the \code{stripRegex = TRUE} (not the default), the matching \code{open} or \code{close} regular expressions are removed
from the output.
This can be useful if the character/tokens used to indicate windows are no longer needed
once windowing is done.
}

\subsection{Special References}{

The \code{open} and \code{close} arguments have a few more special behaviors.
What if we'd like each of our windows to close right before the next window opens?
We can do this by making the \code{close} argument to refer to the \emph{next} \code{open}, by
referring to \code{nextopen} object:

\if{html}{\out{<div class="sourceCode">}}\preformatted{context(letters, open = '[aeiou]', close = nextopen - 1L)
}\if{html}{\out{</div>}}

Conversely, \code{open} can refer to the \code{prevclose} close:

\if{html}{\out{<div class="sourceCode">}}\preformatted{context(letters, open = prevclose + 1, close = '[aeiou]', alignToOpen = FALSE)
}\if{html}{\out{</div>}}

Notice that when we called \code{context(letters, open = '[aeiou]', close = nextopen - 1L)},
the window opening on \code{"u"} is not returned.
This is because there is no "\code{nextopen}" open to close on.
We can instead provide an \code{context()} alternative, using \code{|} (or):

\if{html}{\out{<div class="sourceCode">}}\preformatted{context(letters, open = '[aeiou]', close = nextopen - 1L | 26)

}\if{html}{\out{</div>}}

What if we don't know exactly how long our input vector is?
Refer to the \code{end} object:

\if{html}{\out{<div class="sourceCode">}}\preformatted{context(letters, open = '[aeiou]', close = nextopen - 1L | end)
}\if{html}{\out{</div>}}
}
}

\section{Nested Windows}{


A common use case for \code{context()} is analyzing phrases indicated in music.
In \verb{**kern}, phrases are indicated with opening (\code{(}) and close (\verb{)}) parentheses,
which we can capture with regular expressions for \code{open} and \code{close}.
Here is an example:

\if{html}{\out{<div class="sourceCode">}}\preformatted{nesting1 <- c('(a', 'b)', '(c', 'd', 'e)', '(d', 'e', 'f)', '(e', 'f', 'f#', 'g', 'g#', 'a)')

context(nesting1, open = '(', close = ')')
}\if{html}{\out{</div>}}

Perfect.
However, what if there are nested phrasing indicators?

\if{html}{\out{<div class="sourceCode">}}\preformatted{nesting2 <- c('(a', 'b)', '(c', '(d', 'e)',  '(d', 'e)', 'f)', '(e', '(f', '(f#', 'g)', 'g#)', 'a)')

context(nesting2, open = '(', close = ')')
}\if{html}{\out{</div>}}

That's not what we want!
By default, \code{context()} "pairs" each \code{open} with the next \code{close}, which often makes the most sense.
But in this case, we want different behavior.
We can get what we want by specifying \code{overlap = 'nested'}:

\if{html}{\out{<div class="sourceCode">}}\preformatted{context(nesting2, open = '(', close = ')', overlap = 'nested')
}\if{html}{\out{</div>}}

Now context aligns each \code{open} with the corresponding \code{close} at the same \emph{nesting level}.
What if we are only interested in the highest (or lowest) level of nesting?
Use the \code{depth} argument, which can be non-zero integers: the highest level is \code{1},
with "deeper" levels incrementing up.

\if{html}{\out{<div class="sourceCode">}}\preformatted{context(nesting2, open = '(', close = ')', overlap = 'nested', depth = 1)
context(nesting2, open = '(', close = ')', overlap = 'nested', depth = 2)
context(nesting2, open = '(', close = ')', overlap = 'nested', depth = 2:3)
}\if{html}{\out{</div>}}

You can also use negative \code{depth} to specify from the deepest levels outward.
For example, in this case  \code{depth == -1} should get us that deepest level:

\if{html}{\out{<div class="sourceCode">}}\preformatted{context(nesting2, open = '(', close = ')', overlap = 'nested', depth = -1)
}\if{html}{\out{</div>}}

I \code{depth} is \code{NULL} (the default), all depths are returned.
}

\section{Controlling Overlap}{


There are some other options for controlling how windows can, or cannot, overlap.
Perhaps we'd like to look at every melodic phrase moving from so (dominant) to do (tonic).

\if{html}{\out{<div class="sourceCode">}}\preformatted{melody <- c('so', 'la', 'ti', 'do', 'so', 'fi', 'so', 'la', 'ti', 're', 'do', 'so', 'la', 're', 'do')

context(melody, open = 'so', close = 'do')

}\if{html}{\out{</div>}}

This output is probably not what we want.
Again, \code{context()} (by default) pairs each opening with the next close \emph{which hasn't already been paird}.
In this case, that means the third so is getting pairs with the third do,
even though there is another do in between!
We might want to try either the \code{"edge"} or \code{"none"} options for the \code{overlap} argument:

\if{html}{\out{<div class="sourceCode">}}\preformatted{context(melody, open = 'so', close = 'do', overlap = 'edge')
context(melody, open = 'so', close = 'do', overlap = 'none')
```

The `"edge"` option allows the closing edge of windows to share a `close`---in this case,
the second and third so (`open`) are paired with the same do.
On the other hand, with `overlap = "none"`, overlapping windows are simply not allowed, so the third `open` 
simply doesn't get paired with anything.

What if you would like to pair windows on their left (opening) edge?
If you specify `rightward = FALSE`, the overlap argument works backwards (right-to-left) through
the input vector, starting on each `close` and ending on each `open`.
By combining `righward = FALSE` with various `overlap` options, you can achieve a lot of windowing 
options you might need.
}\if{html}{\out{</div>}}
}

\section{Repeated Indices}{


Note that if \code{duplicates_indices = TRUE} (the default) the \code{open} and \code{close} arguments can
incorporate repeated indices, including multiple matches to a regular expression in the same index.
This is useful with, for example, nested phrases:

\if{html}{\out{<div class="sourceCode">}}\preformatted{nesting3 <- c('(a', 'b)', '((c', 'd', 'e)',  '(d', 'e', 'f))', '(e', 'f', '((f#', 'g)', 'g#)', 'a)')

context(nesting3, open = '(', close = ')', overlap = 'nested', depth = 1)
context(nesting3, open = '(', close = ')', overlap = 'nested', depth = 2)
}\if{html}{\out{</div>}}

In some cases, you might want to turn \code{duplicate_indices = FALSE}.
}

\examples{

# use the built-in 'letters' vector

context(letters, open = hop(4), close = open + 3)

context(letters, open = "[aeiou]", close = nextopen - 1 | end)
context(letters, open = "[aeiou]", close = nextopen - 1 | end, inPlace = TRUE)
context(letters, open = "[aeiou]", close = nextopen - 1 | end, collapse = FALSE)


\dontrun{
# within.humdrumR
chorales <- readHumdrum(humdrumRroot, "HumdrumData/BachChorales/.*.krn")

# 4-grams
chorales |>
  context(open = hop(), open + 3) |>
  within(paste(Token, collapse = ','))
       
# phrases leading to fermatas
chorales |>
  context(open = 1 | prevclose + 1, close = ';', overlap = 'none') |>
  within(paste(Token, collapse = ','), alignLeft = FALSE)
  
}

}
