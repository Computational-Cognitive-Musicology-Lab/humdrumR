% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Context.R
\name{context}
\alias{context}
\alias{context.default}
\alias{context.humdrumR}
\alias{uncontext}
\alias{windows}
\title{Group vectors into contextual windows}
\usage{
context(x, open, close, ...)

\method{context}{default}(
  x,
  open,
  close,
  reference = x,
  overlap = "paired",
  depth = NULL,
  rightward = TRUE,
  duplicate_indices = TRUE,
  min_length = 2L,
  max_length = Inf,
  inPlace = FALSE,
  complement = FALSE,
  alignToOpen = TRUE,
  collapse = TRUE,
  sep = ",",
  stripRegex = FALSE,
  groupby = list()
)

\method{context}{humdrumR}(
  humdrumR,
  open,
  close,
  overlap = "paired",
  depth = NULL,
  rightward = TRUE,
  duplicate_indices = TRUE,
  min_length = 2L,
  max_length = Inf,
  groupby
)

uncontext(humdrumR)

windows(humdrumR)
}
\arguments{
\item{x}{\emph{\strong{Input data to group into windows.}}

Must be an atomic vector.}

\item{open}{\emph{\strong{Where to "open" (start) windows.}}

Can be natural numbers, \code{logical} vectors (of the same length as \code{x}),
a single \code{character} string (interpreted as a regular expression).
May also be an arbitrary expression which returns natural numbers;
the expression can refer to named elements of \code{reference}, to \code{end} (last index),
to \code{close}, or to \code{prevclose} (the previous close).}

\item{close}{\emph{\strong{Where to "close" (end) windows.}}

Can be natural numbers, \code{logical} vectors (of the same length as \code{x}),
a single \code{character} string (interpreted as a regular expression).
May also be an arbitrary expression which returns natural numbers;
the expression can refer to named elements of \code{reference}, to \code{end} (previous index),
to \code{open}, or to \code{nextopen} (the next open).}

\item{reference}{\emph{\strong{Vector(s) to use to identify window open/closes.}}

Defaults to \code{x}.

Must be either an atomic vector of the same length as \code{x}, or a \code{list()}/\code{data.frame}
of such vectors, all \link[=names]{named}.

If \code{context()} is applied to a \link[=humdrumRclass]{humdrumR dataset},
all the fields of the data's \link[=humTable]{humdrum table} are used as \code{reference}.}

\item{overlap}{\emph{\strong{How are overlapping windows treated/created?}}

Defaults to \code{'paired'}.

Must be a single \code{character}, \link[=partialMatching]{partially matching}
either \code{"paired"}, \code{"nested"}, \code{"edge"}, or \code{"none"}.}

\item{depth}{\emph{\strong{How "deep" can windows overlap?}}

Defaults to \code{NULL}.

Must be \code{NULL}, or a vector of non-zero whole numbers.}

\item{rightward}{\emph{\strong{Should window alignment/overlap be determined from left to right?}}

Defaults to \code{TRUE}.

Must be a singleton \code{logical} value: an on/off switch.}

\item{duplicate_indices}{\emph{\strong{Can the same index open/close multiple windows?}}

Defaults to \code{TRUE}.

Must be a singleton \code{logical} value: an on/off switch.}

\item{min_length, max_length}{\emph{\strong{The minimum/maximum lengths of output windows.}}

Default to two and infinity (no maximum) respectively.

Must be single, positive whole numbers.}

\item{inPlace}{\emph{\strong{Should output be padded to same length as input?}}

Defaults to \code{FALSE}.

Must be a singleton \code{logical} value: an on/off switch.}

\item{complement}{\emph{\strong{Should input "outside" any windows, be output?}}

Defaults to \code{FALSE}.

Must be a singleton \code{logical} value: an on/off switch.}

\item{alignToOpen}{\emph{\strong{Should '\code{inPlace}' output be aligned to the open of each window?}}

Defaults to \code{TRUE}.

Must be a singleton \code{logical} value: an on/off switch.}

\item{collapse}{\emph{\strong{Should output windows be collapsed to single \code{character} strings?}}

Defaults to \code{TRUE}.

Must be a singleton \code{logical} value: an on/off switch.}

\item{sep}{\emph{\strong{Separator for collapsed output.}}

Defaults to a comma (\code{","}).

Must be a single \code{character} string.}

\item{stripRegex}{\emph{\strong{Should regular expressions matched by the \code{open}/\code{close} arguments be removed from the output?}}

Defaults to \code{FALSE}.

Must be a singleton \code{logical} value: an on/off switch.}

\item{groupby}{\emph{\strong{Optional vectors to group windows within.}}

Defaults to empty \code{list()}.

Must be a \code{\link[=list]{list()}}, which is either empty or contains vectors which are all the same length as \code{x}.
In calls to \link[=withinHumdrum]{with/within.humdrumR}, \code{groupby} is passed \code{list(Piece, Spine, Path)} by default.

Windows cannot cross group boundaries.}

\item{humdrumR}{\emph{\strong{HumdrumR data.}}

Must be a \link[=humdrumRclass]{humdrumR data object}.}
}
\description{
The \code{context()} command can be used to group input data (vectors or \link{fields})
into arbitrary contextual windows.
Unlike \link[=groupHumdrum]{grouping vectors},
\code{context()} windows 1) are always contiguous relative to the reference vector(s)/field(s)
(which can depend on \link[=order_by]{order}); 2) can \emph{overlap}; and 3) don't necesarily exhaustively
divide the data.
The \code{context()} function should generally be called on
\link[=humdrumRclass]{humdrumR data}, but it can also be called directly on vectors.

The \code{uncontext()} function removes contextual windows
from a \link[=humdrumRclass]{humdrumR data object}.

Once contextual windows are created, the \code{windows()} function can be used to
view a \link{data.table} representing these windows.
The \code{Open} and \code{Close} columns indicate row indices in the \link[=humTable]{humdrum table}.
}
\details{
The \code{context()} function determines where contextual windows will begin and end based on
\link[=expressionEvaluation]{expressions} in its \code{open} and \code{close} arguments.
These \code{open} and \code{close} expressions are evaluated using a \strong{reference} \link{vector}, or set of vectors/\code{\link[=fields]{fields()}} that are all
the same length.

In most cases, we'll apply \code{context()} to a \link{humdrumR data object}, so windows are defined by
evaluating the \code{open} and \code{close} arguments using the \code{\link[=fields]{fields()}} of the humdrum table as the reference.
Once this has been done, the humdrumR object will \link[=humdrumRclass]{show} how many windows
have been identified when printed in the console.
If we then use \link[=withinHumdrum]{with/within/mutate/summarize/reframe} on our data, these methods
will evaluate their argument expressions within each and every contextual window defined by \code{context()}.
This means we can do basically anything we want to/with our contextual windows.

We can also apply \code{context()} directly to a single input vector \code{x}, providing a \link{vector} or \link{list}/\link{data.frame} of
equal-length vectors as the \code{reference} for the \code{open} and \code{close} arguments.
By default, \code{x} itself is reused as the \code{reference}, so windows are based on the input \code{x} itself.
When applied to a vector, \code{context()} will simply group the elements of \code{x} into the windows we defined,
with a few arguments to control how this is done:
\itemize{
\item \code{complement}: The "complement" refers to elements of the input vector that don't fall inside
any indicated windows: if \code{complement = FALSE} (the default), these "outside" values are
dropped; if \code{complement = TRUE}, they are retained.
\item \code{inPlace}: If \code{inPlace = TRUE}, windows are output in a vector of the same length as the input,
padded with \code{NA} as needed---otherwise (the default), only the windows are returned
\item \code{collapse}: If \code{collapse = TRUE}, the windows are collapsed to strings (separated by \code{sep}), otherwise,
a \code{list()} of windows is returned.
\itemize{
\item \code{sep} the separator used if \code{collapse = TRUE}.
}
\item \code{alignToOpen}: Should padded output (\code{inPlace = TRUE}) by aligned to the openning (left-side)
of each window?
\item \code{stripRegex}: Should regular expressions used to identify windows (details below) be stripped from the output?
}

In the rest of this man page, we will apply \code{context()} to simple vectors (like the \link{letters} vector)
to illustrate how windows are defined.
In actual analyses, you'll be more likely to apply \code{context()} to \link[=humdrumRclass]{humdrumR data}.

Note that, when using \code{context()} inside \link[=withinHumdrum]{with, within, etc.},
the \code{alignToOpen} argument will have no effect.
Instead, use \code{alignLeft = FALSE} as an argument to
\code{with()}/\code{within()}, not as an argument to \code{context()}.
\subsection{groupby}{

The \code{groupby} argument is an optional \link{list} of grouping vectors,
all the same length as \code{x}/\code{reference}.
Contextual windows cannot cross boundaries indicated in \code{groupby}.
When applying \code{context()} to \link[=humdrumRclass]{humdrumR data},
\code{groupby} is automatically passed \code{list(Piece, Spine, Path)}, which prevents
windows from crossing normal "melodic" boundaries in the data.
}
}
\section{Defining windows}{


The system \code{context()} uses to define/identify windows in the data is quite sophisticated,
and can take some time to master!
The basic idea is that you must indicate where you want windows to start ("\emph{open}") and
where you want them to end ("\emph{close}"):
you indicate this using the \code{open} and \code{close} arguments.
To introduce their usage, we will first do some simple examples applying
\code{context()} to the built-in \link{letters} vector, which (by default) will act as our \code{reference}
vector \emph{and} the target vector \code{x} to contextualize.
We will then show how these techniques can be used with multiple vectors/\code{\link[=fields]{fields()}}.

The \code{open} and \code{close} arguments are \link[=evaluatingExpressions]{expressions} which, when evaluated,
must indicate indices in the \code{reference} vector(s)/\link[=fields]{field(s)};
For example, if we want a window to open at the 4th and 11th indices,
and close at the 15th and 24th index,
we can write:

\if{html}{\out{<div class="sourceCode">}}\preformatted{context(letters, open = c(4, 11), close = c(15, 24))

}\if{html}{\out{</div>}}

This is quite trivial.
However, the \code{open} and \code{close} expressions can do a number of special tricks,
including refering to each other.
For example, if either argument includes a call to \code{\link[=hop]{hop()}},
\code{hop()} will automatically be applied along the input vector.
Consider this example:

\if{html}{\out{<div class="sourceCode">}}\preformatted{context(letters, open = hop(2), close = open + 3)
}\if{html}{\out{</div>}}

In this example, the \code{\link[=hop]{hop()}} command generates \code{open} indices for every odd
number from \code{1} to \code{25}.
The \code{close} argument then references these \code{open} indices, and adds \code{3} to each---
the result is pairs like \code{1:4}, \code{2:5}, \code{3:6}, \code{4:7}, etc.
If we give \code{\link[=hop]{hop()}} different arguments (like \code{by} or \code{from}), we can modify this process.
In fact, if we use the default \code{by} value for \code{hop()} (\code{1}), we can use this approach to
create standard N-grams.

We can also indicate open/closes by providing \code{logical} vectors (the same length as \code{x}/\code{reference}).
For example:

\if{html}{\out{<div class="sourceCode">}}\preformatted{context(letters, open = letters \%in\% c('e', 'j', 'l'), close = open + 2)

}\if{html}{\out{</div>}}
\subsection{Regular Expressions}{

If either \code{open} or \code{close} are provided a \code{character} string, this string is treated
as a regular expression and is matched against the \code{reference} vector.
For example, we could make windows in the alphabet starting or ending on each vowel:

\if{html}{\out{<div class="sourceCode">}}\preformatted{context(letters, open = '[aeiou]', close = open + 4)
context(letters, open = close - 4, close = '[aeiou]', alignToOpen = FALSE)

}\if{html}{\out{</div>}}

If the \code{stripRegex = TRUE} (not the default), the matching \code{open} or \code{close} regular expressions are removed
from the output.
This can be useful if the character/tokens used to indicate windows are no longer needed
once windowing is done.
}

\subsection{Special variables}{

The \code{open} and \code{close} expressions will understand a few special variable names:
\itemize{
\item \code{nextopen}: represents the index of the \emph{next} open---can only be used in the \code{close} argument.
\item \code{prevclose}: represents the index of the \emph{previous} close---can only be used in the \code{open} argument.
\item \code{end}: represents the last index of the \code{reference} vector(s).
\item \code{|}: As in "OR"---specify alternative window \code{open}/\code{close} criteria.
}

\verb{What if we'd like each of our windows to close right before the next window opens? We can do this by making the}close\verb{argument refer to the *next*}open\verb{, by referring to the }nextopen` variable:

\if{html}{\out{<div class="sourceCode">}}\preformatted{context(letters, open = '[aeiou]', close = nextopen - 1L)
}\if{html}{\out{</div>}}

Conversely, \code{open} can refer to the \code{prevclose} close:

\if{html}{\out{<div class="sourceCode">}}\preformatted{context(letters, open = prevclose + 1, close = '[aeiou]', alignToOpen = FALSE)
}\if{html}{\out{</div>}}

Notice that when we called \code{context(letters, open = '[aeiou]', close = nextopen - 1L)},
the window opening on \code{"u"} is not returned.
This is because there is no "\code{nextopen}" open to close on.
We can instead provide \code{context()} an alternative, using \code{|} (or):

\if{html}{\out{<div class="sourceCode">}}\preformatted{context(letters, open = '[aeiou]', close = nextopen - 1L | 26)

}\if{html}{\out{</div>}}

Here we are saying, close a window 1 index before the next open \emph{OR} at index 26.
What if we don't know exactly how long our input vector is?
Refer to the \code{end} variable:

\if{html}{\out{<div class="sourceCode">}}\preformatted{context(letters, open = '[aeiou]', close = nextopen - 1L | end)
}\if{html}{\out{</div>}}
}

\subsection{Separating context reference from application}{

The previous examples illustrate the basic concepts of using \code{open}/\code{close};
to grasp how they work, study these examples and play around with them.
We can also define \code{open} and \code{close} expressions that reference more than one vector(s)/\href{s}{field},
and which aren't necessarily the thing we want to apply the windowing to.
To illustrate this last point, let's take the last command from the previous section
and make it so the \code{x} argument is different than the \code{reference} argument:

\if{html}{\out{<div class="sourceCode">}}\preformatted{context(LETTERS, reference = letters, open = '[aeiou]', close = nextopen - 1L | 26)
}\if{html}{\out{</div>}}

Now, \code{letters} is still being used as the windowing reference, but the contextual windowing is being
applied to \code{LETTERS}.
When we use \code{context()} on a \link[=humdrumRclass]{humdrumR dataset}, the data's \code{\link[=fields]{fields()}} can be used as the reference,
then \link[=withinHumdrum]{with(), within(), mutate()} can be used to manipulate other fields.
}

\subsection{Multi-vector/field reference}{

The \code{open} and \code{close} arguments can reference more than one reference vector.
When applying \code{context()} to a vector \code{x}, we can provide a named \code{list()} or \code{data.frame()}
as the \code{reference} argument---so long as all the vectors they contain are the same length as \code{x}.
We can then refer to these vectors by name:

\if{html}{\out{<div class="sourceCode">}}\preformatted{reference.frame <- data.frame(Threes = rep(1:3, length.out = 26), 
                               Fours = rep(4:1, length.out = 26))

context(letters, 
        reference = reference.frame,
        open = Threes == Fours, close = Fours == 1)
}\if{html}{\out{</div>}}

So we created a data.frame with columns \code{Threes} and \code{Fours}.
We referenced \emph{both} of these columns when defining where windows \code{open} and \code{close}.
\subsection{Using humdrumR data}{

When we apply \code{context()} to \link[=humdrumRclass]{humdrumR data}, we can refer to \emph{any} of the
data's \code{\link[=fields]{fields()}} in \code{open} or \code{close}.
We can also use all of \code{open}/\code{close}'s special tricks (described above), like \code{hop()}, \code{nextopen}, \code{prevclose},
and \code{end}.
For example, to create 4-grams in a humdrum dataset:

\if{html}{\out{<div class="sourceCode">}}\preformatted{humData |> context(open = hop(), open + 3)

}\if{html}{\out{</div>}}

As mentioned above, when we apply \code{context()} to \link[=humdrumRclass]{humdrumR data},
\code{groupby} is automatically passed \code{list(Piece, Spine, Path)}, which prevents
windows from crossing normal "melodic" boundaries in the data.
This can be overrriden by providing your own explicit \code{groupby} argument.
\link[=groupHumdrum]{Grouping fields} that have already been defined in the data, are \emph{also} used.
}

}
}

\section{Filtering windows}{


Once \code{open} and \code{close} have identified where windows can start and end, there is still
some options for which open and close indices to associate with each other to create a window.
For example, as mentioned above, the \code{groupby} argument can be used to make sure windows to cross
grouping boundaries---even if one group has and extra open index and the next an extra close index.
The minimum and maximum length of windows can also be controlled using the \code{min_length} and \code{max_length} arguments.
The \code{overlap}, \code{depth}, \code{rightward}, and \code{duplicate_indices} arguments provide a number of additional options,
which are useful for some use cases (details below).
\subsection{Nested windows}{

A common use-case for \code{context()} is analyzing phrases indicated in music.
In \verb{**kern}, phrases are indicated with opening (\code{(}) and close (\verb{)}) parentheses,
which we can capture with regular expressions for \code{open} and \code{close}.
Here is an example:

\if{html}{\out{<div class="sourceCode">}}\preformatted{nesting1 <- c('(a', 'b)', '(c', 'd', 'e)', '(d', 'e', 'f)', '(e', 'f', 'f#', 'g', 'g#', 'a)')

context(nesting1, open = '(', close = ')')
}\if{html}{\out{</div>}}

Perfect.
However, what if there are nested phrasing indicators?

\if{html}{\out{<div class="sourceCode">}}\preformatted{nesting2 <- c('(a', 'b)', '(c', '(d', 'e)',  '(d', 'e)', 'f)', '(e', '(f', '(f#', 'g)', 'g#)', 'a)')

context(nesting2, open = '(', close = ')')
}\if{html}{\out{</div>}}

That's not what we want!
By default, \code{context()} "pairs" each \code{open} with the next \code{close}, which often makes the most sense.
But in this case, we want different behavior.
We can get what we want by specifying \code{overlap = 'nested'}:

\if{html}{\out{<div class="sourceCode">}}\preformatted{context(nesting2, open = '(', close = ')', overlap = 'nested')
}\if{html}{\out{</div>}}

Now context aligns each \code{open} with the corresponding \code{close} at the same \emph{nesting level}.
What if we are only interested in the highest (or lowest) level of nesting?
Use the \code{depth} argument, which can be non-zero integers: the highest level is \code{1},
with "deeper" levels incrementing up.

\if{html}{\out{<div class="sourceCode">}}\preformatted{context(nesting2, open = '(', close = ')', overlap = 'nested', depth = 1)
context(nesting2, open = '(', close = ')', overlap = 'nested', depth = 2)
context(nesting2, open = '(', close = ')', overlap = 'nested', depth = 2:3)
}\if{html}{\out{</div>}}

You can also use negative \code{depth} to specify from the deepest levels outward.
For example, in this case  \code{depth == -1} should get us that deepest level:

\if{html}{\out{<div class="sourceCode">}}\preformatted{context(nesting2, open = '(', close = ')', overlap = 'nested', depth = -1)
}\if{html}{\out{</div>}}

If \code{depth} is \code{NULL} (the default), all depths are returned.
}

\subsection{Controlling overlap}{

There are some other options for controlling how windows can, or cannot, overlap.
Perhaps we'd like to look at every melodic phrase moving from \emph{So} (dominant) to \emph{Do} (tonic).

\if{html}{\out{<div class="sourceCode">}}\preformatted{melody <- c('so', 'la', 'ti', 'do', 'so', 'fi', 'so', 'la', 'ti', 're', 'do', 'so', 'la', 're', 'do')

context(melody, open = 'so', close = 'do')

}\if{html}{\out{</div>}}

This output is probably not what we want.
Again, \code{context()} (by default) pairs each opening with the next close \emph{which hasn't already been paired}.
In this case, that means the third \emph{So} is getting pairs with the third \emph{Do},
even though there is another \emph{Do} in between!
We might want to try either the \code{"edge"} or \code{"none"} options for the \code{overlap} argument:

\if{html}{\out{<div class="sourceCode">}}\preformatted{context(melody, open = 'so', close = 'do', overlap = 'edge')
context(melody, open = 'so', close = 'do', overlap = 'none')
}\if{html}{\out{</div>}}

The \code{"edge"} option allows the closing edge of windows to share a \code{close}---in this case,
the second and third \emph{So} (\code{open}) are paired with the same \emph{Do}.
On the other hand, with \code{overlap = "none"}, overlapping windows are simply not allowed, so the third \code{open}
simply doesn't get paired with anything.

What if you would like to pair windows on their left (opening) edge?
If you specify \code{rightward = FALSE}, the overlap argument works backwards (right-to-left) through
the input vector, starting on each \code{close} and ending on each \code{open}.
By combining \code{righward = FALSE} with various \code{overlap} options, you can achieve a lot of windowing
options you might need.
}

\subsection{Repeated indices}{

Note that if \code{duplicates_indices = TRUE} (the default) the \code{open} and \code{close} arguments can
incorporate repeated indices, including multiple matches to a regular expression in the same index.
This is useful with, for example, nested phrases:

\if{html}{\out{<div class="sourceCode">}}\preformatted{nesting3 <- c('(a', 'b)', '((c', 'd', 'e)',  '(d', 'e', 'f))', '(e', 'f', '((f#', 'g)', 'g#)', 'a)')

context(nesting3, open = '(', close = ')', overlap = 'nested', depth = 1)
context(nesting3, open = '(', close = ')', overlap = 'nested', depth = 2)
}\if{html}{\out{</div>}}

In some cases, you might want to turn \code{duplicate_indices = FALSE}.
}
}

\examples{

# use the built-in 'letters' vector

context(letters, open = hop(4), close = open + 3)

context(letters, open = "[aeiou]", close = nextopen - 1 | end)
context(letters, open = "[aeiou]", close = nextopen - 1 | end, inPlace = TRUE)
context(letters, open = "[aeiou]", close = nextopen - 1 | end, collapse = FALSE)


\dontrun{
# within.humdrumR
chorales <- readHumdrum(humdrumRroot, "HumdrumData/BachChorales/.*.krn")

# 4-grams
chorales |>
  context(open = hop(), open + 3) |>
  within(paste(Token, collapse = ','))
       
# phrases leading to fermatas
chorales |>
  context(open = 1 | prevclose + 1, close = ';', overlap = 'none') |>
  within(paste(Token, collapse = ','), alignLeft = FALSE)
  
}

}
\seealso{
Other {Contextual grouping functions.}: 
\code{\link{groupHumdrum}}
}
\concept{{Contextual grouping functions.}}
