% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tools.R
\name{ditto}
\alias{ditto}
\alias{ditto.default}
\alias{ditto.data.frame}
\alias{ditto.matrix}
\alias{ditto.humdrumR}
\title{Propagate data points to "fill" null data.}
\usage{
ditto(x, ...)

\method{ditto}{default}(
  x,
  nonnull = function(x) !is.na(x) & x != ".",
  reverse = FALSE,
  boundaries = list()
)

\method{ditto}{data.frame}(x, ...)

\method{ditto}{matrix}(x, margin = 2, ...)

\method{ditto}{humdrumR}(x, field = activeFields(x)[1], ..., newField = paste0(field, "_ditto"))
}
\arguments{
\item{x}{The input argument. Should be a vector (including lists), \code{matrix}, or \code{data.frame}.}

\item{nonnull}{Either a logical vector where (\code{length(x) == length(nonnull)}), a numeric
vector of positive indices, or a function which, when applied to \code{x} returns an appropriate logical/numeric vector.}

\item{reverse}{(\code{logical} & \code{length == 1}) If \code{reverse == TRUE}, the "non-null" values are coped to overwrite null values
\emph{earlier} (lower indices) in the vector.}

\item{boundaries}{A vector or list of vectors, all of the same length as \code{x}. Each segment of \code{x} delineated
by the \code{boundaries} vector(s) is treated separately.}

\item{margin}{a vector giving the subscripts which the function will be applied over.
E.g., for a matrix 1 indicates rows, 2 indicates columns, c(1, 2) indicates rows and columns.
Where X has named dimnames, it can be a character vector selecting dimension names.}

\item{field}{Which field (\link[=partialMatching]{partially matched}) in the \code{humdrumR} dataset should be dittoed?}

\item{newField}{(\code{character} of \code{length == 1}) What to name the new (dittoed) field.}
}
\description{
\code{ditto} is a function that allow you to "fill" null values in a vector
with non-null values from earlier/later in the same vector.
The default, "forward," behavior fills each null value with the previous (lower index) non-null value, if there are any.
The \code{reverse} argument can be used to cause "backward" filling, where the \emph{next} (higher index) non-null value is used.
}
\details{
Which values are considered "non-null" can be controlled using the \code{nonnull} argument.
The \code{nonnull} argument can either be a logical vector which is the same length as the input (\code{x}) argument, a numeric
vector of positive indices, or a function which, when applied to \code{x} returns an appropriate logical/numeric vector.
The values of \code{x} where \code{nonnull == TRUE} are copied forward/backwards to replace any adjacent vales where \code{nonnull == FALSE}.
By default, \code{nonnull} is the function \verb{\\(x) !is.na(x) & x != '.'}, which means that \code{NA} values and the string \code{"."} are
"null", and are overwritten by adjacent values.

\code{ditto} methods are defined for data.frames and arrays (including matrices).
The \code{data.frame} method simply applies \code{ditto} to each column of the \code{data.frame} separately.
For arrays, ditto can be applied across columns (\code{margin == 2}), rows (\code{margin == 1}), or other dimensions.

The \code{ditto} method for a \link[=humdrumRclass]{humdrumR object} applies \code{ditto} to each spine-path within each file
in the corpus. The \code{field} argument indicates which field to apply ditto to. The result of the dittoing
is saved to a new field---the \code{newField} argument can be used to control what to name the new field.
}
\section{Boundaries}{


In many cases we want to perform lagged calculations in a vector, but \emph{not across certain boundaries}.
For example, if your vector includes data from multiple pieces, we wouldn't want to calculate melodic intervals
between pieces, only within pieces.
The \code{boundaries} argument indicates one, or more, grouping vectors, which break the \code{x} (input) argument
into groups.
If more than \code{boundaries} vectors are given, a change in \emph{any} vector indicates a boundary.

Value pairs which cross between groups are treated as if they were at the beginning.
Basically, using boundaries should be essentially identical to using \code{tapply(x, boundaries, laggedFunction, ...)},
except generally faster when the number of groups is large.

The most common use case in humdrum data, is looking at "melodies" within spines.
For this, we want \code{boundaries = list(File, Spine, Path )}.
In fact, \code{humdrumR} \link[=withinHumdrum]{with(in)} calls will \emph{automatically} feed these
three fields as \code{boundaries} arguments to certain functions: mint, delta, sigma, lag, or ditto.
Do any use of \code{delta} in a call to \link[=withinHumdrum]{with(in)}, will automatically calculate the \code{delta}
in a "melodic" way, within each spine path of each file.
However, if you wanted, for instance, to calculate differences across spines (like harmonic intervals)
you could manually set \code{boundaries = list(File, Record)}.
}

\seealso{
Other {Lagged vector functions}: 
\code{\link{delta}()},
\code{\link{lag}()},
\code{\link{sigma}()}
}
\concept{{Lagged vector functions}}
