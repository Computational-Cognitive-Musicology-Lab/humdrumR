% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tools.R
\name{ditto}
\alias{ditto}
\alias{ditto.default}
\alias{ditto.data.frame}
\alias{ditto.matrix}
\alias{ditto.humdrumR}
\title{Propagate data points to "fill" null data.}
\usage{
ditto(x, ...)

\method{ditto}{default}(
  x,
  null = function(x) is.na(x) | x == ".",
  initial = NA,
  reverse = FALSE,
  groupby = list(),
  orderby = list()
)

\method{ditto}{data.frame}(x, ...)

\method{ditto}{matrix}(x, margin = 2, ...)

\method{ditto}{humdrumR}(x, ..., initial = NA, reverse = FALSE)
}
\arguments{
\item{x}{\emph{\strong{A vector.}}

Should be \code{list}, \code{atomic}, \code{matrix}, or \code{data.frame}.}

\item{null}{\emph{\strong{Defines which elements needs to be filled.}}

Defaults to \code{function(x) is.na(x) | x == "."}.

Should be either a logical vector where (\code{length(x) == length(null)}), a numeric
vector of positive indices, or a function which, when applied to \code{x} returns an appropriate logical/numeric vector.}

\item{initial}{\emph{\strong{Padder for the beginning (or end, if \code{reverse == TRUE}) of the output, if needed.}}

Defaults to \code{NA}.

Should be the same class as \code{x}; must be length \code{1}.}

\item{reverse}{\emph{\strong{Whether the excecution order is reversed.}}

Defaults to \code{FALSE}.

Must be a singleton \code{logical} value: an on/off switch.

If \code{reverse == TRUE}, the "non-null" values are coped to overwrite null values
\emph{earlier} (lower indices) in the vector.}

\item{groupby}{\emph{\strong{How to group the data.}}

Should be \code{vector} or \code{list} of \code{vectors}; must be length \code{length(x)}.

Each segment of \code{x} delineated by the \code{groupby} vector(s) is treated separately.}

\item{margin}{\emph{\strong{A vector giving the dimensions which the function will be applied over.}}

Defaults to \code{2} (across columns) for \code{matrix} inputs.

Must be natural number(s).

E.g., for a matrix \code{1} indicates rows, \code{2} indicates columns.
Where \code{x} has named dimnames, it can be a character vector selecting dimension names.

Must be a single \code{character} string.}
}
\description{
\code{ditto} is a function that allow you to "fill" null values in a vector
with non-null values from earlier/later in the same vector.
The default, "forward," behavior fills each null value with the previous (lower index) non-null value, if there are any.
The \code{reverse} argument can be used to cause "backward" filling, where the \emph{next} (higher index) non-null value is used.
If the input begins (or ends if \code{reverse == TRUE}) with a null value, the \code{initial} argument is filled instead; defaults to \code{NA}.
}
\details{
Which values are considered "null" can be controlled using the \code{null} argument.
The \code{null} argument can either be a logical vector which is the same length as the input (\code{x}) argument, a numeric
vector of positive indices, or a function which, when applied to \code{x} returns an appropriate logical/numeric vector.
The values of \code{x} where \code{null == FALSE} are copied forward/backwards to replace any adjacent vales where \code{null == TRUE}.
By default, \code{null} is the function \verb{\\(x) is.na(x) | x == '.'}, which means that \code{NA} values and the string \code{"."} are
"null", and are overwritten by adjacent values.

\code{ditto} methods are defined for data.frames and matrices.
The \code{data.frame} method simply applies \code{ditto} to each column of the \code{data.frame} separately.
For matrices, ditto can be applied across columns (\code{margin == 2}), rows (\code{margin == 1}), or other dimensions.

The \code{ditto} method for a \link[=humdrumRclass]{humdrumR object} simply applies \code{ditto} to the, by default,
the selected field; thus \code{ditto(humData)} is equivalent to \code{within(humData, newField <- ditto(.), dataTypes = 'Dd')}.
The \code{field} argument can be used to indicated a different field to apply to. The result of the dittoing
is saved to a new field---the \code{newField} argument can be used to control what to name the new field.
}
\section{Grouping}{


In many cases we want to perform lagged calculations in a vector, but \emph{not across certain boundaries}.
For example, if your vector includes data from multiple pieces, we wouldn't want to calculate melodic intervals
between pieces, only within pieces.
The \code{groupby} argument indicates one, or more, grouping vectors, which break the \code{x} (input) argument
into groups.
If more than \code{groupby} vectors are given, a change in \emph{any} vector indicates a boundary.

Value pairs which cross between groups are treated as if they were at the beginning.
Basically, using the \code{groupby} argument to a function should be
similar or identical to using \code{tapply(x, groupby, laggedFunction, ...)} or using a \code{groupby}
expession in a call to \link[=withinHumdrum]{with(in).humdrumR}.
However, using a \code{groupby} argument directly is usually much faster, as they have been
specially optimized for this functions.

The most common use case in humdrum data, is looking at "melodies" within spines.
For this, we want \code{groupby = list(Piece, Spine, Path)}.
In fact, \code{humdrumR} \link[=withinHumdrum]{with(in)} calls will \emph{automatically} feed these
three fields as \code{groupby} arguments to certain functions: mint, delta, sigma, lag, ditto, ioi, sumTies, or hop.
So any use of \code{delta} in a call to \link[=withinHumdrum]{with(in)}, will automatically calculate the \code{delta}
in a "melodic" way, within each spine path of each piece.
However, if you wanted, for instance, to calculate differences across spines (like harmonic intervals)
you could manually set \code{groupby = list(Piece, Record)}.
}

\section{Order}{


When performing lagged calculations, we typically assume that the order of the values in the input vector
(\code{x}) is the order we want to "lag" across.
E.g., the first element is "before" the second element, which is "before" the third element, etc.
[Humdrum tables][humTable] are always ordered \verb{Piece > Piece > Spine > Path > Record > Stop}.
Thus, any lagged calculations across fields of the humtable will be, by default, "melodic":
the \emph{next} element is the next element in the spine path.
For example, consider this data:

\if{html}{\out{<div class="sourceCode">}}\preformatted{**kern  **kern
a       d
b       e
c       f
*-      *-
}\if{html}{\out{</div>}}

The default order of these tokens (in the \code{Token} field) would be \verb{a b c d e f}.
If we wanted to instead lag across our tokens \emph{harmonically} (across records) we'd need to specifiy a different order
For example, we could say \code{orderby = list(Pice, Record, Spine)}---the lagged function
would interpret the \code{Token} field above as \verb{a d b e c f}.

For another example, note \code{Stop} comes last in the order.
Let's consider what happens then if here are stops in our data:

\if{html}{\out{<div class="sourceCode">}}\preformatted{**kern  **kern
a       d
b D     e g
c A     f a
*-      *-
```

The default ordering here (`Piece > Spine > Record > Stop`) "sees" this in the order `a b D c A d e g f a`.
That may or may not be what you want!
If we wanted, we could reorder such that `Stop` takes precedence over `Record`: `orderby = list(Piece, Spine, Stop, Record)`.
The resulting order would be `a b c d e f D G g a`.

   

[humTable]: R:humTable
}\if{html}{\out{</div>}}
}

\seealso{
Other {Lagged vector functions}: 
\code{\link{delta}()},
\code{\link{int}()},
\code{\link{lag}()},
\code{\link{sigma}()}
}
\concept{{Lagged vector functions}}
