% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tools.R
\name{ditto}
\alias{ditto}
\alias{ditto.default}
\alias{ditto.data.frame}
\alias{ditto.matrix}
\alias{ditto.humdrumR}
\title{Propagate data points to "fill" null data.}
\usage{
ditto(x, ...)

\method{ditto}{default}(
  x,
  null = function(x) is.na(x) | x == ".",
  initial = NA,
  reverse = FALSE,
  groupby = list()
)

\method{ditto}{data.frame}(x, ...)

\method{ditto}{matrix}(x, margin = 2, ...)

\method{ditto}{humdrumR}(
  x,
  field = getActiveFields(x)[1],
  ...,
  newField = paste0(field, "_ditto")
)
}
\arguments{
\item{x}{A vector.}

\item{null}{Either a logical vector where (\code{length(x) == length(null)}), a numeric
vector of positive indices, or a function which, when applied to \code{x} returns an appropriate logical/numeric vector.}

\item{initial}{A value (\code{length == 1}) of the same class as \code{x}, used to pad the beginning (or end, if \code{reverse == TRUE}) of the output,
if necessary.}

\item{reverse}{(\code{logical} & \code{length == 1}) If \code{reverse == TRUE}, the "non-null" values are coped to overwrite null values
\emph{earlier} (lower indices) in the vector.}

\item{groupby}{A vector or list of vectors, all of the same length as \code{x}. Each segment of \code{x} delineated
by the \code{groupby} vector(s) is treated separately.}

\item{margin}{a vector giving the subscripts which the function will be applied over.
E.g., for a matrix \code{1} indicates rows, \code{2} indicates columns.
Where \code{x} has named dimnames, it can be a character vector selecting dimension names.}

\item{field}{Which field (\link[=partialMatching]{partially matched}) in the \code{humdrumR} dataset should be dittoed?}

\item{newField}{(\code{character} of \code{length == 1}) What to name the new (dittoed) field.}
}
\description{
\code{ditto} is a function that allow you to "fill" null values in a vector
with non-null values from earlier/later in the same vector.
The default, "forward," behavior fills each null value with the previous (lower index) non-null value, if there are any.
The \code{reverse} argument can be used to cause "backward" filling, where the \emph{next} (higher index) non-null value is used.
If the input begins (or ends if \code{reverse == TRUE}) with a null value, the \code{initial} argument is filled instead; defaults to \code{NA}.
As a special option, \code{initial == "_next_"} will cause the first (or last) non-null value to be filled backwards into the initial nulls.
}
\details{
Which values are considered "null" can be controlled using the \code{null} argument.
The \code{null} argument can either be a logical vector which is the same length as the input (\code{x}) argument, a numeric
vector of positive indices, or a function which, when applied to \code{x} returns an appropriate logical/numeric vector.
The values of \code{x} where \code{null == FALSE} are copied forward/backwards to replace any adjacent vales where \code{null == TRUE}.
By default, \code{null} is the function \verb{\\(x) is.na(x) | x == '.'}, which means that \code{NA} values and the string \code{"."} are
"null", and are overwritten by adjacent values.

\code{ditto} methods are defined for data.frames and matrices.
The \code{data.frame} method simply applies \code{ditto} to each column of the \code{data.frame} separately.
For matrices, ditto can be applied across columns (\code{margin == 2}), rows (\code{margin == 1}), or other dimensions.

The \code{ditto} method for a \link[=humdrumRclass]{humdrumR object} simply applies \code{ditto} to the, by default,
the active field; thus \code{ditto(humData)} is equivalent to \code{within(humData, newField <- ditto(.), dataTypes = 'Dd')}.
The \code{field} argument can be used to indicated a different field to apply to. The result of the dittoing
is saved to a new field---the \code{newField} argument can be used to control what to name the new field.
}
\section{Grouping}{


In many cases we want to perform lagged calculations in a vector, but \emph{not across certain boundaries}.
For example, if your vector includes data from multiple pieces, we wouldn't want to calculate melodic intervals
between pieces, only within pieces.
The \code{groupby} argument indicates one, or more, grouping vectors, which break the \code{x} (input) argument
into groups.
If more than \code{groupby} vectors are given, a change in \emph{any} vector indicates a boundary.

Value pairs which cross between groups are treated as if they were at the beginning.
Basically, using groupby should be essentially identical to using \code{tapply(x, groupby, laggedFunction, ...)},
except generally faster when the number of groups is large.

The most common use case in humdrum data, is looking at "melodies" within spines.
For this, we want \code{groupby = list(File, Spine, Path)}.
In fact, \code{humdrumR} \link[=withinHumdrum]{with(in)} calls will \emph{automatically} feed these
three fields as \code{groupby} arguments to certain functions: mint, hint, delta, sigma, lag, or ditto.
Do any use of \code{delta} in a call to \link[=withinHumdrum]{with(in)}, will automatically calculate the \code{delta}
in a "melodic" way, within each spine path of each file.
However, if you wanted, for instance, to calculate differences across spines (like harmonic intervals)
you could manually set \code{groupby = list(File, Record)}.
}

\seealso{
Other {Lagged vector functions}: 
\code{\link{delta}()},
\code{\link{lag}()},
\code{\link{sigma}()},
\code{\link{xint}()}
}
\concept{{Lagged vector functions}}
