% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Plots.R
\name{draw}
\alias{draw}
\title{Visualize data}
\usage{
draw(
  x,
  y,
  facets = list(),
  ...,
  xlab = NULL,
  ylab = NULL,
  axes = 1:4,
  legend = TRUE,
  aspect = NULL,
  margin = 0.2,
  main = "",
  sub = "",
  col = 1,
  cex = NULL
)
}
\arguments{
\item{...}{\emph{\strong{Additional parameters to pass to par().}}

Any base-R graphing parameters that can be set using the \code{\link[=par]{par()}} function
may be passed to \code{draw()}.
These parameters are set using \code{par()} (overriding humdrumR's defaults), but only for the duration of the
\code{draw()} call---i.e., the global \code{par()} settings are not changed.}

\item{xlab, ylab}{\emph{\strong{What X and/or Y axis labels should be used?}}

Must be single \code{character} strings.

See "Plot Text" section below.}

\item{legend}{\emph{\strong{Should legends be drawn?}}

Defaults to \code{TRUE}.}

\item{margin}{\emph{\strong{How big should plot margins be?}}

Defaults to \code{0.2}.

Must be as single numeric value \eqn{0.4 \geq margin \geq 0.1}.

This controls the proportion of the plotting area used for margins.
A value of \code{0.2} means that 20\% of the plotting area is used for the margins.}

\item{col}{\emph{\strong{What colors should be used in plots?}}

See "Color" section below.}

\item{cex}{\emph{\strong{What size of points should be plotted?}}

See "Point size" section below.}

\item{xlim, ylim}{\emph{\strong{What range of X/Y values should drawn on the plot?}}

By default, X and Y limits are automatically selected.

Must be a \code{numeric} vector of length two.

The first number of each \code{xlim}/\code{ylim} vector specifies the left/bottom
edge of the X/Y axis. The second number specifies the right/top edge.}

\item{`aspect`}{Defaults to \code{NULL}.

Must be a single numeric value \eqn{5 \geq aspect \geq 0.2}, or \code{NULL}.

This controls the aspect ratio of the plot:
\code{1} (square), \code{4/3}, \code{16/9}, etc.
If \code{aspect} is \code{NULL} , R #' automatically uses the current aspect of
your current plotting device.}

\item{heat}{\emph{\strong{Should a heatmap be drawn?}}

Defaults to \code{FALSE}, unless the input has two or more dimensions
\emph{and} at least 80 conditions.

Must be a singleton \code{logical} value: an on/off switch.}

\item{normalReference}{\emph{\strong{Should a reference Normal distribution by overlayed?}}

Defaults to \code{FALSE}.

Must be a singleton \code{logical} value: an on/off switch.}

\item{showCounts}{\emph{\strong{Should the number of observations in each category be drawn on the plot?}}

Defaults to \code{TRUE}.

Must be a singleton \code{logical} value: an on/off switch.}

\item{showPoints}{\emph{\strong{Should individual data points be plotted above the histogram?}}

Defaults to \code{TRUE}.

Must be a singleton \code{logical} value: an on/off switch.}

\item{log}{\emph{\strong{Should X and/or Y axes be drawn on a logarithmic scale?}}

Defaults to \code{""} (linear scale on both axes).

Must be a single \code{character} string; options are \code{"x"} (X axis on log scale),
\code{"y"} (Y-axis on log scale), and \code{"xy"} (both axes on log scale).}

\item{smooth}{\emph{\strong{Should continuous values be grouped using density estimation or binning?}}

Defaults to \code{TRUE} for violin and area plots, but \code{FALSE} for histograms.

Must be a singleton \code{logical} value: an on/off switch.}
}
\description{
The \code{draw()} function is humdrumR's go-to plotting function,
which can make a variety of graphs depending on the type of data you give it.
For the most part, \code{draw()} is simply a easy-to-use wrapper around
the base-R graphics functions \code{\link[=plot]{plot()}}, \code{\link[=barplot]{barplot()}}, and \code{\link[=hist]{hist()}}.
}
\details{
\code{draw()} is a generic function, which does different plots depending on the data you pass to its
\code{x} and \code{y} arguments.
The following table indicates the seven possibilities, with separate section below explaining how each plot can be modified.\tabular{lll}{
   \code{x} \tab \code{y} \tab Plot type \cr
   \code{numeric} \tab (missing) \tab Density Histogram/Contour \cr
   (missing) \tab \code{numeric} \tab Quantile plot \cr
    \tab  \tab (or Violin plot) \cr
   \code{numeric} \tab \code{numeric} \tab Scatter plot \cr
   1 or 2 dimensional \link[=table]{table} or \link{distribution} \tab  \tab  \cr
   \code{character} or \code{factor} \tab (additional \code{character}/\code{factor}) \tab Barplot or Heatmap \cr
   \code{character} or \code{factor} \tab \code{numeric} \tab Violin plot \cr
   \code{numeric} \tab \code{character} or \code{factor} \tab Area chart \cr
}


For purely categorical data, the default behavior is to draw barplots for 1D distributions, or
2D distributions with 80 or fewer conditions, and heatmaps otherwise.
This default behavior can be overridden using either \code{heat = TRUE} or \code{heat = FALSE}.
Similarly, \code{violin = TRUE} can be used to force \code{draw( , y)} to draw a violin plot.

Note that, if you pass one or two \code{character}/\code{factor} vectors to \code{draw()}, it will pass these vectors to \code{\link[=count]{count()}},
then pass the resulting \link{distribution} to \code{draw()}, creating a barplot.
Thus, \code{draw(charvec1, charvec2)} is equivalent to \code{draw(count(charvec1, charvec2))}.
\subsection{Drawing dimensions of data}{

\code{draw()} is equipped to visualize data in up to four dimensions in one plot.
The main dimensions are, of course, the X and Y axes, controlled by the \code{x} and \code{y} arguments.
The other two dimensions are color (\code{col}) and point-size (\code{cex}).
An another approach is to draw multiple plots at the same time in a grid, each sub
plot called a "facet."
Details for all these options can be found below.
}
}
\section{Common Arguments}{


\code{draw()} is built on top of R's "base" plotting system.
This means that all the standard arguments to base-R plots can be used to customize plots
(See \code{\link[=par]{par()}} for a full list) or add to them (for example, using \code{\link[=points]{points()}} or \code{\link[=mtext]{mtext()}}).
However, \code{draw()} has a number of special additional features, including easily plotting "facets"
(dividing data into multiple plots).
Anything that \code{draw()} does can be done using normal base-R plotting functions (\code{\link[=plot]{plot()}}, \code{\link[=barplot]{barplot()}}, etc.),
but \code{draw()} makes making good looking plots faster and easier.
\subsection{Plot Text}{

Every \code{draw()} plot can have a title, subtitle, X-axis label, and Y-axis label.

The \code{draw()} function will automatically generate X and Y labels for every plot,
usually just using the expression you passed; for example, if you say \code{draw(rnorm(100))}, the
X label will be "rnorm(100)."
This can be overriden using the \code{xlab} and/or \code{ylab} arguments, which can be provided a single string
each---to surpress a label, provide an empty string, like \code{ylab = ""}.

Titles and subtitles are specified using the \code{main} and \code{sub} arguments, respectively.
No title or subtitle is drawn by default.

You can use the base-R \code{\link[=mtext]{mtext()}} function to draw additional text on plot axes.
}

\subsection{Axes control}{

The \code{draw()} function will select reasonable X and Y axes ranges automatically.
If you want to override the defaults, you can use \code{xlim} or \code{ylim} to control
the range of values shown on each axis.
Each of these must be passed a vector of two numbers, representing the left and right
X-axis extremes (\code{xlim}) and the bottom and top Y-axis extremes (\code{ylim}).
For example, to show data in the range \eqn{[10, 50]} on the X axis,
specifiy \code{xlim = c(10, 50)}.

For \code{numeric} axes, you can also plot data on a logarithmic scale
using the \code{log} argument.
This set by providing a single \code{character} string containing lower-case
\code{"x"}, \code{"y"}, or both (\code{"xy"}).
Note that \code{draw()} will throw an error if you try to plot negative values
on a logarithmic scale.
Note that some plots will not allow logarithmic scaling on some axes,
and will simply ignore attempts to do that.
}

\subsection{Color}{

Colors can be specified in all \code{draw()} plots using the \code{col} argument, along with the
\code{alpha} argument which controls the transparency of colors.
Note that color control can used for entirely aesthetic purposes (picking
a color scheme you want) \emph{or} to represent an additional dimension of data.

Colors can be specified as either:
\itemize{
\item Names (e.g., \code{"red"} or \verb{"darkgreen'})
\item Hex codes (e.g., \code{"#ff0000"} or \verb{"#00ff00})
\item Using the \code{\link[=rgb]{rgb()}} function.
\itemize{
\item If a single \code{col} value is provided, all points are drawn this color.
\item If the \code{col} value is the same length as \code{x} and \code{y}, a scale of colors (either discrete of continuous)
is generated to match the values this variable takes, and a legend is drawn.
}
\item Or as natural numbers, indexing \code{humdrumR}'s flatly palette,
based on the colors \code{'#18BC9C'}, \code{'#3498DB'}, \code{'#F39C12'}, \code{'#E74C3C'}, and \code{'#2C3E50'}.
}

The \code{alpha} argument must be a \code{numeric} value \eqn{1 \geq alpha \geq 0},
where \code{alpha = 0} is totally transparent and \code{alpha = 1} is totally opaque.

It is always possible to specify a single color value for a plot.
However, \code{draw()} can also (generally) accept more color values, depending on the type of plot.
For some plots, multiple colors are used (aesthetically) by default;
For other types of plots, its possible to use color to represent an additional dimension of information.
In the "Specific Plot" subsections below, the details of how each plot type interprets the \code{col} argument are explained.
\itemize{
\item Scatter (\code{x = y = 'numeric'}) and Quantile plots (\code{y = 'numeric'})
\itemize{
\item \code{col} may be an atomic vector the same length as \code{x}/\code{y}.
\item A color scheme is automatically computed to cover the range of values in \code{col}
and a legend is added to the plot.
\item For example, if the \code{col} vector contains five unique values, each of these five values
will be assigned a color in the plot.
If the \code{col} values are continuous and numeric, the range of values will placed on a continuum
of colors.
}
\item Histograms (\code{x = 'numeric'})
\itemize{
\item \code{col} may be an atomic vector the same length as \code{x}.
\itemize{
\item The histogram is divided into a separate histogram
for each unique color value, they are plotted overlayed on top of each other,
and a legend is added to the plot.
\item For example, if the \code{col} vector contains five unique values, five separate
histograms will be overlayed on top of each other, each with their own color.
\item If the color argument contains is \code{numeric} with more than three unique values,
these values will be divided into four ranges, each assigned a color.
}
}
\item Barplots, Violinplots, and Area plots
\itemize{
\item \code{col} may be an atomic vector of the same length as the number of levels in the first
(X) dimension of the plotted distribution (or the Y dimension for area plots).
\item These colors are used to select the colors of each bar and a legend is added to the plot.
Note that \code{draw()} will color levels by default (this currently can't be turned off).
}
\item Heatmaps
\itemize{
\item Heatmaps use colors to represent values, and there is currently no control of this process.
Using \code{col} will have no effect.
}
}
}
}

\section{Specific Plot Type Details}{

\subsection{Denisty Histogram or Contour (x = numeric, y = )}{

To draw a single numeric variable on the X-axis, \code{draw()} either bins the numbers to create a
histogram, or estimates a smooth density contour to draw.
To choose which approach, use the \code{smooth} argument: \code{smooth = FALSE} (default) for histogram,
and \code{smooth = TRUE} for density contour.
The \code{draw()} function relies on the algorithms used by base-R's \code{\link[=hist]{hist()}} and \code{\link[=density]{density()}} functions, respectively, for
these two tasks.
In many cases, we can pass arguments directly through to these functions.
For example, the \code{breaks} argument can be passed through to \code{\link[=hist]{hist()}},
or the \code{bw} and \code{kernel} arguments to \code{\link[=density]{density()}}.

Whether smoothed or binned, the Y-axis represents the probability density.
This means that the height of histogram bars does not correspond exactly to the
the probability mass in each bin, because it depends on the width of the bins;
For narrow bins, density can even be greater than 1.
If bin sizes are all equal, then the relative height of he density bars does
map exactly to the probability mass of each bin.
However, if bins are not equal width---which can only happen if you manually specify
unequal bins using the \code{breaks} argument---the heights of bars \emph{don't} map to probability mass.
However, using the density assures that the relative \strong{area} of each bin does match the probability mass
associated with that bin, even if the bins are of unequal width.
This is ideal for a plot.

In addition to Plot Text and Axes Control parameters (listed above), arguments understood by histogram/density plots
are listed below.
The following arguments are all singleton \code{logical} on/off switches (\code{TRUE} or \code{FALSE}):
\itemize{
\item \code{smooth} --- Controls whether histogram is binned or smooth.
\item \code{showPoints} --- Controls whether individual data points from the \code{x} input vector
are plotted in a "cloud" above the density plot.
\itemize{
\item The X-position of each point is matched to its actual value.
\item The Y-position of each point is randomly (uniformly) selected in a range at the top of the plot window.
This spaces out points that are close together, so it is easier to see how dense they are.
}
\item \code{showCounts} --- Controls whether the actual count of values associated with each
bin (or countour) is printed above the each bar/contour. Defaults to \code{TRUE}.
\itemize{
\item Note that, if the data is grouped into multiple draws by \code{col} (see below), there is no guarantee
the counts won't be drawn on top of each other.
}
\item \code{normalReference} --- If \code{TRUE}, a normal (Gaussian) distribution is drawn as a dashed
black line. The mean and standard deviation of this distribution is taken from the input vector \code{x}.
This gives a sense of how close to normally distributed \code{x} is.
\item \code{mean} --- If \code{TRUE}, the mean of input vector \code{x} is marked on the X-axis below the plot, using
a black cross hairs.
\itemize{
\item If \code{global_quantiles = FALSE}, a separate mean for each \code{col} group (see below) is marked with an appropriately
colored cross hair.
}
\item \code{conditional} --- If the data is grouped in multiple draws by \code{col} (see below), should the density
of each color match it's global share in the distribution of input variable \code{x}, or be rescaled in each
group to sum/integrate to 1? I.e., should probabilities be conditioned on the grouping factor?
\itemize{
\item Setting \code{conditional = TRUE} is useful if you want to see the details of how each group is distributed.
\item \code{conditional = FALSE} (the default) is useful when you want to see the actual proportion of
data in each group (if they are different size).
}
\item \code{global_quantiles} --- If the data is grouped into multiple draws by \code{col} (see below), and if \code{quantiles}
(see below) or the \code{mean} are going to be drawn, should they be computed separately
for each group or for the whole (global) distribution of the input variable \code{x}?
\itemize{
\item Defaults to \code{TRUE}.
}
}

Two other arguments are not \code{logical}:
\itemize{
\item \code{quantiles} --- Must be a vector of numbers between 0 and 1 (inclusive), or an empty vector (the default).
\itemize{
\item If any quantiles are specified, each quantile is marked with a vertical line on the plot, labeled appropriately.
For example,
\itemize{
\item \code{quantiles = .5} will draw a line at the median of input vector \code{x}.
\item \code{quantiles = c(.25, .5, .75)} will draw lines marking the four quartiles of \code{x}.
}
\item By default, \code{global_quantiles = TRUE}, so the overall quantiles of input vector \code{x} are drawn.
If the data is grouped by \code{col} (see below), and \code{global_quantiles = FALSE}, quantiles are instead
computed and drawn separately for each group. This can get very messy very quickly!
}
\item \code{col} --- The \code{col} (color) argument can be used two ways for a histogram/density draw.
\itemize{
\item You can specify a single color, to color the whole graph.
\item You pass to \code{col} a vector of values which is the exact same length as input vector \code{x}.
The unique values of this vector will be used to group the \code{x} data, and a separate plot is
drawn for each group, with its own color. These colors will be automatically computed,
unless the entire \code{col} vector is valid color values. (Use \code{alpha} independently to change the
transparency.)
\itemize{
\item A color legend will be drawn automatically.
\item Use the \code{conditional} argument (see above) to control how the densities of each group
are scaled relative to each other.
\item If the grouping \code{col} vector is numeric and there are more than five unique values,
the numbers are automatically divided into five bins.
}
}
}
}

\subsection{Point size}{

Point size in \code{draw()} scatter and quantile plots can be controlled using the \code{cex} argument.
Note that point-size control can used for entirely aesthetic purposes \emph{or} to represent an
additional dimension of data.
Generally, \code{draw()} automatically picks an aesthetic point size based on the number of data points,
and the size of the plotting window:
the more data points, the smaller the points.

If a single \code{cex} value is provided, all points are drawn the same size.
If the \code{cex} value is numeric and the same length as \code{x} and \code{y}, a scale of sizes is generated to match
the range of values this variable takes, and a legend is added to the plot.
The generated scale matches the range of \code{cex} values to the \emph{area} of drawn points.
If the range of values is too great, it is not feasible to represent them using points,
because the points would either get too small to see, or too big (covering the whole plot).
Thus, if the largest \code{cex} value is more than 100 times greater than the smallest,
the scaling will be changed to accomodate this.
When this happens, a message will be printed, explaining how the relative area of drawn
points relates to the relative magnitude of \code{cex} values.
For example, in the two calls below, the first will work with no message
but the second one will print the message shown:

\if{html}{\out{<div class="sourceCode">}}\preformatted{draw(rnorm(100)|>sort(),rnorm(100), cex=(1:100))

draw(rnorm(100)|>sort(),rnorm(100), cex=(1:100)^2)
# In draw(cex = ), your largest cex value is 10000 times greater than the smallest value.
# To plot this, we must understate the differences between points. 
# When comparing the point in this plot, a doubling of area corresponds to multiplying the value by three.

}\if{html}{\out{</div>}}
}

\subsection{Drawing descriptive/reference statistics}{

Most \code{draw()} plots have options for drawing (overlaying) additional useful information and the
data distribution.
For example, the arithmetic mean of numeric distributions can be marked (with a black cross hair) by specifying
\code{mean = TRUE}.
(Only violin plots do this by default.)
For scatter plots, the cross hair mark is placed at the mean of both \code{x} and \code{y}.

All \code{draw()} plots (except heatmaps) also have an option to overlay lines marking data quantiles.
(Only quantile plots do this by default.)
To do this, specify your desired quantiles as a vector of numbers \eqn{1 \geq qs \geq 0},
provide to the \code{quantiles} argument.
For example, \code{draw(rnorm(100), quantiles = c(.05, .25, .5, .75 ,.95))}.
For scatter plots, quantiles are drawn for both \code{x} and \code{y} variables.
For violin plots, if \code{global_quantiles = TRUE}, the quantiles of the marginal \code{y}
distribution (ignoring the grouping by \code{x} categories) are drawn; however,
if \code{global_quantiles = FALSE} (the default), separate quantiles are drawn for each group.

Note that, when drawing \code{\link[=density]{density()}} objects, the mean and quantiles of the density estimate are
shown, not the raw data.

Another option is to compare numeric distributions to a normal (Gaussian) distribution.
If \code{normalReference = TRUE}, a normal distribution, with mean and standard deviation estimated
from the data, is overlayed on the plot as a dashed, black line.
If the data distribution is approximately normal, this line should approximate the data.
For scatter plots, the bivariate normal distribution of the two variables is estimated
(i.e., using their individual variances and their covariance).
A sample ten times the length of \code{x}/\code{y} (up to 10,000 at the most) is drawn
and these sample points are drawn as a transparent underlay of the actual scatter plot.
This conveys a sense of what the bivariate normal would look like, compared to the actual data.
A final option for scatter plots, is to automatically overline the simple linear regression line
between the two variables.
When \code{lm = TRUE}, the simple regression line is estimated using \link[=lm]{lm(y ~ x)};
the regression line and 95\% confidence limits on the regression line---estimated using \code{\link[=predict.lm]{predict.lm()}}---are
drawn (as solid lines and dashed lines respectively).
The regression coefficients are also drawn in a legend at the top left corner of the plot.
}

\subsection{Group proportions}{

Violin plots, area plots, and multi-color histograms draw probability mass grouped across categories.
A consideration is whether to draw this mass proportioned to the overall mass, or proportioned within each group.
These two possibilities can be set using the \code{conditional} argument: when \code{conditional = FALSE},
each group's probability mass is drawn as a proportion of the total; when \code{conditional = TRUE}, each group's
probability mass is scaled up to the size of the group (i.e., so it should sum to 1).
For illustrate, consider the following data and associated drawings:

\if{html}{\out{<div class="sourceCode">}}\preformatted{X <- c(A = rnorm(1000, mean = 0), B = rnorm(5000, mean = 1), C = rnorm(2000, mean = 1))
Categories <- rep(c('A', 'B', 'C'), c(1000, 5000, 2000))

# violin plot
draw(Categories, X) 
draw(Categories, X, conditional = TRUE) 

# area plot
draw(X, Categories) 
draw(X, Categories, conditional = TRUE) 

# multi-color histogram
draw(X, col = Categories) 
draw(X, col = Categories, conditional = TRUE) 

}\if{html}{\out{</div>}}
}
}

\section{Facets}{

}

