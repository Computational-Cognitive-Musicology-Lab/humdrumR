% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/humVector.R
\name{struct}
\alias{struct}
\alias{is.struct}
\alias{as.matrix.struct}
\alias{as.data.frame.struct}
\alias{format.struct}
\title{Pseudo-vector classes for humdrum data.}
\usage{
\S4method{nrow}{struct}(x)

\S4method{names}{struct}(x)

\S4method{c}{struct}(x, ..., rbind = FALSE)

\S4method{is.na}{struct}(x)

is.struct(x)

\S4method{is.vector}{struct}(x)

\S4method{as.vector}{struct}(x)

\S4method{as.list}{struct}(x, ...)

\method{as.matrix}{struct}(
  x,
  ...,
  collapse = function(x, y) .paste(x, y, sep = ",", na.rm = TRUE)
)

as.data.frame.struct(x, optional = FALSE, ...)

\method{format}{struct}(x, ...)

\S4method{as.character}{struct}(x)

\S4method{show}{struct}(object)

\S4method{sort}{struct}(x, decreasing = FALSE)

\S4method{==}{struct,struct}(e1, e2)

\S4method{<}{struct,struct}(e1, e2)

\S4method{<=}{struct,struct}(e1, e2)

\S4method{colSums}{struct}(x, na.rm = FALSE, drop = FALSE)

\S4method{rowSums}{struct}(x, na.rm = FALSE)

\S4method{cumsum}{struct}(x)

\S4method{diff}{struct}(x, lag = 1L)

\S4method{+}{struct,struct}(e1, e2)

\S4method{+}{struct,ANY}(e1, e2)

\S4method{+}{ANY,struct}(e1, e2)

\S4method{-}{struct,struct}(e1, e2)

\S4method{-}{struct,missing}(e1)

\S4method{-}{struct,struct}(e1, e2)

\S4method{-}{struct,ANY}(e1, e2)

\S4method{-}{ANY,struct}(e1, e2)

\S4method{*}{struct,numeric}(e1, e2)

\S4method{*}{numeric,struct}(e1, e2)
}
\description{
HumdrumR defines a number of S4 classes which are,
underneath the surface, \link{https://en.wikipedia.org/wiki/Composite_data_type}(composite data types),
made up of collections of base::R atomic vectors, stuck together.
(Things like this are called structs, or tuples, or records in other languages.)
The "vectorization" or R's atomic types is R's key strength so we
want, as much as possible for our composite types to act just R atomics.
}
\details{
\code{struct} is a \emph{virtual} S4 class for just such composite atomic vectors.
The \code{struct} defines all the necessarry methods to treat a collection of
atomic vectors as a single vector/matrix-like object---simply
make your new class inherit \code{struct} and it is all taken care of!
(To do this, specifify \code{contains = "struct"} in your call to \code{\link[methods:setClass]{methods::setClass()}}.)

Be warned, \code{R} is limited in this regard---users can't \emph{really} define
S4 classes that act fully like R atomics---, so you may
run in to problems if you take this too far.
For instance, though \code{struct} classes work (ok) in \link[base:data.frame]{base::data.frame}s
\link[data.table:data.table]{data.table::data.table}s and \link[tibble:tibble]{tibble::tibble}s might give you problems.
}
\section{Behavior}{


\code{struct} subclasses behave very similarly to normal R vectors.
However, they do differ in a few respects, mostly in ways that
avoid some of the quirky behaviors with R vectors:
In general, the distinction between dimensionless vectors
and dimensioned vectors is slightly weakened with \code{structs}
compared to normal R atomic vectors.
In general, dimensionless \code{struct}s are treated more implicitely
like column-matrices.
Notably, if the struct has rows, \code{length(struct) == nrow(struct)}.
Most importantly, dimensioned \code{struct}s won't drop their dimensions
under various common operations (\code{c}, \verb{[]}, etc.), the way
base-R matrices do.
Thie biggest difference is that \code{c} doesn't always cause \code{struct}s to lose their dimensions.
Rather, if the first argument to \code{c} has dimensions, the dimensions are kept and the \code{struct}s
are \code{rbind}ed (assuming the number of columns are conformable).

Other differences:
\itemize{
\item \code{struct}s can only have no dimensions (\code{dim(struct) == NULL}) or two dimentions. Higher dimensional arrays are not possible (yet).}
\item \code{rowSums} and \code{colSums} will coerce a dimensionless struct to a column matrix.
\item \code{struct}s always throw an error if you try to index them with a index value
that is greater than the length/nrow of the \code{struct}. This is different than atomic vectors,
which will pad the vector up to the length of the index you give---a sometimes useful but quirky behavior.
\item \code{struct}s with two dimensions have a \code{cartesian} indexing argument.
If \code{cartesian = TRUE}, the \code{i} and \code{j} arguments are treated as cartesian coordinates.
(This behavior can be achieved with base R matrices (or \code{struct}s) by inputing a matrix with two columns.)
}
}

\section{Requirements}{


To work, \code{struct} makes a few assumptions about your class.
Your class must have one or more slots which are vectors, all of which are the same length.
\code{struct}'s indexing method will cause all of these vectors to be indexed as one.
When you define a new subclass of \code{struct}, it will inherit a
\code{validObject} method which assures that all elements are the same dimension.
Thus, if you are writing your own \code{\link[methods:validObject]{methods::validObject()}} method (using \code{\link[methods:setValidity]{methods::setValidity()}})
you just have to worry specifically about the validity of the information in your slots,
not that the slots are all the same length.
}

\section{Initialize}{


An initialize method which automatically makes all slots the same length is predefined
for \code{structs}. If you want to make a more specialized \code{\link[methods:initialize]{methods::initialize()}} method,
you can still take advantage of the inherited method by using \code{\link[methods:callNextMethod]{methods::callNextMethod()}} at the
beginning of your function.
}

\section{Predefined methods}{


You must specify \link[base:order]{base::order} and any arithmetic/comparison methods for your class
yourself. However,
\itemize{
\item{If you define \code{>} and \code{>=}, \code{<} and \code{<=} will be automatically defined.}
\item{If you define \code{order}, \code{sort} will be automatically defined.}
\item{If you define \code{as.character} for your class, \code{show} and
\code{format} methods are defined automatically.}
}

Default arithmetic methods for addition, (scalar) multiplication, and negation (\code{-x}) are defined.
They assume that adding your class to another is simply the same as adding each numeric slot in parallel.
If this is not the case, you'll need to create your own, more specific, method!
}

