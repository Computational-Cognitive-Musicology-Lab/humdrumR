% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tools.R
\name{sigma}
\alias{sigma}
\alias{sigma.default}
\alias{sigma.matrix}
\title{Cumulative sum of numeric vector}
\usage{
sigma(x, lag, skip = is.na, init, right, boundaries = list(), ...)

\method{sigma}{default}(
  x,
  lag = 1,
  skip = is.na,
  init = 0,
  right = FALSE,
  boundaries = list(),
  ...
)

\method{sigma}{matrix}(x, margin = 2L, ...)
}
\arguments{
\item{x}{(Any numeric vector.) \code{NULL} values are returned \code{NULL}.}

\item{lag}{(Non-zero integer.) Which lag to use. (See \emph{Great lags} section, below.)}

\item{skip}{(\code{function}.) This must be a function which can be applied to \code{x} and returns a logical vector
of the same length. And \code{TRUE} values are skipped over in the calculations.
By default, the \code{skip} function is \code{is.na}, so \code{NA} values in the input (\code{x} argument) are skipped.
The skipped values are returned as is in the output vector.}

\item{init}{(Atomic value of same class as \code{x}, with \code{length(init) <= lag}.) \code{NA} values at the beginning
(or end of \code{right == TRUE}) are filled with these values \emph{before} summing.}

\item{right}{(single \code{logical} value) Should the \code{init} padding be at the "right" (end of the vector)?
By default, \code{right == FALSE} so the \code{init} padding is at the beginning of the output.}

\item{boundaries}{(vector of same length as \code{x}, or a list of such vectors) Differences are not calculated
across groups indicated by the \code{boundaries} vector(s).}
}
\description{
Calculate sequential cummulative sum of values in numeric vectors.
}
\details{
\code{sigma} is very similar base-\code{R} \code{\link[=cumsum]{cumsum()}}.
However, \code{sigma} should be favored in \link{humdrumR} use because:
\enumerate{
\item It has a \code{boundaries} argument, which is \emph{automatically} used by \code{humdrumR} \link[=withinHumdrum]{with(in)}
commands to constrain the differences within files/spines/paths of \code{humdrum} data.
The \code{boundaries} approach (details below) is generally faster than applying the commands within \code{groupby} groups.
\item They (can) automatically skip \code{NA} (or other) values.
\item \code{sigma} also has a \code{init} argument which can be used to ensure full invertability with \code{\link[=delta]{delta()}}. See the "Invertability"
section below.
}

If applied to a matrix, \code{sigma} is applied separately to each column, unless \code{margin} is set to \code{1} (rows)
or, if you have a higher-dimensional array, a higher value.
}
\section{Invertability}{


The \code{sigma} and \code{delta} functions are inverses of each other, meaning that with the right arguments set,
\code{sigma(delta(x)) == x} and \code{delta(sigma(x)) == x}.
In other words, the two functions "reverse" each other.
The key is that the \code{init} argument needs to be set to \code{0}, and all other
arguments (\code{lag}, \code{skip}, \code{boundaries}, etc.) need to match.
So \emph{actually},  \code{sigma(delta(x, init = 0, ...)) == x} and \verb{delta(sigma(x), init = 0)) == x}.

When we take the differences between values (\code{delta(x)}), the resulting differences can't tell us
fully how to reconstruct the original unless we know where to "start" (a constant offset).
For example,
\itemize{
\item \code{delta(c(5, 7, 5, 6)) == c(NA, 2, -2, 1)}
}

We know our input goes up 2, back down 2, then up 1, but the starting value (the first \code{5})
is lost.
If we call sigma on this, we'll get:
\itemize{
\item \code{sigma(c(NA, 2, -2, 1)) == c(0, 2,0, 1)}
}

We get the right contour, but we're offset by that constant \code{5}.

If we call \code{delta(x, init = 0)} the necessary constant (the first value) is kept at the beginning of the vector
\itemize{
\item \code{delta(c(5, 7, 5, 6), init = 0) == c(5, 2, -2, 1)}
}

so \code{sigma} gets what we want, full invertability:
\itemize{
\item \code{sigma(delta(c(5, 7, 5, 6), init = 0)) == c(5, 7, 5, 6)}
}

Alternatively, we could specify the necessary constant as the \code{init} argument of \code{sigma}:
\itemize{
\item \code{sigma(delta(c(5, 7, 5, 6)), init = 5) == c(5, 7, 5, 6)}
}

so the \code{init} arguments of the two functions are complementary.
}

\section{Greater lags}{


The behavior of \code{sigma} when \code{abs(lag) > 1} is easiest to understand as the inverse of the
behavior of \link[=delta]{delta(abs(lag) > 1)}, which is more intuitive. (\code{sigma} is the inverse of \code{\link[=delta]{delta()}}, see the
\emph{Invertability} section above).

Generally, if \code{abs(lag) > 1}, \code{x} is grouped by its indices modulo \code{lag}, and the cumulative sum is calculated separately
for each set of modulo indices.
For example, consider \code{lag == 2} for the following input:\tabular{lll}{
   \code{x} \tab index \tab index modulo 2 \cr
   1 \tab 1 \tab 1 \cr
   3 \tab 2 \tab 0 \cr
   2 \tab 3 \tab 1 \cr
   2 \tab 4 \tab 0 \cr
   5 \tab 2 \tab 1 \cr
}


The cumulative sum of the \code{1} and \code{0} modulo-index groups are:
\itemize{
\item Index \code{1}: \code{cumsum(c(1,2,5)) == c(1, 3, 8)}.
\item Index \code{0}: \code{cumsum(c(3,2)) == c(3, 5)}
}

Interleaved back into order, the result is \code{c(1,3,3,5,8)}.
This may not be very clear, but sure enough \code{delta(c(1, 3, 3, 5, 8), lag = 2, init = 0)} returns the original
\code{c(1,3,2,2,5)} vector!
Again, understanding \link[=delta]{delta(..., lag = n)} is easier than \code{sigma(..., lag = n)} (see the \emph{Invtertability} section
below.)
}

\section{Negative lag}{


If \code{lag} is negative, the output is the same as the equivalent positive lag, except
the sign is reversed (\code{output * -1}).
This behavior is easiest to understand as the inverse of the
behavior of \link[=delta]{delta(lag < 0)}, which is more intuitive. (\code{sigma} is the inverse of \code{\link[=delta]{delta()}}, see the
\emph{Invertability} section above).
}

\section{Boundaries}{


In many cases we want to perform lagged calculations in a vector, but not across certain boundaries.
For example, we don't want to calculate the difference between the first note in one file and the last
note of the previous file!
The \code{boundaries} argument indicates one, or more, grouping vectors, which break the \code{x} (input) argument
into groups.
If more than \code{boundaries} vectors are given, a change in \emph{any} vector indicates a boundary.
(\code{boundaries} are evaluated using the \code{\link[=changes]{changes()}} function, so you can also pass the argument \code{any = FALSE}
if you want their only to boundaries where \emph{all} boundary vectors change.)

Value pairs which cross between groups are compared to the \code{init} value(s), as if they were at the beginning
(or end, if \code{right == TRUE}).
Basically, using boundaries should be essentially identical to using \code{tapply(x, boundaries, delta/sigma, ...)},
except generally faster when the number of groups is large.

\code{humdrumR} \link[=withinHumdrum]{with(in)} calls will automatically feed the \code{File}, \code{Spine}, and \code{Path}
fields as three \code{boundaries} vectors, anywhere you use \code{delta}.
This is the most common, "melodic" use case.
However, if you wanted, for instance, to calculate differences across spines (like harmonic intervals)
you could manually set \code{boundaries = list(File, Record)}.
}

\seealso{
This function's inverse is \code{\link[=delta]{delta()}}.
}
