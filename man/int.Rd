% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Pitch.R
\name{int}
\alias{int}
\alias{mint.default}
\alias{mint.humdrumR}
\alias{hint.default}
\alias{hint.humdrumR}
\title{Calculate intervals between pitches}
\usage{
int(
  x,
  from = tint(0L, 0L),
  deparser = interval,
  incomplete = NULL,
  bracket = is.function(incomplete),
  classify = FALSE,
  ...,
  Exclusive = NULL,
  Key = NULL,
  parseArgs = list()
)

\method{mint}{default}(
  x,
  lag = 1,
  deparser = interval,
  incomplete = kern,
  bracket = is.function(incomplete),
  classify = FALSE,
  ...,
  parseArgs = list(),
  Exclusive = NULL,
  Key = NULL,
  groupby = list(),
  orderby = list()
)

humData  select(Token) |> mint() 
humData |> mint(simple = TRUE)
humData |> mint(Token, Key = Key)

\method{hint}{default}(
  x,
  lag = 1,
  deparser = interval,
  incomplete = kern,
  bracket = is.function(incomplete),
  ...,
  parseArgs = list(),
  Exclusive = NULL,
  Key = NULL,
  groupby = list(),
  orderby = list()
)

humData |> select(Token) |> hint() 
humData |> hint(simple = TRUE)
humData |> hint(Token, Key = Key)
}
\arguments{
\item{x}{\emph{\strong{Input pitch information.}}

Can be any (\link[base:vector]{atomic}) vector, or a \link[=tonalIntervalS4]{tonalInterval}, or \code{NULL}.
Must be \link[=pitchParsing]{parsable as pitch information}.}

\item{from}{\emph{\strong{Pitches to calculate the intervals from.}}

Defaults to middle C / unison.

Can be any (\link[base:vector]{atomic}) vector, or a \link[=tonalIntervalS4]{tonalInterval}, or \code{NULL}.
Must be \link[=pitchParsing]{parsable as pitch information}.}

\item{deparser}{\emph{\strong{What output representation do you want?}}

Defaults to \link[=interval]{interval}.

Must be a \link[=pitchFunctions]{pitch function}, like \code{kern()}.}

\item{incomplete}{\emph{\strong{How to pad incomplete intervals (e.g., the start/end of input).}}

Defaults to \code{NULL} for \code{int()}, \code{kern} for \code{mint()} and \code{hint()}.

Must \code{NULL}, a \link[=pitchFunctions]{pitch function}, or an atomic value of \code{length(incomplete) == abs(lag)}.}

\item{bracket}{\emph{\strong{Whether to print brackets around \code{incomplete} output.}}

Defaults to \code{TRUE} if \code{incomplete} is a function, \code{FALSE} otherwise.

Must be a singleton \code{logical} value: an on/off switch.

If \code{TRUE}, square brackets (\code{"[]"}) are printed around \code{incomplete} observations.}

\item{classify}{\emph{\strong{Should intervals be classified as step/skip/leaps?}}

Defaults to \code{FALSE}.

Must be a singleton \code{logical} value: an on/off switch.

If \code{TRUE}, the \code{deparser} is ignored and the output is classified as \code{Unison}, \code{Step}, \code{Skip}, or \code{Leap}.}

\item{parseArgs}{\emph{\strong{An optional list of arguments passed to the \link[=pitchParsing]{pitch parser}.}}

Defaults to an empty \code{list()}.

Must be a \code{list} of named arguments to the \link[=pitchParsing]{pitch parser}.}

\item{lag}{\emph{\strong{The \code{\link[=lag]{lag()}} to calculate harmonic/melodic intervals between.}}

Defaults to \code{1}, which means intervals between immediate successors in \code{x}.

Must be either a single number, or a \code{logical} of \code{length(x)} (see "Logical lags" section in manual).}

\item{groupby}{\emph{\strong{A \code{list} of vectors to group \code{x}.}}

Defaults to \code{list()}.

Must be a \code{list}; every element of the list must be length \code{length(x)}.}

\item{orderby}{\emph{\strong{A \code{list} of vectors to group \code{x}.}}

Defaults to \code{list()}.

Must be a \code{list}; every element of the list must be length \code{length(x)}.

Used to interpret the order of elements in \code{x}. Lagged computations are done in the indicated
order, but the output is returned in the original order.}
}
\description{
These functions allow us to calculate intervals between pitches.
\code{int()} is the most basic form, calculating the interval(s) between two input vectors.
\code{mint()} and \code{hint()} are special forms for calculating intervals "melodically" or "harmonically," respectively.

If \code{mint()} is applied to a \link[=humdrumRclass]{humdrumR data class}
you may use the data's \link[=fields]{fields} as arguments.
If no field names are specified, the first \link{selectedField} is used as \code{x}.

If \code{hint()} is applied to a \link[=humdrumRclass]{humdrumR data class}
you may use the data's \link[=fields]{fields} as arguments.
If no field names are specified, the first \link{selectedField} is used as \code{x}.
}
\details{
Input vectors \code{x} (and \code{from}) are \link[=tonalInterval]{parsed as pitches} (\link[=tonalIntervaS4]{tonal interval objects}), if possible.
(Parsing arguments can be passed via the \code{parseArgs} list, or \code{parse(...)} sugar.
\code{Key} and \code{Exclusive} arguments are also passed to the parser.)
Any inputs that fail to parse will show up as \code{NA} in the output.

Once parsed, the intervals between the pitches are calculated as \code{x - from}.
The resulting intervals are then "\link[=pitchDeparsing]{deparsed}" into a standard representation; by default, the \code{\link[=intervals]{intervals()}}
representation is used, but you can set the \code{deparser} argument to any \link[=pitchFunctions]{pitch function}.
However, the only alternative deparser that would be \emph{commonly} used (besides \code{\link[=intervals]{intervals()}}) would be \code{\link[=semits]{semits()}}.
If \code{deparser} is \code{NULL}, the raw \link[=tonalIntervalS4]{tonalIntervals} are returned.
}
\section{Melodic and Harmonic intervals}{


\code{mint} and \code{hint} calculate "melodic" and "harmonic" intervals respectively.
In this context, "melodies" are sequences of notes within a \strong{spine path}, while
"harmonies" are intervals between notes occurring in the same \strong{record} (at the same time).
Outside of a \link[=withinHumdrum]{with(in)} call, \code{mint} or \code{hint} are exactly the same;
It is only when used in a call to \link[=withinHumdrum]{with(in)} that you will see them have different behaviors,
as \link[=withinHumdrum]{with(in)} will automatically apply them across spine paths (\code{mint()}) or records (\code{hint()}).
This is achieved by modifying the \code{groupby} and \code{orderby} arguments to \code{\link[=lag]{lag()}}---you can manually achieve
the default behaviors, or other behaviors, by setting these arguments yourself.

When used in a \link[=withinHumdrum]{with(in)} expression, \code{mint()} will (by default) calculate the melodic interval \emph{approaching} each note
from the previous note:
for example, \code{mint('C4', 'D4', 'Eb4')} fill return \code{c('[c]', '+M2', '+m2')}, because D4 is approached by
ascending whole step \emph{from} C4, and Eb4 is approached by ascending half step \emph{from} D4.
Similarly, the default \link[=withinHumdrum]{with(in)} behavior of \code{hint()} is to calculate successive intervals in the same record
(\emph{across} spine paths), from left to right.
So the record \verb{C3  G4  C5} will return values \verb{[CC]  +P12  +P4}, because the G4 is a perfect 12th above C3, and
C5 is a perfect fourth above G4.

\code{mint()} and \code{hint()} work by passing \link[=lag]{lagged} and/or \link[=ditto]{dittoed}
versions of \code{x} as the \code{from} argument to \code{int()}.
Basically, \code{mint()} is equivalent to \code{int(x, lag(x, lag = lag, groupby = list(Piece, Spine, Path)), ...)}
and \code{hint()} is equivalent to \code{int(x, lag(x, lag = lag, groupby = list(Piece, Record), orderby = list(Piece, Record, Spine, Path)), ...)}.
In either case, the parsed pitch vector is copied and lagged using \code{\link[=lag]{lag()}}, with pairs crossing outside \code{groupby} groups ignored.
The \code{lag} argument controls how far apart in the melody intervals are calculated.
For instance, a lag of \code{2} will calculate intervals between \emph{every other} note in the vector.
Positive lags (the default) will calculate \strong{approaching} intervals: each token represents the interval between the current note
and the \emph{previous} note.
Negative lags will calculate \strong{departing} intervals: each token represents the interval
between the current note and the \emph{next} note.
Note that, by passing \code{directed = FALSE} through the the \link[=pitchDeparsing]{deparser}, the undirected (absolute value)
of the melodic intervals can be returned.
}

\section{Incomplete value padding}{


By default, \code{int} will return \code{NA} anywhere where \code{x} \strong{or} \code{from} is \code{NA}.
However, if \code{from} is \code{NA} but \code{x} is \emph{not} \code{NA}, we can ask for different output for these "incomplete" pairs.
using the \code{incomplete} argument.
If \code{incomplete} is an atomic value, incomplete outputs indices are willed with this value.
If the incomplete argument is a \link[=pitchFunctions]{pitch function} (like the \code{deparser} argument),
this function is used to (re)parse the values of \code{x} where \code{from} is missing.
If \code{bracket == TRUE}, incomplete output values are surrounded with \verb{[]}, so they are easier to distinguish from the
actual intervals.

The main use of the \code{incomplete} argument is in \code{mint()} and \code{hint()}.
The lagged \code{from} arguments used in \code{mint()}/\code{hint()} (see previous section) are necessarily padded by \code{abs(lag)} \code{NA}
values at the beginning (positive lag) or end (negative lag).
These are thus "incomplete" pairs passed to \code{int()}, and can controlled using the \code{incomplete} argument.
By default, both \code{mint()} and \code{hint()} set \verb{incomplete = kern(), bracket = TRUE} which cause these
notes to show up as bracketed kern, like \verb{[ee-]} or \verb{[C#]}.
If \code{incomplete} is \code{NULL}, the incomplete values are simply padded with \code{NA}.
}

\section{Interval classification}{


If the \code{classify} argument is set to \code{TRUE}, intervals are classified as either \code{"Unison"},
\code{"Step"}, \code{"Skip"}, or \code{"Leap"}.
Alternatively, skips can be interpreted as leaps by setting \code{skips = FALSE}.
(\code{classify = TRUE} overrides the \code{deparser} argument.)

By default, intervals are categorized tonally, meaning that the interval in tonal \emph{steps}
is used as the basis of classification.
For example, an augmented 2nd is a step, and a diminished 3rd is a skip/leap.
This means that augmented and diminished unisons are marked \code{"Unison"} as well!
However, if \code{directed = TRUE}, augmented/diminished unisons will be marked with \code{+} or \code{-}
to indicate direction, whereas perfect unisons are never marked with \code{+}/\code{-}.

Alternatively, you may choose to categorize intervals \emph{atonally} by setting \code{atonal = TRUE}.
If so, intervals are categorized based only on semitone (enharmonic) intervals:
D# and Eb are classified the same.
}

\section{Logical (ditto) lags}{


For calls to \code{hint()} and \code{mint()} the default behavior is a \code{numeric} \code{lag} argument passed to \code{\link[=lag]{lag()}}.
An alternate option is to specify the \code{lag} argument as  \code{logical} vector the same length as the input (\code{x} argument).
Rather than calculating the interval between a pitch and another pitch separated by a regular lag,
a \code{logical} \code{lag} argument "lags" each pitch back to the previous value where \code{lag == TRUE}.
This means that more than one interval can be calculated from those same \code{TRUE} indices.

The canonic use of this "logical lag" feature is to calculate harmonic intervals relative to the same voice, like the bass voice.
For example, consider this file:

\if{html}{\out{<div class="sourceCode">}}\preformatted{ **kern        **kern        **kern        **kern
*I"Bass      *I"Tenor       *I"Alto    *I"Soprano
      C             e             g            cc
      G             d             f             b
      C             c             e            cc             
     *-            *-            *-            *-
}\if{html}{\out{</div>}}

If we \link[=readHumdrum]{read} this file and applied \code{hint()} to the \code{Token} field (with default arguments)
the result would be:

\if{html}{\out{<div class="sourceCode">}}\preformatted{ **kern        **kern        **kern        **kern
*I"Bass      *I"Tenor       *I"Alto    *I"Soprano
    [C]          +M10           +m3           +P4
    [G]           +P5           +m3           +A4
    [C]           +P8           +M3           +m6             
     *-            *-            *-            *-
}\if{html}{\out{</div>}}

In each record, we see the intervals as lagged (\code{lag == 1}) from left right:
we see the intervals between the bass and the tenoir, the tenor and the alto, and the alto
and the soprano.
What if we wanted to see all the intervals with the bass?
Well, we can use a \code{logical} \code{lag} argument, where we would specify that \code{Spine == 1}:
\verb{with(humData, hint(Token, lag = Spine == 1)}.
This means that all \code{from} values are "lagged" back to the previous value where \code{Spine == 1}.
The result would be:

\if{html}{\out{<div class="sourceCode">}}\preformatted{ **kern        **kern        **kern        **kern
*I"Bass      *I"Tenor       *I"Alto    *I"Soprano
    [C]          +M10          +P12          +P14
    [G]           +P5           +m7          +M10
    [C]           +P8          +M10          +P14             
     *-            *-            *-            *-
}\if{html}{\out{</div>}}

Now we see all the intervals relative to the bass.

The \code{logical} \code{lag} only takes place within the \code{groupby} groups.
However, note that any values \emph{before} the first index where \code{lag == TRUE}
are calculated relative to that first value.
}

\section{Grouping}{


In many cases we want to perform lagged calculations in a vector, but \emph{not across certain boundaries}.
For example, if your vector includes data from multiple pieces, we wouldn't want to calculate melodic intervals
between pieces, only within pieces.
The \code{groupby} argument indicates one, or more, grouping vectors, which break the \code{x} (input) argument
into groups.
If more than \code{groupby} vectors are given, a change in \emph{any} vector indicates a boundary.

Value pairs which cross between groups are treated as if they were at the beginning.
Basically, using the \code{groupby} argument to a function should be
similar or identical to using \code{tapply(x, groupby, laggedFunction, ...)} or using a \code{groupby}
expession in a call to \link[=withinHumdrum]{with(in).humdrumR}.
However, using a \code{groupby} argument directly is usually much faster, as they have been
specially optimized for this functions.

The most common use case in humdrum data, is looking at "melodies" within spines.
For this, we want \code{groupby = list(Piece, Spine, Path)}.
In fact, \code{humdrumR} \link[=withinHumdrum]{with(in)} calls will \emph{automatically} feed these
three fields as \code{groupby} arguments to certain functions: mint, delta, sigma, lag, ditto, ioi, untie, or hop.
So any use of \code{delta} in a call to \link[=withinHumdrum]{with(in)}, will automatically calculate the \code{delta}
in a "melodic" way, within each spine path of each piece.
However, if you wanted, for instance, to calculate differences across spines (like harmonic intervals)
you could manually set \code{groupby = list(Piece, Record)}.
}

\examples{
exampleToken <- c('4GG', '4G', '4E', '4F#', '4G', '4D', '4E')
results <- mint(exampleToken)
results
results <- hint(exampleToken)
results

exampleHumdrum <- readHumdrum(humdrumRroot, "HumdrumData/BeethovenVariations/B075_00_05_a.krn")
results <- with(exampleHumdrum[[,3:4]], mint(Token))
results
results <- with(exampleHumdrum[[,3:4]], hint(Token))
results

}
\seealso{
{\code{mint} uses \code{\link[=lag]{lag()}} to "lag" the input pitches, and also makes use of \link[=tonalInterval]{pitch parsers} and \link[=pitchFunctions]{pitch functions}.}

Other {relative pitch functions}: 
\code{\link{bhatk}()},
\code{\link{degree}()},
\code{\link{interval}()},
\code{\link{solfa}()}

Other {Lagged vector functions}: 
\code{\link{delta}()},
\code{\link{ditto}()},
\code{\link{lag}()},
\code{\link{sigma}()}
}
\concept{{Lagged vector functions}}
\concept{{relative pitch functions}}
