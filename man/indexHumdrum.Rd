% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Subset.R
\name{indexHumdrum}
\alias{indexHumdrum}
\alias{index}
\alias{index2}
\alias{[,humdrumR,missing,ANY-method}
\alias{[,humdrumR,numeric,ANY-method}
\alias{[,humdrumR,character,ANY-method}
\alias{[[,humdrumR,numeric,missing-method}
\alias{[[,humdrumR,missing,numeric-method}
\alias{[[,humdrumR,character,missing-method}
\alias{[[,humdrumR,missing,character-method}
\alias{[[,humdrumR,ANY,ANY-method}
\title{Indexing humdrumR objects}
\usage{
index(x, i, j, drop = FALSE)

index2(x, i, j, drop = FALSE)

humdata[] # returns unchanged

humdata[x:y]

humdata['regex']

humdata[[x:y]]

humdata[[ , x:y]]

humdata[['regex']]

humdata[[ , 'regex']]

humdata[[x:y, l:m]]
}
\arguments{
\item{x}{\emph{\strong{HumdrumR data to index.}}

Must be a \link[=humdrumRclass]{humdrumR data object}.}

\item{i}{\emph{\strong{Index for vectors or matrix/data.frame rows.}}

A numeric vector or a \code{character} string treated as a regular expression.}

\item{j}{\emph{\strong{Index for matrix/data.frame columns.}}

A numeric vector or a \code{character} string treated as a regular expression.}
}
\description{
R's built-in indexing operators, \verb{[]} (single brakcets) and \verb{[[]]} (double brackets) can
be used as shortcuts for common calls to \code{\link[=subset.humdrumR]{subset.humdrumR()}},
allowing you to filter out specific pieces, spines, or records.
}
\details{
In \code{R}, the basic \link[base:Extract]{indexing operators}, \verb{[]} and \verb{[[]]},
are used to select subsets of data.
For many data types (for instance, base R \link[base:list]{lists})
the \strong{\code{[}single brackets\verb{]}} are used for "shallower" extraction while the
\strong{\code{[[}double brackets\verb{]]}} are used for "deeper" extraction.
\link[=humdrumRclass]{HumdrumR corpus} indexing follows this same basic pattern:
\strong{\code{[}single brackets\verb{]}} are used to index \code{humdrumR} objects
\emph{by piece} while \strong{\code{[[}double brackets\verb{]]}} are used to index
\emph{within pieces}. (Accidentally writing \verb{[]} when you need
\verb{[[]]} is a very common error, so watch out!)

Whether, indexing by piece or within, \code{humdrumR} objects can use
two types of indexing arguments:
\itemize{
\item By \code{numeric} (ordinal integers)
\item By \code{character} string (regular expressions)
}

For more powerful/flexible indexing options, use \link[=subset.humdrumR]{subset} directly.
\subsection{Numeric indexing:}{

Indexing \code{humdrumR} corpora with
\strong{\code{[}single brackets\verb{]}} will accept
one numeric argument.
This argument will be used to pick pieces within the \code{humdrumR} object ordinally.
Thus, \code{humdata[1:10]} will select the first ten pieces in the data while \code{humdata[42]}
will select only the 42nd piece.

Indexing \code{humdrumR} objects with
\strong{\code{[[}double brackets\verb{]]}} will accept
one or two numeric arguments, \code{i} and \code{j}, either of which can
be used in isolation or in combination.
(If \code{j} is used in isolation, it must be named or placed after a comma, as in \code{humdata[[ , j ]]}.)
\itemize{
\item \code{i} is used to index data records (i.e., based on the humtable \code{Record} field).
Thus, \code{humdata[[1:20]]} indexes the first twenty records \emph{from each piece}
in the corpus, and \code{humdata[[42]]} extracts the 42nd record \emph{from each piece}.
\item \code{j} is used to index spines  (i.e., based on the \code{Spine} field).
Thus, \code{humdata[[ , 3:4]]} returns the third and fourth spines \emph{from each}
piece in the corpus.
}

When indexing \link[=humdrumRclass]{humdrumR corpora} with numbers,
all \code{numeric} (double) inputs are converted to integers.

Since \link[=subset.humdrumR]{subset} always renumbers pieces/spines that remain after filtering/indexing,
\code{humdrumR} indexing is entirely \strong{ordinal}.
For example,

\if{html}{\out{<div class="sourceCode">}}\preformatted{humsubset <- humdata[11:20]
humsubset[2]
}\if{html}{\out{</div>}}

will return the 12th piece from the original \code{humdata} object.
This is because the first call to \verb{[]} returns the 11th through 20th pieces, which
are renumbered \code{1:10} and the second index call returns the \emph{new} 2nd index, which was the 12th
originally.
Similarly,

\if{html}{\out{<div class="sourceCode">}}\preformatted{humsubset2 <- humdata[[ , 2:4]]
humsubset2[[ , 2]]
}\if{html}{\out{</div>}}

will return the third spine from the original data.

As in normal \code{R} indexing, negative numbers can be used, causing corresponding elements to be
\emph{removed} instead of retained. Thus, \code{humdata[-3:-5]} will remove the third, fourth, and fifth pieces from the data
while \code{humdata[[ , -3:-5]]} will remove the third, fourth, and fifth spines from each piece.
Positive and negative indices cannot be mixed in a single argument.

In all cases, indices outside of range (or of value \code{0}) are ignored.
E.g., if you have a corpus of twenty pieces and you call \code{corpus[21]}, there is no 21st piece, so \code{21} is "out of range".
If all your input indices are \code{0} and error will result.
If all your input indices are out of range then
an empty \code{humdrumR} object is returned.
For instance, \code{humdata[[401:500, ]]} will return an empty
\code{humdrumR} object if there are no pieces with more than 400
data records.
}

\subsection{Character indexing:}{

Indexing \link[=humdrumR:humdrumRclass]{humdrumR objects} with
\code{[}single brackets\verb{]} will accept one
vector of \code{character} strings. These strings are
treated as
\href{https://en.wikipedia.org/wiki/Regular_expression}{regular expressions} (regexes).

The tokens from the humdrumR object's \link[=humActive]{active field(s)} are searched
for matches to any of the regular expressions you input. Any piece that contains
\strong{any} match to \strong{any} of the regular expressions is retained---all other pieces
are filtered out. Note that (because this is \code{[}single-bracket\verb{]} indexing) the entire piece is
retained, even if there is only one match.
If no matches occur in any pieces, an empty \code{humdrumR} object is returned.

Indexing \code{humdrumR} objects with \code{[[}double brackets\verb{]]} will
accept one or two vectors of \code{character} strings, \code{i} and \code{j},
either of which can
be used in isolation or in combination.
(If \code{j} is used in isolation, it must be placed after a comma,
as in \code{humdata[[ , j]]}.)
These strings are
treated as \href{https://en.wikipedia.org/wiki/Regular_expression}{regular expressions} (regexes).
The tokens from the humdrumR object's \link[=humActive]{active field(s)} are searched
for matches to any of the regular expressions you input.
Any record which contains at least one token matching any regex in \code{i}
will be retained.
Similarly, any spine which contains at least one token matching any
regex in \code{j} is retained.
If \code{i} and \code{j} are used together,
matching spines (\code{j}) are indexed first, so that
tokens matching the regular expression(s) in \code{i}
must be found in the matching spines.
}
}
\section{removeEmpty}{


By default, calls to indexing operators will completely remove
data which you are filtering out.
However, if you set the \code{removeEmpty} argument to \code{FALSE},
the filtered data is set to \code{NULL}, but not actually removed from the data object.
(See \code{\link[=subset.humdrumR]{subset.humdrumR()}} for more details.)
}

\seealso{
{These indexing operators work through special calls to \code{\link[=subset.humdrumR]{subset.humdrumR()}}}
}
