% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Subset.R
\name{indexHumdrum}
\alias{indexHumdrum}
\alias{[,humdrumR,missing,ANY-method}
\alias{[,humdrumR,numeric,ANY-method}
\alias{[,humdrumR,character,ANY-method}
\alias{[[,humdrumR,numeric,missing-method}
\alias{[[,humdrumR,missing,numeric-method}
\alias{[[,humdrumR,character,missing-method}
\alias{[[,humdrumR,missing,character-method}
\alias{[[,humdrumR,ANY,ANY-method}
\alias{[[,humdrumR,missing,missing-method}
\alias{index}
\alias{index2}
\title{Indexing humdrumR objects}
\usage{
humData[] # returns unchanged

humData[x:y]

humData['regex']

humData[[x:y]]

humData[[ , x:y]]

humData[['regex']]

humData[[ , 'regex']]

humData[[x:y, l:m]]

humData[[ , , regex]]

index(x, i, j, drop = TRUE)

index2(x, i, j, drop = TRUE)
}
\arguments{
\item{x}{\emph{\strong{HumdrumR data to index.}}

Must be a \link[=humdrumRclass]{humdrumR data object}.}

\item{i}{\emph{\strong{Index for vectors or matrix/data.frame rows.}}

A numeric vector or a \code{character} string treated as a regular expression.}

\item{drop}{\emph{\strong{Should empty records/spines/pieces be removed?}}

Defaults to \code{TRUE}.

Must be a singleton \code{logical} value: an on/off switch.}

\item{j}{\emph{\strong{Index for matrix/data.frame columns.}}

A numeric vector or a \code{character} string treated as a regular expression.}
}
\description{
R's built-in indexing operators, \verb{[]} (single brakcets) and \verb{[[]]} (double brackets) can
be used to filter \link[=humdrumRclass]{humdrumR data}, by removing specific
pieces, spines, or records from the \link[=humTable]{humdrum table}.
Unlike the more flexible/powerful \link[=subset.humdrumR]{subset()/filter()} methods,
the indexing operators are generally destructive (by default), meaning filtered data can no longer
be accessed after indexing.
The functions \code{index()} and \code{index2()} are synonyms for single and double brackets respectively,
which can be used in pipes.
}
\details{
In R, the fundamental \link[base:Extract]{indexing operators}, \verb{[]} and \verb{[[]]},
are used to select subsets of data.
For many data types (for instance, base R \link[base:list]{lists})
the \strong{\code{[}single brackets\verb{]}} are used for "shallower" extraction while the
\strong{\code{[[}double brackets\verb{]]}} are used for "deeper" extraction.
By rough analogy with this "shallow vs deep" dichotomy, \link[=humdrumRclass]{HumdrumR corpus}
indexing brackets are used in two ways:
\itemize{
\item \strong{\code{[}single brackets\verb{]}} are used to select \emph{pieces} in your data.
\item \strong{\code{[[}double brackets\verb{]]}} are used to select records or spines \emph{within the pieces} in your data.
}

(Accidentally writing \verb{[]} when you need
\verb{[[]]} is a very common error, so watch out!)

Whether, indexing by piece or within, \code{humdrumR} objects can use
two types of indexing arguments: \code{numeric} (ordinal integers) or \code{character} string
(interpreted as regular expressions).
\subsection{Numeric indexing:}{

Indexing \code{humdrumR} corpora with
\strong{\code{[}single brackets\verb{]}} will accept
one numeric argument---only whole numbers are accepted.
This argument will be used to pick pieces within the \code{humdrumR} object ordinally.
Thus, \code{humData[1:10]} will select the first ten pieces in the data while \code{humData[42]}
will select only the 42nd piece.

Indexing \code{humdrumR} objects with
\strong{\code{[[}double brackets\verb{]]}} will accept
one or two numeric arguments, \code{i} and \code{j}, either of which can
be used in isolation or in combination.
(If \code{j} is used in isolation, it must be named or placed after a comma, as in \code{humData[[ , j ]]}.)
\itemize{
\item \code{i} is used to index records (i.e., based on the humtable \code{Record} field).
Thus, \code{humData[[1:20]]} indexes the first twenty records \emph{from each piece}
in the corpus, and \code{humData[[42]]} extracts the 42nd record \emph{from each piece}.

To avoid breaking the humdrum syntax, exclusive interpretations and spine-path
interpretations are not removed.
\item \code{j} is used to index spines  (i.e., based on the \code{Spine} field).
Thus, \code{humData[[ , 3:4]]} returns the third and fourth spines \emph{from each}
piece in the corpus.
}

Pieces/spines/records are renumbered after indexing
(see the \strong{Renumbering} section of the \link[=subset.humdrumR]{subset()/filter() docs} for explantion).
As a result, \code{humdrumR} indexing is entirely \strong{ordinal}.
For example,

\if{html}{\out{<div class="sourceCode">}}\preformatted{humsubset <- humData[11:20]
humsubset[2]
}\if{html}{\out{</div>}}

will return the 12th piece from the original \code{humData} object.
This is because the first call to \verb{[]} returns the 11th through 20th pieces, which
are renumbered \code{1:10} and the second index call returns the \emph{new} 2nd index, which was the 12th
originally.
Similarly,

\if{html}{\out{<div class="sourceCode">}}\preformatted{humsubset2 <- humData[[ , 2:4]]
humsubset2[[ , 2]]
}\if{html}{\out{</div>}}

will return the third spine from the original data.
\subsection{Negative numbers}{

As in normal \code{R} indexing, negative numbers can be used, causing corresponding elements to be
\emph{removed} instead of retained. Thus, \code{humData[-3:-5]} will remove the third, fourth, and fifth pieces from the data
while \code{humData[[ , -3:-5]]} will remove the third, fourth, and fifth spines from each piece.
Positive and negative indices cannot be mixed in a single argument.
}

\subsection{Out of bounds indices}{

In all cases, indices outside of bounds (or of value \code{0}) are ignored.
E.g., if you have a corpus of twenty pieces and you call \code{corpus[21]}, there is no 21st piece, so \code{21} is "out of bounds".
If all your input indices are \code{0} and error will result.
If \emph{all} your input indices are out of bounds then
an empty \code{humdrumR} object is returned.
For instance, \code{humData[[401:500, ]]} will return an empty
\code{humdrumR} object if there are no pieces with more than 400
data records.
}

}

\subsection{Character indexing:}{

If you index a \link[=humdrumR:humdrumRclass]{humdrumR object}
with \code{character} strings, these strings are
treated as \href{https://en.wikipedia.org/wiki/Regular_expression}{regular expressions} (regexes),
which are matched against non-null data tokens (\code{"D"}) in the object's first \link[=selectedFields]{selected field}.
A match to \strong{any} of the regular expressions considered a match.

Indexing with \code{[}single brackets\verb{]} accepts one
vector of \code{character} regular expressions.
Any piece that contains even a single match will be retained.
If no matches occur in any pieces, an empty \code{humdrumR} object is returned.

Indexing \code{humdrumR} objects with \code{[[}double brackets\verb{]]}
accepts one or two vectors of \code{character} strings, \code{i} and \code{j},
either of which can be used in isolation or in combination.
(If \code{j} is used in isolation, it must be placed after a comma,
as in \code{humData[[ , j]]}.)
Any data record which contains at least one match to the \code{i} regex(es)
will be retained.
Similarly, any spine which contains at least one match to the
\code{j} regex(es) is retained.
If \code{i} and \code{j} are used together,
matching spines (\code{j}) are indexed first, so that
tokens matching the regular expression(s) in \code{i}
must be found in the matching spines.
}

\subsection{Exclusive indexing:}{

Spines can also be indexed ordinally by exclusive interpretation.
To do this, provide a double-bracket index with a \emph{named} numeric (whole number) argument,
with name(s) corresponding to exclusive interpretations in the data.
For example, if you want to index the 3rd \verb{**kern} spine in each piece,
use \code{humData[[kern = 3]]}.
Note that \emph{other} exclusive interpretations in each piece are unaffected---in
this example, only the kern spines (if there are any) are indexed!
}
}
\section{drop}{


The \code{drop} argument to any humdrumR indexing controls whether
filtered data is completely removed from the data, or simply set to null
This means the filtered data can be recovered using \code{\link[=unfilter]{unfilter()}} (see the \link[=subset.humdrumR]{subset()/filter()}
docs for an explanation).
By default, piece-indexing and spine-indexing have \code{drop = TRUE},
but record-indexing defaults to \code{drop = FALSE}.
}

\examples{

humData <- readHumdrum(humdrumRroot, "HumdrumData/RollingStoneCorpus/*.hum")

humData[1:2]
humData[-1]

humData[[ , 3:4]]
humData[[1:40 , ]]

# find all pieces which use a flat 3
humData['b3']

# find all records that use a flat 3
humData[['b3', ]]
humData[['b3', drop = TRUE]]

# Exclusive interpretation indexing
humData[[deg = 1]]

# pipe indexing
humData |> index(1:3) |> index2(3:4)

}
\seealso{
{For more powerful/flexible indexing options, use \link[=subset.humdrumR]{subset()/filter()}.}
}
