% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Rational.R
\name{rational}
\alias{rational}
\alias{\%R\%}
\alias{numerator}
\alias{denominator}
\alias{numerator,rational-method}
\alias{denominator,rational-method}
\alias{is.rational}
\alias{is.numeric,rational-method}
\alias{order,rational-method}
\alias{Compare,rational,rational-method}
\alias{Compare,rational,ANY-method}
\alias{Compare,ANY,rational-method}
\alias{Summary,rational-method}
\alias{prod,rational-method}
\alias{abs,rational-method}
\alias{sign,rational-method}
\alias{max,rational-method}
\alias{min,rational-method}
\alias{mean,rational-method}
\alias{round,rational-method}
\alias{floor,rational-method}
\alias{ceiling,rational-method}
\alias{trunc,rational-method}
\alias{expand,rational-method}
\alias{sum,rational-method}
\alias{cumsum,rational-method}
\alias{as.rational}
\alias{as.rational,rational-method}
\alias{as.rational,matrix-method}
\alias{as.rational,integer-method}
\alias{as.rational,numeric-method}
\alias{as.rational,logical-method}
\alias{as.rational,character-method}
\alias{as.rational,fraction-method}
\alias{fraction}
\alias{as.fraction}
\alias{as.double.fraction}
\alias{as.integer.fraction}
\title{Rational numbers}
\usage{
rational(numerator, denominator = 1L)

e1 \%R\% e2

numerator(x)

denominator(x)

\S4method{numerator}{rational}(x)

\S4method{denominator}{rational}(x)

is.rational(x)

\S4method{is.numeric}{rational}(x)

\S4method{order}{rational}(
  x,
  ...,
  na.last = TRUE,
  decreasing = FALSE,
  method = c("auto", "shell", "radix")
)

\S4method{Compare}{rational,rational}(e1, e2)

\S4method{Compare}{rational,ANY}(e1, e2)

\S4method{Compare}{ANY,rational}(e1, e2)

\S4method{Summary}{rational}(x)

\S4method{prod}{rational}(x, ..., na.rm = FALSE)

\S4method{abs}{rational}(x)

\S4method{sign}{rational}(x)

\S4method{max}{rational}(x, ..., na.rm = FALSE)

\S4method{min}{rational}(x, ..., na.rm = FALSE)

\S4method{mean}{rational}(x)

\S4method{round}{rational}(x)

\S4method{floor}{rational}(x)

\S4method{ceiling}{rational}(x)

\S4method{trunc}{rational}(x)

\S4method{expand}{rational}(x)

\S4method{sum}{rational}(x, ..., na.rm = FALSE)

\S4method{cumsum}{rational}(x)

as.rational(x, ...)

\S4method{as.rational}{rational}(x)

\S4method{as.rational}{matrix}(x)

\S4method{as.rational}{integer}(x)

\S4method{as.rational}{numeric}(x)

\S4method{as.rational}{logical}(x)

\S4method{as.rational}{character}(x, sep = "/|\%")

\S4method{as.rational}{fraction}(x, sep = "/|\%")

fraction(numerator, denominator, sep = "/")

as.fraction(x, sep = "/")

\method{as.double}{fraction}(x)

\method{as.integer}{fraction}(x)
}
\description{
R has no built in rational number representation; \code{humdrumR} defines one.
}
\details{
Using rational numbers, we can represent numbers like 1/3 without any numeric inaccuracies.
In other words, \eqn{1/3 * 3 = 3}, never \eqn{.999999999}.
On the other hand, if our rational numbers start to have numerators or demoninators that are too large, we can run into
integer overflow problems.
Since the rational numbers we'll be using in the context of music analysis are relatively simple,
we can safely use such numbers without any numeric inaccuracy.

\code{fraction} is a class (and associated constructor) which represents rational numbers as \code{character} strings.
Unlike \code{rational}, the \code{fraction} class is not numeric and thus cannot do arithmetic.
However, \code{fraction} can be converted to/from \code{rational}.
}
\seealso{
\code{\link[=as.real]{as.real()}} \code{\link[=as.numeric]{as.numeric()}}
}
\concept{{humdrumR numeric functions}}
