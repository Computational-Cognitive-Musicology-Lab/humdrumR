% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/humVector.R, R/humRhythm.R, R/humDiatonic.R
\docType{class}
\name{humdrumVector}
\alias{humdrumVector}
\alias{is.humdrumVector}
\alias{as.data.frame.humdrumVector}
\alias{rep.humdrumVector}
\alias{format.humdrumVector}
\title{Pseudo-vector classes for humdrum data.}
\usage{
\S4method{names}{humdrumVector}(x)

\S4method{[}{humdrumVector,ANY}(x, i)

\S4method{[}{humdrumVector,ANY,missing,humdrumVector}(x, i) <- value

\S4method{c}{humdrumVector}(x, ...)

\S4method{length}{humdrumVector}(x)

\S4method{dim}{humdrumVector}(x)

\S4method{is.na}{humdrumVector}(x)

is.humdrumVector(x)

\S4method{is.vector}{humdrumVector}(x)

\S4method{as.vector}{humdrumVector}(x)

\S4method{as.list}{humdrumVector}(x, ...)

as.data.frame.humdrumVector(x, row.names = NULL, optional = FALSE, ...)

\S4method{as.character}{humdrumVector}(x)

\S4method{show}{humdrumVector}(object)

\method{rep}{humdrumVector}(x, ...)

\S4method{sort}{humdrumVector}(x, decreasing = FALSE)

\S4method{==}{humdrumVector,humdrumVector}(e1, e2)

\S4method{<}{humdrumVector,humdrumVector}(e1, e2)

\S4method{<=}{humdrumVector,humdrumVector}(e1, e2)

\method{format}{humdrumVector}(x, ...)

\S4method{sum}{humdrumVector}(x)

\S4method{cumsum}{humdrumVector}(x)

\S4method{-}{humdrumVector,humdrumVector}(e1, e2)

\S4method{diff}{humdrumVector}(x, lag = 1L, differences = 1L)

\S4method{+}{humdrumVector,ANY}(e1, e2)

\S4method{+}{ANY,humdrumVector}(e1, e2)

\S4method{-}{humdrumVector,ANY}(e1, e2)

\S4method{-}{ANY,humdrumVector}(e1, e2)

\S4method{*}{humdrumVector,numeric}(e1, e2)

\S4method{*}{numeric,humdrumVector}(e1, e2)

\S4method{is.numeric}{rhythmInterval}(x)

\S4method{is.numeric}{diatonicSet}(x)
}
\description{
R's "vectorization" is a key strength, so being able to define
S4 classes that act in a vectorized manner is very useful.
Unfortunetaly, defining this classes is a bit tedious.
\code{humdrumVector} is a \emph{virtual} S4 class which takes care of some of 
this tediousness for developers. The \code{humdrumVector}
defines all the necessarry methods to treat an object as a vector---simply
make your new class inherit \code{humdrumVector} and it is all taken care of!
(To do this, specifify \code{contains = 'humdrumVector'} in your call to \code{setClass}.)
}
\details{
Be warned, \code{R} is limited in this regard---users can't \emph{really} define
\code{S4} classes that really act fully like \code{R} atomics---, so you may 
run in to problems if you take this too far. 
For instance, though \code{humdrumVector} classes work (ok) in \code{\link[base]{data.frame}}s
\code{data.table}s and \code{tibbles} might give you problems.
}
\section{Requirements}{


To work, \code{humdrumVector} makes a few assumptions about your class.
Your class must one or more slots which themselves contain vectors or matrices, with 
all vector lengths and matrix number-of-rows the same.
\code{humdrumVector}'s indexing method will cause all of these vectors to be indexed as one.
When you define a new subclass of \code{humdrumVector}, it will inherit a 
\code{validObject} method which assures that all elements are the same length/number-of-rows.
Thus, if you are writing your own \code{validObject} method (using \code{setValidity})
you just have to worry specifically about the validity of the information in your slots,
not that the slots are all the same length.
}

\section{Initialize}{

An initialize method which automatically makes all slots the same length is predefined
for \code{humdrumVectors}. If you want to make a more specialized \code{initialize} method,
you can still take advantage of the inherited method by using \code{UseNextMethod} at the 
beginning of your function.
}

\section{Predefined methods}{


You must \code{order} and any arithmetic/comparison methods for your class
yourself. However,
\itemize{
 \item{If you define \code{>} and \code{>=}, \code{<} and \code{<=} will be automatically defined.}
 \item{If you define \code{order}, \code{sort} will be automatically defined.}
 \item{If you define \code{as.character} for your class, \code{show} and
  \code{format} methods are defined #' automatically.}
 \item{If you define \code{+} methods for your class (adding two of class together), inefficient but
  functional implementations of \code{sum} and \code{cumsum} are defined.}
 \item{If you \emph{also} define a prefix \code{-} method (with 
 \code{signature = c(e1 = 'myclass', e2 = 'missing')}),  \code{-} methods between 
 two of your classes are defined, as well as a inefficient default implementation 
 of \code{diff}.}
}
}

