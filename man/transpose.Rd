% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Pitch.R
\name{transpose}
\alias{transpose}
\title{Transpose pitches and keys}
\usage{
transpose(x, by, Key, to, real, relative, ...)
}
\arguments{
\item{x}{The input pitch(es) to transpose. A \code{tonalInterval} or something intepretable as a \code{tonalInterval}.}

\item{by}{A \code{tonalInterval} or something intepretable as a \code{tonalInterval}.
The input \code{x} is transposed by this interval.}

\item{Key}{A \code{diatonicSet} or something intepretable as a \code{diatonicSet}. For tonal and/or to transpositions,
this is the "from" key. If this value is \code{NULL}, it defaults to C major.}

\item{to}{A \code{diatonicSet} or something intepretable as a \code{diatonicSet}. The input \code{x} is transposed
to this key.}

\item{real}{A logical. If \code{TRUE} (the default), transposition is real. If \code{FALSE}, transposition is tonal.}

\item{relative}{A logical. If \code{TRUE} transposition is relative. If \code{FALSE} (the default), transposition is parallel.}
}
\description{
This function \link[=https://en.wikipedia.org/wiki/Transposition_(music)]{transposes} pitches or keys
by various intervals or to target keys.
Inside the box, inputs and transpositions take place as \code{tonalInterval}s or \code{diatonicSet}s,
but any numeric or character string representation of pitches can be transposed as well.
This function is incorporated directly into \link{tonalTransform}, and thence, all \link[=pitchRepresentations]{pitch translation}
functions, so you probably won't call it directly very often.
}
\details{
There are two distinct types of transposition (real and tonal).
There are also two different approaches to \emph{specifying} transpositions: "to" and "by".
"To" transpositions can also be either \emph{parallel} or \emph{relative}.
}
\section{Types of Transposition}{
There are two different types of transposition: \strong{real} transposition and \strong{tonal} transposition.
In \emph{real} transposition, all inputs are transposed by the same \emph{specific} interval.
For example, the pitches \verb{\{C D E F G\}} could be transposed up a major second to \verb{\{C D E F# G\}}.
In \emph{tonal} transposition, inputs are transposed by \emph{generic} intervals, within a key.
For example, the sequence \verb{\{C D E F G\}}, in the key of C major, could be translated up a generic second
to \verb{\{D E F G A\}}.

To choose between real and tonal transposition, use the \code{real} argument:
\code{real = TRUE} for real transposition, \code{real = FALSE} for tonal transposition.
\subsection{Alterations}{

Tonal transposition is complicated by the presence of any alterations in the input pitches.
For instance, if we are given the pitches \verb{\{C F# G D# E\}`` in the key of C major, how should they by tonally transposed up a second, within C major? There is not one obvious, correct answer answer, which can be easily identified. The algorithm implemented by }humdrumR` is as follows:
\enumerate{
\item Alterations/accidentals in the input are identified. (In this case, F# and D#).
\item The generic pitches are transposed within the key, resulting in \verb{\{D G A E F\}}.
\item Alterations in the input are added to the output \emph{unless} the resulting pitches are interpreted as a comma
by a call to \link{tintPartion}, with a given enharmonic wrap value (the default is \code{12}).
In this example, adding the first accidental results in \verb{\{G#\}} which is not a comma.
However, the second accidental results in \verb{\{E#\}} which \emph{is} a comma away from the natural \code{{F}}.
Thus, this accidental is not added to the output, resulting in \code{{E}}, not \verb{\{E#\}}.
The resulting output is \verb{\{D G# A E F\}}.
}

The size of \code{enharmonicWrap} effectively determines how extreme accidentals are allowed.
The default value, \code{12}, assures that no output notes are enharmonically equivalent to notes in the key.
To further illustrate, here is the sequence \verb{\{C F# G D# E, B- A A- G C# D, B D- C\}} transposed
tonally within C major by all seven possible generic intervals, with \code{enharmonicWrap = 12}:
}
}

\section{Specifying Transpositions}{
There are two approaches to specifying transpositions, the \code{by} and \code{to} arguments.
The \code{by} argument must be an interval, and the input is translated by that interval.
If the \code{by} interval is specific but \code{real = FALSE}, the input is treated as a generic interval,
and tranposition takes place within the key indicated by the \code{Key} argument.

The \code{to} argument translates an input \emph{to} a desired key.
For example, if the input is in the key of E major but we want it transposed to G major, we could say \code{to = '*E:'}.
If \code{real = TRUE}, input is simply translated to the root of the \code{to} key, with all the exact same intervals.
If \code{real = FALSE}, the input is translated to the root of the new key, with its intervals changed to match the new key as well.
In either case, the result depends on what the input's key is, which is indicated by the \link[=tonalTransform]{standard} \code{Key} argument.
The \code{Key} arguments is like the "from" key.
If \code{Key = NULL}, the input key is interpreted as C major.

Consider the input notes \verb{\{D B C A# B, D C# D E D\}} in the key of the G major.
If we specify \verb{to = e:, real = TRUE}, the output will be \verb{\{B G# A F## G#, B A# B C# B\}}.
(Notice that even though the \code{to} key is minor, the output is still clearly in E major).
If we specify \verb{to = e:, real = FALSE}, the output will instead be \verb{\{B G A F# G, B A# B C B\}}.

Building off the previous example, consider how the input \emph{key} matters as well.
If we use the same input notes (\verb{\{D B C A# B, D C# D E D\}}) but the input \code{Key} is C major, then:
If we specify \verb{to = e:, real = TRUE}, the output will be \verb{\{F# D# E C## D#, F# E# F# G# F#\}}.
If we specify \verb{to = e:, real = FALSE}, the output will instead be \verb{\{F# D E C# D, F# E F# G F#\}}.

If \emph{both} \code{by} and \code{to} are specified, the \code{to} transposition is applied first, followed by the \code{by} transposition.
If \code{real = FALSE}, the \code{by} transposition happens within the \code{to} key, not the \code{Key} key.
\subsection{Relative vs Parallel}{

When transposing to, we have diferent approaches about to determining the relationship between the
"from" key (\code{Key} argument) and the "to" key (\code{to} argument).
If we think of "parallel" relationships between keys, we match the roots of the keys regardless of modes.
For instance, C major and C minor are parallel keys.
If we instead think of "relative" relationships between keys, we match the modes of the keys, not the roots.
For instance, C major and A minor are relative keys.
This is similar to the distinction between "la-based minor" solfege (relative) vs "fixed-do" solfege (parallel).

When transposing using a \code{to} argument, if \code{relative = FALSE} the input key (\code{Key} argument) is transposed to match the \emph{root}
of the \code{to} argument.
For example, if the input key is G minor and the \verb{to`` key is C major, the output is transposed to G minor. However, if }relative = TRUE\verb{the input key is transposed to match the mode of the}to\verb{key: A G minor input with a C major}to\verb{would be translated to A minor, the parallel minor of the}to\verb{key. If the}Key\verb{(from key) and}to` (to key) arguments have the same mode, the parallel and relative transpositions
are the same.
}
}

\section{Special Operators +-}{
As a note, real transposition \code{by} and interval can be achieved more concisely using the \code{+} and \code{-} operators,
as long as at least one side of the operators is an actual \code{tonalInterval} object.
\code{humdrumR} preassigns all common tonalIntervals to objects in your global environment.
Thus, you can type commands like \code{"c#" + M2} to get \code{d#}, or \code{c("C4", "E4", "C5") - m6} to get \verb{"E3" "G#3" "E4"}.
}

\seealso{
Other tonal transformations: 
\code{\link{invert}()}
}
\concept{tonal transformations}
