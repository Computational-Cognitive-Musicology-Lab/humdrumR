% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Within.R
\name{withinHumdrum}
\alias{withinHumdrum}
\alias{within}
\alias{with}
\alias{with.humdrumR}
\alias{within.humdrumR}
\alias{mutate.humdrumR}
\alias{summarise.humdrumR}
\alias{reframe.humdrumR}
\alias{ggplot.humdrumR}
\title{Working \emph{with} humdrum data fields}
\usage{
\method{with}{humdrumR}(
  data,
  ...,
  dataTypes = "D",
  recycle = "no",
  alignLeft = TRUE,
  expandPaths = FALSE,
  drop = TRUE,
  .by = NULL,
  variables = list()
)

\method{within}{humdrumR}(
  data,
  ...,
  dataTypes = "D",
  alignLeft = TRUE,
  expandPaths = FALSE,
  recycle = "pad",
  .by = NULL,
  variables = list()
)

\method{mutate}{humdrumR}(
  .data,
  ...,
  dataTypes = "D",
  recycle = "ifscalar",
  alignLeft = TRUE,
  expandPaths = FALSE,
  .by = NULL
)

\method{summarise}{humdrumR}(
  .data,
  ...,
  dataTypes = "D",
  expandPaths = FALSE,
  drop = FALSE,
  .by = NULL
)

\method{reframe}{humdrumR}(
  .data,
  ...,
  dataTypes = "D",
  alignLeft = TRUE,
  expandPaths = FALSE,
  recycle = "pad",
  .by = NULL
)

\method{ggplot}{humdrumR}(data = NULL, mapping = aes(), ..., dataTypes = "D")
}
\arguments{
\item{data}{\emph{\strong{HumdrumR data.}}

Must be a \link[=humdrumRclass]{humdrumR data object}.}

\item{...}{\emph{\strong{Any number of expressions to evaluate.}}

These expressions can reference \code{\link[=fields]{fields()}} in the data by name,
as well as variables outside the data.

If the expressions are named, the names are used to name new fields
(or column names for \code{with(..., drop = FALSE)}.}

\item{dataTypes}{\emph{\strong{Which types of humdrum records to include.}}

Defaults to \code{"D"}.

Must be a single \code{character} string. Legal values are \verb{'G', 'L', 'I', 'M', 'D', 'd'}
or any combination of these (e.g., \code{"LIM"}).
(See the \link[=humTable]{humdrum table} documentation \strong{Fields} section for explanation.)}

\item{alignLeft}{\emph{\strong{Should output that is shorter than input be aligned to the left?}}

Defaults to \code{TRUE}.

Must be a singleton \code{logical} value: an on/off switch.}

\item{expandPaths}{\emph{\strong{Should spine paths be expanded before evaluating expressions?}}

Defaults to \code{FALSE}.

Must be a singleton \code{logical} value: an on/off switch.
If \code{TRUE}, the \code{\link[=expandPaths]{expandPaths()}} function is run on the data
before evaluating the expressions.
After evaluation, the expanded locations are removed from the output.}

\item{drop}{\emph{\strong{Whether to return a simplified data structure.}}

Defaults to \code{TRUE}.

Must be a singleton \code{logical} value: an on/off switch.

This argument is conceptually similar to the \code{drop} argument in R matrices.
If \code{drop = TRUE}, the output of \code{with()}/\code{summarize()} is simplified as much as possible (trying to return
the "raw" vector, list, table, etc. within it). If \code{drop = FALSE}, the result is \emph{always}
a \link{data.table}.}

\item{.by}{\emph{\strong{Optional grouping fields; an alternative to using \link[=groupHumdrum]{group_by()}.}}

Defaults to \code{NULL}.

Must be \code{NULL}, or \code{character} strings which \link[=partialMatching]{partially match} one or more
\code{\link[=fields]{fields()}} in the \code{data}.

If not \code{NULL}, these fields are used to group the data.
If grouping fields have already been set by a call to \link[=groupHumdrum]{group_by()},
the \code{.by} argument overrides them.}

\item{variables}{\emph{\strong{A named \code{list} of values, to interpolate into your expressions.}}

Defaults to \code{list()}.

Must be a named \code{list}.
These values are interpolated into the \code{...} expression arguments wherever
a variable name matches a name from the list.}
}
\description{
These functions are the primary means of working with
humdrumR data.
They allow us to perform arbitrary (free form) manipulation of data \link[=fields]{fields}
held within a \link[=humdrumRclass]{humdrumR data object}, with convenient functionality
for ignoring null data, \link[=lag]{lagging} data, \link[=groupHumdrum]{grouping} data,
\link[=context]{windowing}, and more.
The \code{with()} and \code{within()} functions, which come from \link[=base]{base R}, are the core functions.
However, the \link{dplyr} "verbs" \code{mutate()}, \code{summarize()}, and \code{reframe()} can be used as well---they
are equivalent to using \code{with()}/\code{within()} with particular arguments.
}
\section{Overview}{


These functions are the primary means of working with
\link[=humdrumRclass]{humdrumR data}.
They all allow you to write code that accesses and manipulates the raw \code{\link[=fields]{fields()}}
in our data.
The main differences between them are what they do with the \emph{results} of your code:
\code{with()} and \code{summarize()} return results in normal, "raw" R formats, \strong{removed}
from the \link[=humdrumRclass]{humdrumR data};
In contrast, \code{within()}, \code{mutate()}, and \code{reframe()} always insert the results of your code into
new \code{\link[=fields]{fields()}} \strong{within} your humdrum data.
The other distinctions between these functions have to do with how they recycle/pad results (see below).
}

\section{Expression evaluation}{


The \code{with()}, \code{within()}, \code{mutate()}, \code{summarize()}, and \code{reframe()} methods for \link[=humdrumRclass]{humdrumR data}
all perform "\href{http://adv-r.had.co.nz/Computing-on-the-language.html}{non-standard evalation}" of
any \link[=evaluatingExpressions]{expressions} you provide them as arguments.
Basically, when you use a function like \code{with(...)} or \code{mutate(...)}, the expressions you write inside
the function call aren't \link[=evaluatingExpressions]{evaluated} right then and there---instead, R takes those expressions
into the "\link[=evaluatingExpressions]{environment}" of your \link[=humTable]{humdrum table}, where
all your fields are "visible" to the expression.
This means you can write code (expressions) that refer to your \code{\link[=fields]{fields()}}, like \code{Token} or \code{Spine}.
For example:

\if{html}{\out{<div class="sourceCode">}}\preformatted{
with(humData, 
     ifelse(Spine > 2, 
            kern(Token), 
            recip(Token)))
}\if{html}{\out{</div>}}

Since all the fields in a \link[=humTable]{humdrum table} are the same length, the expressions you write
can be, and generally should be, \link[=vectorization]{vectorized}.

By default, \code{with()}, \code{within()}, etc. don't use the whole \link[=humTable]{humdrum table},
but instead only evaluate their expressions using rows containing non-null data tokens (\code{Type == "D"}).
This means that interpretations, comments, barlines, and null data tokens are automatically ignored for you!
This feature is controlled by the \code{dataTypes} argument:
you can choose to work with the other token types by providing a \code{character} string containing combinations
of the characters \code{G} (global comments), \code{L} (local comments), \code{I} (interpretations),
\code{M} (barlines), \code{D} (non-null data), or \code{d} (null data).
For example, \code{dataTypes = 'MDd'} will evaluate your expressions on barline tokens (\code{=}), non-null data,
and null data.
See the \code{\link[=ditto]{ditto()}} manual for an example application of using \code{dataTypes = 'Dd'}.
Keep in mind that \code{humdrumR} dynamically updates what tokens are considered "null" (\code{"d"}) based on what fields
are \link[=selectedFields]{selected}.

If multiple expression arguments are provided, each expression is evaluated in order, from left to right.
Each expression can refer variables assigned in the previous expression (examples below).
\subsection{Expression pre-processing}{

These functions all do some
pre-processing of expressions arguments before evaluating them.
This pre-processing provides some convenient "\href{https://en.wikipedia.org/wiki/Syntactic_sugar}{syntactic sugar}"
for working with humdrum data.
There are currently five pre-processing steps:
\enumerate{
\item Explicit variable interpolation.
\item The \code{.} placeholder for selected fields.
\item Automatic argument insertion.
\item "Lagged"-vectors shorthand.
\item "Splatted" arguments.
}

Each of these is explained below.
\subsection{Explicit variable interpolation}{

The \code{variable} argument can be provided as an (option) \code{list} of named values.
If any of the names in the \code{variable} list appear as symbols (variable names)
in any expression argument, their value is interpolated in place of that symbol.
For example, in

\if{html}{\out{<div class="sourceCode">}}\preformatted{within(humData, kern(Token, simple = x), variable(x = TRUE))

}\if{html}{\out{</div>}}

the variable \code{x} will be changed to \code{TRUE}, resulting in:

\if{html}{\out{<div class="sourceCode">}}\preformatted{within(humData, kern(Token, simple = TRUE))

}\if{html}{\out{</div>}}

This feature is most useful for programmatic purposes, like if you'd like
to run the same expression many times but with slightly different parameters.
}

\subsection{The . placeholder}{

The \code{.} variable can be used as a special placeholder representing the data's first
\link[=selectedFields]{selected field}.
For example, in

\if{html}{\out{<div class="sourceCode">}}\preformatted{humData |>
  select(Token) |>
  with(tally(.))

}\if{html}{\out{</div>}}

will run \code{\link[=tally]{tally()}} on the \code{Token} field.

Because new fields created by \code{within()}/\code{mutate()}/\code{reframe()} become the \link[=selectedFields]{selected fields}
(details below), the \code{.} makes it easy to refer to the \emph{last} new field in pipes.
For example, in

\if{html}{\out{<div class="sourceCode">}}\preformatted{humData |>
   mutate(kern(Token, simple = TRUE)) |>
   with(tally(.))

}\if{html}{\out{</div>}}

the \code{tally()} function is run on the output of the \code{mutate(kern(Token, simpe = TRUE))} expression.
}

\subsection{Automatic argument insertion}{

Many \link{humdrumR} functions are designed to work with certain common fields in \link[=humdrumRclass]{humdrumR data}.
For example, many \link[=pitchFunctions]{pitch functions} have a \code{Key} argument which (can) take the
content of the \code{Key} which \code{\link[=readHumdrum]{readHumdrum()}} creates when there are key interpretations,
like \verb{*G:}, in the data.
When an expression argument uses one of these functions, but doesn't explicitly set the argument, humdrumR
will \emph{automatically} insert the appropriate field into the call (if the field is present).
So, for example, if you run

\if{html}{\out{<div class="sourceCode">}}\preformatted{humData |> 
   mutate(Solfa = solfa(Token))
}\if{html}{\out{</div>}}

on a data set that includes a \code{Key} field, the expression will be changed to:

\if{html}{\out{<div class="sourceCode">}}\preformatted{humData |> 
   mutate(Solfa = solfa(Token, Key = Key))
}\if{html}{\out{</div>}}

If you \emph{don't} want this to happen, you need to explicitly give a different \code{Key} argument, like:

\if{html}{\out{<div class="sourceCode">}}\preformatted{humData |> 
   mutate(Solfa = solfa(Token, Key = 'F:'))
}\if{html}{\out{</div>}}

(The \code{Key} argument can also be set to \code{NULL}).

Another common/important automatic argument insertion is for functions with a \code{groupby} argument.
These functions will automatically have appropriate grouping fields inserted into them.
For example, the \code{\link[=mint]{mint()}} (melodic intervals) command will \emph{automatically} by applied using \code{groupby}
\code{groupby = list(Piece, Spine, Path)}, which makes sure that melodic intervals are only calculated within
spine paths...not between pieces/spines/paths (which wouldn't make sense!).

All \code{humdrumR} functions which use automatic argument interpolation will mention it in their own documentation.
For example, the \link{?solfa} documentation mentions the treatment of \code{Key} in its "Key" section.
}

\subsection{Lagged vectors}{

In music analysis, we very often want to work with "\link[=lag]{lagged}" vectors of data.
For example, we want to look at the relationship between a vector and the previous values of the
same vector---e.g., the vector offset or "lagged" by one index.
The \code{\link[=lag]{lag()}} and \code{\link[=lead]{lead()}} functions are useful for this,
always keeping them the same length so vectorization is never hindered.

In expression arguments, we can use a convenient shorthand to call \code{lag()} (or \code{lead}).
In an expression, any vector can be indexed with an \code{integer} argument named \code{lag} or \code{lead} (case insensitive),
causing it to be lagged/led by that integer amount.
(A vector indexed with \code{lag = 0} returns the unchanged vector.)
For example, the following two calls are the same:

\if{html}{\out{<div class="sourceCode">}}\preformatted{humData |> with(Token[lag = 1])
humData |> with(lag(Token, 1))
}\if{html}{\out{</div>}}

This is most useful if the \code{lag}/\code{lead} index has \emph{multiple} values:
if the indexed object appears within a higher function call,
each lag is inserted as a \emph{separate} argument to that call.
Thus, \emph{these} two calls are also the same:

\if{html}{\out{<div class="sourceCode">}}\preformatted{humData |> with(tally(Token[lag = 1:2]))
humData |> with(tally(lag(Token, 1), lag(Token, 2)))
}\if{html}{\out{</div>}}

Note that the lagging will also be automatically grouped within the fields \code{list(Piece, Spine, Path)},
which is the default "melodic" structure in most data.
This assures that a vector is "lagged" from one piece to another, or from one spine to the next.
If you'd like to turn this off or change the grouping, you need to override it by adding a
\code{groupby} argument to the lagged index, like \code{Token[lag = 1, groupby = list(...)]}.

Using lagged vectors, since they are vectorized, is the fastest (computationally) and easiest way of working with n-grams.
For example, if you want to create \code{character}-string 5-grams of your data, you could call:

\if{html}{\out{<div class="sourceCode">}}\preformatted{humData |> with(paste(Token[lag = 0:5], sep = '-'))
}\if{html}{\out{</div>}}

Since the lagging is grouped by \code{list(Piece, Spine, Path)},
these are true "melodic" n-grams, only created within spine-paths within each piece.
}

\subsection{Splatted arguments}{

"Splatting" refers to feeding a function a list/vector of arguments.
Sometimes we want to divide our data into pieces (a l\'a \link[=groupHumdrum]{group_by()}), but
rather than applying the same expression to each piece, we want to feed
the separate pieces as separate arguments to the same function.
You can use some
\href{https://en.wikipedia.org/wiki/Syntactic_sugarsyntactic}{syntactic sugar}
to do just this.
We can index any field in our call with a \code{splat} argument, which must be a \code{Field \%in\% x}.
For example,

\if{html}{\out{<div class="sourceCode">}}\preformatted{humData |> with(list(Token[splat = Spine \%in\% 1:2]))
}\if{html}{\out{</div>}}

In this call, the \code{Token} field will be divided into two groups, one where \code{Spine == 1} and the other where
\code{Spine == 2}; the first group (\code{Spine == 1}) will be used as the first argument to \code{list}, and the second group
(\code{Spine == 2}) as the second argument.
Thus, \code{within} translates the previous expression to this:

\if{html}{\out{<div class="sourceCode">}}\preformatted{humData |> within(list(Token[Spine == 1], Token[Spine == 2]))
}\if{html}{\out{</div>}}

Splatting can be little weird, because there is nothing to assure that the splatted arguments
are all the same length, which we usually want (\link{vectorization}).
For example, in the previous example, there is no guarantee that \code{Token[Spine == 1]} and \code{Token[Spine == 2]} are the same length.
This just means we should only use splatting if we really understand the groups we are splatting.
For example, \emph{if} there are \link[=anyPaths]{no spine paths or stops in our data}, \emph{then} we can know that all spines
have the same number of data records, but only including \strong{all} data records (null \emph{and} non-null).
So, if I know there are no stops/paths in our data, we can run something like this:

\if{html}{\out{<div class="sourceCode">}}\preformatted{humData |> within(dataTypes = 'Dd', 
                  tally(Token[splat = Spine \%in\% 1:2]))
}\if{html}{\out{</div>}}
}

}

\subsection{Saving expressions for later}{

In some cases you may find that there are certain arguments expressions that you use repeatedly.
You can store expressions as variables by "quoting" them: the most common way to
quote an expression in R is using the \link[base:tilde]{~}, which creates what is called a
"formula"---essentially a quoted expression.
You can also quote expressions, using \code{\link[=quote]{quote()}}.
Once you've quoted an expression you can pass it to
\code{with()}, \code{within()}, \code{mutate()}, \code{summarize()}, and \code{reframe()}.

Image that you have three different datasets (\code{humData1}, \code{humData2}, and \code{humData3}),
and you'd like to evaluate the expression \code{tally(kern(Token, simple = TRUE))} in all three.
Use the \code{~} operator to quote and save that expression to variable, then use it with \code{with()}:

\if{html}{\out{<div class="sourceCode">}}\preformatted{tallyKern <- ~tally(kern(Token, simple = TRUE))

humData1 |> with(tallyKern)
humData2 |> with(tallyKern)
humData3 |> with(tallyKern)

}\if{html}{\out{</div>}}
}

\subsection{Expanding paths}{

For data that includes spine paths (which you can check with \code{\link[=anyPaths]{anyPaths()}}),
some analyses may require that spine paths are treated as contiguous "melodies."
The \code{\link[=expandPaths]{expandPaths()}} function can be used to "expand" spine paths into new spines.
The \code{expandPaths} \emph{argument} to \code{with()}/\code{within()} will cause \code{\link[=expandPaths]{expandPaths()}}
to be run on your data before evaluating your argument expressions.
After evaluation, the expanded parts of the data are then removed from the output.
}
}

\section{Parsing expression results}{


The only differences between the \code{with()}, \code{within()}, \code{mutate()}, \code{summarize()}, and \code{reframe()} humdrumR methods
are what they do with the \emph{results} of expressions passed to them.
The major difference is that \code{within()}, \code{mutate()}, and \code{reframe()} put results into new \link{fields}
in a \link[=humdrumRclass]{humdrumR data}, while \code{with()} and \code{summarize()} just return their results in "normal" R.
The other differences between the functions simply relate to how the \code{recycle} and \code{drop} arguments are used (details below).

The \code{recycle} argument controls how the results of your code are, or aren't, \link[=recycling]{recycled (or padded)}.
When you write code using your \link[=humdrumRclass]{humdrumR data}'s \code{\link[=fields]{fields()}}
as input, your results are inspected to see how long they are compared to the length of the input field(s).
If any of your results are \emph{longer} than the input, you'll get an error message---\code{humdrumR} can't (yet) handle that case.
If any of your results are \emph{shorter} than the input, the \code{recycle} argument controls what happens to that result.
There are seven options:
\itemize{
\item \code{"no"}: The result is not recycled or padded. For calls to \code{within()}, \code{mutate}, or \code{reframe()}, this option is not allowed.
\item \code{"yes"}: the result is recycled, no matter how long it is.
\item \code{"pad"}: the result is padded with \code{NA} values.
\item \code{"ifscalar"}: if the result is scalar (length 1), it is recycled; otherwise you see an error.
\item \code{"ifeven"}: if the result length evenly divides the input length, it is recycled; otherwise you see an error.
\item \code{"never"}: The result is not recycled. If the result does not match the input length, you see an error.
\item \code{"summarize"}: if the result is not scalar, \emph{even if it matches the input length}, you see an error. The result is not recycled.
}

The result of padding/recycling also depends on the \code{alignLeft} argument:
If \code{alignLeft = TRUE}, results are padded to the right: like \code{c(result, NA, NA, ...)};
If \code{alignLeft = FALSE}, results are padded on the left: like \code{c(..., NA, NA, results)}.
Recycling is also affected if the result's length does not evenly divide the input length.
For example, consider a result \code{c(1, 2, 3)} which needs to be recycled to length \code{10}:
If \code{alignLeft = TRUE}, the result is recycled \code{c(1, 2, 3, 1, 2, 3, 1, 2, 3, 1)};
If \code{alignLeft = FALSE}, the result is recycled \code{c(3, 1, 2, 3, 1, 2, 3, 1, 2, 3)}.
\subsection{with() and summarize()}{

The humdrumR \code{with()} and \code{summarize()} methods return "normal" R data objects.
The only difference between the \code{with()} and \code{summarize()} methods is their default  \code{drop} and \code{recycle} arguments:
\itemize{
\item \code{with(..., drop = TRUE, recycle = 'no')}
\item \code{summarize(..., drop = FALSE, recycle = 'summarize')}
}

If \code{drop = TRUE}, these methods return whatever your code's result is, with no parsing.
This can be \emph{any} kind of R data,
including \link[=vector]{vectors} or objects like \link[=lm]{lm fits}
or \link[base:table]{tables}.
If \code{drop = FALSE}, the results will instead be returned in a \code{\link[=data.table]{data.table()}}.

If you are working with \link[=groupHumdrum]{grouped data},
the \code{drop = FALSE} output (\code{data.table}) will include all grouping columns as well
as the results of your expressions.
If \code{drop = TRUE} \emph{and} there is only one result per group, the grouping fields will be
used to generate names for the output vector.
}

\subsection{within(), mutate(), and reframe().}{

The humdrumR \code{within()}, \code{mutate()}, and \code{reframe()} methods always return a new \link[=humdrumRclass]{humdrumR data object},
with new \link{fields} created from your code results.
The only differences between these methods is their default \code{recycle} argument and the types of \code{recycle} argument they allow:
\itemize{
\item \code{within(..., recycle = 'pad')}
\itemize{
\item Can accept any \code{recycle} option except \code{"no"}.
}
\item \code{mutate(..., recycle = 'ifscalar')}
\itemize{
\item Can only accept \code{"ifscalar"} or \code{"never"}.
}
\item \code{reframe(..., recycle = 'pad')}
\itemize{
\item Can only accept \code{"pad"} or \code{"yes"}.
}
}
}

\subsection{Creating new humdrumR fields}{

When running \code{within()}, \code{mutate()}, or \code{reframe()}, new \code{\link[=fields]{fields()}} are
added to the output \link[=humdrumRclass]{humdrumR data}.
These new fields become the \link[=selectedFields]{selected fields} in the output.
You can explicitly name newly created fields (recommended), or allow \code{humdrumR} to automatically name them (details below).
When using \code{with(..., drop = FALSE)} or \code{summarize(..., drop = FALSE)}, the column names of the output \link{data.table}
are determined in the same way.

Note that \code{within()}, \code{mutate()}, and \code{reframe()} will (attempt to) put \emph{any} result back into your
\link[=humdrumRclass]{humdrumR data}...even if it doesn't make much sense.
Things will work well with \link[base:vector]{vectors}.
Atomic vectors are usually the best to work with (i.e., numbers, \code{character} strings, or \code{logical} values),
but \code{list}s will work well too---just remember that you'll need to treat those fields as lists
(e.g., you might need to use \code{\link[=lapply]{lapply()}} or \code{\link[=Map]{Map()}} to work with \code{list} fields.)
Any \emph{non-vector} result will be put into a list as well, padded as needed.
For example, if you use \code{\link[=lm]{lm()}} to compute a linear-regression in a call to \code{within()}
the result will be a new field containing a \code{list}, with first element in the
list being a single \code{lm} fit object, and the rest of the list empty (padded to the length of the field).
\subsection{Naming new fields}{

If you don't explicitly name the code expressions you provide, the new fields are named
by capturing the expression code itself as a \code{character} string.
However, it is generally a better idea to explicitly name your new fields.
This can be done in two ways:
\itemize{
\item Base-R \link[base:with]{within()} style: Use the \verb{<-} assignment operator inside your expression.
\itemize{
\item Example: \code{within(humData, Kern <- kern(Token))}.
}
\item Tidyverse \link[dplyr:mutate]{mutate()} style: provide the expression as a named argument with \code{=}.
\itemize{
\item Example: \code{mutate(humData, Kern = kern(Token))}.
}
}

Either style can be used with any of the \code{humdrumR} methods.
When using \verb{<-}, only top-level assignment will create a new field, which means only one field can be assigned per expression.
For example,

\if{html}{\out{<div class="sourceCode">}}\preformatted{within(humData, 
       Semits <- semits(Token),
       Recip <- recip(Token))
}\if{html}{\out{</div>}}

will create two fields (\code{Semits} and \code{Recip}).
However,

\if{html}{\out{<div class="sourceCode">}}\preformatted{within(humData,
       \{ 
         Semits <- semits(Token)
         Recip <- recip(Token)
        \})
}\if{html}{\out{</div>}}

will not.
The \link[=evaluatingExpressions]{result of expressions} grouped by \code{{}} is always the \emph{last} expression in the brackets.
Thus, the last example above will only create one new field, corresponding to the result of \code{recip(Token)}.
However, the resulting field won't be called \code{Recip}!
This is because only \emph{top-level} assignments are used to name an expression:
To name a multi-expression expression (using \code{{}}), you could do something like this:

\if{html}{\out{<div class="sourceCode">}}\preformatted{within(humData,
       Recip <- \{ 
         Semits <- semits(Token)
         recip(Token)
        \})

}\if{html}{\out{</div>}}

Of course, only the result of \code{recip(Token)} would be saved to \code{Recip},
so the \code{Semits <- semits(Token)} expression is doing nothing useful here.
}

}

\subsection{Piped references}{

All argument expressions passed to the \code{with()}/\code{within()} methods are evaluated in order, from left to right,
so any assignments in a previous expression will be visible to the next expression.
This means we can, for example, do this:

\if{html}{\out{<div class="sourceCode">}}\preformatted{within(humData, 
       Kern <- kern(Token),
       Kern2 <- paste0(Kern, nchar(Kern)))

}\if{html}{\out{</div>}}

the use of \code{Kern} in the second expression will refer to the \code{Kern} assigned in the previous expression.
}
}

\section{Evaluating expressions in groups or windows}{


The \code{with()}, \code{within()}, \code{mutate()}, \code{summarize()}, and \code{reframe()} functions all
work with \link[=groupHumdrum]{grouped} data, or data with \link[=context]{contextual windows} defined.
When groups or windows are defined, all argument expressions are evaluated independtly
within each and every group/window.
Results are then processed (including recycling/padding) within each group/window.
Finally, the results are then pieced back together in locations corresponding to the
original data locations.
Since \link[=groupHumdrum]{groups} are necessarily exhaustive and non-overlapping, the results
location are easy to understand.
On the other hand \link[=context]{contextual windows} may overlap, which means and non-scalar results
could potentially overlap as well;
in these cases, which result data lands where may be hard to predict.
}

\examples{


# with/within style:

humData <- readHumdrum(humdrumRroot, "HumdrumData/BachChorales/chor00[1-4].krn")

humData |> with(tally(kern(Token, simple = TRUE), Spine))

humData |> within(Kern <- kern(Token), 
                  Recip <- recip(Token),
                  Semits <- semits(Token)) -> humData
                  
humData |> 
    group_by(Spine) |>
    with(mean(Semits))
    
humData |> 
    group_by(Piece, Spine) |>
    with(mean(Semits), drop = FALSE)
    
# tidyverse (dplyr) style:

humData <- readHumdrum(humdrumRroot, "HumdrumData/BachChorales/chor00[1-4].krn")

humData |> mutate(Kern = kern(Token), 
                  Recip = recip(Token),
                  Semits = semits(Token)) -> humData
                  
humData |> 
    group_by(Spine, Bar) |>
    summarize(mean(Semits))
      
# dataTypes argument

humData |>
   group_by(Piece, Spine) |>
   within(paste(Token, seq_along(Token)))
   
humData |>
   group_by(Piece, Spine) |>
   mutate(Enumerated = paste(Token, seq_along(Token)),
          dataTypes = 'Dd')
          
# recycle argument

humData |>
   group_by(Piece, Bar, Spine) |>
   mutate(BarMean = mean(Semits), recycle = 'ifscalar')
   
humData |>
   group_by(Piece, Bar, Spine) |>
   within(BarMean = mean(Semits), recycle = 'pad')  




}
\seealso{
{These functions are most useful in combination with the
\link[=subset.humdrumR]{subset()}, \link[=groupHumdrum]{group_by()}, and \code{\link[=context]{context()}} commands.}
}
