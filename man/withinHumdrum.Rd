% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Within.R
\name{withinHumdrum}
\alias{withinHumdrum}
\alias{with.humdrumR}
\alias{within.humdrumR}
\title{with(in)Humdrum}
\usage{
\method{with}{humdrumR}(data, ..., dataTypes = "D", drop = TRUE, variables = list())

\method{within}{humdrumR}(data, ..., dataTypes = "D", variables = list())
}
\arguments{
\item{...}{Any number of do expressions or evaluation modifying expressions.}

\item{dataTypes}{A string or vector of characters drawn from \code{c("D", "d", "I", "L", "M","G")}.
These characters  correspond to types of humdrum records: \strong{D}ata, null \strong{d}ata, \strong{I}nterpretations,
\strong{M}easures, \strong{L}ocal comments, and \strong{G}lobal comments respectively. The expression
is only evaluated on data drawn from the specified record types (defaults to \code{"D"}).}

\item{drop}{This argument is conceptually similar to the \code{drop} argument in R matrices.
If \code{drop = TRUE}, the output of \code{with.humdrumR} is simplified as much as possible (trying to return
the "raw" vector, list, table, etc. within it). If \code{drop = FALSE}, the result is \emph{always}
a \code{data.table}. The default value (\code{drop = TRUE}) is usually what we want because it is more
intuitive, but in more complex code, it can be helpful to set \code{drop = FALSE} so that
the output is consistent.}

\item{humdrumR}{A \verb{[humdrumR][humdrumRclass]} data object.}
}
\value{
From \code{within.humdrumR}  a new humdrumR data object.
From \code{with.humdrumR}, whatever value is returned by the expression or, if \code{drop = TRUE},
a \code{data.table}.
}
\description{
Apply arbitrary expressions to fields within \link[=humdrumRclass]{humdrumR} data.
}
\section{Overview}{


These functions are the primary means of working with
humdrumR data. They are analogous to the base functions
\link[base:with]{with and within}
methods for \link[base:data.frame]{data.frames}.
Specifically they allow you to evaluate arbitrary
expressions involving fields in a \link[=humdrumRclass]{humdrumR data object}.
They also includes a number of special evaluation options:
\itemize{
\item Evaluate an expression in a subset of the data.
\item Evaluate the same expression separately in different subsets of the data.
\item Evaluate an expression across windows in the data (e.g., ngrams, rolling windows).
\item Evaluate an expression which produces a plot, with particular plotting parameters set using \code{\link[graphics:par]{graphics::par()}}.
}

The difference between \code{with.humdrumR} and \code{within.humdrumR} is
analogous to the difference between \code{\link[base:with]{base::with()}} and \code{\link[base:with]{base::within()}}.
\code{with.humdrumR} evaluates your expression(s) and then simply returns the result of
the evaluation. \code{within.humdrumR} evaluates your expression(s) and then
inserts the results back into the humdrumR object (if possible), generating new
fields called \code{ResultX} (see details).
}

\section{Expression evaluation}{


An "expression" is a legal bit of R code, like \code{2 + 2} or \code{x - mean(x)}.
Each call to \code{with}/\code{within.humdrumR} must have at least one expression to evaluate,
or "\emph{do}"  which we call "do" expressions.
These expressions are evaluated (executed) within the \code{humdrumR} object's humdrum table.
which means the expression can, refer to any field in the humdrumR object (\code{Record}, \code{Token}, \code{File}, etc.).
Since all the fields in a data.table are all vectors of the same length, expressions should usually be
vectorized.

A number of special \href{https://en.wikipedia.org/wiki/Syntactic_sugarsyntactic}{syntactic sugars}
can be used in the "do" expressions.
The most basic, is that a \code{.} anywhere in the expression, will be
interpreted as the humdrumR object's current \link[=humActive]{active expression}.
More syntactic sugars are described below.

If multiple do expressions are provided, each expression is evaluated in order, and
can refer to results of the previous do expression as \code{.} (variables assigned in previous expressions
can also be used.)
Other syntactic sugars are described in sections below.\preformatted{humdata <- readHumdrum(humdrumRroot, 'HumdrumData/BachChorales/.*krn') # read some data

within(humdata, pitch(Token))
within(humdata, pitch(.)) # Same as previous (unless `Active` field has been changed))

with(humdata, table(solfa(Token, Key = Key)))
# Assumes that the Key field was parsed during the call to `[readHumdrum][readHumdrum]`

within(humdata, semits(Token) - mean(semits(Token))) 

}

Unnamed arguments (or formulae without a left-hand side) are interpreted as \code{do} expressions.
Do expressions can also be explicitly labeled by naming an argument "do" or with \code{do} on the left side
of a formula:\preformatted{with(chorales, table(Token))
with(chorales, do = table(Token))
with(chorales, do ~ table(Token))
# These all return the same result

}
\subsection{Special Do}{

A few special versions of the \code{do} expression can be used.
\itemize{
\item \code{doplot}:
\itemize{
\item The expression is evaluated, but the original \code{humdrumR} input
if returned unchanged. This can be used for achieving a side effect (like making a plot)
without saving the result.
}
\item \code{dofill}:
\itemize{
\item The result is evaluated, and the result is recycled to the length of the input, making
sure the result is the same length as the input.
Basically, do fill is the equivalent of \code{rep(do ~ f(x), length.out = length(x))}.
}
}
}
}

\section{Special Evaluation Keywords}{


\code{with.humdrumR} and \code{within.humdrumR} can be provided with
additional keyword expressions which modify how the main "do" expressions are evaluated.
The complete list of options are:
\itemize{
\item \code{by} (group by)
\item \code{where} (apply to subset)
\item \code{windows}
\item \code{ngrams}
\item \code{pre} and \code{post}
}

These special expressions can be specified either as named arguments
(\code{with(data, do(x), by = group)}) or as formula, with the keyword on the left side
(\verb{with(data, do(x), by ~ group}).
Any unnamed argument (or formula without a left-side) is interpreted as a \code{do} expression,
not a special expression.
\itemize{
\item A \code{by} expression is used to break the data into groups, with the \code{do} expression(s) evaluated
separately in each group (see "Group by", below).
\item A \code{where} expression indicates a subset of the data
in which to evaluate the \code{do} expression (see "Partitioning", below).
\item \code{ngrams} A positive number \emph{n}. The expression is evaluated across overlapping length-\emph{n} windows.
+. \code{pre} An expression to evaluate once before evaluating the do expression(s). Useful, for instance, for taking logs
or opening a graphing window. The \code{pre} expression is evaluated in the global environment.
+. \code{post} An expression evaluate once after evaluating the do expression(s). Always evaluated in the global environment.
}
}

\section{Group by}{


A \code{by} expression is used to break the data into subsets, with the \code{do} expression(s) evaluated
separately within each subset. This works the similarly to the \code{by} argument in
\verb{[data.table][data.table]}s, the \code{INDEX}
argument of \verb{[base][tapply]}, or the \code{INDICES} argument of \verb{[base][by]}.
Each \code{by} expression must evaluate, within the \code{humdrumR} data object, to a vector (or a list of vectors
of equal length) of categories to group the data by.

Most commonly, the \code{by} expression(s) are simply field(s) in the data:
for instance,\preformatted{with(humdata,
     do = table(Token),
     by = File)
}

will apply the function \verb{[base][table]} to the \code{Token} field
\emph{separately} for each file in the \code{humdrumR} data.
However, we can also use more complex expressions like\preformatted{with(humdata,
     do = table(Token), 
     by = Spine > 3 | Record \\\%\\\% 2 == 0)
}

which will evaluate the do expression in two groups, one where either the spine number is
three or less \emph{or} the record number is even, and another group where the opposite is true.

If the \code{by} expression evaluates to a list of grouping vectors,
the \code{do} expressions are evaluated across every combination of categories in all the vectors.
Thus,\preformatted{with(humdata, 
     do = table(Token),
     by = list(File, Spine))
}

will apply \code{table} to \code{Token} across each spine \emph{in} each file.

As some \href{https://en.wikipedia.org/wiki/Syntactic_sugarsyntactic}{syntactic sugar}, if the
\code{by} expression is input as a formulae, lists of grouping expressions
can be created by separating each expression by a \code{~}.
Thus, \code{by = list(File ~ Spine)} can be written
\code{by = File ~ Spine} or \code{by ~ File ~ Spine}.
}

\section{Apply where TRUE}{


A \code{where} expression is used to identify a subset of the data and evaluate
the \code{do} expression(s) \emph{only} in that subset.
\code{where} expressions must evaluate, within the \code{humdrumR} data object, to
a single logical vector. The \code{do} expression(s) are only evaluated where this logical
vector is \code{TRUE}.
kept unchanged.
}

\section{Advanced partitioning}{


If multiple \code{by} or \code{where} expressions, or combinations of the two, are specified,
each is evaluated recursively, in order from left to right.
If \code{where} is specified after \code{by}, the \code{where} expression is evaluated within each \code{by} group
If \code{by} is specified after \code{where}, the grouping \code{by} expression is evaluated only where \code{where == TRUE}.
Thus, if you specify\preformatted{within(humdata,
         do = sd(Semits),
         by = File, 
         where = Semits > mean(Semits))
```

the standard deviation of the `semits` field will be calculated in each file,
but only where the `semits` field is greater than the mean `semits` value
*within that file*. Contrast this with this call:

```
within(humdata,
         do = sd(Semits)
         where = Semits > mean(Semits), 
         by = File) 
```

wherein the standard deviation of `semits` is, again, calculated for each file,
but this time wherever the `semits` field is greater than the mean value *across all the data*.
}
}

\section{Plotting}{


The \code{doplot} keyword behaves exactly like the \code{do} keyword, except that the result of the
evaluation is ignored. This is useful for plotting as well as \emph{other} side-effects (like writing to a file).
If \code{doplot} is used with \code{with.humdrumR}, the function simply returns \code{NULL} (after executing the \code{doplot}
expression.
If \code{doplot} is used with \code{within.humdrumR}, the function simply returns the unaltered
\code{humdrumR} argument.

\code{within.humdrumR} also allows you to specify plotting options inline, without having to make a separate call
to \code{\link[=par]{par()}}. Any \code{\link[=par]{par()}} argument can be specified by providing a named list to the \code{graphics} keyword.
For example, we can set the plot margins with the \code{mar} argument:\preformatted{within(data, 
       doplot = plot(sort(table(Token))), 
       graphics = list(mar = c(4, 4, 4, 4)))

}

The best part is \code{within.humdrumR} will reset \code{par} to it's previous state after its done.

You can also use the syntactic sugar, \code{graphics(parargs = ...)}:\preformatted{within(data,
       doplot = plot(sort(nchar(Token))),
       graphics(mar = c(4, 4, 4, 4)))
}
}

\section{Tandem interpretations}{


The function \verb{[readHumdrum][readHumdrum]} automatically parses
tandem interpretations (that it recognizes) into
their own fields in the resulting \verb{[humdrumR][humdrumRclass]} data.
For instance, data with a \code{'*clefF4'} will show
up as a \code{Clef} field. However, users might read humdrum data with their
own custom tandem interpretations that are not built into \code{humdrumR}.
\code{humdrumR} includes the function \verb{[getTandem][getTandem]} to help us
extract arbitrary tandem intrpretation data.
Luckily, \code{within.humdrumR} knows some
\href{https://en.wikipedia.org/wiki/Syntactic_sugarsyntactic}{syntactic sugar}
which makes it easy to do this anywhere in our expressions, simply by putting a
named object beginning with the symbol \code{*}. Of course, R doesn't normally
allow names to begin with symbols like \code{*}, but you can force it by
placing grave symbols around the name \verb{*name}. If you do this in a \code{within.humdrumR}
expression, \code{within.humdrumR} will treat this name as a
regular expression and substitute a call \code{getTandem(Tandem, 'regular expression')} in the expression.
This means you can could do something like
within(humdata,
do ~ myFunction(Token, \verb{*mytandempattern}))
and \code{myFunction} will be called with the first argument being the
\code{Token} field, and the second argument being tandem interpretations
which match \code{'mytandempattern'} (extracted from the \code{Tandem} field).
}

\section{Splatting}{


("Splatting" refers to feeding a function a list/vector of arguments.)
Sometimes we want to divide our data into pieces (a l\'a \code{partition} option), but
rather than applying the same expression to each piece, we want to feed
the separate pieces as separate arguments to the same function.
In \verb{with(in).humdrumR} you can use some
\href{https://en.wikipedia.org/wiki/Syntactic_sugarsyntactic}{syntactic sugar}
to do just this.
We can index any field in our call with a \code{splat} argument, which must be a \code{Field \%in\% x}.
For example,\preformatted{within(humdata, list(Token[splat = Spine \%in\% 1:2])) 
}

In this call, the \code{Token} field will be divided into two groups, one where \code{Spine == 1} and the other where
\code{Spine == 2}; the first group (\code{Spine == 1}) will be used as the first argument to \code{list}, and the second group
(\code{Spine == 2}) as the second argument.
Thus, \code{wihtin.humdrumR} translates the previous expression to this:\preformatted{within(humdata,
       list(Token[Spine == 1], Token[Spine == 2]))
}
}

\section{Argument interpolation}{


The \code{variables} argument is a list of named arguments which are \verb{[humdrumR:interpolateArguments][interpolated]} into the
\code{do} expressions. This is useful if you've already created a list of formulas that you like, but would like
to make small changes to a function call within the \code{do} expressions, without starting from scratch.
Examples:\preformatted{mycommand <- c(do ~ mean(., na.rm = x), by ~ Spine ~ File)
within(humdata,
              mycommand,
              variables(x = TRUE))
}
}

\section{N grams}{

}

\section{Results}{


The difference between \code{with.humdrumR} and \code{within.humdrumR} is in what they do with the results
of the evaluated do expression(s).
\subsection{With}{

For calls to \code{with.humdrumR}, the result is simply returned as is.
This is what you want when you want to get out of thue humdrumR object and drop back into "normal" R,
often in the last stages of an analysis.
However, you may optionally specify \code{drop = FALSE}, in which case the result is returned
in a \code{\link[=data.table]{data.table()}}.
}

\subsection{Within}{

For calls to \code{within.humdrumR}, the result of each \code{do} expression
is inserted back into the \verb{[humtable][humdrum table]}.
Usually, \code{do} expressions should evaluate to atomic output which is the same length as the input:
in other words, every data point in the input field(s) correspond to a single data point in the new field.
However, if the results are shorter than input fields \link[=humdrum table]{humtable},
they are padded with null tokens to match the full (original) length.
\subsection{Naming results}{

If you don't explicitely name the results, they are put into new field(s) labeled
\code{Result1}, \code{ResultX}, \code{...}, \code{ResultN}.
You can name the new fields in one of two ways:
\itemize{
\item normal R assignment, using \verb{<-} or \verb{->} anywhere in a do expression.
\itemize{
\item For example, \code{within(data, Semits <- semits(Token))}.
}
\item end the expression with a named list.
\itemize{
\item For example, \code{within(data, list(Semits = semits(Token)))}
}
}
}

}
}

\examples{
humdata <- readHumdrum('directorywithdata/*.krn')

within(humdata, nchar(.)) # counts characters in each data token.
within(humdata, table(.), by ~ Spine) # Tabulates data tokens in each Spine.

}
