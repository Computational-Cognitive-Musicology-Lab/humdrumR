% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/humClass.R
\docType{class}
\name{humdrumR-class}
\alias{humdrumR-class}
\alias{makeHumdrumR}
\alias{humdrumRS4}
\alias{is.humdrumR}
\alias{fields}
\title{HumdrumR class}
\usage{
is.humdrumR(x)

humdata$Field

fields(humdrumR, fieldTypes = c("Data", "Structure", "Interpretation",
  "Formal", "Reference"))

humdata[] # returns unchanged

humdata[x:y]

humdata['regex']

humdata[~expression]

humdata[[x:y]]

humdata[[ , x:y]]

humdata[[x:y, l:m]]

humdata[['regex']]

humdata[[ , 'regex']]

humdata[['regex1', 'regex2']]

humdata[[] , , ~expression]] or humdata [[ , , 'regex']] or humdata[z = ~expression] or humdata[[z = 'regex']]

humdata[[~expression]]

humdata[[ , ~expression]]

hudmata[[~expression1, ~expression2]]

humdata$name <- vector

humdata$name <- humdata2

humdata['character'] <- vector

humdata['character'] <- humdata2
}
\description{
This \code{S4} class is the basic unit of the 
\code{\link[humdrum:humdrumR]{humdrumR}} package.
Each \code{humdrumR} object represents data \code{\link[humdrumR:readHumdrum]{read}} from one or 
more humdrum files.
In the documentation we refer to the collection of files within a \code{\linkS4class{humdrumR}} object
as a "\strong{corpus}," and each file as a "\strong{piece}."
However, though humdrum data is \emph{usually} encoded as one "piece" per file, this is not necessarily the case:
files might represent movements within a piece, or even just a part of a score. Still, we tend to refer
to them as "pieces."
In coding examples, we name \code{humdrumR} objects \code{\strong{humdata}}.
}
\details{
The most imporant part of a \code{humdrumR} object is the 
\code{\link[humdrumR:humTable]{humdrum table(s)}} it holds within it.
In essence, an \code{humdrumR} object is simply a wrapper around the 
\code{\link[humdrumR:humTable]{humdrum table}} which helps users to
to visualize, index, \code{\link[humdrumR:humSummary]{summarize}}, and manipulate
the table in a variety of ways.

Basic information about the size and shape of \code{humdrumR} data can be
obtained with calls to \code{\link[humdrumR:humSize]{nrecords, npieces, length, ncol, etc.}}
More detailed summary information can be obtained with the humdrumR \code{\link[humSummary]{corpus summary functions}}.
\code{humdrumR} data can also be coerced to more basic \code{R} data types using \code{\link[humdrumR:humCoersion]{as.matrix, as.data.frame, etc.}}

A number of helpful functions are also defined to \code{\link[humdrumR:humShape]{reshape}} humdrumR data.
}
\section{Slots}{

\describe{
\item{\code{Humtable}}{A list of \code{\link[humTable]{humdrum tables}}, each having the same fields
but containing data from different types of records (e.g., interpretations, data, barlines, comments).}

\item{\code{Files}}{A list of two elements. The first, "Search", contains a single character representing
the \code{pattern} used in the call to \code{\link{readHumdrum}} which created this \code{humdrumR} object.
The second, "Names", is a vector of strings representing all the files which matched the \code{pattern}
and were read into the \code{humdrumR} object.}

\item{\code{Fields}}{A list containing strings corresponding to the existing fields in the \code{humdrumR} object.
The fields are divided into five categories: "Data", "Structure", "Interpretation", "Formal", and "Reference"---see (\code{\link{fields}}).}

\item{\code{Active}}{A quosure expression which 
extracts data from field(s) in the \code{\link[humdrum:humTable]{humdrum table}}: the "active expression."}

\item{\code{LoadTime}}{A \code{\link[base:DataTimeClasses]{POSIXct}} value, indicating the time at which \code{\link{readHumdrum}} was
called to create this \code{humdrumR} object.}
}}

\section{Indexing}{

In \code{R}, the basic \code{\link[base:Extract]{indexing operators}}
are \code{[]} and \code{[[]]}.

These are used to filter out subsets of data.
In many \code{R} data types (for instance, base \code{R}'s \code{\link[base:list]{list}}),
the \code{[}single brackets\code{]}
are used for "shallower" extraction while the \code{[[}double brackets\code{]]}
are used for "deeper" extraction.
\code{humdrumR} object indexing follows this same basic pattern:
\code{[}single brackets\code{]} are used to index \code{humdrumR} objects
\emph{by piece} while \code{[[}double brackets\code{]]} are used to index
\emph{within pieces}. (Accidentally writing \code{[]} when you need
\code{[[]]} is a very common error, so watch out!)

Whether, indexing by piece or within, \code{humdrumR} objects can use
three types of indexing arguments:
\itemize{
\item By \code{numeric} (ordinal integers)
\item By \code{character} string (regular expressions)
\item By \code{formula} (arbitrary expressions)
}
The last option (by \code{formula}) is the most powerful option,
and indeed, the first two options (\code{numeric} or \code{character} indexing)
are just convenient shorthands for indexing that can be accomplished using 
the \code{formula} method.


\strong{Numeric indexing:} Indexing \code{humdrumR} objects with
 \strong{\code{[}single brackets\code{]}} will accept
one numeric argument. (Non-integer arguments will be converted to integers.)
This argument will be used to pick pieces within the \code{humdrumR} object ordinally.
Thus, \code{humdata[1:10]} will select the first ten pieces in the data while \code{humdata[42]}
will select only the 42nd piece. 


Indexing \code{humdrumR} objects with
 \strong{\code{[[}double brackets\code{]]}} will accept 
one or two numeric arguments, \code{i} and \code{j}, either of which can 
be used in isolation or in combination.
If \code{j} is used in isolation, it must be placed after a comma, as in \code{humdata[[ , j ]]}.
(Non-integer arguments will be converted to integers.)
\code{i} is used to index data records (i.e., based on the \code{NData} field) ordinally.
Thus, \code{humdata[[1:20]]} indexes the first twenty data records \emph{from each file}
in the corpus, and \code{humdata[[42]]} extracts the 42nd data record \emph{from each file}.
\code{j} is used to index spines  (i.e., based on the \code{Spine} field) ordinally.
Thus, \code{humdata[[ , 3:4]]} returns the third and fourth spines \emph{from each}
file in the corpus.

Note that numeric \code{humdrumR} indexing is entirely \strong{ordinal}, meaning 
that pieces/data records/spines are not matched based on their value in their
respective fields, but rather on their order among all existing values.
Thus, for \code{[}single-bracket\code{]} indexing the \eqn{ith} piece in the
corpus is taken, regardless of that \code{FileN} field associated
with that piece:

\preformatted{
humsubset <- humdata[11:20]
humsubset[2]
}

will return the 12th piece from the original \code{humdata} object, not the second piece.
Similarly,
\preformatted{
humsubset2 <- humdata[[ , 2:4]]
humsubset2[[ , 2]]
}
will return the third spine from the original data.

As in traditional \code{R} indexing, negative numbers are allowed as well, causing corresponding elements to be
removed instead of retained. Thus, \code{humdata[-3:-5]} will remove the third, fourth, and fifth pieces from the data
while \code{humdata[[ , -3:-5]]} will remove the third, fourth, and fifth spines from each piece.
Positive and negative indices cannot be mixed in a single argument.

In all cases, indices outside of range (or of value \code{0)} are ignored.
If all indices are \code{0} or outside of range then 
an empty \code{humdrumR} object is returned.
For instance, \code{humdata[[401:500, ]]} will return an empty
\code{humdrumR} object if there are no pieces with more than 400
data records.


\strong{Character indexing:} Indexing \code{humdrumR} objects with 
\code{[}single brackets\code{]} will accept one 
vector of \code{character} strings. These strings are 
treated as 
\href{https://en.wikipedia.org/wiki/Regular_expression}{regular expressions} (regexes).
The tokens from the \code{humdrumR} object's \code{Active} fields are searched
for matches to all the regular expressions you input. Any piece that contains
\emph{\strong{any}} match to \emph{\strong{any}} of the regular expressions is retained---all other pieces
are dropped. Note that (because this is \code{[}single-bracket\code{]} indexing) the entire piece is retained, even if there is only one match.
If no matches occur in any pieces, an empty \code{humdrumR} object is returned.

Indexing \code{humdrumR} objects with \code{[[}double brackets\code{]]} will 
accept one or two vectors of \code{character} strings, \code{i} and \code{j}, 
either of which can 
be used in isolation or in combination. 
If \code{j} is used in isolation, it must be placed after a comma, 
as in \code{humdata[[ , j]]}.
These strings are 
treated as \href{https://en.wikipedia.org/wiki/Regular_expression}{regular expressions} (regexes).
The tokens from the \code{humdrumR} object's \code{Active} fields are searched
for matches to all the regular expressions you input.
Any record which contains at least one token matching any regex in \code{i}
will be retained.
Similarly, any spine which contains at least one token matching any
regex in \code{j} is retained.
If \code{i} and {j} are used together,
 matching spines are indexed first, so that 
tokens matching the regular expression(s) in \code{i}
must be found in matching spines.

A third argument, \code{k}, can also be used, but only if 
both \code{i} and \code{j} arguments are missing.
In the case of \code{k}, only matching tokens are retained,
regardless of their spine or record number(s).
Any pieces, spines, or records with no matches are dropped entirely.


\strong{Formula indexing:} Indexing \code{humdrumR} objects with 
\code{formulae} is the most powerful, flexible indexing option.
Either \code{[}single\code{]} or \code{[}double\code{]} brackets will accept
a formula. The right-hand side of each formula will be evaluated
within the \code{humdrumR} objects internal 
\code{\link[humdrumR:humTable]{humdrum table}}.
Each formula must evaluate to a \code{logical} vector of the same 
length as the total number of tokens (rows in the humdrum table).

In the case of \code{[}single-bracket\code{]} indexing, only one \code{formula}
is accepted, and \emph{every piece} that evalues with at least one 
\code{TRUE} will be retained.
For instance, \code{humdata[~Spine > 4]} will return all pieces
which contain five (or more) spines.
\code{[}single-bracket\code{]} formula indexing is especially useful for indexing
meta-data properties like reference records:
for instance, \code{humdata[~COM == "Paul McCartney"]} will return
all pieces with a \code{!!!COM: Paul McCartney} reference record.

In the case of \code{[[}double-bracket\code{]]} indexing, one or two formulas are accepted, 
in arguments \code{i} and \code{j}, either of which can 
be used in isolation or in combination. 
If \code{j} is used in isolation, it must be placed after a comma, 
as in \code{humdata[[ , j]]}.
In the case of \code{i} formulae, any record which evaluates to
at least one \code{TRUE} value is retained.
In the case of \code{j}, any spine which evaluates to
at least one \code{TRUE} value is retained.
Any piece which contains no matches is dropped entirely.

For \code{[[}double-bracket\code{]]} formula indexing, a third argument, \code{k}
may be used in the absence of \code{i} and \code{j}.
In the case of \code{k} all tokens which evaluate to \code{TRUE}
are retained, regardless of piece/spine/record.
Pieces, spines, or records with no \code{TRUE} values
are simply dropped.
}

\section{Assignment}{

\code{R} objects often have ways of assigning new values to 
\emph{part} of the object using \code{\link[base:Extract]{indexing operators}}.
\code{humdrumR} objects are no different.

A new field can be inserted in a \code{humdrumR} object in two ways:
\enumerate{
\item A field can be copied from one humdrumR object to another if the humdrumR objects'
\code{\link[humdrumR:humTable]{humdrum tables}} have the same number of data tokens (i.e., rows).
This is actually most useful for renaming fields within a humdrumR object (explained below).
\item A \code{\link[base:vector]{vector}} or \code{\link[base:list]{list}} can be instered as a 
new field in a \code{humdrumR}---but again, it must be the same length as the number of tokens
in the object's \code{\link[humdrumR:humTable]{humdrum table}}.
}

Fields can be assigned using two syntaxes:
\preformatted{
humdata['fieldname'] <- x
# or
humdata[c('field1', 'field2')] <- x
}
or 
\preformatted{
humdata$fieldname <- x
}

\strong{\code{humdrumR$fieldname <- humdrumR} assignment}: Assigning a field in one \code{humdrumR}
object from another \code{humdrumR} object works like this. First of call, as a reminder, the two \code{humdrumR}
objects must have the exact same numbers of data tokens in their \code{\link[humdrumR:humTable]{humdrum tables}}.
This means, that this is most useful for assigning field names from one \code{humdrumR} object to itself.
The name(s) given in the indexing expression on the left side of the assignment (i.e., \code{humdata[c('name1', 'name2')]} or
\code{humdata$name}) are used as new field names.
How fields are extracted from the right side of the assignment is a little trickier:
Any fields in the right-side \code{humdrumR} object which are named \eqn{PipeN} (where \eqn{N} is an integer) are copied
in descending order into the named fields on the left side.
If there are no \eqn{PipeN} fields on the right side, any fields used in the current Active formula (on the right side)
are copied instead.

This system might seem odd at first, but it is very useful in combination with the \code{\link[humdrumR:with-in-Humdrum]{withinHumdrum}} function,
and its convenient pipe operator \code{\link[humdrumR:humPipe]{\%hum>\%}}.
The \code{withinHumdrum} command always creates new fields that are called \eqn{Pipe1 ... Pipe2 ... PipeN}.
By using \code{humdata$name} we can immediately assign these pipe fields more meaningful names!

Examples:
\preformatted{
humdata \%hum>\% ~ as.semits(Token) -> humdata$Semits
}
}

