% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Rhythm.R
\name{timeline}
\alias{timeline}
\alias{timestamp}
\title{Rhythmic timeline of a piece}
\usage{
timeline(
  x,
  start = 0,
  pickup = NULL,
  ...,
  Exclusive = NULL,
  parseArgs = list(),
  groupby = list()
)

timestamp(
  x,
  BPM = 60,
  start = 0,
  pickup = NULL,
  minutes = TRUE,
  ...,
  Exclusive = NULL,
  parseArgs = list(),
  groupby = list()
)
}
\arguments{
\item{x}{\emph{\strong{Input rhythm information.}}

Must be \code{atomic}, or \code{NULL}.

Is \link[=rhythmParsing]{parsed as duration information}.}

\item{start}{\emph{\strong{Where does timeline begin?}}

Defaults to \code{0}.

Must be a single number.}

\item{pickup}{\emph{\strong{Where is there a pickup (anacrusis)?}}

Defaults to \code{NULL}

Must be \code{logical} of same \code{length(x)}, Or \code{NULL}.
See "Pickups" section below.}

\item{parseArgs}{\emph{\strong{An optional list of arguments passed to the \link[=rhythmParsing]{rhythm parser}.}}

Defaults to an empty \code{list()}.

Must be a \code{list} of named arguments to the \link[=rhythmParsing]{rhythm parser}.}

\item{groupby}{\emph{\strong{A \code{list} of vectors to group \code{x}.}}

Defaults to \code{list()}.

Must be a \code{list}; every element of the list must be length \code{length(x)}.

To function as a by-record timeline, the \code{groupby} list music include a \emph{named} \code{Piece} and \code{Record} fields.
Luckily, these are automatically passed by \link[=withinHumdrum]{with(in).humdrumR}, so you won't need to worry about it!}

\item{BPM}{\emph{\strong{The tempo.}}

Defaults to \code{60}.

Must be a single number or a \code{character} string in the format \code{"MM120"} (for 120 bpm).

By default, \link[=withinHumdrum]{with(in).humdrumR} passes the \code{BPM} \link[=fields]{field}, if present.}

\item{minutes}{\emph{\strong{Should minutes be counted in output?}}

Defaults to \code{TRUE}.

Must be a singleton \code{logical} value: an on/off switch.

If \code{TRUE}, output seconds are converted to a character string encoding minutes, seconds, and milliseconds in the format \code{MM.SS.ms}.}
}
\description{
These functions calculate the ammount of time (either in beats, or seconds)
that have unfolded since the beginning of a piece, giving a sense of the timeline in which events unfold.
In \code{music21} this information is described as "offsets"---however,
we prefer to reserve the words "onset" and "offset" to refer
to the beginning (attack) and end (release) of rhythmic events.
}
\details{
Music unfolds over time, and humdrum data typically represents this
by placing simultaneous events in the same record, with successive events
in ever higher records---progressing "top down" through the file.
In some humdrum data, only this (implicit) ordering of data over time is present.
The \code{Record} and \code{NData} \link[=fields]{fields} capture this ordering in all data parsed by \code{humdrumR}.
However, many (probably most) humdrum data files contain at least some information about the relative
duration of events, representing more detailed information about timing and rhythm.

\code{timeline()} parses and input vector \code{x} as \link[=duration]{durations},
computes the \link[=sigma]{cumulative sum} of the durations, with the \code{start} argument appended to the beginning.
The result is a \code{numeric} vector representing the total duration since the beginning of the vector (plus the value of \code{start}, which defaults to zero).
The cumulative durations of \code{timeline()} represent musical duration units, where \code{1} equals a whole note.
\code{timestamp()} converts these durations to seconds, either using the \code{BPM} argument/field to determine the tempo or using the
default tempo of 60 beats per minute.
If \code{minutes == TRUE}, the output is formatted into \code{"minute:seconds.milliseconds"} character strings.

If a \code{groupby} argument is provided, \code{\link[=localDuration]{localDuration()}} is used to compute the minimum durations in each group before
computing the cumulative sum only with unique values from each \code{Record} in the \code{groupby}.
By default, \link[=withinHumdrum]{with(in).humdrumR} will automatically pass \code{groupby = list(Piece = Piece, Record = Record)}
into calls to \code{timeline()} or \code{timestamp()}.
Thus, a call like \code{within(humData, timeline(Token))} will compute the correct timeline position for \emph{all}
tokens across all spines/paths/stops---all values in the same record will be the same.

Note that, \code{timeline()} and \code{timestamp()} follow the default behavior of \code{\link[=duration]{duration()}} by treating grace-notes as duration \code{0}.
If you want to use the duration(s) of grace notes, specify \code{grace = TRUE}.
}
\section{Pickups}{


Another option is to pass the \code{pickup} argument a logical vector of the same length as the input \code{x}.
Within each piece/group, any block of \code{TRUE} values at the \emph{beginning} of the \code{pickup} vector
indicate a pickup.
The \emph{first} index where the \code{pickup} logical is \code{FALSE} is used as the starting point of the timeline/count;
All the earlier (\code{pickup == TRUE}) points will be negative numbers, measured backwards from the start index.
In \code{humdrumR}, and datapoints before the first barline record (\code{=}) are labeled \code{Bar == 0} in the \code{Bar} \link[=fields]{field}.
Thus, a common use for the \code{pickup} argument is \verb{within(humData, timeline(Token, pickup = Bar < 1)}, which makes the downbeat of
the first complete bar \code{1} the starting point of the timeline---any notes in pickup bars are negative on the timeline.
}

\seealso{
{The \code{\link[=count]{count()}} and \code{\link[=metcount]{metcount()}} functions provide "higher level" musical interpretations of timeline information.}
}
\concept{rhythm analysis tools}
