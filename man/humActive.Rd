% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/humdrumR-class.R
\name{humActive}
\alias{humActive}
\alias{evalActive}
\alias{getActive}
\alias{getActiveFields}
\alias{setActive}
\alias{setActiveFields}
\alias{$,humdrumR-method}
\title{The "Active expression" of a \link[=humdrumRclass]{humdrumR object}}
\usage{
evalActive(
  humdrumR,
  dataTypes = "D",
  forceAtomic = TRUE,
  sep = ", ",
  nullChar = FALSE
)

getActive(humdrumR)

getActiveFields(humdrumR)

setActive(humdrumR, expr)

setActiveFields(humdrumR, fieldnames)

\S4method{$}{humdrumR}(x, name)
}
\arguments{
\item{humdrumR}{A \link{humdrumRclass} data object.}

\item{dataTypes}{(\code{character}, \code{length == 1}) Which types of humdrum records to include.
Legal values are \verb{'G', 'L', 'I', 'M', 'D', 'd', }
or any combination of these in a single string (e.g., \code{"LIM"}).
(see the \link[=humTable]{humdrum table} documentation \strong{Fields} section for an explanation.).}

\item{forceAtomic}{(\code{logical}, \code{length == 1}) If \code{TRUE} (default), the evaluated active field
is forced/coerced into a atomic vector.}

\item{sep}{(\code{character}, \code{length == 1}) Only used if \code{forceAtomic == TRUE}; if coercion involves pasting
together lists of vectors, \code{sep} is used as a separator when \link[base:paste]{pasting}.}

\item{nullChar}{(\code{logical}, \code{length == 1}) Only used if \code{forceAtomic == TRUE}; if \code{nullChar == TRUE}
and \code{NA}s in the output vector are replaced with humdrum null character tokens: \code{"."}, \code{"!"}, \code{"="},
or \code{"*"}, depending on type.}
}
\description{
\link[=humdrumRclass]{humdrumR objects} contain many fields of data stored in their underlying
\link[=humTable]{humdrum table};
You can \emph{explicitly} access any of these fields using \link[=withinHumdrum]{with(in)Humdrum}.
When you don't explicitly indicate a field, \code{humdrumR} will generally default to showing/using
an the objects "\emph{Active expression}".
}
\details{
Most of the time, the active expression just points to a single field: when first \link[=readHumdrum]{read in},
the active expression/field is \code{Token}.
However, the active expression can be any arbitrary \code{R} expression involving fields of the \link[=humTable]{humdrum table}.
When called for, the expression is evaluated within the object's \link[=humTable]{humdrum table}
(similar to a "\link[=withinHumdrum]{within} expression," without any extra evaluation options).
For instance, the active expression could be:
\code{paste(Token, Record)}, which would print each \code{Token} with its record number pasted to it.
Any fields referenced in the active expression are called "active fields."

Common commands which evaluate the active expression include:
\itemize{
\item When is printing a \code{humdrumR} object in the terminal, the active expression is shown.
(\code{evalActive} is used to evaluate the expression as a \code{character} string, if needed.)
When a \link[=humdrumRclass]{humdrumR object} prints, the active fields are marked with \code{"*"}
by their name(s).
\item When \link[=writeHumdrum]{writing to files}, the active expression is written.
\item In a  "\link[=withinHumdrum]{within expression}," the variable \code{.} is automatically replaced with the active expression.
}

Functions like \url{collapseHumdrum}], \code{\link[=foldHumdrum]{foldHumdrum()}}, and \code{\link[=fields]{fields()}}, use the active field(s) for default arguments.

The current active field can be seen by calling \code{getActive(humData)}.
A \code{character} vector of all fields being used by the active expression
can be extracted with \code{getActiveFields(humData)}.
}
\section{Setting the active expression}{


The active expression can be changed in several ways.
The simplest and most common is using the \link{$ operator}, which takes a field name
(\link[=partialMatching]{partially matched}) and sets the active expression to simply call that field.
This is a handy way to quickly look at different fields in your data:\preformatted{humData$Token

humData$Spine
humData$Sp # same as last one, because it partially matches Spine

}

More complex active expressions can be set using \code{setActive}, specified directly as the second argument:
e.g., \code{setActive(humData, paste(Token, Record))}.
Notice that the active field \emph{must}
\enumerate{
\item Refer to at least one field in the \link[=humTable]{humdrum table}.
\item Evaluate to an vector that is same length as the humdrum table (given the target \code{dataTypes}),
or a \emph{list} of vectors of that length.
}

For programmatic work, \code{setActiveFields} accepts a \code{character} vector of \link[=partialMatching]{partially matched}
field names;
If one field name is given, the active field just calls that field.
If two or more field names are given, the active expression is set to an expression of the form
\code{list(Field1, Field2, Field3, ...)}.
This is the easiest way to quickly see two or three fields side by side.
As special syntactic sugar, if you call \code{humData$All}, a liit of \emph{all} the data fields is set to the active field.
This is a useful way to look at all your data fields.
}

\section{Null data}{


\verb{humdrumR`` identifies "null data" based on the active field---it might not be obvious, but this  is one of the most important jobs of the active field! Anywhere the current active field evaluates to }"."\code{or}NA\verb{(or}NULL\verb{for [lists][base::list()]) is considered null data; in the internal [humdrum table][humTable] these data points are set to}TRUE\verb{in the}Null\verb{field and assigned the type}"d"\verb{in the}Type` field.
Null data is updated whenever the active field is changed or reset, including by functions which create new fields, like
\code{\link[=foldHumdrum]{foldHumdrum()}} and \code{\link[=within.humdrumR]{within.humdrumR()}}.

As you work, there will often be data tokens which are null in one field, but not in another field.
For example, if you load \verb{**kern} data, a token like \code{"4r"} (quarter-note rest) token will be \code{NA} if you call \code{pitch}, but
not \code{NA} if you call \code{recip} (rhythm).\preformatted{
kerndata <- readHumdrum(...)

within(kerndata$Token,
       Pitch  <- pitch(.),
       Rhythm <- recip(.)) -> kerndata

}

Now, if you change the active field between \code{Pitch} and \code{Rhythm} (using \code{$}) you'll see that there
are different numbers of (non-null) data tokens: \code{ntoken(kerndata$Pitch ,'D')} vs \verb{ntoken(kerndata$Rhythm, 'D)} will
return different numbers!
(The difference would be the number of rest tokens.)
Similarly, if you apply functions/expressions to this data (using \code{\link[=withinHumdrum]{withinHumdrum()}} for example), the result will depend on
what the active field is:\preformatted{
with(kerndata$Pitch, length(.))
with(kerndata$Rhythm, length(.))
}

Once again, we'll get different numbers here! (Assuming there are rests in the data.)
This is the case even though the do-expression isn't actually using the \code{Pitch} or \code{Rhythm} fields!
If \code{Pitch} is the active field, the rest tokens are null-data and will be ignored!
}

\section{Evaluating the active expression}{


Evaluation of the active expression is usually something done automatically by \code{humdrumR} functions,
especially for printing data at the console.
However, you can also do it manually using the \code{evalActive} command.
The "raw" result of evaluating the active expression can be returned by specifying \code{forceAtomic == FALSE}.
However, by default \code{forceAtomic == TRUE} which causes \code{evalActive} to coerce the evaluated results
into an atomic vector.
Obviously, the evaluated active result is an atomic vector, no coercion is needed.

If the evaluated active result is a \link[base:list]{list}, it must be either the full length of the \link[=humTable]{humdrum table},
or a list of vectors/lists of that length.
In other words, the result must be one or more "full length" vector/lists.
For each full length \code{list}, each element of the list is coerced to a single atomic value and then
\link[base:unlist]{unlisted} to create an atomic vector.
If the elements of the list are not themselves atomic, they are converted to various \code{character} representations.
\itemize{
\item \link[base:table]{tables} are coerced to the string \code{"<table: k=x, n=y>"}, where \code{x} is the number of categories in the table
and \code{y} is the total number of values in the table (\code{sum(table(...))}).
\item \link[base:list]{lists} of \code{length < 5} are coerced to \code{"list(a, b, c, d, e)"}, where \code{a-e} are the elements of the list.
Longer lists are coerced to \verb{"list[n]:}, where \code{n} is the length of the list.
\item All other \code{R} objects are coerced to \verb{<class>}, where \code{class} is the \link[base:class]{class} of the object.
}

Finally, all the thus-generated full-length vectors (if there are more than one) are pasted together, separated
by \code{sep} (default = \code{", "}).
A common practical illustration/application of this last is to specify active fields that are
lists of fields---for example, \code{list(Token, Spine, Record)}.
Following the algorithm above, the evaluated result is would be \code{character} vector looking
like \code{"Token, Spine, Record"}.
This is exactly what \code{setActiveFields} does when fed multiple \code{fieldNames}, as well as the
special call \code{humData$All}.
}

