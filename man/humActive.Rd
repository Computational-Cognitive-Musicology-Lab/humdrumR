% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/humdrumR-class.R
\name{humActive}
\alias{humActive}
\alias{evalActive}
\alias{activeAtomic}
\alias{getActive}
\alias{setActive}
\alias{setActiveFields}
\title{The "Active expression" of a humdrumR object.}
\usage{
evalActive(humdrumR, dataTypes = "D")

activeAtomic(humdrumR, dataTypes = "D", sep = ", ")

getActive(humdrumR)

setActive(humdrumR, expr)

setActiveFields(humdrumR, fieldnames)
}
\arguments{
\item{humdrumR}{A \link{humdrumRclass} data object.}

\item{dataTypes}{Which dataTypes of humdrum records to include. Legal values are \verb{'G', 'L', 'I', 'M', 'D', 'd', }
or any combination of these in a single string (e.g., \code{"LIM"}).
(see the \link[=humTable]{humdrum table} documentation \strong{Fields} section for an explanation.).}
}
\description{
This "Active" expression is used as the default value in a lot of humdrumR code.
For one, it is the data which is printed by \link[methods:show]{show} calls,
i.e., whenever you return a \code{humdrumR} object in the terminal.
In any expression within a call to
\link[=withinHumdrum]{with(in)Humdrum}
\code{.} is automatically replaced with the \code{Active} expression.
}
\details{
The active expression can be changed with the commands
\link[=humdrumRclass]{setActive or the $ operator}.
This is a handy way to quickly look at different fields in your data.

The \code{Active} expression is often just the name of a
\link[=humTable]{field}:
for instance, the default value is \code{Token}.
However, it can actually be any complex expression which evaluates
within the \link[=humTable]{humdrum table}.
For instance, the \code{Active} expression could be:
\code{paste0(Token, " ", Record)}, which would automatically
print each Token with its record number pasted to it.
}
\section{Null data}{


HumdrumR identifies "null data" based on the active field.
Anywhere the current active field evaluates to \code{"."} or \code{NA} is considered Null data, and assigned the type \code{"d"} in the internal
\link[=humTable]{humdrum table}.
As you work, there will often be data tokens which are null in one field, but not in another field.
For example, if you load \verb{**kern} data, a token like \code{"4r"} (quarter-note rest) token will be \code{NA} if you call \code{pitch}, but
not \code{NA} if you call \code{recip} (rhythm).\preformatted{
kerndata <- readHumdrum(...)

within(kerndata$Token,
       Pitch  <- pitch(.),
       Rhythm <- recip(.)) -> kerndata

}

Now, if you change the active field between \code{Pitch} and \code{Rhythm} you'll see that there
are different numbers of (non-null) data tokens: \code{ntokens(kerndata$Pitch)} vs \code{ntokens(kerndata$Rhythm)} will return different numbers!
(The different would be the number of rest tokens.)
Similarly, if you apply functions/expressions to this data (using \link{withinHumdrum} for example), the result will depend on
what the active field is:\preformatted{
with(kerndata$Pitch, length(.))
with(kerndata$Rhythm, length(.))
}

Once again, we'll get different numbers here! (Assuming there are rests in the data.)
This is the case even though the do-expression isn't actually using the \code{Pitch} or \code{Rhythm} fields!
If \code{Pitch} is the active field the rest tokens are null-data and will be ignored!
}

