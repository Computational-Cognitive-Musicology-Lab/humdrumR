% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Pitch.R
\name{helmholtz}
\alias{helmholtz}
\alias{helmholtz.default}
\alias{helmholtz.humdrumR}
\title{Helmholtz pitch representation}
\usage{
\method{helmholtz}{default}(
  x,
  ...,
  generic = FALSE,
  simple = FALSE,
  octave.relative = FALSE,
  Key = NULL,
  transposeArgs = list(),
  parseArgs = list(),
  gamutArgs = list(),
  inPlace = FALSE
)

humData |> select(Token) |> helmholtz() 
humData |> helmholtz(simple = TRUE)
humData |> helmholtz(Token, Key = Key)
}
\arguments{
\item{x}{\emph{\strong{Input data to parse as pitch information.}}

The \code{x} argument can be any (\link[base:vector]{atomic}) vector, or a \link[=tonalIntervalS4]{tonalInterval}, or \code{NULL}.}

\item{...}{\emph{\strong{Arguments passed to the \link[=pitchDeparsing]{pitch deparser}.}}

There are also two hidden (advanced) arguments you can specify: \code{memoize} and \code{deparse} (see the details below).}

\item{generic}{\emph{\strong{Should "specific" pitch information (accidentals and qualites) be discarded?}}

Defaults to \code{FALSE}.

Must be a singleton \code{logical} value: an on/off switch.}

\item{simple}{\emph{\strong{Should "compound" pitch information (octave/contour) be discarded?}}

Defaults to \code{FALSE}.

Must be a singleton \code{logical} value: an on/off switch.}

\item{Key}{\emph{\strong{The input \code{Key} used by the parser, deparser, and transposer.}}

Defaults to \code{NULL}.

Must be a \code{diatonicSet} or something coercable to \code{diatonicSet}; must be either length \code{1} or \code{length(x)}}

\item{transposeArgs}{\emph{\strong{An optional list of arguments passed to a special \code{\link[=transpose]{transpose()}} call.}}

Defaults to an empty \code{list()}.

Must be a \code{list} of named arguments to \code{\link[=transpose]{transpose()}}.}

\item{parseArgs}{\emph{\strong{An optional list of arguments passed to the \link[=pitchParsing]{pitch parser}.}}

Defaults to an empty \code{list()}.

Must be a \code{list} of named arguments to the \link[=pitchParsing]{pitch parser}.}

\item{inPlace}{\emph{\strong{Should non-pitch information be retained in the output string.}}

Defaults to \code{FALSE}.

Must be a singleton  \code{logical} value: an on/off switch.

This argument only has an effect if the input (the \code{x} argument) is \code{character} strings,
\emph{and} there is extra, non-pitch information in the input strings "besides" the pitch information.
If so, and \code{inPlace = TRUE}, the output will be placed into an output string beside the original non-pitch information.
If \code{inPlace = FALSE}, only the pitch output information will be returned (details below).}
}
\description{
\href{https://en.wikipedia.org/wiki/Helmholtz_pitch_notation}{Helmholtz notation}

If \code{helmholtz()} is applied to a \link[=humdrumRclass]{humdrumR data class}
you may use the data's \link[=fields]{fields} as arguments.
If no field names are specified, the first \link{selectedField} is used as \code{x}.
}
\section{Basic pitch arguments}{


Each pitch function has a few standard arguments which control details of the output.
The most important are the \code{generic} and \code{simple} arguments, which allow you to control what type of pitch information
is returned.
\subsection{Generic vs Specific}{

If \code{generic = TRUE}, \href{https://en.wikipedia.org/wiki/Generic_and_specific_intervals}{specific pitch information}
(accidentals or qualities) is omitted from the output.
As an alternative way of controlling the same functionality, you can use the \code{specific} argument, where \code{specific == !generic}.

In the case of atonal functions, the "generic" version of that pitch is output:
for example, \code{semits('c#', generic = TRUE)} will return \code{0}, because the "generic" version of \emph{C#} is \emph{C}, which corresponds to \code{0}.
However, note that the generic version of a pitch follows the key, so \code{semits('c#', generic = TRUE, Key = 'A:')} will return \code{1}!
}

\subsection{Simple vs Compound}{

If \code{simple = TRUE}, \href{https://en.wikipedia.org/wiki/Interval_(music)#Simple_and_compound}{compound pitch information}
(octave and contour) is omitted from the output.
As an alternative way of controlling the same functionality, you can use the \code{compound} argument ,where \code{compound == !simple}.

There is actually more than one way you might want to divide compound intervals up into simple and octave parts.
For example, you might like to call an output \code{-M2} (descending major 2nd) \emph{OR} \code{+m7} (ascending minor 7th in the octave below).
This functionality can be controlled with the \code{octave.round} argument:
see the \link[=pitchDeparsing]{pitch deparsing documentation}.
}

\subsection{Key}{

The \code{Key} argument must be a \link{diatonicSet}, or something that can be parsed into one.
The \code{Key} argument is passed to the \link[=pitchParsing]{parser}, deparser, \emph{and} transpose---\emph{unless}
an alternate \code{Key} is passed to \code{transposeArgs} or \code{parseArgs}.
Various deparsing options use the \code{Key} argument; for example, use of \code{implicitSpecies} (see advanced parsing section) is dependent on the \code{Key}.

If you use any \link[=pitchFunctions]{pitch function} within a special call to \link{withinHumdrum},
\code{humdrumR} will automatically pass the \code{Key} field from the humdrum data to the function---this means, that in most cases,
you don't need to explicitly do anything with the \code{Key} argument!
(If you want this \emph{not} to happen, you need to explicitly specify your own \code{Key} argument, or \code{Key = NULL}.)
}

\subsection{Parse arguments}{

The \code{parseArgs} argument must be a \code{\link[=list]{list()}} of (named) arguments which are passed to the input \link[=pitchParsing]{parser}.
For example, if our input representation uses \code{"X"} to represent double sharps, we could specify \code{kern('CX5', parseArgs = list(doublesharp = 'X'))}
and get the correct result (\code{"cc##"}).
As a convenient shorthand, or "syntactic sugar," you can specify \code{parseArgs} in an alternate way:
Simply input \code{parse(args...)} as unnamed argument to any pitch function.
For example, we can get the exact same result as before by typing \code{kern('CX5', parse(doublesharp = 'X'))}.
}

\subsection{Transpose arguments}{

The \code{transposeArgs} argument must be a \code{\link[=list]{list()}} of (named) arguments which are passed to an internal call
to \code{\link[=transpose]{transpose()}}, allowing us to easily transpose pitch information.
For example, we could type \code{kern(c('C', 'D', 'E'), transposeArgs = list(by = 'M9'))} can get the output \code{c('d', 'e', 'f#')}.
The possible transpose args are:
\itemize{
\item \code{by} (\link[=tonalIntervalS4]{tonalInterval}, \code{length == 1 | length == (x)})
\item \code{from} (\link{diatonicSet}, \code{length == 1 | length == (x)})
\item \code{to}  (\link{diatonicSet}, \code{length == 1 | length == (x)})
\item \code{real} (\code{logical}, \code{length == 1}) Should transposition be real or tonal?
\item \code{relative} (\code{logical}, \code{length == 1}) Should key-wise transposition be based on relative or parallel keys?
}

As a convenient shorthand, or "syntactic sugar," you can specify \code{transposeArgs} in an alternate way:
Simply input \code{transpose(args...)} as unnamed argument to any pitch function.
For example, we can get the exact same result as before by typing \code{kern(c('C', 'D', 'E'), transpose(by = 'M9'))}.
\subsection{Transposing by interval}{

As when calling \code{\link[=transpose]{transpose()}} directly, the \code{by} argument can be anything coercable to a \link[=tonalIntervalS4]{tonalInterval}, and
the output will be transposed by that amount.
If \code{real = FALSE}, tonal transposition (within the \code{Key}) will be performed.
For more details on transposition behavior, check out the \code{\link[=transpose]{transpose()}} docs.
}

\subsection{Transposing by key}{

Another way of transposing is by specifying an input ("from") key and an output ("to") key.
By default, the \code{Key} argument is passed to \code{transpose} as both \code{from} and \code{to}, so nothing actually happens.
Thus, if you specify either a \code{from} key or \code{to} key, transposition will happen to/from that key to \code{Key}.
Of course, if you specify \code{from} \emph{and} \code{to} the transposition will happen between the keys you specify.

If you use any \link[=pitchFunctions]{pitch function} within a special call to \link{withinHumdrum},
\code{humdrumR} will automatically pass the \code{Key} field from the humdrum data to the function.
If you specify a \code{to} key, the \code{Key} field will be passed as the transpose \code{from} key, and as a result,
all the pitches in the input will be transposed from whatever keys they are in to your target (\code{to}) key!

The \code{real} and \code{relative} arguments give you special control of how key-wise transposition works, so
check out the \code{\link[=transpose]{transpose()}} docs for more details!
}

}

\subsection{In-place parsing}{

In humdrum data, character strings are often encoded with multiple pieces of musical information right besides each other:
for example, \verb{**kern} data might include tokens like \verb{"4.ee-[}.
The \code{humdrumR} parser (\code{tonalInterval}) will automatically "pull out" pitch information from within strings, if it can find any
using the appropriate known regular expressions.
For example, \code{pitch('4.ee-[')} returns Eb5.
However, all the pitch functions (like \code{\link[=pitch]{pitch()}} and \code{\link[=kern]{kern()}}) have an option to keep the "extra" information
and return the result "in place"---i.e., embedded right where it was found in the input string.
This is controlled with the \code{inPlace} argument, which is \code{FALSE} by default.
So, \code{pitch('4.ee-[', inPlace = TRUE)} will return 4.Eb5[---keeping the \code{"4."} and the \code{"["}.
(This obviously only works if the input is a string, not a numeric!)
Note that \code{inPlace = TRUE} will force functions like \code{semits}, which normally return \code{numeric} values, to return \code{character} strings
\emph{if} their input is a character string.
}
}

\section{Pitch-Gamut Levels}{


The \code{\link[=table]{table()}} will automatically generate factor levels
for pitch data using the \code{\link[=gamut]{gamut()}} function.
This is makes sure tabulated data sorted in a logical order, and includes
missing pitches.
The \code{simple}/\code{complex} and  \code{generic}/\code{specific} arguments are automatically passed to \code{\link[=gamut]{gamut()}}; additional
arguments can be passed to gamut using \code{gamutArgs = list(...)}, or with the syntactic sugar \code{gamut(...)}.
(Read the \code{\link[=gamut]{gamut()}} docs for an explanation of gamut generation.)
This feature be used to control table layout of pitch data, as well as to assure
consistent tables when grouping data.

When \code{inPlace = TRUE} no special tabulation will occur.
}

\examples{
exampleToken <- c('4GG', '4G', '4E', '4F#', '4G', '4D', '4E')
results <- helmholtz(exampleToken)
results

exampleHumdrum <- readHumdrum(humdrumRroot, "HumdrumData/BeethovenVariations/B075_00_05_a.krn")
results <- with(exampleHumdrum[[,3:4]], helmholtz(Token))
results

}
\seealso{
To better understand how this function works, read about the \link[=pitchFunctions]{family of pitch functions},
or how pitches are \link[=pitchParsing]{parsed} and \link[=pitchDeparsing]{deparsed}.

Other {absolute pitch functions}: 
\code{\link{kern}()},
\code{\link{lilypond}()},
\code{\link{pitch}()},
\code{\link{solfg}()},
\code{\link{tonh}()}

Other {pitch functions}: 
\code{\link{accidental}()},
\code{\link{bhatk}()},
\code{\link{degree}()},
\code{\link{freq}()},
\code{\link{interval}()},
\code{\link{kern}()},
\code{\link{lilypond}()},
\code{\link{octave}()},
\code{\link{pc}()},
\code{\link{pitch}()},
\code{\link{quality}()},
\code{\link{semits}()},
\code{\link{solfa}()},
\code{\link{solfg}()},
\code{\link{step}()},
\code{\link{tonh}()}
}
\concept{{absolute pitch functions}}
\concept{{pitch functions}}
