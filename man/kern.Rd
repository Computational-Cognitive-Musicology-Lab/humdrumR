% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Pitch.R
\name{kern}
\alias{kern}
\title{Kern pitch representation}
\usage{
kern(
  x,
  ...,
  generic = FALSE,
  simple = FALSE,
  octave.relative = FALSE,
  Key = NULL,
  transposeArgs = list(),
  parseArgs = list(),
  as.factor = factor.default,
  gamutArgs = list(),
  inPlace = FALSE
)
}
\arguments{
\item{x}{(\code{atomic} vector) The \code{x} argument can be any (\link[base:vector]{atomic}) vector, or a \link[=tonalIntervalS4]{tonalInterval}, or \code{NULL}.}

\item{...}{These arguments are passed to the \link[=pitchDeparsing]{pitch deparser}.
There are also two hidden (advanced) arguments you can specify: \code{memoize} and \code{deparse} (see the details below).}

\item{generic}{(\code{logical}, \code{length == 1}) If \code{generic = TRUE} the "specific" pitch information (accidentals and qualites) is discarded.}

\item{simple}{(\code{logical}, \code{length == 1}) If \code{simple = TRUE} the "compound" pitch information (octave/contour) is discarded.}

\item{Key}{(a \link{diatonicSet} or something coercable to \code{diatonicSet}, \code{length == 1 | length == length(x)}) The input \code{Key} used by
the parser, deparser, and transposer.}

\item{transposeArgs}{(\code{list}) \code{transposeArgs} can be a list of arguments that are passed to a special call to \code{\link[=transpose]{transpose()}}.}

\item{parseArgs}{(\code{list}) \code{parseArgs} can be a list of arguments that are passed to the \link[=pitchParsing]{pitch parser}.}

\item{as.factor}{Should the output be converted to a factor?

Defaults to \code{TRUE} for \code{character}-string output (like \code{\link[=kern]{kern()}}) and \code{FALSE} for numeric output (like \code{\link[=semits]{semits()}}).

Must be singleton \code{logical} value: an on/off switch.

If \code{inPlace = TRUE}, \code{as.factor} is forced to \code{FALSE}.}

\item{gamutArgs}{(\code{list}) \code{gamutArgs} can be a list of arguments that are passed to a special call to \code{\link[=gamut]{gamut()}}.}

\item{inPlace}{(\code{logical}, \code{length == 1}) This argument only has an effect if the input (the \code{x} argument) is \code{character} strings,
\emph{and} there is extra, non-pitch information in the input strings "besides" the pitch information.
If so, and \code{inPlace = TRUE}, the output will be placed into an output string beside the original non-pitch information.
If \code{inPlace = FALSE}, only the pitch output information will be returned (details below).}
}
\description{
Kern (\verb{**kern}) is the most common humdrum interpretation for representing "notes" in the style of
traditional Western scores.
However! In \link{humdrumR}, the \code{kern} function outputs the \emph{pitch} part of the \verb{**kern} interpretation.
\verb{**kern} \emph{rhythms} are instead created using the \code{\link[=recip]{recip()}} function.
}
\details{
The pitch part of \verb{**kern} tokens breakdown tonal pitch information as so:
\itemize{
\item \strong{Steps}
\itemize{
\item 1: \code{"C"} or \code{"c"}
\item 2: \code{"D"} or \code{"d"}
\item 3: \code{"E"} or \code{"e"}
\item 4: \code{"F"} or \code{"f"}
\item 5: \code{"G"} or \code{"g"}
\item 6: \code{"A"} or \code{"a"}
\item 7: \code{"B"} or \code{"b"}
}
\item \strong{Accidentals}
\itemize{
\item Flat: \code{"-"}
\item Sharp: \code{"#"}
}
\item \strong{Octave}
\itemize{
\item Octave is indicated through the case of the step characters, as well as \emph{repetition} of the step character.
Uppercase letters are used for octaves below ; lowercase letters for the middle-\strong{C} octave and higher.
The  octave, and the octave below it get one character each, with higher and lower octaves repeating that character.
For example, using \code{C#} as the step value, and relative to the  octave:
\itemize{
\item -3: \code{"CCC#"}
\item -2: \code{"CC#"}
\item -1: \code{"C#"}
\item 0: \code{"c#"}
\item +1: \code{"cc#"}
\item +2: \code{"ccc#"}
\item +3: \code{"cccc#"}
}
}
}

Tokens are ordered \code{Step/Octave + Accidentals}, with no separator.

Like all \code{humdrumR} pitch functions, the ways that \code{kern} \link[=pitchParsing]{parses} and \link[=pitchDeparsing]{deparses} tokens
can be modified to accomodate variations of the standard \verb{**kern} pitch representation.
}
\section{Basic pitch arguments}{


Each pitch function has a few standard arguments which control details of the output.
The most important are the \code{generic} and \code{simple} arguments, which allow you to control what type of pitch information
is returned.
\subsection{Generic vs Specific}{

If \code{generic = TRUE}, \href{https://en.wikipedia.org/wiki/Generic_and_specific_intervals}{specific pitch information}
(accidentals or qualities) is omitted from the output.
As an alternative way of controlling the same functionality, you can use the \code{specific} argument, where \code{specific == !generic}.

In the case of atonal functions, the "generic" version of that pitch is output:
for example, \code{semits('c#', generic = TRUE)} will return \code{0}, because the "generic" version of \emph{C#} is \emph{C}, which corresponds to \code{0}.
However, note that the generic version of a pitch follows the key, so \code{semits('c#', generic = TRUE, Key = 'A:')} will return \code{1}!
}

\subsection{Simple vs Compound}{

If \code{simple = TRUE}, \href{https://en.wikipedia.org/wiki/Interval_(music)#Simple_and_compound}{compound pitch information}
(octave and contour) is omitted from the output.
As an alternative way of controlling the same functionality, you can use the \code{compound} argument ,where \code{compound == !simple}.

There is actually more than one way you might want to divide compound intervals up into simple and octave parts.
For example, you might like to call an output \code{-M2} (descending major 2nd) \emph{OR} \code{+m7} (ascending minor 7th in the octave below).
This functionality can be controlled with the \code{octave.round} argument:
see the \link[=pitchDeparsing]{pitch deparsing documentation}.
}

\subsection{Key}{

The \code{Key} argument must be a \link{diatonicSet}, or something that can be parsed into one.
The \code{Key} argument is passed to the \link[=pitchParsing]{parser}, deparser, \emph{and} transpose---\emph{unless}
an alternate \code{Key} is passed to \code{transposeArgs} or \code{parseArgs}.
Various deparsing options use the \code{Key} argument; for example, use of \code{implicitSpecies} (see advanced parsing section) is dependent on the \code{Key}.

If you use any \link[=pitchFunctions]{pitch function} within a special call to \link{withinHumdrum},
\code{humdrumR} will automatically pass the \code{Key} field from the humdrum data to the function---this means, that in most cases,
you don't need to explicitly do anything with the \code{Key} argument!
(If you want this \emph{not} to happen, you need to explicitly specify your own \code{Key} argument, or \code{Key = NULL}.)
}

\subsection{Parse arguments}{

The \code{parseArgs} argument must be a \code{\link[=list]{list()}} of (named) arguments which are passed to the input \link[=pitchParsing]{parser}.
For example, if our input representation uses \code{"X"} to represent double sharps, we could specify \code{kern('CX5', parseArgs = list(doublesharp = 'X'))}
and get the correct result (\code{"cc##"}).
As a convenient shorthand, or "syntactic sugar," you can specify \code{parseArgs} in an alternate way:
Simply input \code{parse(args...)} as unnamed argument to any pitch function.
For example, we can get the exact same result as before by typing \code{kern('CX5', parse(doublesharp = 'X'))}.
}

\subsection{Transpose arguments}{

The \code{transposeArgs} argument must be a \code{\link[=list]{list()}} of (named) arguments which are passed to an internal call
to \code{\link[=transpose]{transpose()}}, allowing us to easily transpose pitch information.
For example, we could type \code{kern(c('C', 'D', 'E'), transposeArgs = list(by = 'M9'))} can get the output \code{c('d', 'e', 'f#')}.
The possible transpose args are:
\itemize{
\item \code{by} (\link[=tonalIntervalS4]{tonalInterval}, \code{length == 1 | length == (x)})
\item \code{from} (\link{diatonicSet}, \code{length == 1 | length == (x)})
\item \code{to}  (\link{diatonicSet}, \code{length == 1 | length == (x)})
\item \code{real} (\code{logical}, \code{length == 1}) Should transposition be real or tonal?
\item \code{relative} (\code{logical}, \code{length == 1}) Should key-wise transposition be based on relative or parallel keys?
}

As a convenient shorthand, or "syntactic sugar," you can specify \code{transposeArgs} in an alternate way:
Simply input \code{transpose(args...)} as unnamed argument to any pitch function.
For example, we can get the exact same result as before by typing \code{kern(c('C', 'D', 'E'), transpose(by = 'M9'))}.
\subsection{Transposing by interval}{

As when calling \code{\link[=transpose]{transpose()}} directly, the \code{by} argument can be anything coercable to a \link[=tonalIntervalS4]{tonalInterval}, and
the output will be transposed by that amount.
If \code{real = FALSE}, tonal transposition (within the \code{Key}) will be performed.
For more details on transposition behavior, check out the \code{\link[=transpose]{transpose()}} docs.
}

\subsection{Transposing by key}{

Another way of transposing is by specifying an input ("from") key and an output ("to") key.
By default, the \code{Key} argument is passed to \code{transpose} as both \code{from} and \code{to}, so nothing actually happens.
Thus, if you specify either a \code{from} key or \code{to} key, transposition will happen to/from that key to \code{Key}.
Of course, if you specify \code{from} \emph{and} \code{to} the transposition will happen between the keys you specify.

If you use any \link[=pitchFunctions]{pitch function} within a special call to \link{withinHumdrum},
\code{humdrumR} will automatically pass the \code{Key} field from the humdrum data to the function.
If you specify a \code{to} key, the \code{Key} field will be passed as the transpose \code{from} key, and as a result,
all the pitches in the input will be transposed from whatever keys they are in to your target (\code{to}) key!

The \code{real} and \code{relative} arguments give you special control of how key-wise transposition works, so
check out the \code{\link[=transpose]{transpose()}} docs for more details!
}

}

\subsection{In-place parsing}{

In humdrum data, character strings are often encoded with multiple pieces of musical information right besides each other:
for example, \verb{**kern} data might include tokens like \verb{"4.ee-[}.
The \code{humdrumR} parser (\code{tonalInterval}) will automatically "pull out" pitch information from within strings, if it can find any
using the appropriate known regular expressions.
For example, \code{pitch('4.ee-[')} returns Eb5.
However, all the pitch functions (like \code{\link[=pitch]{pitch()}} and \code{\link[=kern]{kern()}}) have an option to keep the "extra" information
and return the result "in place"---i.e., embedded right where it was found in the input string.
This is controlled with the \code{inPlace} argument, which is \code{FALSE} by default.
So, \code{pitch('4.ee-[', inPlace = TRUE)} will return 4.Eb5[---keeping the \code{"4."} and the \code{"["}.
(This obviously only works if the input is a string, not a numeric!)
Note that \code{inPlace = TRUE} will force functions like \code{semits}, which normally return \code{numeric} values, to return \code{character} strings
\emph{if} their input is a character string.
}
}

\section{Pitch-Gamut Factor Levels}{


All pitch formats have the option to be output (\link[=pitchDeparsing]{deparsed}) as R \link[=factor]{factors}.
(See the \code{vignette('RPrimer')} for an explanation of what factors are.)
For \code{character} representations, the \code{as.factor} argument defaults to \code{TRUE}; for \code{numeric}
representations, \code{as.factor} defaults to \code{FALSE}---note that if \code{inPlace = TRUE},
\code{as.factor} is forced to \code{FALSE}.

As factors, the pitch data will implicitly remember the \code{\link[=gamut]{gamut()}} of possible pitches,
and their order, so when you call \code{\link[=table]{table()}}, the resulting table is well formatted.
The gamut is generated by the \code{\link[=gamut]{gamut()}} function: the \code{simple}/\code{complex} and
\code{generic}/\code{specific} arguments are automacitally passed to \code{\link[=gamut]{gamut()}}; additional
arguments can be passed to gamut using \code{gamutArgs = list(...)}, or with the syntactic sugar \code{gamut(...)}.
Read the \code{\link[=gamut]{gamut()}} docs for an explanation of gamut generation.
}

\seealso{
To better understand how this function works, read about the \link[=pitchFunctions]{family of pitch functions},
or how pitches are \link[=pitchParsing]{parsed} and \link[=pitchDeparsing]{deparsed}.

Other {absolute pitch functions}: 
\code{\link{degree}()},
\code{\link{helmholtz}()},
\code{\link{lilypond}()},
\code{\link{pitch}()},
\code{\link{solfg}()},
\code{\link{tonh}()}

Other {pitch functions}: 
\code{\link{accidental}()},
\code{\link{bhatk}()},
\code{\link{degree}()},
\code{\link{freq}()},
\code{\link{helmholtz}()},
\code{\link{interval}()},
\code{\link{lilypond}()},
\code{\link{octave}()},
\code{\link{pc}()},
\code{\link{pitch}()},
\code{\link{quality}()},
\code{\link{semits}()},
\code{\link{solfa}()},
\code{\link{solfg}()},
\code{\link{step}()},
\code{\link{tonh}()}
}
\concept{{absolute pitch functions}}
\concept{{pitch functions}}
