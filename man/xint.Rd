% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Pitch.R
\name{xint}
\alias{xint}
\alias{mint}
\alias{hint}
\title{Calculate melodic intervals}
\usage{
xint(to, from = tint(0L, 0L), deparser = interval, parseArgs = list(), ...)

mint(
  x,
  lag = 1,
  deparser = interval,
  initial = kern,
  bracket = TRUE,
  classify = FALSE,
  ...,
  parseArgs = list(),
  Exclusive = NULL,
  Key = NULL,
  groupby = list()
)

hint(
  x,
  lag = 1,
  deparser = interval,
  initial = kern,
  bracket = TRUE,
  classify = FALSE,
  ...,
  parseArgs = list(),
  Exclusive = NULL,
  Key = NULL,
  groupby = list()
)
}
\description{
\code{mint} calculates melodic intervals in a vector, or across spine/paths of a \link[=humdrumRclass]{humdrumR data object}.
A vector is interpreted as an ordered sequence of notes, forming a "melody,"
and the intervals \emph{between} successive pitches are calculated.

\code{hint} calculates harmonic intervals in a vector, or across records of a \link[=humdrumRclass]{humdrumR data object}.
}
\details{
Input vector \code{x} is \link[=tonalInterval]{parsed as pitch information}.
(Parsing arguments can be passed via the \code{parseArgs} list, or \code{parse(...)} sugar. \code{Key} and \code{Exclusive} are also passed to the parser.)

The parsed pitch vector is copied and lagged using \code{\link[=lag]{lag()}}, and pairs which cross \code{groupby} are ignored.
The melodic intervals are then "\link[=pitchDeparsing]{deparsed}" into a standard representation; by default, the \code{\link[=intervals]{intervals()}}
representation is used, but you can set the \code{deparser} argument to any \link[=pitchFunctions]{pitch function}.
However, the only alternative deparser that would be \emph{commonly} used (other than \code{\link[=intervals]{intervals()}}) would be \code{\link[=semits]{semits()}}.

The \code{lag} argument controls how far apart in the melody intervals are calculated.
For instance, a lag of \code{2} will calculate intervals between \emph{every other} note in the vector.
Positive lags will calculate \strong{approaching} intervals: each token represents the interval between the current note
and the \emph{previous} note.
Negative lags will calculate \strong{departing} intervals: each token reprseents the interval
between the current note and the \emph{next} note.

Note that you by passing \code{directed = FALSE} through the the deparser, the undirected (absolute value)
of the melodic intervals can be returned.
}
\section{Initial value padding}{


Any output of \code{mint} is necessarily padded by \code{abs(lag)} undefined intervals at the beginning
(positive lag) or end (negative lag).
The \code{initial} argument controls how these initial values are presented.

If \code{initial} is a function, the "initial" pitches are parsed "absolutely" relative to middle-C;
in this case, \code{initial} should be another \link[=pitchFunctions]{pitch function} to deparse these pitches.
The default is the \code{\link[=kern]{kern()}} function.
If \code{bracket == TRUE}, these initial values are are surrounded with \verb{[]}, so they are easier to distinguish from the
actual melodic intervals.

If \code{initial} is an atomic value, these value are used as the padder;
An atomic (vector) \code{initial} must be the same length as \code{abs(lag)}.
For example, you could set \code{initial = 'start'} to label these locations as the character string \code{'start'}.
If \code{initial} is \code{NULL}, the initial values are simply padded with \code{NA}.
}

\section{Interval classification}{


If the \code{classify} argument is set to \code{TRUE}, intervals are classified as either \code{"Unison"},
\code{"Step"}, \code{"Skip"}, or \code{"Leap"}.
Alternatively, skips can be interpreted as leaps by setting \code{skips = FALSE}.
(Note that classification will only work if \code{deparser = interval}, which is the default).

By default, intervals are categorized tonally, meaning that the interval in tonal \emph{steps}
is used as the basis of classification.
For example, an augmented 2nd is a step, and a diminished 3rd is a skip/leap.
This means that augmented and diminished unisons are marked \code{"Unison"} as well!
However, if \code{directed = TRUE}, augmented/diminished unisons will be marked with \code{+} or \code{-}
to indicate direction, whereas perfect unisons are never marked with \code{+}/\code{-}.

Alternatively, you may choose to categorize intervals \emph{atonally} by setting \code{atonal = TRUE}.
If so, intervals are categorized based only on semitone (enharmonic) intervals:
D# and Eb are classified the same.
}

\section{Grouping}{


In many cases we want to perform lagged calculations in a vector, but \emph{not across certain boundaries}.
For example, if your vector includes data from multiple pieces, we wouldn't want to calculate melodic intervals
between pieces, only within pieces.
The \code{groupby} argument indicates one, or more, grouping vectors, which break the \code{x} (input) argument
into groups.
If more than \code{groupby} vectors are given, a change in \emph{any} vector indicates a boundary.

Value pairs which cross between groups are treated as if they were at the beginning.
Basically, using groupby should be essentially identical to using \code{tapply(x, groupby, laggedFunction, ...)},
except generally faster when the number of groups is large.

The most common use case in humdrum data, is looking at "melodies" within spines.
For this, we want \code{groupby = list(File, Spine, Path)}.
In fact, \code{humdrumR} \link[=withinHumdrum]{with(in)} calls will \emph{automatically} feed these
three fields as \code{groupby} arguments to certain functions: mint, hint, delta, sigma, lag, or ditto.
Do any use of \code{delta} in a call to \link[=withinHumdrum]{with(in)}, will automatically calculate the \code{delta}
in a "melodic" way, within each spine path of each file.
However, if you wanted, for instance, to calculate differences across spines (like harmonic intervals)
you could manually set \code{groupby = list(File, Record)}.
}

\seealso{
{\code{mint} uses \code{\link[=lag]{lag()}} to "lag" the input pitches, and also makes use of \link[=tonalInterval]{pitch parsers} and \link[=pitchFunctions]{pitch functions}.}

Other {relative pitch functions}: 
\code{\link{bhatk}()},
\code{\link{degree}()},
\code{\link{interval}()},
\code{\link{solfa}()}

Other {Lagged vector functions}: 
\code{\link{delta}()},
\code{\link{ditto}()},
\code{\link{lag}()},
\code{\link{sigma}()}

Other {relative pitch functions}: 
\code{\link{bhatk}()},
\code{\link{degree}()},
\code{\link{interval}()},
\code{\link{solfa}()}

Other {Lagged vector functions}: 
\code{\link{delta}()},
\code{\link{ditto}()},
\code{\link{lag}()},
\code{\link{sigma}()}
}
\concept{{Lagged vector functions}}
\concept{{relative pitch functions}}
