% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/humClass.R
\name{humColumns}
\alias{humColumns}
\alias{alignColumns}
\title{Spines vs Paths vs Columns}
\usage{
alignColumns(humdrumR, padder = "_C")
}
\description{
In the \href{http://www.humdrum.org/guide/ch05/}{humdrum syntax}, data is placed in "spines,"
which are not the same as "columns" in a spreadsheet. A "column" refers to a 
tab-delineated group of values.
"Spines" can be a single column, or they may (at any time) split into multiple columns,
which can in turn split again, using the \code{"*^"} interpretation token. The reverse can happen as well,
with two or more columns merging into a single column, using the \code{"v"} token.
This means that, while humdrum data at first glance looks like a simple two-dimensional table,
it is actually a flexible tree structure. As spines split and merge, the total number of columns
can change during a piece, creating a "ragged" edge.
Another similar issue is that a corpus of humdrum files may have varying numbers of spines/columns, between pieces.
("Global" comment/reference records are also a special case, as that are always a single value, even if interspersed with
multi-column local records.)
}
\details{
In \code{\link{humdrumR}}, spines, columns, and spine paths work like this.
First of all, we actually assume a slightly more strict version of the humdrum syntax:
we assume that all the spines which appear at the beginning of a file (headed with exlusive interpretations
like \code{"**kern"}) can never merge into each other. Thus, a humdrum file read into \code{humdrumR}
must not end with fewer columns than it starts.
Spine merges (\code{"*v"}) can only happen within spine paths that originally split off the same spine.
This extra-strict specification of spine paths in the humdrum syntax is, fortunately, something that has been
informally followed in most humdrum datasets.

Our strict spine-path definition makes everything work fairly simply: 
Within a piece, the spines which appear at the beginning of the piece are the "true" spines through the rest of the piece, numbered
from left to right, starting from \code{1L}.
For each local token, the value in the \code{Spine} field is an integer indicating which of these
"true" spines it belongs to---global tokens have a \code{NA} value in their \code{Spine} field, because they are considerd to not belong to any spine.
Any spine path splits (\code{"*^"} from the main spines form subspines, which we call \strong{Paths}.
Every spine's paths are numbered, from right to left, starting from \code{0L}.
A spine with no splits will have all \code{0L}s in its \code{Path} field.
}
\section{Columns}{

It is very useful to sometimes turn humdrum data into a true two dimensional structure, with no ragged edges.
(This always requires removing global records.)
In order to do this, while maintaining a sensible relationship between spine which have spine paths,
\code{\link{humRead}} automatically \emph{pads} humdrum data into a complete, non-ragged 2d table.
For instance, given this file
\preformatted{
**kern  **kern
A       E
*^      *
A       C       E
G       B       D
*v      *v      *
A       C        
*-      *-
}
\code{\link{humRead}} pads the file as so:
\preformatted{
**kern   _P       **kern
A        _P       E
*^       _P       *
A        C        E
G        B        D
*v       *v       *
A        _P       C        
*-       _P       *-

##########################################
1        1        2        Spine
0        1        0        Path
1        2        3        Column
}
(In this example, the \code{Spine}, \code{Path}, and \code{Column} values are shown below the data.)
The \code{"_P"} tokens stand for "padded path."
This appraoch assures that every \strong{Spine} is a contiguous block of tokens, of constant width.
In most \code{\link{humdrumR}} use cases, these padding tokens (and the \code{Column} field) can be safely ignored.
}

\section{Corpus padding}{

\code{\link{humRead}} automatically pads spine paths \emph{within pieces}.
However, as mentioned above, there is also (sometimes) a need to pad across pieces, in order
to create a logical, clean 2d structure.
Consider this example, with humdrum data from two pieces:
\preformatted{
(From piece 1:)
**kern   **kern  **kern
E        D       C
D        .       .
C        C       E
*-       *-      *-
(From piece 2:)
**kern   **kern
A        A
.        B
C        C
*-       *-
}
In this example, we have two pieces, one with three spines, the other with two.
There is no way to squish these two pieces into one regular 2d table.
But we \emph{could} pad any missing columns, as so:
\preformatted{
(From piece 1:)
**kern   **kern  **kern
E        D       C
D        .       .
C        C       E
*-       *-      *-
(From piece 2:)
**kern  **kern   _C
A        A       _C
.        B       _C
C        C       _C
*-       *-      _C
}
The function \code{alignColumns} is used to achieve just this effect.
In this example, the \code{"_C"} token stands for "padded column."

The presence of spine paths makes padding columns across pieces a bit more complicated.
What \code{alignColumns} will do, is match up all pieces in a corpus so that
every \strong{Spine}/\strong{Path} field pair allign in the same column.
Here is an example, with its paths already padded: 
\preformatted{
(From piece 1:)
**kern      _P        **kern
A           _P        E
B           _P        D
*^          _P        *
A           C         E
G#          B         E
*v          *v        *
A           _P        E
*-          _P        *-
#################################################
1           1         2         Spine
0           1         0         Path
1           2         3         Column

(From piece 2:)
**kern     **kern    _P
A          E         _P
*          *^        _P
G#         D         F
A          C         E
*          *v        *v
E          D         _P
*-         *-        _P        
#################################################
1          2         2        Spine
0          0         1        Path
1          2         3        Column
}
We have two pieces, each with two spines,
but in the first piece, the first spine splits, while in the second piece, the
second spine splits. Thus, the padded output will have four columns:
\preformatted{
(From piece 1:)
**kern    _P        **kern   _C
A         _P        E        _C
B         _P        D        _C
*^        _P        *        _C
A         C         E        _C
G#        B         E        _C
*v        *v        *        _C
A         _P        E        _C
*-        _P        *-       _C 
###########################################################
1         1         2        2         Spine
0         1         0        1         Path
1         2         3        4         Column

(From piece 2:)
**kern    _C        **kern   _P
A         _C        E        _P
*         _C        *^       _P
G#        _C        D        F
A         _C        C        E
*         _C        *v       *v
E         _C        D        _P
*-        _C        *-       _P 
#########################################################       
1         1         2        2         Spine
0         1         0        1         Path
1         2         3        4         Column
}
Note that code{alignColumns} actually adds rows to the \code{\linkS4class{humdrumR}} object's
internal \code{\link[humdrumR:humTable]{humdrum tables}}.
}

