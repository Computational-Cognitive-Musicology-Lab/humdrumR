% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/humdrumR-package.R
\name{evaluatingExpressions}
\alias{evaluatingExpressions}
\title{"Evaluating" "Expressions" in "Environments"?}
\description{
"Evaluating" "Expressions" in "Environments"?
}
\section{Expressions}{


The term "expression" is just a fancy way of describing any bit of (valid) code than can be parsed
and evaluated (executed) by R.
For example, the following bits of code are all valid R "expressions":
\itemize{
\item \code{2 + 2}
\item \code{sqrt(2)}
\item \code{x <- (1:10)^2}
\item \code{log(x, base = 10) |> mean(na.rm = TRUE)}
\item \code{sum((x - mean(x))^2)}
\item 

\if{html}{\out{<div class="sourceCode">}}\preformatted{\{ 
  x <- 1:10
  b <- mean(x)
  z <- x * z
\}
}\if{html}{\out{</div>}}
}

Expressions are frequently built of other expressions: so \code{2 + 2} is an expression, and \code{sqrt(2 + 2)} is an expression.
The \code{{ }} operators are used to group any valid expressions into one bigger expression.
You can also use \verb{;} to write two expressions on the same line, like \verb{x <- 2; log(x^2)}
}

\section{Evaluation}{


An expression like \code{sum((x - mean(x))^2)} is just a sequence of characters until we do something with it.
We call this "\emph{evaluating}" the expression.
This exactly what the R "interpreter" does when you "run" some R code.

In R, an evaluated expression always "returns" a "\emph{result}"---a value, like a number, \code{character} string, or some other data.
Some expressions might "return" \code{NULL} as their result, but it's still a result!
In a multi-line expression, like \code{{sqrt(2); 2 + 2}} or

\if{html}{\out{<div class="sourceCode">}}\preformatted{\{
  x <- 2
  x^2
\}
}\if{html}{\out{</div>}}

the result of the overall expression is simply the result of the last expression---so the last two examples both return the result \code{4}.
}

\section{Environment}{


To evaluate an expression, R must look up any variable names in the expression in the current "\emph{environment}";
For example, the expression \code{sum((x - mean(x))^2)} includes the variables \code{sum}, \code{mean}, and \code{x}.
The variables \code{sum} and \code{mean} are \link{base} R functions, so R will find them no problem (unless you \link[=rm]{remove} them).
However, \code{x} is not generally going to be "defined" unless \emph{you've} defined it.
If you try to evaluate \code{sum((x - mean(x))^2)}, you'll get an error if \code{x} is not defined.

There are many different "\link[=environment]{environments}" in R, where R will search for variables:
When you run R, you can save variables in the \emph{global environment}; R-packages have their own environments;
\emph{every} time you call a function,
the function has its \emph{own} environment inside it---this is why a function can "see" it's own arguments,
but variable you save inside a function isn't "visible" outside the function.

One of the greatest features of R is that we can often tell R to evaluate an expression using
a specific \link{data.frame} as the environment, so we can use the column names of our data as variables.
The humdrumR \link[=withinHumdrum]{with(in)} (and their tidyverse equivalents) use this functionality a lot!
\subsection{Incomplete expressions}{

One of the most annoying things that can happen in R is if you try running something and it kind just hangs,
getting stuck with nothing happening no matter how many times you press enter.
This is usually because you have (accidentally) provided R and \emph{incomplete} expression.
For example, \verb{2 + } is an incomplete expression---that \code{+} needs a number after it!
Failing to have properly paired parentheses will often result in incomplete expressions:
For example, \verb{mean(sqrt(log(x))} is an incomplete expression!
}
}

