% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Pitch.R
\name{bhatk}
\alias{bhatk}
\title{Swara representation}
\usage{
bhatk(
  x,
  ...,
  generic = FALSE,
  simple = FALSE,
  octave.relative = FALSE,
  Key = NULL,
  transposeArgs = list(),
  parseArgs = list(),
  inPlace = FALSE
)
}
\arguments{
\item{x}{(\code{atomic} vector) The \code{x} argument can be any (\link[base:vector]{atomic}) vector, or a \link[=tonalIntervalS4]{tonalInterval}, or \code{NULL}.}

\item{...}{These arguments are passed to the \link[=pitchDeparsing]{pitch deparser}.
There are also two hidden (advanced) argumens you can specify: \code{memoize} and \code{deparse} (see the details below).}

\item{generic}{(\code{logical}, \code{length == 1}) If \code{generic = TRUE} the "specific" pitch information (accidentals and qualites) is discarded.}

\item{simple}{(\code{logical}, \code{length == 1}) If \code{simple = TRUE} the "compound" pitch information (octave/contour) is discarded.}

\item{Key}{(a \link{diatonicSet} or something coercable to \code{diatonicSet}, \code{length == 1 | length == length(x)}) The input \code{Key} used by
the parser, deparser, and transposer.}

\item{transposeArgs}{(\code{list}) \code{transposeArgs} can be a list of arguments that are passed to a special call to \link{transpose}.}

\item{parseArgs}{(\code{list}) \code{parseArgs} can be a list of arguments that are passed to the \link[=pitchParsing]{pitch parser}.}

\item{inPlace}{(\code{logical}, \code{length == 1}) This argument only has an effect if the input (the \code{x} argument) is \code{character} strings,
\emph{and} there is extra, non-pitch information in the input strings "besides" the pitch information.
If so, and \code{inPlace = TRUE}, the output will be placed into an output string beside the original non-pitch information.
If \code{inPlace = FALSE}, only the pitch output information will be returned (details below).}
}
\description{
\href{https://en.wikipedia.org/wiki/Svara}{Swara} are syllabes used to represent scale degrees
in hindustani music---like solfege.
}
\section{Basic pitch arguments}{


Each pitch function has a few standard arguments which control details of the output.
The most important are the \code{generic} and \code{simple} arguments, which allow you to control what type of pitch information
is returned.
\subsection{Generic vs Specific}{

If \code{generic = TRUE}, \href{https://en.wikipedia.org/wiki/Generic_and_specific_intervals}{specific pitch information}
(accidentals or qualities) is omitted from the output.
As an alternative way of controlling the same functionality, you can use the \code{specific} argument, where \code{specific == !generic}.

In the case of atonal functions, the "generic" version of that pitch is output:
for example, \code{semits('c#', generic = TRUE)} will return \code{0}, because the "generic" version of \emph{C#} is \emph{C}, which corresponds to \code{0}.
However, note that the generic version of a pitch follows the key, so \code{semits('c#', generic = TRUE, Key = 'A:')} will return \code{1}!
}

\subsection{Simple vs Compound}{

If \code{simple = TRUE}, \href{https://en.wikipedia.org/wiki/Interval_(music)#Simple_and_compound}{compound pitch information}
(octave and contour) is omitted from the output.
As an alternative way of controlling the same functionality, you can use the \code{compound} argument ,where \code{compound == !simple}.

There is actually more than one way you might want to divide compound intervals up into simple and octave parts.
For example, you might like to call an output \code{-M2} (descending major 2nd) \emph{OR} \code{+m7} (ascending minor 7th in the octave below).
This functionality can be controlled with the \code{octave.round} argument:
see the \link[=pitchDeparsing]{pitch deparsing documentation}.
}

\subsection{Key}{

The \code{Key} argument must be a \link{diatonicSet}, or something that can be parsed into one.
The \code{Key} argument is passed to the \link[=pitchParsing]{parser}, deparser, \emph{and} transpose---\emph{unless}
an alternate \code{Key} is passed to \code{transposeArgs} or \code{parseArgs}.
Various deparsing options use the \code{Key} argument; for example, use of \code{implicitSpecies} (see advanced parsing section) is dependent on the \code{Key}.

If you use any \link[=pitchFunctions]{pitch function} within a special call to \link{withinHumdrum},
\code{humdrumR} will automatically pass the \code{Key} field from the humdrum data to the function---this means, that in most cases,
you don't need to explicitly do anything with the \code{Key} argument!
(If you want this \emph{not} to happen, you need to explicitly specify your own \code{Key} argument, or \code{Key = NULL}.)
}

\subsection{Parse arguments}{

The \code{parseArgs} argument must be a \code{\link[=list]{list()}} of (named) arguments which are passed to the input \link[=pitchParsing]{parser}.
For example, if our input representation uses \code{"X"} to represent double sharps, we could specify \code{kern('CX5', parseArgs = list(doublesharp = 'X'))}
and get the correct result (\code{"cc##"}).
As a convenient shorthand, or "syntactic sugar," you can specify \code{parseArgs} in an alternate way:
Simply input \code{parse(args...)} as unnamed argument to any pitch function.
For example, we can get the exact same result as before by typing \code{kern('CX5', parse(doublesharp = 'X'))}.
}

\subsection{Transpose arguments}{

The \code{transposeArgs} argument must be a \code{\link[=list]{list()}} of (named) arguments which are passed to an internal call
to \code{\link[=transpose]{transpose()}}, allowing us to easily transpose pitch information.
For example, we could type \code{kern(c('C', 'D', 'E'), transposeArgs = list(by = 'M9'))} can get the output \code{c('d', 'e', 'f#')}.
The possible transpose args are:
\itemize{
\item \code{by} (\link[=tonalIntervalS4]{tonalInterval}, \code{length == 1 | length == (x)})
\item \code{from} (\link{diatonicSet}, \code{length == 1 | length == (x)})
\item \code{to}  (\link{diatonicSet}, \code{length == 1 | length == (x)})
\item \code{real} (\code{logical}, \code{length == 1}) Should transposition be real or tonal?
\item \code{relative} (\code{logical}, \code{length == 1}) Should key-wise transposition be based on relative or parallel keys?
}

As a convenient shorthand, or "syntactic sugar," you can specify \code{transposeArgs} in an alternate way:
Simply input \code{transpose(args...)} as unnamed argument to any pitch function.
For example, we can get the exact same result as before by typing \code{kern(c('C', 'D', 'E'), transpose(by = 'M9'))}.
\subsection{Transposing by interval}{

As when calling \code{\link[=transpose]{transpose()}} directly, the \code{by} argument can be anything coercable to a \link[=tonalIntervalS4]{tonalInterval}, and
the output will be transposed by that amount.
If \code{real = FALSE}, tonal transposition (within the \code{Key}) will be performed.
For more details on transposition behavior, check out the \code{\link[=transpose]{transpose()}} docs.
}

\subsection{Transposing by key}{

Another way of transposing is by specifying an input ("from") key and an output ("to") key.
By default, the \code{Key} argument is passed to \code{transpose} as both \code{from} and \code{to}, so nothing actually happens.
Thus, if you specify either a \code{from} key or \code{to} key, transposition will happen to/from that key to \code{Key}.
Of course, if you specify \code{from} \emph{and} \code{to} the transposition will happen between the keys you specify.

If you use any \link[=pitchFunctions]{pitch function} within a special call to \link{withinHumdrum},
\code{humdrumR} will automatically pass the \code{Key} field from the humdrum data to the function.
If you specify a \code{to} key, the \code{Key} field will be passed as the transpose \code{from} key, and as a result,
all the pitches in the input will be transposed from whatever keys they are in to your target (\code{to}) key!

The \code{real} and \code{relative} arguments give you special control of how key-wise transposition works, so
check out the \code{\link[=transpose]{transpose()}} docs for more details!
}

\subsection{In-place parsing}{

In humdrum data, character strings are often encoded with multiple pieces of musical information right besides each other:
for example, \verb{**kern} data might include tokens like \verb{"4.ee-[}.
The \code{humdrumR} parser (\code{tonalInterval}) will automatically "pull out" pitch information from within strings, if it can find any
using the appropriate known regular expressions.
For example, \code{pitch('4.ee-[')} returns Eb5.
However, all the pitch functions (like \code{\link[=pitch]{pitch()}} and \code{\link[=kern]{kern()}}) have an option to keep the "extra" information
and return the result "in place"---i.e., embedded right where it was found in the input string.
This is controlled with the \code{inPlace} argument, which is \code{FALSE} by default.
So, \code{pitch('4.ee-[', inPlace = TRUE)} will return 4.Eb5[---keeping the \code{"4."} and the \code{"["}.
(This obviously only works if the input is a string, not a numeric!)
Note that \code{inPlace = TRUE} will force functions like \code{semits}, which normally return numeric values, to return character strings
\emph{if} their input is a character string.
}

}
}

\seealso{
To better understand how this function works, read about the \link[=pitchFunctions]{family of pitch functions},
or how pitches are \link[=pitchParsing]{parsed} and \link[=pitchDeparsing]{deparsed}.

Other {relative pitch functions}: 
\code{\link{degree}()},
\code{\link{interval}()},
\code{\link{int}()},
\code{\link{solfa}()}

Other {pitch functions}: 
\code{\link{accidental}()},
\code{\link{degree}()},
\code{\link{freq}()},
\code{\link{helmholtz}()},
\code{\link{interval}()},
\code{\link{kern}()},
\code{\link{lilypond}()},
\code{\link{octave}()},
\code{\link{pc}()},
\code{\link{pitch}()},
\code{\link{quality}()},
\code{\link{semits}()},
\code{\link{solfa}()},
\code{\link{solfg}()},
\code{\link{step}()},
\code{\link{tonh}()}
}
\concept{{pitch functions}}
\concept{{relative pitch functions}}
