% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Piping.R
\name{humPipe}
\alias{humPipe}
\alias{\%hum>\%}
\alias{\%hum<\%}
\alias{\%humT\%}
\alias{\%s>\%}
\alias{\%hums>\%}
\alias{\%hums<\%}
\alias{\%humsT\%}
\alias{\%hums[]\%}
\title{Piping humdrumR data}
\usage{
humdrumR \%hum>\% formula

humdrumR \%hum<\% formula

humdrumR \%humT\% formula

e1 \%s>\% e2

list \%hums>\% formula

list \%hums<\% formula

list \%humsT\% formula

list \%hums[]\% formula
}
\description{
These infix operators make it possible to use
the \verb{[humdrumR:with-in-Humdrum][with(in)Humdrum]}
functions in a piping style, similar to the \code{|} (pipe)
in unix-style terminals, or the \verb{|>}  pipe operator.
from the R package \href{https://cran.r-project.org/web/packages/magrittr/index.html}{magrittr}.
}
\details{
The key is that the function \verb{[withinHumdrum][withinHumdrum]} always returns a new
\verb{[humdrumR][humdrumR]} data object. Thus, you can always send the output
of \verb{[withinHumdrum][withinHumdrum]} back in to a new call of \verb{[withinHumdrum][withinHumdrum]}.
This is exactly what the \verb{\%hum>\%} is for: on the left-hand side,
input a \verb{[humdrumR][humdrumR]} object, on the right-hand side suitable
arguments to \verb{[withinHumdrum][withinHumdrum]} (i.e., a formula, a function, or list of formulae,
functions, and named arguments). You can then chain this call with another call to
\verb{\%hum>\%} and more \verb{[withinHumdrum][withinHumdrum]} arguments.

\verb{\%hum<\%} acts the same way as \verb{\%hum>\%} except it calls \verb{[withHumdrum][withinHumdrum]}.
Since \verb{[withHumdrum][withinHumdrum]} does \emph{not} return a \verb{[humdrumR][humdrumR]},
the output can't be piped any further (using \verb{\%hum>\%} or \verb{\%hum<\%}).
Thus, \verb{\\\%hum<\\\%} should only be used as the last step in a pipe---you would do this
if you want to extract the last step in your pipe from the data's \verb{[humdrumR:humtable][Humdrum Table]} into
a normal vector or list of R data.

' \verb{\\\%humT\\\%} creates a "T" in the pipe, applying the desired expression but not keeping the result---the unaltered
humdrumR input object is returned. This works simply by replacing all \verb{do~} with \verb{doplot~} in a call to
\verb{[withinHumdrum][withinHumdrum]}. The purpose of this option, is if you want to apply expressions for their
\href{https://en.wikipedia.org/wiki/Side_effect_(computer_science)}{side effects},
for instance, for plotting.

\verb{\%hum[]\%} is similar to \verb{\%hum>\%} except it apply the formulae on its right-hand
side using \verb{[humdrumR][filterHumdrum]}. Thus, it can be used to filter/index
a \verb{[humdrumR][humdrumR]} data object on the fly.
}
\section{Plural pipes}{


In R we often apply the same function to a \code{list} of data.
"Plural pipes" expand this idea to piping: take a \code{list} of data
and pipe each element in the list to an expression/function.
There are plural pipe versions of each singular pipe operator.
Just add an "s" to make them plural:
\itemize{
\item \verb{|>} (singular) : \verb{\%s>\%} (plural);
\item \verb{\%hum>\%} (singular) : \verb{\%hums>\%} (plural);
\item \verb{\%hum<\%} (singular) : \verb{\%hums<\%} (plural);
\item \verb{\%humT\%} (singular) : \verb{\%humsT\%} (plural);
\item \verb{\%hum[]\%} (singular) : \verb{\%hums[]\%} (plural);
}

Note: \verb{\%s>\%} is an expansion of the \verb{\\>} pipe operator, which
makes use of some clever meta-programming---we can't guarantee it will
always behave the way we might like!
}

\examples{

humdata <- readHumdrum('path*.krn')

humdata \%hum>\% ~table(.)

humdata \%hum>\%
     c(by~Spine, do ~ table(.)) \%hum>\%
     c(mfcol ~ c(2,2), doplot~barplot(.))
     
humdata \%hum>\%
     c(by ~ Spine, do ~ table(.)) \%hum<\%
     (do ~ sort(.))    

}
