% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/humdrumR-class.R
\name{foldHumdrum}
\alias{foldHumdrum}
\alias{foldPaths}
\alias{foldStops}
\title{"Fold" humdrumR data into new fields}
\usage{
foldHumdrum(
  humdrumR,
  fold,
  onto,
  what = "Spine",
  Piece = NULL,
  fromField = selectedFields(humdrumR)[1],
  fillFromField = FALSE,
  newFieldNames = NULL
)

foldPaths(
  humdrumR,
  fromField = selectedFields(humdrumR)[1],
  fillFromField = TRUE
)

foldStops(
  humdrumR,
  fromField = selectedFields(humdrumR)[1],
  fillFromField = FALSE
)
}
\arguments{
\item{humdrumR}{\emph{\strong{HumdrumR data.}}

Must be a \link[=humdrumRclass]{humdrumR data object}.}

\item{fold}{\emph{\strong{Which target structure (spine, path, etc.) to "fold" onto another structural position.}}

Must be natural numbers.}

\item{onto}{\emph{\strong{Which target structure (spine, path, etc.) is the data "folded" onto.}}

Must be natural numbers.}

\item{what}{\emph{\strong{The structural (spine, path, etc.) which is folded across.}}

Defaults to \code{"Spine"}.

Must be a single \code{character} string. Valid options are \code{"Spine"}, \code{"Path"}, \code{"Stop"}, \code{"Record"},and \code{"DataRecord"}.}

\item{Piece}{\emph{\strong{Which pieces in the corpus should be folded (see "Piece-Specific Folding" section, below).}}

Defaults to \code{NULL}.

Must be natural numbers; must be length \code{length(onto)}.}

\item{fromField}{\emph{\strong{Which field to "fold."}}

Defaults to \code{selectedFields(humdrumR)[1]}.

Must be a \code{character} string \link[=partialMatching]{partially} matching the name of a data field in the \code{humdrumR} input.
For example, \code{"Tok"} would match the \code{Token} field.
This is the field which is "folded" into a new field.}

\item{fillFromField}{\emph{\strong{Should the content of the \code{fromField} be to copied unfolded sections?}}

Defaults to \code{FALSE} for \code{foldHumdrum()} and \code{foldStops()}; \code{TRUE} for \code{foldPaths()}.

Must be a singleton \code{logical} value: an on/off switch.

This only comes into play if the folding field is smaller than the \code{to} field.}

\item{newFieldNames}{\emph{\strong{Names to use for new fields created by the folding.}}

Defaults to \code{NULL}.

Must be \code{character}.}
}
\description{
Many humdrum datasets encode data across multiple spines, spine-paths, or stops.
By default, \code{humdrumR} parses each separate spine, spine-path, and stop as their own individual
data points, taking up one row in the \link[=humTable]{humdrum table}.
If we want to treat data in multiple spines/paths/stops as different aspects of the same data
it is easiest to reshape the data so that the information is in different humdrumR \link[=fields]{fields}
rather than separate spines/paths/stops.
We "fold" the data from one structural location over "on top" of other data using \code{foldHumdrum}.
}
\section{From where to where}{


The \code{numeric} \code{fold} and \code{onto} arguments specify where to fold from/to.
\code{fold} indicates the Spine/Path/Stop to fold \emph{from}, "\emph{on to}" the Spine/Path/Stop
indicated by \code{onto}.
For example, if you specify \code{foldHumdrum(mydata, fold = 2, onto = 1, what = 'Spine')}
spine 2 will be folded "on top of" spine 1.
The \code{fold} and \code{onto} targets may not overlap.

The \code{fold} and \code{onto} arguments can be vectors of any length, which are interpreted in parallel:
for example, the combination \code{fold = 1:2} and \code{onto = 3:4} would map the first spine
to the third spine (\code{1 -> 3}) and the second spine to the 4th spine (\code{2 -> 4}).
If the \code{onto} targets are duplicated, the \code{fold} spines will be folded onto
multiple new fields: for example, the combination \code{fold = 1:2} and \code{onto = c(3, 3)} will
map first spine \emph{and} the second spine on to \emph{two} new fields of the third spine.
If the \code{fold} target is duplicated, the same \code{fold} spines can be copied onto multiple
\code{onto} spines: for example, the combination \code{fold = 1} and \code{onto = 2:3} will map the contents
of the first spine onto the second \emph{and} third spine, duplicating the spine-1 data.

The lengths of \code{fold} and \code{onto} are automatically matched, so
arguments like \code{fold = 1:2} and \code{onto = 3} are equivalent to \verb{fold = 1:2, onto = c(3, 3)}.
This makes it easy to do things like "copy all four spines onto spine 1":
just write \verb{fold = 2:4, onto = 1}.

To specify what structural field you want to fold across,
use the \code{what} argument (\code{character}, \code{length == 1}).
The default \code{what} value is \code{"Spine"}; other common fold options are \code{"Path"},
and \code{"Stop"}, though you might want to use the convenient \code{foldPaths()} and \code{foldStops()}
functions directly (details below).
(You may also fold across \code{"Record"} or \code{"DataRecord"}), but these are advanced/tricky!)
}

\section{Which fields}{


The \code{fromField} (\code{character}, \code{length == 1}) controls which field in the \code{fold}
spine/path/stop is folded into a new field.
The \code{fromField} argument defaults to the (first) \link[=selectedFields]{selected fields},
and must match (or \link[=partialMatching]{partially match}) a field in the \code{humdrumR} argument data set.
In some cases, the \code{fold} data is smaller than the \code{onto} data---for instance,
spine paths often only exist for part of a spine, so there is less data in the path
than in the full spine.
In these cases, it can be helpful to set \code{fillFromField == TRUE},
which causes the missing parts of \code{fold} to be filled with data from the \code{from}
field. \code{foldPaths} does this by default.

The resulting new fields will automatically be named as appropriate \code{Result}s fields.
The \code{newFieldNames} argument (\code{character}) can be used to control the output names:
one for each new field created by the fold.
If you specify too many \code{newFieldNames}, the later names are ignored.
If you specify too few \code{newFieldNames}, the later names will be given result names,
consistent with the default behavior.
}

\section{Piece-Specific Folding}{


By default, the same "fold" is carried out in each piece in the input corpus
(\code{humdrumR} argument).
If you need to specify different folds in different pieces, you have to specify the \code{Piece}
argument (\code{numeric}, whole number).
For \emph{every} piece in the corpus you want to apply folds to, you must specify all the \code{fold}
and \code{onto} arguments in parallel vectors with the \code{Piece} argument (even if this is reduendant
for some files).
For example, if we specify the combinations,\tabular{ccc}{
   \code{fold} \tab \code{onto} \tab \code{Piece} \cr
   \code{1} \tab \code{2} \tab \code{1} \cr
   \code{3} \tab \code{4} \tab \code{1} \cr
   \code{1} \tab \code{2} \tab \code{2} \cr
   \code{4} \tab \code{3} \tab \code{2} \cr
}


then
\itemize{
\item In \code{Piece} one:
\itemize{
\item the first spine is mapped to the second spine
\item the third spine is mapped to the fourth spine
}
\item In \code{Piece} two:
\itemize{
\item the first spine is mapped to the second spine
\item the fourth spine is mapped to the third spine
}
}

If any files in the corpus are not included, they will not be affected at all!
}

\section{Predefined folds}{


The convenient \code{foldStops()} and \code{foldPaths()} functions automatically fold \emph{all} stops/paths in a dataset
onto the first stop/path, creating new fields named, e.g., \code{Path1}, \code{Path2}, etc.
Another extremely useful function is \code{\link[=foldExclusive]{foldExclusive()}}, which automatically folds spines
based on their exclusive interpretation.
}

\seealso{
The \link[=collapseHumdrum]{collapse family of functions} serves a somewhat
similar function, "collapsing" data \emph{within} a field.

Other {Folding functions}: 
\code{\link{foldExclusive}()},
\code{\link{foldGraceNotes}()},
\code{\link{unfoldStops}()}

Other {Humdrum data reshaping functions}: 
\code{\link{collapseHumdrum}()},
\code{\link{expandPaths}()}
}
\concept{{Folding functions}}
\concept{{Humdrum data reshaping functions}}
