% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tonalInterval.R
\name{tonalIntervalS4}
\alias{tonalIntervalS4}
\alias{tint}
\alias{is.tonalInterval}
\title{Representation of tonal pitch information}
\usage{
tint(
  octave,
  LO5th = 0L,
  cent = numeric(length(octave)),
  partition = FALSE,
  Key = NULL,
  octave.round = floor
)

is.tonalInterval(x)
}
\description{
The \code{tonalInterval} is the core tonal pitch representation in \link[=humdrumR]{humdrumR}.
A \code{tonalInterval} is an abstract representation of tonal pitch, which can be translated to/from all standard
"concrete" pitch representations:
solfege, scientific pitch, semitones, frequencies, scale degrees, intervals, etc.
For the most part, users should not need to interact with \code{tonalInterval}s directly---rather, \code{tonalInterval}s work
behind the scene in numerous \code{humdrumR} pitch functions.
See the \link[=pitchFunctions]{pitch functions} and \link[=pitchParsing]{pitch parsing} documentation for
details on how \code{tonalIntervals} are used by \code{humdrumR}.
}
\section{Slots}{

\describe{
\item{\code{Octave}}{integers representing the octave offset.}

\item{\code{Fifth}}{integers representing the "line-of-fifths" value.}

\item{\code{Cent}}{numeric values representing cents (1200th of an octave).

The \code{tonalInterval} is a \href{http://adv-r.had.co.nz/S4.html}{S4} subclass of \code{humdrumR}'s virtual class \link{struct}, from which it inherits a lot of useful "vector-like" behaviors/functionality.}
}}

\section{Creating tonal intervals}{


Generally, \code{tonalIntervals} are created using the \code{\link[=tonalInterval]{tonalInterval()}} function, and its
various methods.
The \code{tonalInterval} \emph{function} is primarily a parser, \link[=pitchParsing]{documented elsewhere},
which interprets various input representations
and generates \code{tonalInterval} S4 \emph{objects} (documented here).

Alternatively, the constructor function \code{tint} can be used to directly create \code{tonalInterval} objects.
The three arguments to \code{tint} correspond to the three slots: \code{octave}, \code{LO5th} (Fifth), and \code{cent}.
All inputs will be coerced to match in length.
The \code{octave} argument can be left blank, in which case the appropriate octave will automatically be computed
to place the interval in the octave above .

By default, the \link[base:character]{as.character} method,
and thus (via \link{struct}) the \link[methods:show]{show} method, for \code{tonalInterval}s call \code{\link[=interval]{interval()}}.
Thus, if you return a \code{tonalInterval} on the command line
you'll see the \verb{**interval} representation printed.
\subsection{Predefined Intervals:}{

\code{humdrumR} automatically exports a bunch of \code{tonalInterval}s, named by their musical interval representation.
Every generic interval from 1 to 15 is combined with every interval quality \code{dd} (doubly diminished), \code{d} (diminished), \code{m} (minor), \code{M} (major), \code{A} (augumented)
\code{AA} (doubly augmented).
Thus, after loading \code{humdrumR}, you can type things like \code{M3 + M3} and get \code{A5}.
In addition, the variables \code{unison} (\verb{= P1 = tint(0, 0)}) and \code{pythagorean.comma} (\verb{= d2 = tint(-19,12)}) are exported as well.
}

\subsection{Arithmetic:}{

Technically, \code{tonalInterval}s are examples of algebraic \href{https://en.wikipedia.org/wiki/Module_(mathematics)}{modules over integers}.
This means that certain arithmetic operations are defined for \code{tonalIntervals} and can be called
using standard arithmetic operators (\code{+}, \code{-}, etc.):
\itemize{
\item Addition: \code{tonalIntervals} can be added together, acting exactly as you'd expect (i.e., \eqn{M3 + m3 = P5}).
\item Subtraction: \code{tonalIntervals} can be subtracted just as they are added. Also, they can be negated with a single \code{-}
operator (like \code{-M3}).
\item Multiplication: \code{tonalInterval}s can \emph{not} be multiplied together.
However, \href{https://en.wikipedia.org/wiki/Scalar_multiplication}{scalar (integer) multiplication} is defined:
thus, \code{tonalIntervals} can be multiplied by integers to create new \code{tonalInterval}s: e.g., \eqn{M2 * 3 = A4}.
\item Division: as the natural inverse of scale multiplication, \href{https://en.wikipedia.org/wiki/Euclidean_division}{Euclidean division}
is defined for \code{tonalIntervals}---i.e., division by/into whole (integer) pieces, often with leftover "remainders" (modulo).
In R, Euclidean division is achieved with the \link[base:Arithmetic]{\%/\%} operator---\emph{not} \code{/}---, with the associated \link[base:Arithmetic]{\%\%} used for the remainder/modulo.
Two \code{tonalInterval}s can be divided to produced an integer; Conversely, a \code{tonalInterval} can be divided by an integer to produce a \code{tonalInterval}.
}

Take note that the way \code{humdrumR} defines Euclidean division is based in \emph{tonal space}---i.e., the line-of-fifths---not
frequency or atonal-semitone space.
For example, an augmented-fourth divided by a major-second \emph{is} \code{3L}, but a diminished-fifth divided by
a major-second is \emph{not} 3L---\code{d5 \%/\% M2} equals \code{-3L} with a remainder of \code{P8} (plus an octave)!
The division algorithm works by applying standard Euclidean division to the \verb{@Fifth} slot (line-of-fifths tonal space), and shifting the \verb{@Octave} value in
the remainder to the match the appropriate octave.

If you attempt to do addition between a \code{tonalInterval} and non-\code{tonalInterval} atomic vector (e.g., \code{integer}, or \code{character}),
\code{humdrumR} will attempt to \href{https://en.wikipedia.org/wiki/Type_conversion}{coerce}
the other input to a \code{tonalInterval}, using the \code{\link[=tonalInterval]{tonalInterval()}} parser, do the math and then output the answer in
the original format (non-\code{tonalInterval}) format.
For instance, \code{M3 + 2} will interpret \code{2} as two semitones and add a major-second to the major-third, resulting in \code{6} semitones.
\link[=pitchDeparsing]{"In-place"} parsing/deparsing will be used, so "extra" characters in the input will be passed through.
For example, \verb{M3 + 4.ee-} will return \verb{4.gg}.
}

\subsection{Relational Operators}{

\code{tonalInterval}s can be compared using the standard \link[base:Comparison]{relational operations}---\code{==}, \code{!=}, \code{>}, \code{>=}, etc.
Two \code{tonalInterval}s are equal (according to \code{==}) only if all their slots (\code{Octave}, \code{Fifth}, and \code{Cent})
are exactly identical.
Thus, enharmonic notes (like C# and Db) are \emph{not} equal.
In contrast, ordinal comparisons (e.g., \code{>}, \code{<=}) between \code{tonalInterval}s are based on their semitone (equal temperament) size, so enharmonicity is irrelevant.
Thus, \code{m3 >= A2} and \code{A2 >= m3} are both \code{TRUE}, even though \code{m3 == A2} is not.
}
}

\examples{

M3 <- tint(   , 4L)

M2 <- tint(   , 2L)
M9 <- tint(-1L, 2L)

M9 - M2 
# = octave
M9 - 2L
# = 12

M3 \%/\% M2 
# = 2

"cc#]" + M6
# = "aa#]"

###

cMajor <- sort(tint( , -1:5))
eMajor <- cMajor + M3
eMajor + 2L 
# 6 8 10 11 13 15 17

eMajor[4:5] - P8
# = -m3 -m2



}
\seealso{
The main way to create \code{tonalInterval} S4 objects is with the \code{\link[=tonalInterval]{tonalInterval()}} pitch parser.
}
\concept{{core pitch representation}}
