% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Context.R
\name{hop}
\alias{hop}
\title{Generate regular sequence "along" input}
\usage{
hop(
  along.with,
  by = 1,
  from = 1L,
  to = NULL,
  value = FALSE,
  logical = FALSE,
  groupby = list()
)
}
\arguments{
\item{along.with}{\emph{\strong{The vector you want indices to "hop" along.}}

Must be a vector (either atomic, or a \code{list()}).}

\item{by}{\emph{\strong{The pattern of "hops" to to use.}}

Defaults to \code{1}: returning all indices \code{from:to}.

Must be one or more whole numbers.

\code{sum(by)} must non-zero.}

\item{from}{\emph{\strong{Where to start the sequence.}}

Defaults to \code{1}: starting from the first index.

Must be either a single natural number, a single \code{character} string, or
a \code{logical} vector the same length as \code{along.with}.

A \code{character}-string input is treated as a regular expression,
which is matched against \code{along.with} using \code{\link[=grepl]{grepl()}} to generate a \code{logical} vector.
The index of the first \code{TRUE} is used.}

\item{to}{\emph{\strong{Where to end the sequence.}}

Defaults to \code{NULL}.

Must be either \code{NULL}, a single natural number, a single \code{character} string, or
a \code{logical} vector the same length as \code{along.with}.

If \code{NULL}, \code{to} is set to the last index of \code{along.with} (or of each group in \code{groupby}).
A \code{character}-string input is treated as a regular expression,
which is matched against \code{along.with} using \code{\link[=grepl]{grepl()}} to generate a \code{logical} vector.
The index of the last \code{TRUE} is used.}

\item{value}{\emph{\strong{Should indices be returned as logical \code{TRUE}s?}}

Defaults to \code{FALSE}.

Must be a singleton \code{logical} value; an on/off switch.}

\item{groupby}{\emph{\strong{Optional vectors to group hop sequences within.}}

Defaults to empty \code{list()}.

Must be a \code{\link[=list]{list()}}, which is either empty or contains vectors which are all the same length as \code{along.with}.
In calls to \link[=withinHumdrum]{with/within.humdrumR}, \code{groupby} is passed \code{list(File, Spine, Path)} by default.}
}
\value{
By default, \code{hop()} returns an \code{integer} vector, appropriates indices for the \code{along.with} vector.
However, there are two other options:
\itemize{
\item If \code{logical = TRUE}, the indices are returned as a logical vector, the same length as \code{along.with},
with \code{TRUE} values indicating indices. Note that any ordering in the output (due to a mix of positive and negative
values in the \code{by} argument) is lost.
\item If \code{value = TRUE}, the actual indixed elements of the \code{along.with} vector are returned:
Thus, \code{hop(myvector, ..., value = TRUE)} is simply the same as \code{myvector[hop(myvector, ...)]}.
If \code{value = TRUE}, the \code{logical} argument is ignored.
}
}
\description{
\code{hop()} is similar to base R's \code{\link[=seq]{seq()}}, but with some additional features, including
special sugar when used with humdrumR's \code{\link[=context]{context()}} command.
\code{hop()} is used to create customizable sequences of indices for a vector;
for example, if you want to index every third value from a vector.
This is useful for, as when used with \code{\link[=context]{context()}}, defining the start points of "rolling-window"
analyses along a vector; the "hop size" is the gap between the start of each window,
defined by \code{hop()}'s \code{by} argument.
}
\details{
\code{hop()} has similar arguments to \code{\link[base:seq]{base::seq()}}, but focused on the \code{along.with} argument,
a vector which you'd like to generate indices for.
If you simply call \code{hop(myvector)}, the output will be the same as \code{1:length(myvector)}.
The \code{by} argument can be used to specify a different "hop" pattern: \code{by = 2} will get you \emph{every other}
index, \code{1}, \code{3}, \code{5}, \code{7}, etc.
Unlike \code{\link[base:seq]{base::seq()}}, \code{hop()}'s \code{by} argument can be a vector of numbers, allowing you to specify a pattern of hops.
For example, \code{by = c(2, 3)} will first hop \code{2}, then hop \code{3}, then repeat---so the output would be \code{1}, \code{3}, \code{6}, \code{8}, \code{11}, \code{13}, etc.

The by pattern can be comprised of negative numbers, or a mix of negative and positive numbers.
If \code{by} mixes negative and positive numbers, the pattern can hop up and down, as it climbs.
For example, you could go up two, then down one, then repeat using \code{by = c(2,-1)}.
If the pattern is \emph{overall} (sums) negative, the \code{from} argument must be greater than the \code{to} argument (see next section);
if the pattern sums to zero, an error occurs because the pattern would never end!
If a pattern changes directions, it is possible for pattern to hop outside the bounds of the vector;
if this happens, the outside indices return \code{NA}.
}
\section{Starting and Ending}{


By default, \code{hop()} builds indices from \code{1} to the end of the \code{along.with} vector.
The \code{from} and \code{to} arguments can be used to control this.
Either argument can simply be a natural number, indicating where to start and end the output sequences.
(If \code{to} is \code{NULL}, it is set to \code{length(along.with)}.)
An alternate approach is to provide either argument a single \code{character} string, which is treated as a regular
expression and matched against \code{along.with}, or  a \code{logical} vector the same length as \code{along.with}.
The first match/\code{TRUE} is used for the \code{from} index and the last match/\code{TRUE} for the \code{to} index.
This means you can say things like \code{from = Record == 33} in a \link[=withinHumdrum]{within()} call.

If the \code{by} argument is \emph{overall} (sums) positive, \code{from} must be less than \code{to}.
If the \code{by} argument is \emph{overall} (sums) negative, \code{from} must be greater than \code{to}.

If the \code{by} pattern doesn't ever actually the actual \code{to} index---perhaps jumping over it---
the output stops when it would \emph{pass} the \code{to}.
}

\section{Grouping}{


In many cases we want to how along vectors, but \emph{not across certain boundaries}.
For example, if we want all even numbered indices, we can set \code{by = 2} and \code{from = 2}.
However, if your vector includes data from multiple pieces, and some of the pieces have an odd number of data points,
our "even" sequence would end up hitting odd numbers in some pieces.
To get around this, the \code{groupby} argument indicates one, or more, grouping vectors, which break the \code{x} (input) argument
into groups.
If more than \code{groupby} vectors are given, a change in \emph{any} vector indicates a boundary.
Each grouped segement of \code{along.with} is treated just like a separate call to \code{hop()};
for example, if \code{from = 2}, the hop sequence will start on the second index of \emph{each} group.
However, the output indices still represent the original \code{along.with} indices.

Since \code{hop()} is usually used with \code{\link[=context]{context()}} to create rolling windows within musical parts,
we want typically want to apply \code{hop()} using using \code{groupby = list(File, Spine, Path)}.
In fact, \code{humdrumR} \link[=withinHumdrum]{with(in)} calls will \emph{automatically} feed these
three fields as \code{groupby} arguments to \code{hop()}.
So any use of \code{hop()} in a call to \link[=withinHumdrum]{with(in)}, will automatically generate the hop sequence
in a "melodic" way, within each spine path of each file.
}

\examples{
# use the built-in 'letters' vector

hop(letters)

hop(letters, by = 3)

hop(letters, by = 2, from = 4)

hop(letters, by = 2, from = 'e', to = 'x')

hop(letters, by = c(-1, 2), from = 'e', to = 'w', value = TRUE)

hop(letters, by = -1, from = 'z', to = 3)

}
