% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Rhythm.R
\name{ioi}
\alias{ioi}
\alias{ioi.default}
\alias{ioi.humdrumR}
\alias{sumTies.default}
\alias{sumTies.humdrumR}
\alias{sumTies}
\title{Sum "connected" durations}
\usage{
\method{ioi}{default}(
  x,
  onsets = !grepl("r", x) & !is.na(x) & x != ".",
  ...,
  finalOnset = FALSE,
  groupby = list(),
  parseArgs = list(),
  Exclusive = NULL,
  inPlace = TRUE
)

humData |> select(Token) |> ioi() 
humData |> ioi(Token)

ioi(
  x,
  onsets = !grepl("r", x) & !is.na(x) & x != ".",
  ...,
  finalOnset = FALSE,
  groupby = list(),
  parseArgs = list(),
  Exclusive = NULL,
  inPlace = TRUE
)

\method{sumTies}{default}(x, open = "[", close = "]", ..., groupby = list(), inPlace = TRUE)

humData |> select(Token) |> sumTies() 
humData |> sumTies(Token)

sumTies(x, open = "[", close = "]", ..., groupby = list(), inPlace = TRUE)
}
\arguments{
\item{x}{\emph{\strong{Input rhythm information.}}

The \code{x} argument can be any (\link[base:vector]{atomic}) vector, or \code{NULL}.

Must be \link[=rhythmParsing]{parsable as rhythm information}.}

\item{onsets}{\emph{\strong{A \code{logical} vector denotes the onsets.}}

Defaults to a \code{logical} vector with \code{TRUE} wherever there are rests, indicated by the presence of an \code{"r"} character, in the input \code{x}.

Must be \code{logical}; must be length \code{length(x)}.

All durations in \code{x} where \code{onsets == FALSE} are added to the previous value where \code{onsets == TRUE}.}

\item{finalOnset}{\emph{\strong{Whether to count the last onset.}}

Defaults to \code{FALSE}.

Must be a singleton \code{logical} value: an on/off switch.

If \code{TRUE}, the last IOI is computed between the last onset and the end of the input vector.
Otherwise, this last IOI is undefined (\code{NA}).}

\item{groupby}{\emph{\strong{A \code{list} of vectors to group \code{x}.}}

Defaults to \code{list()}.

Must be a \code{list}; every element of the list must be length \code{length(x)}.}

\item{parseArgs}{\emph{\strong{An optional list of arguments passed to the \link[=rhythmParsing]{rhythm parser}.}}

Defaults to an empty \code{list()}.

Must be a \code{list} of named arguments to the \link[=rhythmParsing]{rhythm parser}.}

\item{inPlace}{\emph{\strong{Should non-rhythm information be retained in the output string?}}

Defaults to \code{TRUE}.

Must be a singleton  \code{logical} value: an on/off switch.}

\item{open}{\emph{\strong{How are the beginnings of ties indicated in \code{x}?}}

Defaults to \code{[}.

Must be a single \code{character} string, interpreted as a regular expression.}

\item{close}{\emph{\strong{How are the ends of ties indicated in \code{x}?}}

Defaults to \verb{]}.

Must be a single \code{character} string, interpreted as a regular expression.}
}
\description{
These functions are used to sum (melodically) adjacent rhythmic duration values which are not associated with new onsets/attacks.
\code{ioi()} adds the duration of \href{https://en.wikipedia.org/wiki/Rest_(music)}{rests} to the previous
non-rest (onset) duration, to create \href{https://en.wikipedia.org/wiki/Time_point#Interonset_interval}{interonset intervals} (IOIs).
\code{sumTies()} sums \href{https://en.wikipedia.org/wiki/Tie_(music)}{tied} durations.

If \code{ioi()} is applied to a \link[=humdrumRclass]{humdrumR data class}
you may use the data's \link[=fields]{fields} as arguments.
If no field names are specified, the first \link{selectedField} is used as \code{x}.

If \code{sumTies()} is applied to a \link[=humdrumRclass]{humdrumR data class}
you may use the data's \link[=fields]{fields} as arguments.
If no field names are specified, the first \link{selectedField} is used as \code{x}.
}
\details{
Both functions return "collapsed" durations are as null data tokens.
For example, \code{sumTies(c('[4a', '4a]', '2g'))} returns \code{c('2a', '.', '2g')}, with the second (tied) duration null (\code{"."}).

For interonset intervals, the last duration in a string of durations is undefined---there is a final onset, but no \emph{next} onset, so there
can't really be a "interonset" interval.
Thus, by default, \code{ioi()} will return \code{NA} at the location of the final duration.
However, if the \code{finalOnset} argument is set to \code{TRUE}, the function will act like there is one additional onset \emph{after} the end of the sequence:
the last "IOI" is calculated between the last onset and this fictional "final onset."
For example, if we run \code{ioi(c('4.a','8r', '4.a','8r','2a', '2r'))} the result is \code{c("2a", ".", "2a", ".", NA, ".")},
with the last onset (\verb{2a}) returning \code{NA}.
However, if we run \code{ioi(c('4.a','8r', '4.a','8r','2a', '2r'), finalOnset = TRUE)} the result is \code{c("2a", ".", "2a", ".", "1a", ".")}---the
last onset's whole duration through the end is returned!

Non-onsets (rests) that occur \emph{before} the first onset are returned as null.
}
\examples{
tokens_withrests <- c('2c', '4d', '4e', '4r', '8f','8d#', '4r', '4e')

ioi(tokens_withrests)
ioi(tokens_withrests, finalOnset = TRUE)

tokens_withties <- c('2c', '4d', '[4e', '4e]', '8f','[8d#', '4d#]', '4e')

sumTies(tokens_withties) 

}
