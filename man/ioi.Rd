% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Rhythm.R
\name{ioi}
\alias{ioi}
\alias{untie}
\title{Sum "connected" durations}
\usage{
ioi(
  x,
  onsets = !grepl("r", x) & !is.na(x) & x != ".",
  ...,
  finalOnset = FALSE,
  groupby = list(),
  parseArgs = list(),
  Exclusive = NULL,
  inPlace = TRUE
)

untie(x, open = "[", close = "]", ..., groupby = list(), inPlace = TRUE)
}
\arguments{
\item{x}{An input vector which is parsed for duration information using the
\link[=rhythmParsing]{rhythm parser}. \code{max}, \code{median}, or \code{mode} might be reasonable alternatives.}

\item{onsets}{A \code{logical} vector of the same length as \code{x}. All durations in \code{x} where \code{onsets == FALSE}
are added to the previous value where \code{onsets == TRUE}.}

\item{finalOnset}{(\code{logical}, \code{length == 1}) If \code{TRUE}, the last IOI is computed between the last onset and the end of the input vector.
Otherwise, this last IOI is undefined (\code{NA}).}

\item{groupby}{A \code{list} of vectors, of the same length as \code{x}, which are used to group \code{x}.}

\item{parseArgs}{A \code{list} of arguments to pass to the \link[=rhythmInterval]{rhythm parser}.}

\item{inPlace}{(\code{logical}, \code{length == 1}) This argument only has an effect if the input (the \code{x} argument) is \code{character} strings,
\emph{and} there is extra, non-pitch information in the input strings "besides" the duration information.
If so, and \code{inPlace = TRUE}, the output will be placed into an output string beside the original non-duration information.
If \code{inPlace = FALSE}, only the rhythm output information will be returned.}

\item{open}{A \code{character} string (regular expression) to identify the beginning of ties.
(May also be formula: see \link{humWindows}.)}

\item{close}{A \code{character} string (regular expression) to identify the end of ties.
(May also be formula: see \link{humWindows}.)}
}
\description{
These functions are used to (melodically) adjacent sum rhythmic duration values which are not associated with new onsets/attacks.
\code{ioi()} adds the duration of \href{https://en.wikipedia.org/wiki/Rest_(music)}{rests} to the previous
non-rest (onset) duration, to create \href{https://en.wikipedia.org/wiki/Time_point#Interonset_interval}{interonset intervals} (IOIs).
\code{untie} sums \href{https://en.wikipedia.org/wiki/Tie_(music)}{tied} durations.
}
\details{
Both functions return "collapsed" durations are as null data tokens.
For example, \code{untie(c('[4a', '4a]', '2g'))} returns \code{c('2a', '.', '2g')}, with the second (tied) duration null (\code{"."}).

For interonset intervals, the last duration in a string of durations is undefined---there is a final onset, but no \emph{next} onset, so there
can't really be a "interonset" interval.
Thus, by default, \code{ioi()} will return \code{NA} at the location of the final duration.
However, if the \code{finalOnset} argument is set to \code{TRUE}, the function will act like there is one additional onset \emph{after} the end of the sequence:
the last "IOI" is calculated between the last onset and this fictional "final onset."
For example, if we run \code{ioi(c('4.a','8r', '4.a','8r','2a', '2r'))} the result is \code{c("2a", ".", "2a", ".", NA, ".")},
with the last onset (\verb{2a}) returning \code{NA}.
However, if we run \code{ioi(c('4.a','8r', '4.a','8r','2a', '2r'), finalOnset = TRUE)} the result is \code{c("2a", ".", "2a", ".", "1a", ".")}---the
last onset's whole duration through the end is returned!

Non-onsets (rests) that occur \emph{before} the first onset are returned as null.
}
