% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/humApply.R
\name{humApply}
\alias{humApply}
\title{humApply}
\usage{
humApply(humdrumR, expression, partition = list(), tee = FALSE,
  ngrams = NULL, windows = NULL, applyTo = "D", graphics = list())
}
\arguments{
\item{humdrumR}{A humdrumR data object.}

\item{expression}{A formula (or a function). If fed a function this function
is coerced to a formula as \code{~func(.)}.
The expression on the right side of the formula
is evaluated inside the humdrumR internal data.table (humtable). The left side of the formula
can be use as an alternative way of specifying other arguments to humApply (see details). 
There are a number of useful options and syntactic
treats which make these expressions extra powerful (see details).}

\item{partition}{A list of formulae in the format 
\preformatted{Keyword ~ Expression [~ Expr2 ~ Expr3 ~ ...]} (see details).
Known keywords are \code{by} and \code{where}.}

\item{tee}{A boolean. This controls whether the results of the expression application are
captured and incorporated into a new humdrumR data object. If \code{tee = TRUE}, the results are not
captured. This can be if you want to call a command for it's side-effects (i.e., plotting, writing a file), 
but don't want to keep the output.}

\item{ngrams}{An integer. This argument causes humApply to apply it's expression across ngrams in the data.
The integer specified is interpreted as the desired ngram length. If NULL, ngrams are not applied (the default).}

\item{windows}{An argument which allows you to specify more specific windows to apply within.}

\item{applyTo}{A string. Controls which type of tokens to apply expression to. Defaults to "D" (non-null data tokens).
Other options include "I" (interpretation tokens), "M" (measure tokens), and "C" (comment tokens).}

\item{graphics}{A list. Changes plotting settings within the scope of the humApply call. 
Useful when plotting within humApply. For instance, to specify that you want to create four plots in a 2x2
grid, specify \code{graphics = list(mfcol = c(2,2))}.}
}
\value{
A new humdrumR data object.
}
\description{
Apply arbitrary expressions to \code{\linkS4class{humdrumR}} data.
}
\section{Overview}{

This function is the primary means of working with
humdrumR data. It allows you to specify arbitrary 
expressions involving fields in a humdrumR data object.
It also includes a number of special application options:
\itemize{
  \item Applying an expression to separate subsets of the data.
  \item Applying an expression in only matching parts of the data.
  \item Applying an expression across windows in the data (e.g., ngrams, rolling windows).
}
}

\section{Applying expressions}{

The \code{expression} argument should be a formula. The expression on the 
right side of this formula is evaluate within the humdrumR data object. The expression
can, thus, refer to any field in the humdrumR object (Record, Token, File, etc.). 
You can also include a \code{.} anywhere in the expression, which will be 
interpreted as the humdrumR object's default \code{\link[dest=humdrumR]{Active}} 
expression.
Examples:
\preformatted{
humdata <- readHumdrum('directorywithdata/*.krn') # read some data

humApply(humdata, ~getPitch(Token)) # The most basic pattern
humApply(humdata, ~getPitch(.)) # Same as previous (unless \code{Active} field has been changed))

humApply(humdata, ~solfa(getPitch(Token), key = Key)) 
# Assumes that the Key field was parsed during the call to \code{\link{readHumdrum}}

humApply(humdata, ~getSemits(Token) - mean(getSemits(Token))) 
}
}

\section{Partitioning}{

The \code{partition} argument is used to either apply the expression separately to 
subsets of the data (for instance, applying a function to each file in the data) or
to apply the expression to only a part of the data (for instance, only Spine 3).
The first case is specified with the keyword \code{by}; the second, with the 
keyword \code{where}. Desired partitions are specified as a list of formulae, 
each formatted 

\preformatted{Keyword ~ Expression [~ Expr2 ~ Expr3 ~ ...]}

Each partition expression is evaluated with in the \code{humdrumR} data object. 
Most commonly, the partition expression is simply a field in the data: 
for instance, 
\preformatted{humApply(humdata,
                       expression,
                       partition = list(by ~ File))} 
will cause the \code{expression}
\code{humApply} is applying to be applied separately to each file in the 
humdrumR data. Similarly, 
\preformatted{humApply(humdata, expression,
                       partition = list(by ~ File ~ Spine))} 
will cause application across each file \emph{and} each spine. We can also do 
creative things like

\preformatted{humApply(humdata, expression,
                       partition = list(by ~ Spine > 3 | Record \%\% 2 == 0))}
                       
which will break the data into two groups, one where either the spine number is 
three or less \emph{or} the record number is even, and another group where the opposite is true. 

The \code{where} keyword differs from the \code{by} keyword as so: 
the partition expression associated with the \code{where} keyword must 
evaulate to a boolean (TRUE or FALSE), and the function is only applied 
to data fields where the where expression is \code{TRUE}. Wherever the 
where expression evaluates to \code{FALSE}, the original humdrumR data is 
returned unchanged.

The list of partitionaing formulae in the \code{partition} argument are applied
recursively, in order from left to right. Thus if you specify
\preformatted{humApply(humdata,
                       expression,
                       partition = list(by ~ File, where ~ semits > mean(semits)))}
the application \code{expression} will only be applied to data tokens where
the \code{semits} field is greater than the mean \code{semits} value
\emph{within that file}. Contrast this with this call:
\preformatted{humApply(humdata,
                       expression,
                       partition = list(where ~ semits > mean(semits), by ~ File))} 
wherein the \code{expression} is applied, again, across files, but only
where the semits field is greater than the mean value \emph{across all the data}.
}

\section{Tandem interpretations}{

The function \code{\link{readHumdrum}} automatically parses
tandem interpretations (that it recognizes) in read humdrum data into
their own fields. For instance, data with a \code{'*clefF4'} will show
up as a \code{Clef} field. However, users might read humdrum data with their
own custom tandem interpretations that are not built into \code{humdrumR}.
\code{humdrumR} includes the function \code{\link{getTandem}} to help us
extract arbitrary tandem intrpretation data.
Luckily, \code{humApply} knows some
 \href{https://en.wikipedia.org/wiki/Syntactic_sugarsyntactic}{syntactic sugar}
which makes it easy to do this anywhere in our \code{expression} argument.
In your expression, simply put a named object beginning with the 
symbol \code{*}. Of course, R doesn't normally 
allow names to begin with symbols like \code{*}, but you can force it by
placing grave symbols around the name \code{`*name`}. If you do this in your
\code{expression} argument, \code{humApply} will treat this name as a 
regular expression and create a call \code{getTandem(Tandem, regular expression)}.
This means you can could do something like 
\preformatted{humApply(humdata, ~myFunction(Token, `*mytandempattern`))}
and \code{myFunction} will be called with the first argument being the 
\code{Token} field, and the second argument being tandem interpretations
which match \code{'mytandempattern'} (extracted from the \code{Tandem} field).
}

\section{Splatting}{

"Splatting" refers to feeding a function a list or vector of arguments.
Sometimes we want to divide our data into pieces (a l\'a \code{partition} option), but
rather than applying the same expression to each piece, we want to feed
the separate pieces as separate arguments to the same function.

In \code{humApply} you can use some 
\href{https://en.wikipedia.org/wiki/Syntactic_sugarsyntactic}{syntactic sugar}
to do just this, using the \code{@} symbol in the format \code{myFunction(TargetExpr@GroupingExpr)}.
If we make this call
\preformatted{
humApply(humData, 
         ~myFunction(Token@Spine))
}
and  there are four spines
this is how \code{humApply} will intepret the \code{expression}:
\preformatted{
humApply(humData,
         ~myFunction(Token[Spine == 1], # first argument when Spine == 1
                     Token[Spine == 2], # second argument when Spine == 2
                     Token[Spine == 3], # etc.
                     Token[Spine == 4])) 
}

#' @section Argument specification:
If desired, all arguments to humApply except for \code{humdrumR} and \code{expression}
can be specified in the left hand side of the \code{expression} formula.
For this to work, the left hand side of \code{expression} must contain a list
of formulas, each specifying a keyword (argument) and value/expression.
For instance,
\preformatted{
humApply(humdata, ~table(.), partition = list(by ~ Spine))
}
and
\preformatted{
humApply(humdata, list(by ~ Spine) ~ table(.))
}
are equivalent.
If arguments are specified in the formula, they supercede arguments fed to the function.
This feature is useful for saving more complex combinations of expressions and arguments.
}

\examples{
humdata <- readHumdrum('directorywithdata/*.krn')

humApply(humdata, ~nchar(.)) # counts characters in each data token.
humApply(humdata, ~table(.), partition = list(by ~ Spine)) # Tabulates data tokens in each Spine.

}
