% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Distributions.R
\name{count}
\alias{count}
\alias{count.default}
\alias{count.humdrumR}
\alias{pdist}
\title{Tabulate and/or cross-tabulate data}
\usage{
\method{count}{default}(..., sort = FALSE, na.rm = FALSE, .drop = FALSE, binArgs = list())

\method{count}{humdrumR}(x, ..., sort = FALSE, na.rm = FALSE, .drop = FALSE, binArgs = list())

pdist(
  x,
  ...,
  condition = NULL,
  na.rm = FALSE,
  sort = FALSE,
  .drop = FALSE,
  binArgs = list()
)
}
\description{
The \code{count()} function can be used to tabulate unique values in a vector, or cross-tabulate
combinations of values across multiple vectors of the same length.
This is similar to R's fundamental \link[base:table]{table()} function,
except it returns a specialized \code{data.frame} (\link{distribution} object) instead of an \code{array}.
HumdrumR \code{count()} methods also give special treatment to \code{\link[=token]{token()}} data
and to numeric data.

The \code{pdist()} function is identical to \code{count()}, except it produces (empirical) probability \link[=distribution]{distributions},
simply by dividing by the sum of all counts or, if a \code{condition} is indicated, the marginal sums across one or more dimensions.
The later case produces a conditional probability distribution.
The function of \code{pdist()} is similar to using \code{\link[base:proportions]{base::prop.table()}}.
}
\details{
The \code{count()} function is defined in the \link[dplyr:count]{dplyr} package, but only
for working with \link[=tibble]{tibbles}.
In \code{humdrumR}, we extend the \code{count()} function to work with atomic data (like \code{\link[base:table]{base::table()}})
as well as \link[=humdrumRclass]{humdrumR data}.
When \code{humdrumR} is attached, \code{\link[dplyr:count]{dplyr::count()}} will only be called for \code{\link[=tibble]{tibble()}} objects specifically.
Note that \code{\link[dplyr:count]{dplyr::count()}} doesn't have all the same arguments or behaviors as \code{humdrumR}'s \code{count()}
methods, which are described in \emph{this} documentation.

HumdrumR \code{count()} and \code{pdist()} methods return special \link{distribution} objects, with each input vector
creating one dimension in the distribution.
When applied to atomic vectors, \code{humdrumR::count()} will use the deparsed expression(s)
provided to it as the name for each vector/dimension (similar to \code{base::table(..., dnn = 2)}).
You can override this by specifying dimension names directly as argument names, like \code{count(Kern = kern(Token))};
if you don't specify a name, \code{count()} will make up a name(s) based on expression(s) it is tallying.

The \code{sort} argument can be used to sort the output distribution, just like passing it to the \code{sort()} function.
Thus, \code{count(x) |> sort()} is identical to \code{count(x, sort = TRUE)}.
If you want to sort the output in reverse (ascending), specify \code{sort = -1}.
Thus, \code{count(x) |> sort(decreasing = FALSE)} is also identical to \code{count(x, sort = -1)}.

If \code{count()} or \code{pdist()} are applied directly to a \link[=humdrumRclass]{humdrumR data object},
you can specify any fields in the data as arguments.
If you don't specify any fields, the \link[=selectedFields]{selected} field(s) will be passed and tabulated.
}
\section{NAs and zeros}{


HumdrumR \code{count()} methods will, by default, count \code{NA} values if they are present---if you don't want
to count \code{NA}s, specify \code{na.rm = TRUE}.

By default, \code{count()} will include counts of known levels of variables, even if they are zero.
This can happen if the data are \link[base:factor]{factors} or \link[=token]{tokens}, where all possible levels
are embedded in the data.
When cross-tabulating multiple vectors, zeroes can also occur for any atomic type
if certain combinations never occur.
To drop zeros from the output distribution, specify \code{count(.drop = TRUE)}.
(Note that \code{dplyr::count()} drops levels by default.)
}

\section{Tabulating numeric values}{


For numeric values, especially real numbers, it is often the case that there are few (or no) exact values that
occur more than once, so tabulating unique values is pointless.
In these cases, we might prefer to count numbers into corresponding to ranges of numbers, like in a histogram,
and this is exactly what \code{count()}/\code{pdist()} (can) do.

By default, if you pass a vector of numbers which has more than \code{20} unique values,
the numbers will be binned using the same algorithm as \code{\link[graphics:hist]{graphics::hist()}}.
This process can be controlled using the \code{binArgs} argument, which is itself a list of control arguments.
\code{binArgs = list(maxUnique = N)} controls the number of unique numbers needed before binning occurs (\code{20} by default).
\code{binArgs = list(right = FALSE)} (default is \code{TRUE}) controls whether are closed on the right (larger numbers) instead of the left.
Finally, additional arguments to \code{\link[graphics:hist]{graphics::hist()}} can be passed via \code{binArgs}, controlling how binning occurs: notably,
you can use the \verb{binArgs = list(breaks = _)} to control exactly where boundaries should occur, or the number of bins you want.
For example, \code{binArgs = list(breaks = 10)} will make \code{count()} bin the input numbers into twelve bins (see \code{\link[=hist]{hist()}}
for details).

Alternatively, you can tell \code{count()} to divy up (bin) the input numbers into quantiles by
passing \code{binArgs = list(quantiles = N)}.
For example, \code{binArgs = list(quantiles = 4)} will divide the data into four equal quantiles (0\%-25\%, 25\%-50\%, 50\%-75\%, 75\%-100\%).
In the resulting tables, all the counts/proportions will be the same, but you can see what the quantile ranges would be.

Note that this binning process will also be applied to integer values, if there are more than \code{maxUnique} unique integers.
If you ever want to force \code{count()}/\code{pdist()} to (not) do numeric binning, coerce your input to \code{character}.
For example, \code{count(as.character(myNumbers))}.
}

\section{Coersion/conversion}{


The \code{humdrumR} \link{distribution} class can be converted to and from R's base \link[base:table]{table}.
Count and probability distributions cannot also be converted between.
All you do is call the appropriate function(s).
What this means is that, for example
\itemize{
\item \code{count(x) |> table()} is the same as \code{table(x)}
\item \code{table(x) |> count(na)} is the same as \code{count(x, na.rm = TRUE)}
\item \code{count(x) |> pdist()} is the same as \code{pdist(x)}
\item \code{pdist(x) |> count() |> table()} is the same as \code{count(x) |> table()}
\item etc.
}
}

\section{Conditional probability}{

}

\examples{

generic <- c('c', 'c', 'e', 'g', 'a', 'b', 'b', 'b', NA)
complex <- c('c', 'c#', 'e', 'f', 'g','g#', 'g#', 'a', 'a##')

count(generic)
count(generic, na.rm = TRUE)
count(complex)



count(generic, complex)
count(generic, complex, sort = TRUE)
count(generic, complex, sort = -1)
count(generic, complex, sort = -1, na.rm = TRUE)
count(generic, complex, sort = -1, .drop = TRUE)

# Dimension names
count(Generic = generic, X = complex)

# HumdrumR data
\dontrun{
  humData <- readHumdrum(humdrumRroot, "HumdrumData/BachChorales/.*.krn")

  humData |> kern() |> count()
  humData |> mutate(Kern = kern(Token), Recip = recip(Token)) |> count()
  humData |> mutate(Kern = kern(Token),  Recip = recip(Token)) |> count(Recip, sort = TRUE)
  humData |> mutate(Kern = kern(Token),  Recip = recip(Token)) |> select(Recip) |> count()
}

# Numeric values

real <- rnorm(1000)

count(real)
count(real, binArgs = list(breaks = 40))
count(real, binArgs = list(breaks = 40, right = FALSE))
count(real, binArgs = list(quantiles = 4))

int <- sample(100, 30, replace = TRUE)

count(int)
count(int, binArgs = list(maxUnique = 50))
count(int, binArgs = list(maxUnique = 5))

}
