% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Distributions.R
\name{count}
\alias{count}
\alias{count.default}
\alias{count.humdrumR}
\alias{pdist}
\title{Tabulate and/or cross-tabulate data}
\usage{
\method{count}{default}(..., sort = FALSE, na.rm = FALSE, .drop = FALSE, binArgs = list())

\method{count}{humdrumR}(x, ..., sort = FALSE, na.rm = FALSE, .drop = FALSE, binArgs = list())

pdist(
  x,
  ...,
  condition = NULL,
  na.rm = FALSE,
  sort = FALSE,
  .drop = FALSE,
  binArgs = list()
)
}
\arguments{
\item{...}{\emph{\strong{Values to count.}}

Either one or more vectors of equal length, a \link[=humdrumRclass]{humdrumR object},
or a \link[=table]{table}.}

\item{sort}{\emph{\strong{Should the output table be sorted?}}

Defaults to \code{FALSE}.

Either a single \code{logical} value (on or off), or a single numeric value.

Positive values (or \code{TRUE}) lead to decreasing sort (top to bottom);
Negative values lead to increasing sort;
Zero or \code{FALSE} lead to no sort.}

\item{na.rm}{\emph{\strong{Should \code{NA} values be removed (not counted)?}}

Defaults to \code{FALSE}.

Must be singleton \code{logical} value: an on/off switch.

If \code{TRUE}, \code{NA} values are not counted.}

\item{.drop}{\emph{\strong{Should missing levels be dropped (not counted as zeros)?}}

Defaults to \code{FALSE}. (This is opposite of \link[dplyr:count]{dplyr's} default.)

Must be singleton \code{logical} value: an on/off switch.

If \code{TRUE}, missing factor levels and/or missing combinations of values
are \emph{not} counted in the output table.
If \code{FALSE}, these values are included in the output table (as zeros).}

\item{binArgs}{\emph{\strong{List of arguments to pass to numeric binning algorithm.}}

Defaults to empty \code{list()}.

Possible list arguments include any arguments to \code{\link[=hist]{hist()}}, as well as:
\itemize{
\item \code{maxUnique} (single whole number), defaulting to \code{20}.
\item \code{right} (single \code{logical}), defaulting to \code{TRUE},
\item \code{quantiles} (single whole number), defaulting to \code{0} (no quantiles).
}

Note that the \code{binArgs} argument has no effect if the input (\code{...}) are not numbers.}
}
\description{
The \code{count()} function can be used to tabulate unique values in a vector, or cross-tabulate
combinations of values across multiple vectors of the same length.
This is similar to R's fundamental \link[base:table]{table()} function,
except it returns a specialized \code{data.frame} (\link{distribution} object) instead of an \code{array}.
HumdrumR \code{count()} methods also give special treatment to \code{\link[=token]{token()}} data
and to numeric data.

The \code{pdist()} function is identical to \code{count()}, except it produces (empirical) probability \link[=distribution]{distributions},
simply by dividing by the sum of all counts or, if a \code{condition} is indicated, the marginal sums across one or more dimensions.
The later case produces a conditional probability distribution.
The function of \code{pdist()} is similar to using \code{\link[base:proportions]{base::prop.table()}}.
}
\details{
The \code{count()} function is defined in the \link[dplyr:count]{dplyr} package, but only
for working with \link[=tibble]{tibbles}.
In \code{humdrumR}, we extend the \code{count()} function to work with atomic data (like \code{\link[base:table]{base::table()}})
as well as \link[=humdrumRclass]{humdrumR data}.
When \code{humdrumR} is attached, \code{\link[dplyr:count]{dplyr::count()}} will only be called for \code{\link[=tibble]{tibble()}} objects specifically.
Note that \code{\link[dplyr:count]{dplyr::count()}} doesn't have all the same arguments or behaviors as \code{humdrumR}'s \code{count()}
methods, which are described in \emph{this} documentation.

HumdrumR \code{count()} and \code{pdist()} methods return special \link{distribution} objects, with each input vector
creating one dimension in the distribution.
When applied to atomic vectors, \code{humdrumR::count()} will use the deparsed expression(s)
provided to it as the name for each vector/dimension (similar to \code{base::table(..., dnn = 2)}).
You can override this by specifying dimension names directly as argument names, like \code{count(Kern = kern(Token))};
if you don't specify a name, \code{count()} will make up a name(s) based on expression(s) it is tallying.

The \code{sort} argument can be used to sort the output distribution, just like passing it to the \code{sort()} function.
Thus, \code{count(x) |> sort()} is identical to \code{count(x, sort = TRUE)}.
If you want to sort the output in reverse (ascending), specify \code{sort = -1}.
Thus, \code{count(x) |> sort(decreasing = FALSE)} is also identical to \code{count(x, sort = -1)}.

If \code{count()} or \code{pdist()} are applied directly to a \link[=humdrumRclass]{humdrumR data object},
you can specify any fields in the data as arguments.
If you don't specify any fields, the \link[=selectedFields]{selected} field(s) will be passed and tabulated.
}
\section{NAs and zeros}{


HumdrumR \code{count()} and \code{pdist()} methods will, by default, count \code{NA} values if they are present---if you don't want
to count \code{NA}s, specify \code{na.rm = TRUE}.

By default, \code{count()} and \code{pdist()} will include all known levels of input variables, even if those levels don't occur
(they are counted as zero).
This can happen if the input includes \link[base:factor]{factors} or \link[=token]{tokens}, which have their known levels attached to
them.
Zeros can also occur for any atomic type when cross-tabulating multiple vectors, if certain combinations of values
never occur.
To drop zeros from the output distribution, specify .drop = TRUE\verb{. (Note that }dplyr::count()\verb{drops levels by default, but}r hm` functions do not.=)
}

\section{Tabulating numeric values}{


For numeric values, especially real numbers, it is often the case that there are few (or no) exact values that
occur more than once, so tabulating unique values is pointless.
In these cases, we might prefer to count numbers into corresponding to ranges of numbers, like in a histogram,
and this is exactly what \code{count()}/\code{pdist()} (can) do.

By default, if you pass a vector of numbers which has more than \code{20} unique values,
the numbers will be binned using the same algorithm as \code{\link[graphics:hist]{graphics::hist()}}.
This process can be controlled using the \code{binArgs} argument, which is itself a list of control arguments.
\code{binArgs = list(maxUnique = N)} controls the number of unique numbers needed before binning occurs (\code{20} by default).
\code{binArgs = list(right = FALSE)} (default is \code{TRUE}) controls whether are closed on the right (larger numbers) instead of the left.
Finally, additional arguments to \code{\link[graphics:hist]{graphics::hist()}} can be passed via \code{binArgs}, controlling how binning occurs: notably,
you can use the \verb{binArgs = list(breaks = _)} to control exactly where boundaries should occur, or the number of bins you want.
For example, \code{binArgs = list(breaks = 10)} will make \code{count()} bin the input numbers into twelve bins (see \code{\link[=hist]{hist()}}
for details).

Alternatively, you can tell \code{count()} to divy up (bin) the input numbers into quantiles by
passing \code{binArgs = list(quantiles = N)}.
For example, \code{binArgs = list(quantiles = 4)} will divide the data into four equal quantiles (0\%-25\%, 25\%-50\%, 50\%-75\%, 75\%-100\%).
In the resulting tables, all the counts/proportions will be the same, but you can see what the quantile ranges would be.

Note that this binning process will also be applied to integer values, if there are more than \code{maxUnique} unique integers.
If you ever want to force \code{count()}/\code{pdist()} to (not) do numeric binning, coerce your input to \code{character}.
For example, \code{count(as.character(myNumbers))}.
}

\section{Coersion/conversion}{


Count and probability distributions, as well as base R \link[base:table]{tables}
can be freely converted between using the \code{count()}, \code{pdist()}, and \code{table()} functions.
What this means is that, for example:
\itemize{
\item \code{count(x) |> table()} is the same as \code{table(x)}
\item \code{table(x) |> count()} is the same as \code{count(x, na.rm = TRUE)}
\item \code{count(x) |> pdist()} is the same as \code{pdist(x)}
\item \code{pdist(x) |> count() |> table()} is the same as \code{count(x) |> table()}
\item etc.
}
}

\section{Conditional probability}{


By default, \code{pdist(x)} produces a table which is essentially identical to \code{count(x) / length(x)}, or
\code{count(x, y, ...) / length(x)} for multi-dimensional arrays.
This means the default is the \href{https://en.wikipedia.org/wiki/Marginal_distribution}{marginal probability} (for one variable)
or the \href{https://en.wikipedia.org/wiki/Joint_probability_distribution}{joint probability} (for more than one variables).

If more than variables are present, \code{pdist()} can also the
\href{https://en.wikipedia.org/wiki/Conditional_probability_distribution}{conditional probabilities}, conditioned
on one or more of the variable.
(There can be \code{K - 1} conditions, where \code{K} is the total number of variables.)
Conditions can be expressed as either natural numbers (indicating which variable(s) to condition on
in their input order) or as character strings exactly matching dimension names.
Thus, if we call something like \code{pdist(X = x, Y = y)}, we could condition on the \code{y} variable \emph{either}
by saying \code{pdist(X = x, Y = y, condition = 2)} or \code{pdist(X = x, Y = y, condition = "Y")}.
}

\examples{

generic <- c('c', 'c', 'e', 'g', 'a', 'b', 'b', 'b', NA)
complex <- c('c', 'c#', 'e', 'f', 'g','g#', 'g#', 'a', 'a##')

count(generic)
count(generic, na.rm = TRUE)
count(complex)



count(generic, complex)
count(generic, complex, sort = TRUE)
count(generic, complex, sort = -1)
count(generic, complex, sort = -1, na.rm = TRUE)
count(generic, complex, sort = -1, .drop = TRUE)

# Dimension names
count(Generic = generic, X = complex)

# HumdrumR data
\dontrun{
  humData <- readHumdrum(humdrumRroot, "HumdrumData/BachChorales/.*.krn")

  humData |> kern() |> count()
  humData |> mutate(Kern = kern(Token), Recip = recip(Token)) |> count()
  humData |> mutate(Kern = kern(Token),  Recip = recip(Token)) |> count(Recip, sort = TRUE)
  humData |> mutate(Kern = kern(Token),  Recip = recip(Token)) |> select(Recip) |> count()
}

# Numeric values

real <- rnorm(1000)

count(real)
count(real, binArgs = list(breaks = 40))
count(real, binArgs = list(breaks = 40, right = FALSE))
count(real, binArgs = list(quantiles = 4))

int <- sample(100, 30, replace = TRUE)

count(int)
count(int, binArgs = list(maxUnique = 50))
count(int, binArgs = list(maxUnique = 5))

}
