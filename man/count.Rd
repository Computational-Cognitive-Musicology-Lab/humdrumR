% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Metric.R
\name{count}
\alias{count}
\alias{subpos}
\alias{onbeat}
\title{Count beats or measures}
\usage{
count(
  dur,
  beat = rational(1L),
  start = 1L,
  phase = 0,
  pickup = NULL,
  offBeats = TRUE,
  groupby = list()
)

subpos(
  dur,
  beat = rational(1L),
  phase = 0,
  pickup = NULL,
  deparser = duration,
  ...,
  groupby = list()
)

onbeat(dur, beat = rational(1L), groupby = list(), ...)
}
\arguments{
\item{dur}{\emph{\strong{An input vector of rhythmic durations.}}

Must be a \code{character} or \code{numeric} vector.

Is parsed using \code{\link[=rhythmInterval]{rhythmInterval()}};
Wherever the input can't be parsed as a duration,
that element is treated as a duration of zero.}

\item{beat}{\emph{\strong{The size of "beat" (or measure) to count.}}

Defaults to a whole-note (one measure of 4/4 time).

Must be a \code{character} or \code{numeric} vector, or a list of such vectors;
must be a singleton or the same length as \code{dur}.

Is parsed as a duration using \code{\link[=rhythmInterval]{rhythmInterval()}};
If the input can't be parsed as a duration, the output will be all \code{NA}.}

\item{start}{\emph{\strong{The number to start counting from.}}

Must be a single whole-number value (either \code{numeric} or \code{integer}).}

\item{phase}{\emph{\strong{The phase offset between onsets and beats.}}

Defaults to \code{0}.

Must be a \code{character} or \code{numeric} vector; must be length \code{1} or the same length as \code{dur};
The duration of \code{phase} must be smaller than the smallest duration value in \code{beat}.

Is parsed as a duration using \code{\link[=rhythmInterval]{rhythmInterval()}};
If the input can't be parsed as a duration, an error occurs.}

\item{pickup}{\emph{\strong{Indicates which leading values in the input are pickups, if any.}}

Defaults to \code{NULL}.

Must be \code{NULL}, or a \code{logical} vector of the same length as \code{dur}.}

\item{offBeats}{\emph{\strong{Should off-beat onsets be numbered in the output, or \code{NA}?}}

Defaults to \code{TRUE}.

Must be a single \code{logical} value: an on/off switch.}

\item{groupby}{\emph{\strong{Optional vectors to group by and count within.}}

Defaults to empty \code{list()}.

Must be a \code{\link[=list]{list()}}, which is either empty or contains vectors which are all the same length as \code{dur}.
To function as a by-record timeline, the \code{groupby} list must include a \emph{named} \code{Piece} and \code{Record} vectors.
Luckily, these are automatically passed by \link[=withinHumdrum]{with(in).humdrumR}, so you won't need to worry about it!}
}
\description{
The \code{count()} function takes a vector of rhythmic duration values and
counts (in the musical sense) the number of \emph{beats} (or \emph{measures}) which have occurred since the starting point,
associating each rhythmic onsets with a beat.
The \code{subpos()} function is paired with \code{count()}, computing how far (in rhythmic time) each onset is from its
associated beat; if \code{subpos()} returns \code{0}, this means that an onset is \emph{on} the beat.
Finally, \code{onbeat()} is simply a convenient shorthand for \code{subpos() == 0}, returning
a \code{logical} vector for indicating where onsets fall on or off beat.
}
\details{
In many basic use cases, using \code{count()} is essentially the same as using \code{floor(timeline())}.
However, \code{count()} gives us a few additional options which add musicological power compared to \code{\link[=timeline]{timeline()}}.
(\code{count()} also starts from \code{1} not \code{0}, as \code{\link[=timeline]{timeline()}} does.)

The first beat in an input vector is assigned the value of the \code{start} argument, which defaults to \code{start = 1L}.
There is no 'zeroth' count, as the first beat occurs at the instant of the starting time---i.e., the first onset in the input vector.
Every rhythmic onset is associated with one beat, but multiple onsets may occur within the same beat---thus
the output of \code{count()} assigns (rounds) each onset to the previous beat onset.
However, if \code{offBeats = FALSE}, only onsets that \emph{land} on a beat are counted, with offbeat values returning \code{NA}.

The \code{phase} controls how offbeat onsets are associated with nearby beats.
\code{phase} is \link[=rhythmParsing]{parsed} as a rhythmic value and must be rhythmic values that are smaller than the smallest \code{beat} value.
The \code{phase} argument shifts the "boundary" between beats backwards, before the beat onset.
By default, \code{phase = 0} so the beat-association boundary lands on the beat: only onsets on or after each beat "belong" to that beat.
If \code{phase = '8'}, the beat boundary is pushed back to capture one eighth-note \emph{before} the beat itself.
This can be used to, for example, associate the last 3/8s of a measure with the next measure (like pick ups);
This could be achieved with a command like \code{count(dur, beat = '1', phase = 3/8)}.
}
\section{"Beats"}{


The \code{beat} argument is used to indicate what size of beat you want to count.
The default \code{beat} is a whole note, equivalent to a measure of \code{M4/4} time.
The \code{beat} argument uses the \link[=rhythmInterval]{rhythm parser}, so it can understand beat values input in a variety of formats:
thus, you could specify quarter-note beats as either \code{beat = '4'} or \code{beat = 0.25}.
The parser also understands how to parse the (full) duration of time signature: for example, \code{beat = 'M3/4'} would use a dotted-half-note beat (\code{'2.'}).
\subsection{Changing meter}{

If your data has changing meters (either between pieces, or within pieces), you can specify
the \code{beat} argument as a vector which is the same length as \code{dur}, indicating the
beat size at each moment/index.
This feature is very easy to use with any dataset that includes time signature interpretations, like \code{"*M4/4"};
these interpetations, if present, are automatically \link[=readHumdrum]{read into} a field called \code{TimeSignature}.
For such a dataset, you can simply pass the \code{TimeSignature} field to the \code{beat} argument of \code{count()}, and
the measures of the piece will be correctly counted (even when changing!): \code{count(x, beat = TimeSignature)}.
Alternatively, you can use the \code{\link[=tactus]{tactus()}} command to extract the tactus beat from a time signature, like \code{count(x, beat = tactus(TimeSignature))}.
}

\subsection{Irregular meter}{

Some musical meters consist of a pattern of irregular beats.
For example, the meter \code{M7/8} is often realized as two "short" beats (two eigth-notes each) and one "long" beat (three eigth-notes), forming a 2 + 2 + 3 pattern.
If we want to count each eighth-note, we can simply specify \code{beat = '8'} and get the \code{M7/8} beats counted as c(\code{1}, \code{3}, \code{5}).
However, if we want to count each short \emph{or} long beat as a single unit, we must specify the desired pattern as a \code{list} of beat durations: for example, \code{beat = list(c("4", "4", "4."))}.
Let's see what these two cases look like, applied to two \code{M7/8} measures of straight eighth-notes:\preformatted{rhythm <- rep('8', 14)

count(rhythm, beat = '8'),

# output is: 1  2  3  4  5  6  7  8  9 10 11 12 13 14

count(rhythm, beat = list(c('4', '4', '4.')))

# output is: 1 1 2 2 3 3 3 4 4 5 5 6 6 6
}

To accommodate changing meters, the \code{beat} argument can still accept \code{list} of such patterns, so long as the list is the same length as \code{dur}.
}
}

\section{Pickups}{


Another option is to pass the \code{pickup} argument a logical vector of the same length as the input \code{dur}.
Within each piece/group, any block of \code{TRUE} values at the \emph{beginning} of the \code{pickup} vector
indicate a pickup.
The \emph{first} index where the \code{pickup} logical is \code{FALSE} is used as the location of beat \code{1}:
all the earlier (\code{pickup == TRUE}) points will be negative counts, counting backwards from the start.
In \code{humdrumR}, and datapoints before the first barline record (\code{=}) are labeled \code{Bar == 0} in the \code{Bar} \link[=fields]{field}.
Thus, a common use for the \code{pickup} argument is \verb{within(humData, count(Token, pickup = Bar < 1)}, which makes the downbeat of
the first complete bar \code{1} the stating point---any notes in pickup bars are give negative counts.

\strong{Note that there is never a 'beat zero'.}
Beats before the starting point progress directly from \code{-1} to \code{1} (the start).
As a result, doing arithmetic or other math with beat "counts" can be problematic when using a \code{pickup} argument.
It may be better to use \code{round(timeline())} in cases where you want to do much math with counts.
}

\examples{

humData <- readHumdrum(humdrumRroot, "HumdrumData/BachChorales/chor00[1-4].krn")

show(within(humData, count(Token, beat = TimeSignature, pickup = Bar < 1)))

show(within(humData, count(Token, beat = tactus(TimeSignature))))
 
  
}
\seealso{
{\code{count()} and \code{subpos()} are closely related to the \code{\link[=timeline]{timeline()}} function. The \code{\link[=metcount]{metcount()}} function applies \code{count()} within a metric framework.}
}
