% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tools.R
\name{delta}
\alias{delta}
\alias{delta.default}
\alias{delta.matrix}
\title{Lagged differences}
\usage{
delta(x, lag, skip, init, right, ...)

\method{delta}{default}(
  x,
  lag = 1,
  skip = is.na,
  init = as(NA, class(x)),
  right = FALSE,
  boundaries = list(),
  ...
)

\method{delta}{matrix}(x, margin = 2L, ...)
}
\arguments{
\item{x}{Any numeric vector. \code{NULL} values are returned \code{NULL}.}

\item{lag}{(nonzero integer) Which lag to use. Results will look like: \code{x[i] - x[i - lag]}.}

\item{skip}{(\code{function}) This must be a function which can be applied to \code{x} and returns a logical vector
of the same length. And \code{TRUE} values are skipped over in the differences/sums.
By default, the \code{skip} function is \code{is.na}, so \code{NA} values in the input (\code{x} argument) are skipped.
The skipped values are returned as is in the output vector.}

\item{init}{(atomic value of same class as \code{x}, with \code{length(init) <= lag})}

\item{right}{(single \code{logical} value) Should the \code{init} padding be at the "right" (end of the vector)?
By default, \code{right == FALSE} so the \code{init} padding is at the beginning of the output.}

\item{boundaries}{(vector of same length as \code{x}, or a list of such vectors) Differences are not calculated
across groups indicated by the \code{boundaries} vector(s).}
}
\description{
Calculate sequential differences of values in numeric vectors.
}
\details{
\code{delta} is very similar base \code{R} \code{\link[=diff]{diff()}}.
However, \code{delta} should be favored in \link{humdrumR} use because:
\enumerate{
\item Its output is \emph{always} the same length as its  input.
This is achieved by padding the beginning or end of the output with---by default---\code{NA} values.
\item It has a \code{boundaries} argument, which is \emph{automatically} used by \code{humdrumR} \link[=withinHumdrum]{with(in)}
commands to constrain the differences within files/spines/paths of \code{humdrum} data.
The \code{boundaries} approach (details below) is generally faster than applying the commands within \code{groupby} groups.
\item They (can) automatically skip \code{NA} (or other) values.
}

If applied to a matrix, \code{delta} is applied separately to each column, unless \code{margin} is set to \code{1} (rows)
or, if you have a higher-dimensional array, a higher value.
}
\section{Initial/padding values}{
Each lagged pair of numbers in the vector is summed/subtracted.
This leaves \code{abs(lag)} numbers at the end with nothing to pair with them.
For example, \code{lag == 1}, the indices which are getting subtracted look like this:
\itemize{
\item \eqn{x_1 - x_?}
\item \eqn{x_2 - x_1}
\item \eqn{x_3 - x_2}
\item \eqn{x_4 - x_3}
\item \eqn{x_5 - x_4}
}

If \code{lag == 3}:
\itemize{
\item \eqn{x_1 - x_?}
\item \eqn{x_2 - x_?}
\item \eqn{x_3 - x_?}
\item \eqn{x_4 - x_1}
\item \eqn{x_5 - x_2}
}

The \code{init} argument (for "initial") is a value, or values, to pair with the first \code{lag} values.
By default, \code{init} is \code{NA}, and since \code{n + NA} or \code{n - NA} are themselves, \code{NA}, the output vector is
padded with \code{NA} values. For \code{lag == 3} again:
\itemize{
\item \eqn{x_1 - NA}
\item \eqn{x_2 - NA}
\item \eqn{x_3 - NA}
\item \eqn{x_4 - x_1}
\item \eqn{x_5 - x_2}
}

However, if the \code{init} argument can between 1 and \code{abs(lag)} numeric values.
The result, for \code{lag==3} is:
\itemize{
\item \eqn{x_1 - init_1}
\item \eqn{x_2 - init_2}
\item \eqn{x_3 - init_3}
\item \eqn{x_4 - x_1}
\item \eqn{x_5 - x_2}
}

If \code{right == TRUE}, the \code{init} values are placed at the end, like:
\itemize{
\item \eqn{x_4 - x_1}
\item \eqn{x_5 - x_2}
\item \eqn{init[1] - x_3}
\item \eqn{init[2] - x_4}
\item \eqn{init[3] - x_5}
}

The \code{init} argument functions similarly to the \code{init} argument of \code{\link[=Reduce]{Reduce()}}.
}

\section{Negative lag}{
If \code{lag} is negative, the differences are simply reversed, resulting in the same numbers as the
equivalent positive lag, but \verb{* -1}.
\itemize{
\item \eqn{x_1 - NA}
\item \eqn{x_2 - x_1}
\item \eqn{x_3 - x_2}
\item \eqn{x_4 - x_3}
\item \eqn{x_5 - x_5}
}

to
\itemize{
\item \eqn{NA - x_1}
\item \eqn{x_1 - x_2}
\item \eqn{x_2 - x_3}
\item \eqn{x_3 - x_4}
\item \eqn{x_4 - x_5}
}
}

\section{Boundaries}{
In many cases we want to calculate sequential differences in a vector, but not across certain boundaries.
For example, we don't want to calculate the difference between the first note in one file and the last
note of the previous file!
The \code{boundaries} argument indicates one, or more, grouping vectors, which break the \code{x} (input) argument
into groups.
If more than \code{boundaries} vectors are given, a change in \emph{any} vector indicates a boundary.
(\code{boundaries} are evaluated using the \code{\link[=changes]{changes()}} function, so you can also pass the argument \code{any = FALSE}
if you want their only to boundaries where \emph{all} boundary vectors change.)

Differences which cross between groups are compared to the \code{init} value(s).
Basically, using boundaries should be essentially identical to using \code{tapply(x, boundaries, delta, ...)},
except generally faster when the number of groups is large.

\code{humdrumR} \link[=withinHumdrum]{with(in)} calls will automatically feed the \code{File}, \code{Spine}, and \code{Path}
fields as three \code{boundaries} vectors, anywhere you use \code{delta}.
This is the most common, "melodic" use case.
However, if you wanted, for instance, to calculate differences across spines (like harmonic intervals)
you could manually set \code{boundaries = list(File, Record)}.
}

\concept{interval calculus functions}
