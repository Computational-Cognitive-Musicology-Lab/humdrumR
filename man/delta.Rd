% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tools.R
\name{delta}
\alias{delta}
\alias{delta.default}
\alias{delta.matrix}
\title{Lagged differences}
\usage{
delta(x, lag, skip, init, right, ...)

\method{delta}{default}(
  x,
  lag = 1,
  skip = is.na,
  init = as(NA, class(x)),
  right = FALSE,
  groupby = list(),
  orderby = list(),
  ...
)

\method{delta}{matrix}(x, margin = 2L, ...)
}
\arguments{
\item{x}{\emph{\strong{The input vector.}}

Must be \code{atomic} numbers.

\code{NULL} values are returned \code{NULL}.}

\item{lag}{\emph{\strong{Which lag to use.}}

Defaults to \code{1}.

Must be a single natural number.

Results will look like: \code{x[i] - x[i - lag]}.}

\item{skip}{\emph{\strong{A function to indicate which values to skip.}}

Defaults to \code{is.na}.

This must be a \code{function} which can be applied to \code{x} to return a \code{logical} vector
of the same length. \code{TRUE} values are skipped over in the calculations.
By default, the \code{skip} function is \code{is.na}, so \code{NA} values in the input (\code{x} argument) are skipped.
The skipped values are returned as is in the output vector.}

\item{init}{\emph{\strong{Initial value to fill the beginning for calculation.}}

Defaults to \code{0}.

Should be the same class as \code{x}; length must be not longer than \code{lag}.

\code{NA} values at the beginning
(or end of \code{right == TRUE}) are filled with these values \emph{before} summing.}

\item{right}{\emph{\strong{Should the \code{init} padding be at the "right" (end of the vector)?}}

Defaults to \code{FALSE}.

Must be a singleton \code{logical} value: an on/off switch.

By default, \code{right == FALSE} so the \code{init} padding is at the beginning of the output.}

\item{groupby}{\emph{\strong{How to group the data.}}

Defaults to \code{list()}.

Should be \code{vector} or \code{list} of \code{vectors}; must be length \code{length(x)}.

Differences are not calculated
across groups indicated by the \code{groupby} vector(s).}

\item{orderby}{\emph{\strong{The order for calculating the difference.}}

Defaults to \code{list()}.

Should be \code{vector} or \code{list} of \code{vectors}; must be length \code{length(x)}.

Differences in \code{x} are calculated
based on the order of \code{orderby} vector(s), as determined by \code{\link[base:order]{base::order()}}.}
}
\description{
Calculate sequential differences of values in numeric vectors.
}
\details{
\code{delta} is very similar base-\code{R} \code{\link[=diff]{diff()}}.
However, \code{delta} should be favored in \link{humdrumR} use because:
\enumerate{
\item Its output is \emph{always} the same length as its  input.
This is achieved by padding the beginning or end of the output with1 \code{NA} values (or other options).
\item It has a \code{groupby} argument, which is \emph{automatically} used by \code{humdrumR} \link[=withinHumdrum]{with(in)}
commands to constrain the differences within files/spines/paths of \code{humdrum} data.
The \code{groupby} approach (details below) is generally faster than applying the commands within \code{groupby} groups.
\item They (can) automatically skip \code{NA} (or other) values.
}

If applied to a matrix, \code{delta} is applied separately to each column, unless \code{margin} is set to \code{1} (rows)
or, if you have a higher-dimensional array, a higher value.
}
\section{Initial/padding values}{
Each lagged pair of numbers in the vector is summed/subtracted.
This leaves \code{abs(lag)} numbers at the end with nothing to pair with them.
For example, \code{lag == 1}, the indices which are getting subtracted look like this:
\itemize{
\item \eqn{x_1 - x_?}
\item \eqn{x_2 - x_1}
\item \eqn{x_3 - x_2}
\item \eqn{x_4 - x_3}
\item \eqn{x_5 - x_4}
}

If \code{lag == 3}:
\itemize{
\item \eqn{x_1 - x_?}
\item \eqn{x_2 - x_?}
\item \eqn{x_3 - x_?}
\item \eqn{x_4 - x_1}
\item \eqn{x_5 - x_2}
}

The \code{init} argument (for "initial") is a value, or values, to pair with the first \code{lag} values.
By default, \code{init} is \code{NA}, and since \code{n + NA} or \code{n - NA} are themselves, \code{NA}, the output vector is
padded with \code{NA} values. For \code{lag == 3} again:
\itemize{
\item \eqn{x_1 - NA}
\item \eqn{x_2 - NA}
\item \eqn{x_3 - NA}
\item \eqn{x_4 - x_1}
\item \eqn{x_5 - x_2}
}

However, if the \code{init} argument can between 1 and \code{abs(lag)} numeric values.
The result, for \code{lag==3} is:
\itemize{
\item \eqn{x_1 - init_1}
\item \eqn{x_2 - init_2}
\item \eqn{x_3 - init_3}
\item \eqn{x_4 - x_1}
\item \eqn{x_5 - x_2}
}

If \code{right == TRUE}, the \code{init} values are placed at the end, like:
\itemize{
\item \eqn{x_4 - x_1}
\item \eqn{x_5 - x_2}
\item \eqn{init[1] - x_3}
\item \eqn{init[2] - x_4}
\item \eqn{init[3] - x_5}
}

The \code{init} argument functions similarly to the \code{init} argument of \code{\link[=Reduce]{Reduce()}}.
}

\section{Negative lag}{
If \code{lag} is negative, the differences are simply reversed, resulting in the same numbers as the
equivalent positive lag, but \verb{* -1}.
\itemize{
\item \eqn{x_1 - NA}
\item \eqn{x_2 - x_1}
\item \eqn{x_3 - x_2}
\item \eqn{x_4 - x_3}
\item \eqn{x_5 - x_5}
}

to
\itemize{
\item \eqn{NA - x_1}
\item \eqn{x_1 - x_2}
\item \eqn{x_2 - x_3}
\item \eqn{x_3 - x_4}
\item \eqn{x_4 - x_5}
}
}

\section{Grouping}{


In many cases we want to perform lagged calculations in a vector, but \emph{not across certain boundaries}.
For example, if your vector includes data from multiple pieces, we wouldn't want to calculate melodic intervals
between pieces, only within pieces.
The \code{groupby} argument indicates one, or more, grouping vectors, which break the \code{x} (input) argument
into groups.
If more than \code{groupby} vectors are given, a change in \emph{any} vector indicates a boundary.

Value pairs which cross between groups are treated as if they were at the beginning.
Basically, using the \code{groupby} argument to a function should be
similar or identical to using \code{tapply(x, groupby, laggedFunction, ...)} or using a \code{groupby}
expession in a call to \link[=withinHumdrum]{with(in).humdrumR}.
However, using a \code{groupby} argument directly is usually much faster, as they have been
specially optimized for this functions.

The most common use case in humdrum data, is looking at "melodies" within spines.
For this, we want \code{groupby = list(File, Spine, Path)}.
In fact, \code{humdrumR} \link[=withinHumdrum]{with(in)} calls will \emph{automatically} feed these
three fields as \code{groupby} arguments to certain functions: mint, delta, sigma, lag, ditto, ioi, untie, or hop.
So any use of \code{delta} in a call to \link[=withinHumdrum]{with(in)}, will automatically calculate the \code{delta}
in a "melodic" way, within each spine path of each file.
However, if you wanted, for instance, to calculate differences across spines (like harmonic intervals)
you could manually set \code{groupby = list(File, Record)}.
}

\section{Order}{


When performing lagged calculations, we typically assume that the order of the values in the input vector
(\code{x}) is the order we want to "lag" across.
E.g., the first element is "before" the second element, which is "before" the third element, etc.
[Humdrum tables][humTable] are always ordered \verb{File > Piece > Spine > Path > Record > Stop}.
Thus, any lagged calculations across fields of the humtable will be, by default, "melodic":
the \emph{next} element is the next element in the spine path.
For example, consider this data:\preformatted{**kern  **kern
a       d
b       e
c       f
*-      *-
}

The default order of these tokens (in the \code{Token} field) would be \verb{a b c d e f}.
If we wanted to instead lag across our tokens \emph{harmonically} (across records) we'd need to specifiy a different order
For example, we could say \code{orderby = list(File, Record, Spine)}---the lagged function
would interpret the \code{Token} field above as \verb{a d b e c f}.

For another example, note \code{Stop} comes last in the order.
Let's consider what happens then if here are stops in our data:\preformatted{**kern  **kern
a       d
b D     e g
c A     f a
*-      *-
```

The default ordering here (`File > Spine > Record > Stop`) "sees" this in the order `a b D c A d e g f a`.
That may or may not be what you want!
If we wanted, we could reorder such that `Stop` takes precedence over `Record`: `orderby = list(File, Spine, Stop, Record)`.
The resulting order would be `a b c d e f D G g a`.

   

[humTable]: R:humTable
}
}

\section{Invertability}{


The \code{sigma} and \code{delta} functions are inverses of each other, meaning that with the right arguments set,
\code{sigma(delta(x)) == x} and \code{delta(sigma(x)) == x}.
In other words, the two functions "reverse" each other.
The key is that the \code{init} argument needs to be set to \code{0}, and all other
arguments (\code{lag}, \code{skip}, \code{groupby}, etc.) need to match.
So \emph{actually},  \code{sigma(delta(x, init = 0, ...)) == x} and \verb{delta(sigma(x), init = 0)) == x}.

When we take the differences between values (\code{delta(x)}), the resulting differences can't tell us
fully how to reconstruct the original unless we know where to "start" (a constant offset).
For example,
\itemize{
\item \code{delta(c(5, 7, 5, 6)) == c(NA, 2, -2, 1)}
}

We know our input goes up 2, back down 2, then up 1, but the starting value (the first \code{5})
is lost.
If we call sigma on this, we'll get:
\itemize{
\item \code{sigma(c(NA, 2, -2, 1)) == c(0, 2,0, 1)}
}

We get the right contour, but we're offset by that constant \code{5}.

If we call \code{delta(x, init = 0)} the necessary constant (the first value) is kept at the beginning of the vector
\itemize{
\item \code{delta(c(5, 7, 5, 6), init = 0) == c(5, 2, -2, 1)}
}

so \code{sigma} gets what we want, full invertability:
\itemize{
\item \code{sigma(delta(c(5, 7, 5, 6), init = 0)) == c(5, 7, 5, 6)}
}

Alternatively, we could specify the necessary constant as the \code{init} argument of \code{sigma}:
\itemize{
\item \code{sigma(delta(c(5, 7, 5, 6)), init = 5) == c(5, 7, 5, 6)}
}

so the \code{init} arguments of the two functions are complementary.

Currently, the \code{right} argument of \code{delta} has no complement in \code{sigma}, so invertability
only holds true if \code{right = FALSE} (the default).
}

\seealso{
This function's inverse is \code{\link[=sigma]{sigma()}}.

Other {Lagged vector functions}: 
\code{\link{ditto}()},
\code{\link{int}()},
\code{\link{lag}()},
\code{\link{sigma}()}
}
\concept{{Lagged vector functions}}
