% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tools.R
\name{delta}
\alias{delta}
\alias{delta.default}
\alias{delta.matrix}
\title{Lagged differences}
\usage{
delta(x, lag, skip, init, right, ...)

\method{delta}{default}(
  x,
  lag = 1,
  skip = is.na,
  init = as(NA, class(x)),
  right = FALSE,
  groupby = list(),
  ...
)

\method{delta}{matrix}(x, margin = 2L, ...)
}
\arguments{
\item{x}{(Any numeric vector.) \code{NULL} values are returned \code{NULL}.}

\item{lag}{(Non-zero integer.) Which lag to use. Results will look like: \code{x[i] - x[i - lag]}.}

\item{skip}{(\code{function}.) This must be a function which can be applied to \code{x} and returns a logical vector
of the same length. And \code{TRUE} values are skipped over in the calculations.
By default, the \code{skip} function is \code{is.na}, so \code{NA} values in the input (\code{x} argument) are skipped.
The skipped values are returned as is in the output vector.}

\item{init}{(Atomic value of same class as \code{x}, with \code{length(init) <= lag}.) \code{NA} values at the beginning
(or end of \code{right == TRUE}) are filled with these values \emph{before} summing.}

\item{right}{(single \code{logical} value) Should the \code{init} padding be at the "right" (end of the vector)?
By default, \code{right == FALSE} so the \code{init} padding is at the beginning of the output.}

\item{groupby}{(vector of same length as \code{x}, or a list of such vectors) Differences are not calculated
across groups indicated by the \code{groupby} vector(s).}
}
\description{
Calculate sequential differences of values in numeric vectors.
}
\details{
\code{delta} is very similar base-\code{R} \code{\link[=diff]{diff()}}.
However, \code{delta} should be favored in \link{humdrumR} use because:
\enumerate{
\item Its output is \emph{always} the same length as its  input.
This is achieved by padding the beginning or end of the output with1 \code{NA} values (or other options).
\item It has a \code{groupby} argument, which is \emph{automatically} used by \code{humdrumR} \link[=withinHumdrum]{with(in)}
commands to constrain the differences within files/spines/paths of \code{humdrum} data.
The \code{groupby} approach (details below) is generally faster than applying the commands within \code{groupby} groups.
\item They (can) automatically skip \code{NA} (or other) values.
}

If applied to a matrix, \code{delta} is applied separately to each column, unless \code{margin} is set to \code{1} (rows)
or, if you have a higher-dimensional array, a higher value.
}
\section{Initial/padding values}{
Each lagged pair of numbers in the vector is summed/subtracted.
This leaves \code{abs(lag)} numbers at the end with nothing to pair with them.
For example, \code{lag == 1}, the indices which are getting subtracted look like this:
\itemize{
\item \eqn{x_1 - x_?}
\item \eqn{x_2 - x_1}
\item \eqn{x_3 - x_2}
\item \eqn{x_4 - x_3}
\item \eqn{x_5 - x_4}
}

If \code{lag == 3}:
\itemize{
\item \eqn{x_1 - x_?}
\item \eqn{x_2 - x_?}
\item \eqn{x_3 - x_?}
\item \eqn{x_4 - x_1}
\item \eqn{x_5 - x_2}
}

The \code{init} argument (for "initial") is a value, or values, to pair with the first \code{lag} values.
By default, \code{init} is \code{NA}, and since \code{n + NA} or \code{n - NA} are themselves, \code{NA}, the output vector is
padded with \code{NA} values. For \code{lag == 3} again:
\itemize{
\item \eqn{x_1 - NA}
\item \eqn{x_2 - NA}
\item \eqn{x_3 - NA}
\item \eqn{x_4 - x_1}
\item \eqn{x_5 - x_2}
}

However, if the \code{init} argument can between 1 and \code{abs(lag)} numeric values.
The result, for \code{lag==3} is:
\itemize{
\item \eqn{x_1 - init_1}
\item \eqn{x_2 - init_2}
\item \eqn{x_3 - init_3}
\item \eqn{x_4 - x_1}
\item \eqn{x_5 - x_2}
}

If \code{right == TRUE}, the \code{init} values are placed at the end, like:
\itemize{
\item \eqn{x_4 - x_1}
\item \eqn{x_5 - x_2}
\item \eqn{init[1] - x_3}
\item \eqn{init[2] - x_4}
\item \eqn{init[3] - x_5}
}

The \code{init} argument functions similarly to the \code{init} argument of \code{\link[=Reduce]{Reduce()}}.
}

\section{Negative lag}{
If \code{lag} is negative, the differences are simply reversed, resulting in the same numbers as the
equivalent positive lag, but \verb{* -1}.
\itemize{
\item \eqn{x_1 - NA}
\item \eqn{x_2 - x_1}
\item \eqn{x_3 - x_2}
\item \eqn{x_4 - x_3}
\item \eqn{x_5 - x_5}
}

to
\itemize{
\item \eqn{NA - x_1}
\item \eqn{x_1 - x_2}
\item \eqn{x_2 - x_3}
\item \eqn{x_3 - x_4}
\item \eqn{x_4 - x_5}
}
}

\section{Boundaries}{


In many cases we want to perform lagged calculations in a vector, but \emph{not across certain boundaries}.
For example, if your vector includes data from multiple pieces, we wouldn't want to calculate melodic intervals
between pieces, only within pieces.
The \code{groupby} argument indicates one, or more, grouping vectors, which break the \code{x} (input) argument
into groups.
If more than \code{groupby} vectors are given, a change in \emph{any} vector indicates a boundary.

Value pairs which cross between groups are treated as if they were at the beginning.
Basically, using groupby should be essentially identical to using \code{tapply(x, groupby, laggedFunction, ...)},
except generally faster when the number of groups is large.

The most common use case in humdrum data, is looking at "melodies" within spines.
For this, we want \code{groupby = list(File, Spine, Path )}.
In fact, \code{humdrumR} \link[=withinHumdrum]{with(in)} calls will \emph{automatically} feed these
three fields as \code{groupby} arguments to certain functions: mint, hint, delta, sigma, lag, or ditto.
Do any use of \code{delta} in a call to \link[=withinHumdrum]{with(in)}, will automatically calculate the \code{delta}
in a "melodic" way, within each spine path of each file.
However, if you wanted, for instance, to calculate differences across spines (like harmonic intervals)
you could manually set \code{groupby = list(File, Record)}.
}

\section{Invertability}{


The \code{sigma} and \code{delta} functions are inverses of each other, meaning that with the right arguments set,
\code{sigma(delta(x)) == x} and \code{delta(sigma(x)) == x}.
In other words, the two functions "reverse" each other.
The key is that the \code{init} argument needs to be set to \code{0}, and all other
arguments (\code{lag}, \code{skip}, \code{groupby}, etc.) need to match.
So \emph{actually},  \code{sigma(delta(x, init = 0, ...)) == x} and \verb{delta(sigma(x), init = 0)) == x}.

When we take the differences between values (\code{delta(x)}), the resulting differences can't tell us
fully how to reconstruct the original unless we know where to "start" (a constant offset).
For example,
\itemize{
\item \code{delta(c(5, 7, 5, 6)) == c(NA, 2, -2, 1)}
}

We know our input goes up 2, back down 2, then up 1, but the starting value (the first \code{5})
is lost.
If we call sigma on this, we'll get:
\itemize{
\item \code{sigma(c(NA, 2, -2, 1)) == c(0, 2,0, 1)}
}

We get the right contour, but we're offset by that constant \code{5}.

If we call \code{delta(x, init = 0)} the necessary constant (the first value) is kept at the beginning of the vector
\itemize{
\item \code{delta(c(5, 7, 5, 6), init = 0) == c(5, 2, -2, 1)}
}

so \code{sigma} gets what we want, full invertability:
\itemize{
\item \code{sigma(delta(c(5, 7, 5, 6), init = 0)) == c(5, 7, 5, 6)}
}

Alternatively, we could specify the necessary constant as the \code{init} argument of \code{sigma}:
\itemize{
\item \code{sigma(delta(c(5, 7, 5, 6)), init = 5) == c(5, 7, 5, 6)}
}

so the \code{init} arguments of the two functions are complementary.

Currently, the \code{right} argument of \code{delta} has no complement in \code{sigma}, so invertability
only holds true if \code{right = FALSE} (the default).
}

\seealso{
This function's inverse is \code{\link[=sigma]{sigma()}}.

Other {Lagged vector functions}: 
\code{\link{ditto}()},
\code{\link{lag}()},
\code{\link{sigma}()},
\code{\link{xint}()}
}
\concept{{Lagged vector functions}}
