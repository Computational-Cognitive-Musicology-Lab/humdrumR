% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Reshape.R
\name{cleave}
\alias{cleave}
\alias{pivot_wider.humdrumR}
\alias{cleaveSpines}
\alias{cleavePaths}
\alias{cleaveStops}
\title{Align data from separate spines into new fields.}
\usage{
cleave(humdrumR, ..., field = selectedFields(humdrumR)[1], newFields = NULL)

pivot_wider.humdrumR(
  data,
  names_from = "Spine",
  values_from = selectedFields(data)[1]
)

cleaveSpines(humdrumR, field = selectedFields(humdrumR)[1])

cleavePaths(humdrumR, field = selectedFields(humdrumR)[1])

cleaveStops(humdrumR, field = selectedFields(humdrumR)[1])
}
\arguments{
\item{humdrumR}{\emph{\strong{HumdrumR data.}}

Must be a \link[=humdrumRclass]{humdrumR data object}.}

\item{...}{\emph{\strong{What to cleave?}}

Must be natural numbers, \code{character} strings representing exclusive interpretations, or lists of either.}

\item{field}{\emph{\strong{Which field cleave data from.}}

Defaults to first \link[=selectedFields]{selected field}.

Must be a \code{character} string \link[=partialMatching]{partially} matching the name of a data field in the \code{humdrumR} input.
For example, \code{"Tok"} would match the \code{Token} field.}

\item{newFields}{\emph{\strong{Names to use for new fields created by the cleave.}}

By default generates names by structure/number (like \code{Spine2}) or exclusive interpretation (like \code{Silbe}).

Must be non-empty \code{character} string.}
}
\description{
Cleave, as in "to cleave together," moves data from separate spines (or paths) into
new fields in the \emph{same} spine(s).
Under the hood, \code{cleave()} essentially runs a specialized call to make the \link[=humTable]{humdrum table}
"wider," similar to R functions like \link[=reshape2]{cast()}, \link[=tidyr]{spread()}, or \link[=tidyr]{pivot_wider()}.
In fact, a humdrumR method for \link[=tidyr]{pivot_wider()} is defined, which is equivalent to \code{cleave()}.
The \code{cleave()} function is essentially the inverse of \code{\link[=rend]{rend()}}.
}
\details{
Many humdrum datasets encode data across multiple spines, spine-paths, or stops.
By default, \code{humdrumR} parses each separate spine, spine-path, and stop as their own individual
data points, taking up one row in the \link[=humTable]{humdrum table}.
If we want to treat data in multiple spines/paths/stops as different aspects of the same data
it is easiest to reshape the data so that the information is in different humdrumR \link[=fields]{fields}
rather than separate spines/paths/stops.
In the humdrum syntax view, the spines (or path/stops) are moved "on top" of each other, cleaving them
together.

The convenient \code{cleaveSpines()}, \code{cleaveStops()}, and \code{cleavePaths()} functions automatically cleave \emph{all} stops/paths in a dataset
onto the first spine/stop/path, creating new fields named, e.g., \code{Path1}, \code{Path2}, etc.
\subsection{Syntax}{

The \code{cleave()} function takes any number of \code{...} arguments specifying \emph{groups} of spines/paths/stops
to cleave together.
\itemize{
\item \code{cleave(humData, Spine = 1:2)} will cleave the first and second spine.
\item \code{cleave(humData, Spine = 1:4)} will cleave the first four spines.
\item \code{cleave(humData, Spine = 1:2, Spine = 3:4)} will cleave spine 1 with spine 2, and separately, spine 3 with spine 4.
}

The default is to cleave spines, so you can actually omit the \verb{Spine = } part: e.g., \code{cleave(humData, 1:2)} is the same
as \code{cleave(humData, Spine = 1:2)}.
If you want to cleave spine paths, you'll need to explicitly call something like \code{cleave(humData, Path = 0:1)}.
The \emph{first} element in each group is used as the original location which all other spines/paths/stops are cleaved into.
The ordering of the remaining elements is irrelevant.
\subsection{Piece-specific cleaving}{

By default, the same cleaving will be applied in all pieces (if the pieces \emph{have} the target spines/paths/stops).
However, you can use an alternate argument structure to apply differerent cleaves to different pieces.
To do so, provide groups to cleave arguments in a list, with each element in the list representing cleave group
in one piece.
If the listed groups are unnamed, the groups are mapped to pieces by index.
For example, the call \code{cleave(humData, list(1:2, 2:3, 3:4, NULL, 1:3))} will result in the following cleaves:
\itemize{
\item In piece 1, cleave spines 1 and 2.
\item In piece 2, cleave spines 2 and 3.
\item In piece 3, cleave spines 3 and 4.
\item In piece 4, no cleave (no changes).
\item In piece 5, cleave the first three spines.
\item In any remaining pieces (6 or greater), no cleaves.
}

Alternatively, you can name the list elements with integers corresponding to pieces.
For example, \verb{cleave(humData, Path = list("1" = 0:1, 5 = 0:2"))} will cleave paths 0 and 1 in
piece 1, and paths \code{0:2} in piece 5.
}

\subsection{Exclusive interpretations}{

When cleaving spines, you can specify spines using character strings representing exclusive interpretations.
So you can call \code{cleave(humData, c('kern', 'silbe'))}, which will cause \verb{**kern} and \verb{**silbe} spines in each piece to
be cleaved.
Note that any exclusive interpretations which aren't "mentioned" in the call remain in their original field.

The behavior of exclusive cleaving depends on the relative number of each target exclusive interpretation in each piece.
If there are equal numbers of each interpretation, the spines are grouped in parallel.
For example, if a piece has the spines \verb{**kern **silbe **kern **silbe}, the command \code{cleave(humData, c('kern', 'silbe'))}
will see that there are two \verb{**kern}/\verb{**silbe} pairs, and cleave them just like \code{cleave(humData, 1:2, 3:4)}.

If there are different numbers of spines matching each exclusive interpretation, the cleave behavior depends on which
field is the first field in your input argument---we'll call that the "target" exclusive.
Consider a file with spines \verb{**kern **kern **harm}.
If we specify a cleave call \code{cleave(humData, c('kern', 'harm'))} that means we want \verb{**kern} to be the "target" exclusive.
Since there are fewer \verb{**harm} spines than \verb{**kern} spines, the data in the \verb{**harm} spine will be \emph{duplicated}, can cleaved
to \strong{both} \verb{**kern} spines in parallel.
If we instead call \code{cleave(humData, c('harm', 'kern'))}, making \verb{**harm} the "target", the two \verb{**kern} spines will both be "piled" atop
the single \verb{**harm} spine, making two new \verb{**kern} fields.
}

}
}
\section{Fields}{


Cleaving can (for now) only be applied to one field in our data, which defaults to the first \link[=selectedFields]{selected field};
You can change the target field with the \code{field} argument.

Cleaving will always introduce new fields into your data.
The first spine/path/stop in each cleave group is left in it's original (target) field.
Other spine/path/stops will be put into new fields.
So if you call \code{humData |> select(Token) |> cleave(humData, 1:2)}, spine 1 will remain in the \code{Token}
field and spine 2 data will be put in a new field.
By default, the new field(s) will be automatically named by appending the type of cleave (spine vs path vs stop)
to the number.
In the \code{cleave(humData, 1:2)} case, the new field will be called \code{Spine2}.
You can control the name with the \code{newFields} argument, which must be a \code{character} vector.
You can provide as many new field names as there will be new fields.
If you provide too few field names, your name(s) will have numbers appended as necceasary to cover all the new fields;
If you provide too many field names, the extra names will simply be ignored.

When cleaving by exclusive interpretation \code{newFields} can be used in the exact same way.
However, by default (if \code{newFields} is \code{NULL}), \code{cleave()} will names fields by their exclusive interpretation.
Note that the original target field (specified by the \code{field}) argument will not have it's name changed.
So for example, \code{humData |> select(Token) |> cleave(humData, c('kern', 'silbe'))} will result in the spines \code{Token}
and \code{Silbe}.
No \code{Kern} field is created, because the \code{Kern} data is left in the \code{Token} field.
}

\examples{

humData <- readHumdrum(humdrumRroot, "HumdrumData/MozartVariations/.*.krn")


humData |> cleave(3:4)
humData |> cleave(Path = 0:1, newFields = 'Ossia')
humData |> cleavePaths()

humData |> cleave(c('function', 'harm'), newFields = 'Harmony')

humData |> cleave(c('kern', 'function', 'harm'))

}
\seealso{
{The complement/opposite of \code{cleave()} is \code{\link[=rend]{rend()}}.
The \link[=collapseHumdrum]{collapse family of functions} serves a somewhat
similar function to \code{cleave()}.}

Other {Humdrum table reshaping functions}: 
\code{\link{collapseHumdrum}()},
\code{\link{expandPaths}()},
\code{\link{rend}()}

Other {Humdrum table pivoting functions}: 
\code{\link{rend}()}
}
\concept{{Humdrum table pivoting functions}}
\concept{{Humdrum table reshaping functions}}
