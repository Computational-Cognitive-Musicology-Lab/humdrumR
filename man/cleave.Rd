% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Reshape.R
\name{cleave}
\alias{cleave}
\alias{pivot_wider.humdrumR}
\alias{cleaveSpines}
\alias{cleavePaths}
\alias{cleaveStops}
\title{Align data from separate spines into new fields.}
\usage{
cleave(
  humdrumR,
  ...,
  field = selectedFields(humdrumR)[1],
  newFieldNames = NULL
)

\method{pivot_wider}{humdrumR}(data, names_from = "Spine", values_from = selectedFields(data)[1])

cleaveSpines(
  humdrumR,
  ...,
  field = selectedFields(humdrumR)[1],
  newFieldNames = NULL
)

cleavePaths(humdrumR, field = selectedFields(humdrumR)[1])

cleaveStops(
  humdrumR,
  fromField = selectedFields(humdrumR)[1],
  fillFromField = FALSE
)
}
\arguments{
\item{humdrumR}{\emph{\strong{HumdrumR data.}}

Must be a \link[=humdrumRclass]{humdrumR data object}.}

\item{newFieldNames}{\emph{\strong{Names to use for new fields created by the folding.}}

Defaults to \code{NULL}.

Must be \code{character}.}

\item{fromField}{\emph{\strong{Which field to "fold."}}

Defaults to \code{selectedFields(humdrumR)[1]}.

Must be a \code{character} string \link[=partialMatching]{partially} matching the name of a data field in the \code{humdrumR} input.
For example, \code{"Tok"} would match the \code{Token} field.
This is the field which is "folded" into a new field.}

\item{fillFromField}{\emph{\strong{Should the content of the \code{fromField} be to copied unfolded sections?}}

Defaults to \code{FALSE} for \code{cleave()} and \code{foldStops()}; \code{TRUE} for \code{foldPaths()}.

Must be a singleton \code{logical} value: an on/off switch.

This only comes into play if the folding field is smaller than the \code{to} field.}

\item{fold}{\emph{\strong{Which target structure (spine, path, etc.) to "fold" onto another structural position.}}

Must be natural numbers.}

\item{onto}{\emph{\strong{Which target structure (spine, path, etc.) is the data "folded" onto.}}

Must be natural numbers.}

\item{what}{\emph{\strong{The structural (spine, path, etc.) which is folded across.}}

Defaults to \code{"Spine"}.

Must be a single \code{character} string. Valid options are \code{"Spine"}, \code{"Path"}, \code{"Stop"}, \code{"Record"},and \code{"DataRecord"}.}

\item{Piece}{\emph{\strong{Which pieces in the corpus should be folded (see "Piece-Specific Folding" section, below).}}

Defaults to \code{NULL}.

Must be natural numbers; must be length \code{length(onto)}.}
}
\description{
Cleave, as in "to cleave together," moves data from separate spines (or paths) into
new fields in the \emph{same} spine(s).
Under the hood, \code{cleave()} essentially runs a specialized call to make the \link[=humTable]{humdrum table}
"wider," similar to R functions like \link[=reshape2]{cast()}, \link[=tidyr]{spread()}, or \link[=tidyr]{pivot_wider()}.
In fact, a humdrumR method for \link[=tidyr]{pivot_wider()} is defined, which is equivalent to \code{cleave()}.
The \code{cleave()} function is essentially the inverse of \code{\link[=rend]{rend()}}.
}
\details{
Many humdrum datasets encode data across multiple spines, spine-paths, or stops.
By default, \code{humdrumR} parses each separate spine, spine-path, and stop as their own individual
data points, taking up one row in the \link[=humTable]{humdrum table}.
If we want to treat data in multiple spines/paths/stops as different aspects of the same data
it is easiest to reshape the data so that the information is in different humdrumR \link[=fields]{fields}
rather than separate spines/paths/stops.
We "fold" the data from one structural location over "on top" of other data using \code{cleave}.
}
\section{From where to where}{


The \code{numeric} \code{fold} and \code{onto} arguments specify where to fold from/to.
\code{fold} indicates the Spine/Path/Stop to fold \emph{from}, "\emph{on to}" the Spine/Path/Stop
indicated by \code{onto}.
For example, if you specify \code{cleave(mydata, fold = 2, onto = 1, what = 'Spine')}
spine 2 will be folded "on top of" spine 1.
The \code{fold} and \code{onto} targets may not overlap.

The \code{fold} and \code{onto} arguments can be vectors of any length, which are interpreted in parallel:
for example, the combination \code{fold = 1:2} and \code{onto = 3:4} would map the first spine
to the third spine (\code{1 -> 3}) and the second spine to the 4th spine (\code{2 -> 4}).
If the \code{onto} targets are duplicated, the \code{fold} spines will be folded onto
multiple new fields: for example, the combination \code{fold = 1:2} and \code{onto = c(3, 3)} will
map first spine \emph{and} the second spine on to \emph{two} new fields of the third spine.
If the \code{fold} target is duplicated, the same \code{fold} spines can be copied onto multiple
\code{onto} spines: for example, the combination \code{fold = 1} and \code{onto = 2:3} will map the contents
of the first spine onto the second \emph{and} third spine, duplicating the spine-1 data.

The lengths of \code{fold} and \code{onto} are automatically matched, so
arguments like \code{fold = 1:2} and \code{onto = 3} are equivalent to \verb{fold = 1:2, onto = c(3, 3)}.
This makes it easy to do things like "copy all four spines onto spine 1":
just write \verb{fold = 2:4, onto = 1}.

To specify what structural field you want to fold across,
use the \code{what} argument (\code{character}, \code{length == 1}).
The default \code{what} value is \code{"Spine"}; other common fold options are \code{"Path"},
and \code{"Stop"}, though you might want to use the convenient \code{foldPaths()} and \code{foldStops()}
functions directly (details below).
(You may also fold across \code{"Record"} or \code{"DataRecord"}), but these are advanced/tricky!)
}

\section{Which fields}{


The \code{fromField} (\code{character}, \code{length == 1}) controls which field in the \code{fold}
spine/path/stop is folded into a new field.
The \code{fromField} argument defaults to the (first) \link[=selectedFields]{selected fields},
and must match (or \link[=partialMatching]{partially match}) a field in the \code{humdrumR} argument data set.
In some cases, the \code{fold} data is smaller than the \code{onto} data---for instance,
spine paths often only exist for part of a spine, so there is less data in the path
than in the full spine.
In these cases, it can be helpful to set \code{fillFromField == TRUE},
which causes the missing parts of \code{fold} to be filled with data from the \code{from}
field. \code{foldPaths} does this by default.

The resulting new fields will automatically be named as appropriate \code{Result}s fields.
The \code{newFieldNames} argument (\code{character}) can be used to control the output names:
one for each new field created by the fold.
If you specify too many \code{newFieldNames}, the later names are ignored.
If you specify too few \code{newFieldNames}, the later names will be given result names,
consistent with the default behavior.
}

\section{Piece-Specific Folding}{


By default, the same "fold" is carried out in each piece in the input corpus
(\code{humdrumR} argument).
If you need to specify different folds in different pieces, you have to specify the \code{Piece}
argument (\code{numeric}, whole number).
For \emph{every} piece in the corpus you want to apply folds to, you must specify all the \code{fold}
and \code{onto} arguments in parallel vectors with the \code{Piece} argument (even if this is reduendant
for some files).
For example, if we specify the combinations,\tabular{ccc}{
   \code{fold} \tab \code{onto} \tab \code{Piece} \cr
   \code{1} \tab \code{2} \tab \code{1} \cr
   \code{3} \tab \code{4} \tab \code{1} \cr
   \code{1} \tab \code{2} \tab \code{2} \cr
   \code{4} \tab \code{3} \tab \code{2} \cr
}


then
\itemize{
\item In \code{Piece} one:
\itemize{
\item the first spine is mapped to the second spine
\item the third spine is mapped to the fourth spine
}
\item In \code{Piece} two:
\itemize{
\item the first spine is mapped to the second spine
\item the fourth spine is mapped to the third spine
}
}

If any files in the corpus are not included, they will not be affected at all!
}

\section{Predefined folds}{


The convenient \code{foldStops()} and \code{foldPaths()} functions automatically fold \emph{all} stops/paths in a dataset
onto the first stop/path, creating new fields named, e.g., \code{Path1}, \code{Path2}, etc.
Another extremely useful function is \code{\link[=foldExclusive]{foldExclusive()}}, which automatically folds spines
based on their exclusive interpretation.
}

\seealso{
{The complement/opposite of \code{cleave()} is \code{\link[=rend]{rend()}}.
The \link[=collapseHumdrum]{collapse family of functions} serves a somewhat
similar function to \code{cleave()}.}

Other {Humdrum table reshaping functions}: 
\code{\link{collapseHumdrum}()},
\code{\link{expandPaths}()},
\code{\link{rend}()}

Other {Humdrum table pivoting functions}: 
\code{\link{rend}()}
}
\concept{{Humdrum table pivoting functions}}
\concept{{Humdrum table reshaping functions}}
