axes=F,xlab='',ylab='',
#,
main=paste(c("'",Ref$OTL,"' by ",Ref$COC,'\n',
'MC(s): ',unique(tran$Emcee),
' (',Ref$RRD,')'),collapse='')
)
###Grid
par(xpd=F)
downbeats=c(-64,-31,1,33,65) ; downbeats=downbeats[downbeats>XLIM[1] & downbeats <XLIM[2]]
if(length(downbeats)>0) segments(x0=downbeats,x1=downbeats,col='grey80',lty='dotted',lwd=2, y0=rep(YLIM[1]+1,5),y1=rep(YLIM[2]-1,5),xpd=T)
beatsthree=c(-48,-15,17,49) ; beatsthree=beatsthree[beatsthree>XLIM[1] & beatsthree <XLIM[2]]
if(length(beatsthree)>0) segments(x0=beatsthree,x1=beatsthree,col='grey80',lty='dotted',lwd=1.2, y0=rep(YLIM[1]+1,4),y1=rep(YLIM[2]-1,4),xpd=T)
twonfour=seq(-63+8,65-8,16) ; twonfour=twonfour[twonfour>XLIM[1] & twonfour <XLIM[2]]
if(length(twonfour)>0) segments(x0=twonfour,x1=twonfour,col='grey80',lty='dotted',lwd=1, y0=rep(YLIM[1]+1,8),y1=rep(YLIM[2]-1,8),xpd=T)
##X axis
par(xpd=T)
mtext('Metric position',1,line=3,cex=2)
xaxis.lab=rep(.every_other(c('1','e','&','a','2','e','&','a','3','e','&','a','4','e','&','a'),''),3)
xaxis.coor=(-64:65)
axis(1,XLIM[1]:XLIM[2],xaxis.lab[.mod(XLIM[1]:XLIM[2],metric.alignment)],tick = F,cex.axis=cex*.8,font=3)
axis(3,XLIM[1]:XLIM[2],xaxis.lab[.mod(XLIM[1]:XLIM[2],metric.alignment)],tick = F,cex.axis=cex*.8,font=3)
##Y axis
text(labels=ifelse(plot.by.phrase,'Phrase','Measure'),y = min(line.range)-1,x=XLIM[1]-1,cex=1)
text(XLIM[1]-1,line.range[2]:line.range[1],adj=c(1,0),cex=1,#phrase labes on y axis
labels =c(line.range[2]:line.range[1])) #this is because I can't get axis to allign right with the text
##emcee labels
Y.emcee=unique(Y) ; Y.emcee=Y.emcee[Y.emcee!=0]
mtext(at = min(line.range)-1,text='Emcee',side=2,line=.8,cex=1,las=2)
mtext(at = Y.emcee,text = emcee,side = 2,las=2,line=.8,padj = 0,cex=1)
par(xpd=F)
##Now finally plot the lyrics!
points(X[Text!=''],-.1+Y[Text!=''],pch=15,
col='white',
cex=Cex.vec[Text!='']*3)
text(X,Y,
adj=c(.5,0),cex=Cex.vec,
col=cols,
labels=Text,font=Font)
} # End of plot.Rap function
plot.Rap(FlowData[[1]])
plot.Rap = function(
Rap,
which.verse=1,
line.range=NULL,
rhythmic.layers='all',
color.rhymes=T,
metric.alignment=32,
plot.by.phrase=F,
phrase.break=c('2','3','4'),
IPA=F,
cex=.8
){
#' Flow diagramer
#'
#' This function makes a flow diagram of a given rap verse.
#' @param Rap Object of class rap (a list of data.frames). The desired rap song; The data object FlowData contains Rap objects.
#' @param which.verse Numeric, length 1. Which verse of the rap to plot.
#' @param line.range Numeric vector of length two, specifying the first and last lines, whether measures or phrases, to plot. If left NULL, then entire verse is plotted.
#' @param rhythmic.layers Character. Determines which rhythmic layers should be plotted. Options are either 'all' 'stress' or 'rhymes'
#' @param color.rhymes Logical. Should rhymes be colored?
#' @param metric.alignment Metric distance at which successive lines are aligned in 32nd-note units. 32 = one measure, 16 two beats, etc..
#' @param plot.by.phrase Logical. Plot by phrases instead of by measure?
#' @param phrase.break Vector of character strings. If plot.by.phrase==T, which break annotations should be used to determine phrase boundaries? Options are '2', '3', or '4'. First letters of phrases are also capitalized, whether or not plot.by.phrase==T.
#' @param IPA Print in the International Phonetic Alphabet instead of English orthography?
#' @param cex Size of text.
#' @keywords Flow Diagram Rhyme
#' @return none
#' @examples
#' plot(FlowData[[1]],which.verse=2,plot.by.phrase=T)
#' @export plot.Rap
if(class(Rap)!='Rap'){
par(bg=rgb(0,0,0,alpha=0))
plot(1,1,type='n',main='',axes=F,ylab='',xlab='')
return('')
} # If the input object is not of class Rap, return an error.
par(family='DejaVu Serif') # Serifs are necessary for reading IPA symbols.
Ref=attributes(Rap)[['Reference']] # Reference records...IE song metadata
# which.verse
which.verse=floor(which.verse) # Coerce which.verse to a whole number, just in case a non-whole number is inputed.
if(which.verse<1) which.verse=1 # if which.verse is below 1 (impossible) default to plotting the first verse.
if(which.verse>length(Rap)) which.verse=length(Rap) # if the verse number is greater than the actual number of verses in the rap, default to the last verse of the song.
tran=Rap[[which.verse]] # tran is the data.frame representing the desired verse.
# phrase.break
if(!any(phrase.break %in% c('2','3','4'))) stop('Invalid phrase.break argument.')
# IPA
if(!is.logical(IPA)) stop('Invalid IPA argument')
Text=unlist(ifelse(IPA,list(tran$ipa),list(tran$lyrics))) # Grab either English orthography data or IPA data (unlist(list()) is necesarry because ifelse can't return vectors)
Text[tran$breaks %in% phrase.break] = unlist(lapply(strsplit(Text[tran$breaks %in% phrase.break],''), function(w) {w[1]=toupper(w[1]) ; paste(w,collapse='')})) # Capitalize first letter in each phrase.
# rhymic.layers
if(!rhythmic.layers %in% c('all','stress','rhymes')) stop('Invalid rhythmic.layers argument.')
if(rhythmic.layers=='all') Font=suppressWarnings(as.numeric(tran$stress))+1 else Font=rep(2,nrow(tran)) # If rhythmic.layers=='all', Font vector will put stressed syllables in bold font.
if(rhythmic.layers=='stress') Text[tran$stress=='0']='' # If rhythmic.layers=='stress' get rid of unstressed syllables.
if(rhythmic.layers=='rhymes') Text[tran$rhyme=='.']='' # If rhythmic.layers=='rhymes' get rid of unrhymes syllables.
Text[Text=='.']='' # Get rid of null data tokens
Text[Text=='R']='' # Get rid of rests.
# cex
if(!is.numeric(cex) | cex <= 0 | cex > 5) stop('Invalid cex argument.')
Cex.vec=rep(cex,length(Text))
Cex.vec[tran$Syl.stress=='0']=cex*.9
# color.rhymes
if(!is.logical(color.rhymes)) stop('Invalid color.rhymes argument.')
tran$rhyme=gsub(']','',gsub('[)\\({}]','',gsub('\\[','',tran$rhyme))) # Get rid of rhyme-unit grouping () and [].
rhyme.colors=sample(rainbow(length(unique(tran$rhyme)),start=.2,end=1,v=.5,s=1)) #Get a pallete of rhymes with a unique color for each rhyme.
cols=rep('black',nrow(tran)) #Initialize cols vector. This will be a vector of colors to plot.
if(color.rhymes){
uniq.rhymes=unique(tolower(tran$rhyme[tran$rhyme !='.'])) # Rhymes with same letter name get same color (because of tolower)
cols[tran$rhyme !='.']=rhyme.colors[.mod(.where(tolower(tran$rhyme[tran$rhyme !='.']),uniq.rhymes),length(rhyme.colors))]
}
# plot.by.phrase
if(!is.logical(plot.by.phrase)) stop('Invalid plot.by.phrase argument.')
### Get emcee data. #This forms an emcee spine which indicates the rapping emcee at the side of the plot.
if(plot.by.phrase) {emcee=tran$Emcee[tran$breaks%in%phrase.break]} else {emcee=tran$Emcee[seq(1,nrow(tran),32)]}
emcee[which(head(emcee,-1)==tail(emcee,-1))+1]='' # Only keep data where emcee changes
# line.range
if(!is.null(line.range)) if(length(line.range)>2 | length(line.range)<2 | any(!is.numeric(line.range)) | any(diff(line.range) <= 0)) stop('Invalid line.range argument')
#######
#####Need to get X and Y coordinates for each syllable, as well as XLIM and YLIM values
#######
tran$beat=((tran$beat-1)*2)+1
if(!plot.by.phrase) { # Plot by fixed metric duration.
####Y coordinates
# Y=rep(1:50,each=metric.alignment)[1:nrow(tran)] #Y coordinates
Y=cumsum(as.numeric(sign(diff(tran$beat))==-1))+1
if(is.null(line.range)) line.range=c(1,ceiling((nrow(tran)/metric.alignment))) #default to whole range
if(line.range[2]>max(Y)) line.range[2]=max(Y)
YLIM=rev(line.range)
####X coordinates
# X=.mod(1:nrow(tran),m=metric.alignment) #In this case X coordinates are simply modulo metric.
X=tran$beat
XLIM=c(0,metric.alignment+1)
} else { # Plot by phrases.
####Y coordinates
Y=rep(0,nrow(tran)); Y[tran$breaks %in% phrase.break]=1; Y=cumsum(Y) #Get Y from phrases this time
if(is.null(line.range)) line.range=c(1,max(Y))#default to whole range
if(line.range[2]>max(Y)) line.range[2]=max(Y)
YLIM=rev(line.range)
####X coordinates
X=.find_best_phrase_alignment(tran,Y,metric.alignment)
XLIM=range(X[Text!=''])
}
########
#####Now we plot!
########
par(bg=rgb(0,0,0,alpha=0),mar=c(5,7,3,0)) # transparent backdrop
#setup plot
plot(-1,-1,xlim=XLIM,ylim=YLIM,type='n', cex.main=cex,
axes=F,xlab='',ylab='',
#,
main=paste(c("'",Ref$OTL,"' by ",Ref$COC,'\n',
'MC(s): ',unique(tran$Emcee),
' (',Ref$RRD,')'),collapse='')
)
###Grid
par(xpd=F)
downbeats=c(-64,-31,1,33,65) ; downbeats=downbeats[downbeats>XLIM[1] & downbeats <XLIM[2]]
if(length(downbeats)>0) segments(x0=downbeats,x1=downbeats,col='grey80',lty='dotted',lwd=2, y0=rep(YLIM[1]+1,5),y1=rep(YLIM[2]-1,5),xpd=T)
beatsthree=c(-48,-15,17,49) ; beatsthree=beatsthree[beatsthree>XLIM[1] & beatsthree <XLIM[2]]
if(length(beatsthree)>0) segments(x0=beatsthree,x1=beatsthree,col='grey80',lty='dotted',lwd=1.2, y0=rep(YLIM[1]+1,4),y1=rep(YLIM[2]-1,4),xpd=T)
twonfour=seq(-63+8,65-8,16) ; twonfour=twonfour[twonfour>XLIM[1] & twonfour <XLIM[2]]
if(length(twonfour)>0) segments(x0=twonfour,x1=twonfour,col='grey80',lty='dotted',lwd=1, y0=rep(YLIM[1]+1,8),y1=rep(YLIM[2]-1,8),xpd=T)
##X axis
par(xpd=T)
mtext('Metric position',1,line=3,cex=2)
xaxis.lab=rep(.every_other(c('1','e','&','a','2','e','&','a','3','e','&','a','4','e','&','a'),''),3)
xaxis.coor=(-64:65)
axis(1,XLIM[1]:XLIM[2],xaxis.lab[.mod(XLIM[1]:XLIM[2],metric.alignment)],tick = F,cex.axis=cex*.8,font=3)
axis(3,XLIM[1]:XLIM[2],xaxis.lab[.mod(XLIM[1]:XLIM[2],metric.alignment)],tick = F,cex.axis=cex*.8,font=3)
##Y axis
text(labels=ifelse(plot.by.phrase,'Phrase','Measure'),y = min(line.range)-1,x=XLIM[1]-1,cex=1)
text(XLIM[1]-1,line.range[2]:line.range[1],adj=c(1,0),cex=1,#phrase labes on y axis
labels =c(line.range[2]:line.range[1])) #this is because I can't get axis to allign right with the text
##emcee labels
Y.emcee=unique(Y) ; Y.emcee=Y.emcee[Y.emcee!=0]
mtext(at = min(line.range)-1,text='Emcee',side=2,line=.8,cex=1,las=2)
mtext(at = Y.emcee,text = emcee,side = 2,las=2,line=.8,padj = 0,cex=1)
par(xpd=F)
##Now finally plot the lyrics!
points(X[Text!=''],-.1+Y[Text!=''],pch=15,
col='white',
cex=Cex.vec[Text!='']*3)
text(X,Y,
adj=c(.5,0),cex=Cex.vec,
col=cols,
labels=Text,font=Font)
} # End of plot.Rap function
plot.Rap(FlowData[[1]])
plot.Rap = function(
Rap,
which.verse=1,
line.range=NULL,
rhythmic.layers='all',
color.rhymes=T,
metric.alignment=32,
plot.by.phrase=F,
phrase.break=c('2','3','4'),
IPA=F,
cex=.8
){
#' Flow diagramer
#'
#' This function makes a flow diagram of a given rap verse.
#' @param Rap Object of class rap (a list of data.frames). The desired rap song; The data object FlowData contains Rap objects.
#' @param which.verse Numeric, length 1. Which verse of the rap to plot.
#' @param line.range Numeric vector of length two, specifying the first and last lines, whether measures or phrases, to plot. If left NULL, then entire verse is plotted.
#' @param rhythmic.layers Character. Determines which rhythmic layers should be plotted. Options are either 'all' 'stress' or 'rhymes'
#' @param color.rhymes Logical. Should rhymes be colored?
#' @param metric.alignment Metric distance at which successive lines are aligned in 32nd-note units. 32 = one measure, 16 two beats, etc..
#' @param plot.by.phrase Logical. Plot by phrases instead of by measure?
#' @param phrase.break Vector of character strings. If plot.by.phrase==T, which break annotations should be used to determine phrase boundaries? Options are '2', '3', or '4'. First letters of phrases are also capitalized, whether or not plot.by.phrase==T.
#' @param IPA Print in the International Phonetic Alphabet instead of English orthography?
#' @param cex Size of text.
#' @keywords Flow Diagram Rhyme
#' @return none
#' @examples
#' plot(FlowData[[1]],which.verse=2,plot.by.phrase=T)
#' @export plot.Rap
if(class(Rap)!='Rap'){
par(bg=rgb(0,0,0,alpha=0))
plot(1,1,type='n',main='',axes=F,ylab='',xlab='')
return('')
} # If the input object is not of class Rap, return an error.
par(family='DejaVu Serif') # Serifs are necessary for reading IPA symbols.
Ref=attributes(Rap)[['Reference']] # Reference records...IE song metadata
# which.verse
which.verse=floor(which.verse) # Coerce which.verse to a whole number, just in case a non-whole number is inputed.
if(which.verse<1) which.verse=1 # if which.verse is below 1 (impossible) default to plotting the first verse.
if(which.verse>length(Rap)) which.verse=length(Rap) # if the verse number is greater than the actual number of verses in the rap, default to the last verse of the song.
tran=Rap[[which.verse]] # tran is the data.frame representing the desired verse.
# phrase.break
if(!any(phrase.break %in% c('2','3','4'))) stop('Invalid phrase.break argument.')
# IPA
if(!is.logical(IPA)) stop('Invalid IPA argument')
Text=unlist(ifelse(IPA,list(tran$ipa),list(tran$lyrics))) # Grab either English orthography data or IPA data (unlist(list()) is necesarry because ifelse can't return vectors)
Text[tran$breaks %in% phrase.break] = unlist(lapply(strsplit(Text[tran$breaks %in% phrase.break],''), function(w) {w[1]=toupper(w[1]) ; paste(w,collapse='')})) # Capitalize first letter in each phrase.
# rhymic.layers
if(!rhythmic.layers %in% c('all','stress','rhymes')) stop('Invalid rhythmic.layers argument.')
if(rhythmic.layers=='all') Font=suppressWarnings(as.numeric(tran$stress))+1 else Font=rep(2,nrow(tran)) # If rhythmic.layers=='all', Font vector will put stressed syllables in bold font.
if(rhythmic.layers=='stress') Text[tran$stress=='0']='' # If rhythmic.layers=='stress' get rid of unstressed syllables.
if(rhythmic.layers=='rhymes') Text[tran$rhyme=='.']='' # If rhythmic.layers=='rhymes' get rid of unrhymes syllables.
Text[Text=='.']='' # Get rid of null data tokens
Text[Text=='R']='' # Get rid of rests.
# cex
if(!is.numeric(cex) | cex <= 0 | cex > 5) stop('Invalid cex argument.')
Cex.vec=rep(cex,length(Text))
Cex.vec[tran$Syl.stress=='0']=cex*.9
# color.rhymes
if(!is.logical(color.rhymes)) stop('Invalid color.rhymes argument.')
tran$rhyme=gsub(']','',gsub('[)\\({}]','',gsub('\\[','',tran$rhyme))) # Get rid of rhyme-unit grouping () and [].
rhyme.colors=sample(rainbow(length(unique(tran$rhyme)),start=.2,end=1,v=.5,s=1)) #Get a pallete of rhymes with a unique color for each rhyme.
cols=rep('black',nrow(tran)) #Initialize cols vector. This will be a vector of colors to plot.
if(color.rhymes){
uniq.rhymes=unique(tolower(tran$rhyme[tran$rhyme !='.'])) # Rhymes with same letter name get same color (because of tolower)
cols[tran$rhyme !='.']=rhyme.colors[.mod(.where(tolower(tran$rhyme[tran$rhyme !='.']),uniq.rhymes),length(rhyme.colors))]
}
# plot.by.phrase
if(!is.logical(plot.by.phrase)) stop('Invalid plot.by.phrase argument.')
### Get emcee data. #This forms an emcee spine which indicates the rapping emcee at the side of the plot.
if(plot.by.phrase) {emcee=tran$Emcee[tran$breaks%in%phrase.break]} else {emcee=tran$Emcee[seq(1,nrow(tran),32)]}
emcee[which(head(emcee,-1)==tail(emcee,-1))+1]='' # Only keep data where emcee changes
# line.range
if(!is.null(line.range)) if(length(line.range)>2 | length(line.range)<2 | any(!is.numeric(line.range)) | any(diff(line.range) <= 0)) stop('Invalid line.range argument')
#######
#####Need to get X and Y coordinates for each syllable, as well as XLIM and YLIM values
#######
tran$beat=((tran$beat-1)*2)+1
if(!plot.by.phrase) { # Plot by fixed metric duration.
####Y coordinates
# Y=rep(1:50,each=metric.alignment)[1:nrow(tran)] #Y coordinates
browser()
Y=cumsum(as.numeric(sign(diff(tran$beat))==-1))+1
if(is.null(line.range)) line.range=c(1,ceiling((nrow(tran)/metric.alignment))) #default to whole range
if(line.range[2]>max(Y)) line.range[2]=max(Y)
YLIM=rev(line.range)
####X coordinates
# X=.mod(1:nrow(tran),m=metric.alignment) #In this case X coordinates are simply modulo metric.
X=tran$beat
XLIM=c(0,metric.alignment+1)
} else { # Plot by phrases.
####Y coordinates
Y=rep(0,nrow(tran)); Y[tran$breaks %in% phrase.break]=1; Y=cumsum(Y) #Get Y from phrases this time
if(is.null(line.range)) line.range=c(1,max(Y))#default to whole range
if(line.range[2]>max(Y)) line.range[2]=max(Y)
YLIM=rev(line.range)
####X coordinates
X=.find_best_phrase_alignment(tran,Y,metric.alignment)
XLIM=range(X[Text!=''])
}
########
#####Now we plot!
########
par(bg=rgb(0,0,0,alpha=0),mar=c(5,7,3,0)) # transparent backdrop
#setup plot
plot(-1,-1,xlim=XLIM,ylim=YLIM,type='n', cex.main=cex,
axes=F,xlab='',ylab='',
#,
main=paste(c("'",Ref$OTL,"' by ",Ref$COC,'\n',
'MC(s): ',unique(tran$Emcee),
' (',Ref$RRD,')'),collapse='')
)
###Grid
par(xpd=F)
downbeats=c(-64,-31,1,33,65) ; downbeats=downbeats[downbeats>XLIM[1] & downbeats <XLIM[2]]
if(length(downbeats)>0) segments(x0=downbeats,x1=downbeats,col='grey80',lty='dotted',lwd=2, y0=rep(YLIM[1]+1,5),y1=rep(YLIM[2]-1,5),xpd=T)
beatsthree=c(-48,-15,17,49) ; beatsthree=beatsthree[beatsthree>XLIM[1] & beatsthree <XLIM[2]]
if(length(beatsthree)>0) segments(x0=beatsthree,x1=beatsthree,col='grey80',lty='dotted',lwd=1.2, y0=rep(YLIM[1]+1,4),y1=rep(YLIM[2]-1,4),xpd=T)
twonfour=seq(-63+8,65-8,16) ; twonfour=twonfour[twonfour>XLIM[1] & twonfour <XLIM[2]]
if(length(twonfour)>0) segments(x0=twonfour,x1=twonfour,col='grey80',lty='dotted',lwd=1, y0=rep(YLIM[1]+1,8),y1=rep(YLIM[2]-1,8),xpd=T)
##X axis
par(xpd=T)
mtext('Metric position',1,line=3,cex=2)
xaxis.lab=rep(.every_other(c('1','e','&','a','2','e','&','a','3','e','&','a','4','e','&','a'),''),3)
xaxis.coor=(-64:65)
axis(1,XLIM[1]:XLIM[2],xaxis.lab[.mod(XLIM[1]:XLIM[2],metric.alignment)],tick = F,cex.axis=cex*.8,font=3)
axis(3,XLIM[1]:XLIM[2],xaxis.lab[.mod(XLIM[1]:XLIM[2],metric.alignment)],tick = F,cex.axis=cex*.8,font=3)
##Y axis
text(labels=ifelse(plot.by.phrase,'Phrase','Measure'),y = min(line.range)-1,x=XLIM[1]-1,cex=1)
text(XLIM[1]-1,line.range[2]:line.range[1],adj=c(1,0),cex=1,#phrase labes on y axis
labels =c(line.range[2]:line.range[1])) #this is because I can't get axis to allign right with the text
##emcee labels
Y.emcee=unique(Y) ; Y.emcee=Y.emcee[Y.emcee!=0]
mtext(at = min(line.range)-1,text='Emcee',side=2,line=.8,cex=1,las=2)
mtext(at = Y.emcee,text = emcee,side = 2,las=2,line=.8,padj = 0,cex=1)
par(xpd=F)
##Now finally plot the lyrics!
points(X[Text!=''],-.1+Y[Text!=''],pch=15,
col='white',
cex=Cex.vec[Text!='']*3)
text(X,Y,
adj=c(.5,0),cex=Cex.vec,
col=cols,
labels=Text,font=Font)
} # End of plot.Rap function
plot.Rap(FlowData[[1]])
cumsum(as.numeric(sign(diff(tran$beat))==-1))+1
cumsum(as.numeric(sign(diff(tran$beat))==-1))
cumsum(c(1,as.numeric(sign(diff(tran$beat))==-1)))
head(cumsum(c(1,as.numeric(sign(diff(tran$beat))==-1))),-1)
plot.Rap = function(
Rap,
which.verse=1,
line.range=NULL,
rhythmic.layers='all',
color.rhymes=T,
metric.alignment=32,
plot.by.phrase=F,
phrase.break=c('2','3','4'),
IPA=F,
cex=.8
){
#' Flow diagramer
#'
#' This function makes a flow diagram of a given rap verse.
#' @param Rap Object of class rap (a list of data.frames). The desired rap song; The data object FlowData contains Rap objects.
#' @param which.verse Numeric, length 1. Which verse of the rap to plot.
#' @param line.range Numeric vector of length two, specifying the first and last lines, whether measures or phrases, to plot. If left NULL, then entire verse is plotted.
#' @param rhythmic.layers Character. Determines which rhythmic layers should be plotted. Options are either 'all' 'stress' or 'rhymes'
#' @param color.rhymes Logical. Should rhymes be colored?
#' @param metric.alignment Metric distance at which successive lines are aligned in 32nd-note units. 32 = one measure, 16 two beats, etc..
#' @param plot.by.phrase Logical. Plot by phrases instead of by measure?
#' @param phrase.break Vector of character strings. If plot.by.phrase==T, which break annotations should be used to determine phrase boundaries? Options are '2', '3', or '4'. First letters of phrases are also capitalized, whether or not plot.by.phrase==T.
#' @param IPA Print in the International Phonetic Alphabet instead of English orthography?
#' @param cex Size of text.
#' @keywords Flow Diagram Rhyme
#' @return none
#' @examples
#' plot(FlowData[[1]],which.verse=2,plot.by.phrase=T)
#' @export plot.Rap
if(class(Rap)!='Rap'){
par(bg=rgb(0,0,0,alpha=0))
plot(1,1,type='n',main='',axes=F,ylab='',xlab='')
return('')
} # If the input object is not of class Rap, return an error.
par(family='DejaVu Serif') # Serifs are necessary for reading IPA symbols.
Ref=attributes(Rap)[['Reference']] # Reference records...IE song metadata
# which.verse
which.verse=floor(which.verse) # Coerce which.verse to a whole number, just in case a non-whole number is inputed.
if(which.verse<1) which.verse=1 # if which.verse is below 1 (impossible) default to plotting the first verse.
if(which.verse>length(Rap)) which.verse=length(Rap) # if the verse number is greater than the actual number of verses in the rap, default to the last verse of the song.
tran=Rap[[which.verse]] # tran is the data.frame representing the desired verse.
# phrase.break
if(!any(phrase.break %in% c('2','3','4'))) stop('Invalid phrase.break argument.')
# IPA
if(!is.logical(IPA)) stop('Invalid IPA argument')
Text=unlist(ifelse(IPA,list(tran$ipa),list(tran$lyrics))) # Grab either English orthography data or IPA data (unlist(list()) is necesarry because ifelse can't return vectors)
Text[tran$breaks %in% phrase.break] = unlist(lapply(strsplit(Text[tran$breaks %in% phrase.break],''), function(w) {w[1]=toupper(w[1]) ; paste(w,collapse='')})) # Capitalize first letter in each phrase.
# rhymic.layers
if(!rhythmic.layers %in% c('all','stress','rhymes')) stop('Invalid rhythmic.layers argument.')
if(rhythmic.layers=='all') Font=suppressWarnings(as.numeric(tran$stress))+1 else Font=rep(2,nrow(tran)) # If rhythmic.layers=='all', Font vector will put stressed syllables in bold font.
if(rhythmic.layers=='stress') Text[tran$stress=='0']='' # If rhythmic.layers=='stress' get rid of unstressed syllables.
if(rhythmic.layers=='rhymes') Text[tran$rhyme=='.']='' # If rhythmic.layers=='rhymes' get rid of unrhymes syllables.
Text[Text=='.']='' # Get rid of null data tokens
Text[Text=='R']='' # Get rid of rests.
# cex
if(!is.numeric(cex) | cex <= 0 | cex > 5) stop('Invalid cex argument.')
Cex.vec=rep(cex,length(Text))
Cex.vec[tran$Syl.stress=='0']=cex*.9
# color.rhymes
if(!is.logical(color.rhymes)) stop('Invalid color.rhymes argument.')
tran$rhyme=gsub(']','',gsub('[)\\({}]','',gsub('\\[','',tran$rhyme))) # Get rid of rhyme-unit grouping () and [].
rhyme.colors=sample(rainbow(length(unique(tran$rhyme)),start=.2,end=1,v=.5,s=1)) #Get a pallete of rhymes with a unique color for each rhyme.
cols=rep('black',nrow(tran)) #Initialize cols vector. This will be a vector of colors to plot.
if(color.rhymes){
uniq.rhymes=unique(tolower(tran$rhyme[tran$rhyme !='.'])) # Rhymes with same letter name get same color (because of tolower)
cols[tran$rhyme !='.']=rhyme.colors[.mod(.where(tolower(tran$rhyme[tran$rhyme !='.']),uniq.rhymes),length(rhyme.colors))]
}
# plot.by.phrase
if(!is.logical(plot.by.phrase)) stop('Invalid plot.by.phrase argument.')
### Get emcee data. #This forms an emcee spine which indicates the rapping emcee at the side of the plot.
if(plot.by.phrase) {emcee=tran$Emcee[tran$breaks%in%phrase.break]} else {emcee=tran$Emcee[seq(1,nrow(tran),32)]}
emcee[which(head(emcee,-1)==tail(emcee,-1))+1]='' # Only keep data where emcee changes
# line.range
if(!is.null(line.range)) if(length(line.range)>2 | length(line.range)<2 | any(!is.numeric(line.range)) | any(diff(line.range) <= 0)) stop('Invalid line.range argument')
#######
#####Need to get X and Y coordinates for each syllable, as well as XLIM and YLIM values
#######
tran$beat=((tran$beat-1)*2)+1
if(!plot.by.phrase) { # Plot by fixed metric duration.
####Y coordinates
# Y=rep(1:50,each=metric.alignment)[1:nrow(tran)] #Y coordinates
Y=head(cumsum(c(1,as.numeric(sign(diff(tran$beat))==-1))),-1)
if(is.null(line.range)) line.range=c(1,ceiling((nrow(tran)/metric.alignment))) #default to whole range
if(line.range[2]>max(Y)) line.range[2]=max(Y)
YLIM=rev(line.range)
####X coordinates
# X=.mod(1:nrow(tran),m=metric.alignment) #In this case X coordinates are simply modulo metric.
X=tran$beat
XLIM=c(0,metric.alignment+1)
} else { # Plot by phrases.
####Y coordinates
Y=rep(0,nrow(tran)); Y[tran$breaks %in% phrase.break]=1; Y=cumsum(Y) #Get Y from phrases this time
if(is.null(line.range)) line.range=c(1,max(Y))#default to whole range
if(line.range[2]>max(Y)) line.range[2]=max(Y)
YLIM=rev(line.range)
####X coordinates
X=.find_best_phrase_alignment(tran,Y,metric.alignment)
XLIM=range(X[Text!=''])
}
########
#####Now we plot!
########
par(bg=rgb(0,0,0,alpha=0),mar=c(5,7,3,0)) # transparent backdrop
#setup plot
plot(-1,-1,xlim=XLIM,ylim=YLIM,type='n', cex.main=cex,
axes=F,xlab='',ylab='',
#,
main=paste(c("'",Ref$OTL,"' by ",Ref$COC,'\n',
'MC(s): ',unique(tran$Emcee),
' (',Ref$RRD,')'),collapse='')
)
###Grid
par(xpd=F)
downbeats=c(-64,-31,1,33,65) ; downbeats=downbeats[downbeats>XLIM[1] & downbeats <XLIM[2]]
if(length(downbeats)>0) segments(x0=downbeats,x1=downbeats,col='grey80',lty='dotted',lwd=2, y0=rep(YLIM[1]+1,5),y1=rep(YLIM[2]-1,5),xpd=T)
beatsthree=c(-48,-15,17,49) ; beatsthree=beatsthree[beatsthree>XLIM[1] & beatsthree <XLIM[2]]
if(length(beatsthree)>0) segments(x0=beatsthree,x1=beatsthree,col='grey80',lty='dotted',lwd=1.2, y0=rep(YLIM[1]+1,4),y1=rep(YLIM[2]-1,4),xpd=T)
twonfour=seq(-63+8,65-8,16) ; twonfour=twonfour[twonfour>XLIM[1] & twonfour <XLIM[2]]
if(length(twonfour)>0) segments(x0=twonfour,x1=twonfour,col='grey80',lty='dotted',lwd=1, y0=rep(YLIM[1]+1,8),y1=rep(YLIM[2]-1,8),xpd=T)
##X axis
par(xpd=T)
mtext('Metric position',1,line=3,cex=2)
xaxis.lab=rep(.every_other(c('1','e','&','a','2','e','&','a','3','e','&','a','4','e','&','a'),''),3)
xaxis.coor=(-64:65)
axis(1,XLIM[1]:XLIM[2],xaxis.lab[.mod(XLIM[1]:XLIM[2],metric.alignment)],tick = F,cex.axis=cex*.8,font=3)
axis(3,XLIM[1]:XLIM[2],xaxis.lab[.mod(XLIM[1]:XLIM[2],metric.alignment)],tick = F,cex.axis=cex*.8,font=3)
##Y axis
text(labels=ifelse(plot.by.phrase,'Phrase','Measure'),y = min(line.range)-1,x=XLIM[1]-1,cex=1)
text(XLIM[1]-1,line.range[2]:line.range[1],adj=c(1,0),cex=1,#phrase labes on y axis
labels =c(line.range[2]:line.range[1])) #this is because I can't get axis to allign right with the text
##emcee labels
Y.emcee=unique(Y) ; Y.emcee=Y.emcee[Y.emcee!=0]
mtext(at = min(line.range)-1,text='Emcee',side=2,line=.8,cex=1,las=2)
mtext(at = Y.emcee,text = emcee,side = 2,las=2,line=.8,padj = 0,cex=1)
par(xpd=F)
##Now finally plot the lyrics!
points(X[Text!=''],-.1+Y[Text!=''],pch=15,
col='white',
cex=Cex.vec[Text!='']*3)
text(X,Y,
adj=c(.5,0),cex=Cex.vec,
col=cols,
labels=Text,font=Font)
} # End of plot.Rap function
plot.Rap(FlowData[[1]])
shiny::runApp('~/Bridge/Research/Programming/rapscience.net/NewShiny')
shiny::runApp('~/Bridge/Research/Programming/rapscience.net/NewShiny')
shiny::runApp('~/Bridge/Research/Programming/rapscience.net/NewShiny')
shiny::runApp('~/Bridge/Research/Programming/rapscience.net/NewShiny')
shiny::runApp('~/Bridge/Research/Programming/rapscience.net/NewShiny')
shiny::runApp('~/Bridge/Research/Programming/rapscience.net/NewShiny')
shiny::runApp('~/Bridge/Research/Programming/rapscience.net/NewShiny')
shiny::runApp('~/Bridge/Research/Programming/rapscience.net/NewShiny')
shiny::runApp('~/Bridge/Research/Programming/rapscience.net/NewShiny')
shiny::runApp('~/Bridge/Research/Programming/rapscience.net/NewShiny')
shiny::runApp('~/Bridge/Research/Programming/rapscience.net/NewShiny')
shiny::runApp('~/Bridge/Research/Programming/rapscience.net/NewShiny')
Corpus.Subset(songs='I Get Around')
shiny::runApp('~/Bridge/Research/Programming/rapscience.net/NewShiny')
RapCorpus$Measure
FlowCorpus$Measure
shiny::runApp('~/Bridge/Research/Programming/rapscience.net/NewShiny')
shiny::runApp('~/Bridge/Research/Programming/rapscience.net/NewShiny')
Corpus.Subset(artists=NA,years=1980:2014,songs='I Get Around')
plot.Metric(Corpus.Subset(artists=NA,years=1980:2014,songs='I Get Around'))
plot.Metric(Corpus.Subset(artists=NA,years=1980:2014,songs='I Get Around'),freq=T)
plot.Metric(Corpus.Subset(artists=NA,years=1980:2014,songs='I Get Around'))
shiny::runApp('~/Bridge/Research/Programming/rapscience.net/NewShiny')
plot.Metric(Corpus.Subset(artists='2Pac',years=1980:2014,songs=NA))
shiny::runApp('~/Bridge/Research/Programming/rapscience.net/NewShiny')
plot.Metric(Corpus.Subset(artists=NA,years=1980:2014,songs='Candy Shop'))
plot.Metric(Corpus.Subset(artists=c('Eminem'),years=1980:2014,songs='Candy Shop'))
plot.Metric(Corpus.Subset(artists=c('Eminem'),years=1980:2014,songs=NA))
plot.Metric(Corpus.Subset(artists=c('the Beastie Boys','Eminem'),years=1980:2014,songs=NA))
