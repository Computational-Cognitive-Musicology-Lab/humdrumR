[{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/GettingStarted.html","id":"quick-start","dir":"Articles","previous_headings":"","what":"Quick Start","title":"Getting started with humdrumR","text":"Let’s just dive right ! First, make sure humdrumR installed: install humdrumR. Open R session load humdrumR library using command library(humdrumR)—now ready rock! HumdrumR comes packaged small number humdrum data files just play around . files stored directory computer installed humdrumR, subfolder called “HumdrumData”. can move R session folder using R’s “set working directory command”: setwd(humdrumRroot). ’re humdrumR directory, can use base R dir function see humdrum data available . looks like five folders humdrum data available . Using dir , can look inside one: let’s start ‘BachChorales’ folder. ten files folder, named “chor001.krn”, “chor002.krn”, etc. simple plain humdrum text files, using ’**kern’ interpretation represent ten chorales J.S. Bach. Take minute find files computer’s finder/exporer open simple text editor. One core philosophies humdrumR maintain direct, transparent relationship symbolic data—always take time look data! can also within Rstudio’s “Files” pane—fact, Rstudio make things extra easy can (within Files pane) click “” > “Go Working Directory” quickly find files.","code":"library(humdrumR)  setwd(humdrumRroot)  dir('HumdrumData') [1] \"BachChorales\"        \"BeethovenVariations\" \"MozartVariations\"    [4] \"RapFlow\"             \"RollingStoneCorpus\" dir('HumdrumData/BachChorales')  [1] \"chor001.krn\" \"chor002.krn\" \"chor003.krn\" \"chor004.krn\" \"chor005.krn\"  [6] \"chor006.krn\" \"chor007.krn\" \"chor008.krn\" \"chor009.krn\" \"chor010.krn\""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/GettingStarted.html","id":"reading-humdrum-data","dir":"Articles","previous_headings":"Quick Start","what":"Reading humdrum data","title":"Getting started with humdrumR","text":"Now ’ve found humdrum data look , let’s read humdrumR. can useing humdrumR’s readHumdrum command. Try : command two things: readHumdrum function read “chor001.krn” file R create humdrumR data object . new object saved variable called chor1. (name ‘chor1’ just name chose—welcome give different name want.) ’ve created chor1 object (whatever chose call ), can take quick look just typing name command line pressing enter: (R, enter something command line, R “prints” read.) print-see shows name file, contents file, stuff “Data fields” learn soon. Cool! Still, looking single humdrum file really exciting. whole point using computers working large amounts data. Luckily, humdrumR makes easy. Check next command: Notice ’ve changed instead writing 'chor001.krn', wrote 'chor0'. feed string 'chor0' readHumdrum, won’t just look file called “chor0”; read file folder whose name contains substring “chor0”—case ten files! Try printing new chorales object see different. Wow! ’ve now got “humdrumR corpus ten files”—’s nothing: readHumdrum work just well reading hundreds thousands files! Notice print humdrumR object, humdrumR shows beginning first file end last file, well telling many files total. readHumdrum number cool options can read detail humdrumR read/write tutorial.","code":"readHumdrum('HumdrumData/BachChorales/chor001.krn') -> chor1 Finding and reading files...     REpath-pattern 'HumdrumData/BachChorales/chor001.krn' matches 1 text files in 1 directory. One files read from disk.  Validating one files...all valid. Parsing one files...Assembling corpus...Done! chor1 ############################ vvv chor001.krn vvv ############################     1:  !!!COM: Bach, Johann Sebastian     2:  !!!CDT: 1685/02/21/-1750/07/28/     3:  !!!OTL@@DE: Aus meines Herzens Grunde     4:  !!!OTL@EN:      From the Depths of My Heart     5:  !!!SCT: BWV 269     6:  !!!PC#: 1     7:  !!!AGN: chorale   126:  !!!hum2abc: -Q ''   127:  !!!title: @{PC#}. @{OTL@@DE}   128:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian ***   129:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&***   130:  !!!YOR3: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371***   131:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.***   132:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10   133:  !!!EED:  Craig Stuart Sapp   134:  !!!EEV:  2009/05/22     8:          **kern        **kern        **kern        **kern     9:          *ICvox        *ICvox        *ICvox        *ICvox    10:          *Ibass       *Itenor        *Ialto       *Isoprn    11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano    12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B]    13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B]    14:             *>A           *>A           *>A           *>A    15:         *clefF4      *clefGv2       *clefG2       *clefG2    16:          *k[f#]        *k[f#]        *k[f#]        *k[f#]    17:             *G:           *G:           *G:           *G:    18:             *F:             *             *             *    19:           *M3/4         *M3/4         *M3/4         *M3/4    20:          *MM100        *MM100        *MM100        *MM100    21:             4GG            4B            4d            4g    22:              =1            =1            =1            =1    23:              4G            4B            4d            2g    24:              4E           8cL            4e             .    25:               .           8BJ             .             .    26:             4F#            4A            4d           4dd    27:              =2            =2            =2            =2    28:              4G            4G            2d           4.b    29:              4D           4F#             .             .    30:               .             .             .            8a    31:              4E            4G            4B            4g    32:              =3            =3            =3            =3    33:              4C           8cL           8eL           4.g    34:               .           8BJ            8d             .    35:            8BBL            4c            8e             .    36:            8AAJ             .          8f#J            8a    37:             4GG            4d            4g            4b    38:              =4            =4            =4            =4    39:             2D;           2d;          2f#;           2a;    40:             4GG            4d            4g            4b    41:              =5            =5            =5            =5    42:            4FF#            4A            4d           2dd    43:             4GG            4B            4e             .    44:             4AA            4c           4f#           4cc    45:              =6            =6            =6            =6    46:             4BB            4d            2g            4b    47:              4C            4e             .            2a    48:              4D           8dL           4f#             .    49:               .           8cJ             .             .    50:              =7            =7            =7            =7    51:            2GG;           2B;           2d;           2g;    52:            =:|!          =:|!          =:|!          =:|!    53:             *>B           *>B           *>B           *>B    54:             4GG            4d           [4g            4b    55:              =8            =8            =8            =8    56:             4GG            4d          8gL]            4b    57:               .             .          8f#J             .    58:             4AA            4c           8eL           4cc    59:               .             .          8f#J             .    60:             4BB           8BL           [4g           4dd    61:               .           8AJ             .             .    62:              =9            =9            =9            =9    63:            4.BB           8BL          8gL]          4.dd    64:               .           8cJ           8aJ             .    65:               .            4d           8gL             .    66:             8AA             .          8f#J           8cc    67:             4GG            4d            4g            4b    68:             =10           =10           =10           =10    69:             2D;           2d;          2f#;           2a;    70:             [4E            4B            4e            4g    71:             =11           =11           =11           =11    72:             4E]            4G            4e            2b    73:              4D            4B          8f#L             .    74:               .             .           8gJ             .    75:              4C            4e            4a           4cc    76:             =12           =12           =12           =12    77:            4.BB            2d            4a           2dd    78:               .             .           4.g             .    79:              8C             .             .             .    80:              4D            4d             .           4cc    81:               .             .           8f#             .    82:             =13           =13           =13           =13    83:            8GGL           2.d            2g           2.b    84:            8AAJ             .             .             .    85:             4BB             .             .             .    86:             4GG             .            4f             .    87:             =14           =14           =14           =14    88:             2C;           2c;           2e;           2g;    89:             4GG            4d            4g            4b    90:             =15           =15           =15           =15    91:            4FF#           8dL           4.a           2dd    92:               .           8cJ             .             .    93:             4GG            4B             .             .    94:               .             .            8g             .    95:             4AA            4c           4f#           4cc    96:             =16           =16           =16           =16    97:             4BB            2d            2g            2b    98:             4GG             .             .             .    99:              4D           8dL          [4f#            4a   100:               .           8cJ             .             .   101:             =17           =17           =17           =17   102:             8EL            4B         8f#L]           4.g   103:              8D             .           8eJ             .   104:              8C            4c           8eL             .   105:             8BB             .          8f#J            8a   106:             8AA            4d            4g            4b   107:            8GGJ             .             .             .   108:             =18           =18           =18           =18   109:             2D;           2d;          2f#;           2a;   110:             [4G            4d            4g            4b   111:             =19           =19           =19           =19   112:             4G]            2d            2a           2dd   113:             4F#             .             .             .   114:             [4E            4e           8gL           4cc   115:               .             .          8f#J             .   116:             =20           =20           =20           =20   117:            8EL]            2e            2g            4b   118:             8DJ             .             .             .   119:              4C             .             .            2a   120:              4D           8dL           4f#             .   121:               .           8cJ             .             .   122:             =21           =21           =21           =21   123:           2.GG;          2.B;          2.d;          2.g;   124:              ==            ==            ==            ==   125:              *-            *-            *-            *- ############################ ^^^ chor001.krn ^^^ ############################                      (***four global comments truncated due to screen size***)      Data fields:              *Token :: character readHumdrum('HumdrumData/BachChorales/chor0') -> chorales Finding and reading files...     REpath-pattern 'HumdrumData/BachChorales/chor0' matches 10 text files in 1 directory. Ten files read from disk.  Validating ten files...all valid. Parsing ten files...Assembling corpus...Done! chorales ############################# vvv chor001.krn vvv #############################      1:  !!!COM: Bach, Johann Sebastian      2:  !!!CDT: 1685/02/21/-1750/07/28/      3:  !!!OTL@@DE: Aus meines Herzens Grunde      4:  !!!OTL@EN:      From the Depths of My Heart      5:  !!!SCT: BWV 269      6:  !!!PC#: 1      7:  !!!AGN: chorale    126:  !!!hum2abc: -Q ''    127:  !!!title: @{PC#}. @{OTL@@DE}    128:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B***    129:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a***    130:  !!!YOR3: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 ***    131:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1***    132:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10    133:  !!!EED:  Craig Stuart Sapp    134:  !!!EEV:  2009/05/22      8:          **kern        **kern        **kern        **kern      9:          *ICvox        *ICvox        *ICvox        *ICvox     10:          *Ibass       *Itenor        *Ialto       *Isoprn     11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano     12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B]     14:             *>A           *>A           *>A           *>A     15:         *clefF4      *clefGv2       *clefG2       *clefG2     16:          *k[f#]        *k[f#]        *k[f#]        *k[f#]     17:             *G:           *G:           *G:           *G:     18:             *F:             *             *             *     19:           *M3/4         *M3/4         *M3/4         *M3/4     20:          *MM100        *MM100        *MM100        *MM100     21:             4GG            4B            4d            4g     22:              =1            =1            =1            =1     23:              4G            4B            4d            2g     24:              4E           8cL            4e             .     25:               .           8BJ             .             .     26:             4F#            4A            4d           4dd     27:              =2            =2            =2            =2     28:              4G            4G            2d           4.b     29:              4D           4F#             .             .     30:               .             .             .            8a     31:              4E            4G            4B            4g 32-125::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: ############################# ^^^ chor001.krn ^^^ #############################          (8 more files...)  ############################# vvv chor010.krn vvv #############################   1-51:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::     52:               .             .          8f#J             .     53:              =7            =7            =7            =7     54:              4G            4d            4g            4b     55:           8FnXL           8dL            4a            4a     56:             8EJ           8eJ             .             .     57:              4D            4f           8bL          8ddL     58:               .             .           8aJ          8ccJ     59:              4E            4B           4g#            4b     60:              =8            =8            =8            =8     61:            2AA;           2c;           2e;           2a;     62:              2A            2e            2a           2cc     63:              =9            =9            =9            =9     64:              4E            4e            4g            4b     65:             8DL            4e            4g           4cc     66:             8CJ             .             .             .     67:             4BB            4d           8gL           4dd     68:               .             .           8fJ             .     69:              4C            4c            4e            4g     70:             =10           =10           =10           =10     71:              4D           8F#            4d            4b     72:               .            4G             .             .     73:              4D             .            4c            4a     74:               .           8F#             .             .     75:            2GG;           2G;           2B;           2g;     76:             =11           =11           =11           =11     77:              2C            2G            2e            2g     78:             4AA            4A            4e           4cc     79:              4E           4G#           8eL            4b     80:               .             .           8dJ             .     81:             =12           =12           =12           =12     82:              4F            4A            4c            4a     83:              4C            4G            4c            4e     84:            4BB-            4G           [2d            4g     85:             4AA            4A             .            4f     86:             =13           =13           =13           =13     87:            4GG#            4B           4d]           1e;     88:             4AA            4A            4c             .     89:            2EE;         2G#X;           2B;             .     90:              ==            ==            ==            ==     91:              *-            *-            *-            *- ############################# ^^^ chor010.krn ^^^ #############################                        (***four global comments truncated due to screen size***)      humdrumR corpus of ten files.      Data fields:              *Token :: character"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/GettingStarted.html","id":"the-data-model","dir":"Articles","previous_headings":"","what":"The Data Model","title":"Getting started with humdrumR","text":"really make use humdrumR, need understand bit humdrum data represented humdrumR package: humdrumR “data model.” essential thing understand maps humdrum data syntax R data.table.  fully understand , start least basic understanding humdrum syntax! Read syntax humdrum.org check [vignette]{HumdrumSyntax.html “Humdrum Syntax”} topic.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/GettingStarted.html","id":"data-frames","dir":"Articles","previous_headings":"The Data Model","what":"data.frames","title":"Getting started with humdrumR","text":"Data.frames essential R. data.frame simply two-dimensional table named columns. column either vector list values, length. HumdrumR makes use popular extension base-R data.frames, data.table. humdrumR, every single, individual token collection humdrum-syntax text files given row data.frame. example, consider simple, humdrum-syntax file: file contains nineteen individual tokens. illustrate, ’ll print file, token bracketed < >: happens humdrumR reads file? (file bundled humdrumR \"humdrumRroot/examples\" directory.) see thing saw earlier, reading real humdrum data \"HumdrumData\" folder. ’s hood? see , can use getHumtab function extract underlying humdrum table: Look , data.table nineteen rows! case, humdrum data table (“humtable”) twenty-four columns! columns : humdrumR, refer columns fields. learn fields humdrumR object, better call fields command directly original humdrumR object: see twenty-four fields (humtable columns), divided five types fields: Data fields Structure fields Interpretation fields Form fields Reference fields (good place read details columns means humTable documentation can get calling ?humTable.) Let’s go back Bach chorales dataset loaded earlier (saved chorales): chorales corpus 44 fields!—fields example1, additional ones. additional fields interpretation reference records didn’t appear toy example1.","code":"!!!OTL: Example 1  **kern                        **kern                          *M4/4                         *M4/4                           *C:                           *C:                             =                             =                               2G                            4g                              .                             4f                              2C                            2e                              ==                            ==                              *-                            *-                             NULL <!!!OTL: Example 1> <**kern>                      <**kern>                       <*M4/4>                       <*M4/4>                        <*C:>                         <*C:>                          <=>                           <=>                            <2G>                          <4g>                           <.>                           <4f>                           <2C>                          <2e>                           <==>                          <==>                           <*->                          <*-> example1 <- readHumdrum('examples/BasicExample.krn') Finding and reading files...     REpath-pattern 'examples/BasicExample.krn' matches 1 text files in 1 directory. One files read from disk.  Validating one files...all valid. Parsing one files...Assembling corpus...Done!  example1  vvv BasicExample.krn vvv     1:  !!!OTL: Example 1    2:    **kern  **kern    3:     *M4/4   *M4/4    4:       *C:     *C:    5:         =       =    6:        2G      4g    7:         .      4f    8:        2C      2e    9:        ==      ==   10:        *-      *-  ^^^ BasicExample.krn ^^^       Data fields:              *Token :: character humtab <- getHumtab(example1)  humtab                 Token Record Type Column Spine Path Stop Exclusive  Tandem Bar  1: !!!OTL: Example 1      1    G     NA    NA   NA   NA      <NA>    <NA>  NA  2:            **kern      2    I      1     1    0    1      kern           0  3:             *M4/4      3    I      1     1    0    1      kern    M4/4   0  4:               *C:      4    I      1     1    0    1      kern C:,M4/4   0  5:                 =      5    M      1     1    0    1      kern C:,M4/4   1  6:                2G      6    D      1     1    0    1      kern C:,M4/4   1  7:                 .      7    d      1     1    0    1      kern C:,M4/4   1  8:                2C      8    D      1     1    0    1      kern C:,M4/4   1  9:                ==      9    M      1     1    0    1      kern C:,M4/4   2 10:                *-     10    I      1     1    0    1      kern C:,M4/4   2 11:            **kern      2    I      2     2    0    1      kern           0 12:             *M4/4      3    I      2     2    0    1      kern    M4/4   0 13:               *C:      4    I      2     2    0    1      kern C:,M4/4   0 14:                 =      5    M      2     2    0    1      kern C:,M4/4   1 15:                4g      6    D      2     2    0    1      kern C:,M4/4   1 16:                4f      7    D      2     2    0    1      kern C:,M4/4   1 17:                2e      8    D      2     2    0    1      kern C:,M4/4   1 18:                ==      9    M      2     2    0    1      kern C:,M4/4   2 19:                *-     10    I      2     2    0    1      kern C:,M4/4   2     DoubleBar BarLabel NData       OTL Piece                  Filepath File  1:        NA     <NA>    NA Example 1     1 examples/BasicExample.krn    1  2:         0     <NA>    NA Example 1     1 examples/BasicExample.krn    1  3:         0     <NA>    NA Example 1     1 examples/BasicExample.krn    1  4:         0     <NA>    NA Example 1     1 examples/BasicExample.krn    1  5:         0             NA Example 1     1 examples/BasicExample.krn    1  6:         0              1 Example 1     1 examples/BasicExample.krn    1  7:         0              2 Example 1     1 examples/BasicExample.krn    1  8:         0              3 Example 1     1 examples/BasicExample.krn    1  9:         1        =    NA Example 1     1 examples/BasicExample.krn    1 10:         1        =    NA Example 1     1 examples/BasicExample.krn    1 11:         0     <NA>    NA Example 1     1 examples/BasicExample.krn    1 12:         0     <NA>    NA Example 1     1 examples/BasicExample.krn    1 13:         0     <NA>    NA Example 1     1 examples/BasicExample.krn    1 14:         0             NA Example 1     1 examples/BasicExample.krn    1 15:         0              1 Example 1     1 examples/BasicExample.krn    1 16:         0              2 Example 1     1 examples/BasicExample.krn    1 17:         0              3 Example 1     1 examples/BasicExample.krn    1 18:         1        =    NA Example 1     1 examples/BasicExample.krn    1 19:         1        =    NA Example 1     1 examples/BasicExample.krn    1     Label         Filename  Null Filter Global  Key TimeSignature  1:    _1 BasicExample.krn FALSE  FALSE   TRUE <NA>          <NA>  2:    _1 BasicExample.krn FALSE  FALSE  FALSE <NA>          <NA>  3:    _1 BasicExample.krn FALSE  FALSE  FALSE <NA>          M4/4  4:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4  5:    _1 BasicExample.krn  TRUE  FALSE  FALSE   C:          M4/4  6:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4  7:    _1 BasicExample.krn  TRUE  FALSE  FALSE   C:          M4/4  8:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4  9:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4 10:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4 11:    _1 BasicExample.krn FALSE  FALSE  FALSE <NA>          <NA> 12:    _1 BasicExample.krn FALSE  FALSE  FALSE <NA>          M4/4 13:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4 14:    _1 BasicExample.krn  TRUE  FALSE  FALSE   C:          M4/4 15:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4 16:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4 17:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4 18:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4 19:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4 colnames(humtab)  [1] \"Token\"         \"Record\"        \"Type\"          \"Column\"         [5] \"Spine\"         \"Path\"          \"Stop\"          \"Exclusive\"      [9] \"Tandem\"        \"Bar\"           \"DoubleBar\"     \"BarLabel\"      [13] \"NData\"         \"OTL\"           \"Piece\"         \"Filepath\"      [17] \"File\"          \"Label\"         \"Filename\"      \"Null\"          [21] \"Filter\"        \"Global\"        \"Key\"           \"TimeSignature\" fields(example1)              Name     Class           Type  1:         Token character           Data  2:      Filename character      Structure  3:      Filepath character      Structure  4:          File   integer      Structure  5:         Label character      Structure  6:         Piece   integer      Structure  7:        Column   integer      Structure  8:         Spine   integer      Structure  9:          Path   integer      Structure 10:          Stop   integer      Structure 11:        Record   integer      Structure 12:         NData   integer      Structure 13:        Global   logical      Structure 14:          Null   logical      Structure 15:        Filter   logical      Structure 16:          Type character      Structure 17:     Exclusive character Interpretation 18:        Tandem character Interpretation 19:           Key character Interpretation 20: TimeSignature character Interpretation 21:           Bar   integer         Formal 22:     DoubleBar   integer         Formal 23:      BarLabel character         Formal 24:           OTL character      Reference              Name     Class           Type fields(chorales)                Name     Class           Type  1:           Token character           Data  2:        Filename character      Structure  3:        Filepath character      Structure  4:            File   integer      Structure  5:           Label character      Structure  6:           Piece   integer      Structure  7:          Column   integer      Structure  8:           Spine   integer      Structure  9:            Path   integer      Structure 10:            Stop   integer      Structure 11:          Record   integer      Structure 12:           NData   integer      Structure 13:          Global   logical      Structure 14:            Null   logical      Structure 15:          Filter   logical      Structure 16:            Type character      Structure 17:       Exclusive character Interpretation 18:          Tandem character Interpretation 19:             Key character Interpretation 20:    KeySignature character Interpretation 21:            Clef character Interpretation 22:   TimeSignature character Interpretation 23:     Mensuration character Interpretation 24:             BPM character Interpretation 25:      Instrument character Interpretation 26: InstrumentClass character Interpretation 27:          Formal character         Formal 28:             Bar   integer         Formal 29:       DoubleBar   integer         Formal 30:        BarLabel character         Formal 31:             COM character      Reference 32:             CDT character      Reference 33:         OTL@@DE character      Reference 34:          OTL@EN character      Reference 35:             SCT character      Reference 36:             PC# character      Reference 37:             AGN character      Reference 38:         hum2abc character      Reference 39:           title character      Reference 40:             YOR character      Reference 41:             SMS character      Reference 42:             EED character      Reference 43:             EEV character      Reference 44:             OPR character      Reference                Name     Class           Type"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/GettingStarted.html","id":"main-fields","dir":"Articles","previous_headings":"The Data Model > data.frames","what":"Main Fields","title":"Getting started with humdrumR","text":"important fields always present humdrumR humtable 1) “Token” field contains original character tokens read humdrum data!; 2) “Structural” fields tell us original humdrum data token came . “Structural” fields allow humdrumR (re)construct original humdrum data—translating humdrum-table (data.table) plain-text humdrum syntax. can inspect field humdrumR data using $ operator: Just call humdrumR data object $ name field. Using , can see content structural fields ! important Spine, Record, (Record) Type, File(name) fields. “record types” : \"G\": global comment (including reference records) \"L\": local comment \"\": interpretation \"M\": measure (.e., barlines) \"D\": (non-null) data token \"d\": null data token (\".\")","code":"example1$Spine  vvv BasicExample.krn vvv     1:  !!!OTL: Example 1    2:    **kern  **kern    3:     *M4/4   *M4/4    4:       *C:     *C:    5:         =       =    6:         1       2    7:         1       2    8:         1       2    9:        ==      ==   10:        *-      *-  ^^^ BasicExample.krn ^^^       Data fields:               Token :: character  # example1$Record  example1$Type  vvv BasicExample.krn vvv     1:  !!!OTL: Example 1    2:    **kern  **kern    3:     *M4/4   *M4/4    4:       *C:     *C:    5:         =       =    6:         D       D    7:         D       D    8:         D       D    9:        ==      ==   10:        *-      *-  ^^^ BasicExample.krn ^^^       Data fields:               Token :: character  example1$Filename ######## vvv BasicExample.krn vvv #########    1:  !!!OTL: Example 1    2:              **kern            **kern    3:               *M4/4             *M4/4    4:                 *C:               *C:    5:                   =                 =    6:    BasicExample.krn  BasicExample.krn    7:    BasicExample.krn  BasicExample.krn    8:    BasicExample.krn  BasicExample.krn    9:                  ==                ==   10:                  *-                *- ######## ^^^ BasicExample.krn ^^^ #########      Data fields:               Token :: character"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/GettingStarted.html","id":"stops","dir":"Articles","previous_headings":"The Data Model > data.frames","what":"Stops","title":"Getting started with humdrumR","text":"humdrum syntax, multiple tokens can placed “place” (.e., record, spine) simply separating spaces. (commonly used represent chords **kern data.) humdrumR, call “Stops”—always, every humdrum token, including stops, get row humdrumR humtable. Thus, need Stop field tell us stop token came ! much data, /tokens simply Stop == 1 (first position), one tokens record/spine, numbered ascending one: Let’s look example make sense ! file chords second spine: individual note tokens separated spaces. Let’s inspect humtable: can see note chords gets row, numbered 1, 2, 3 Stop field!","code":"stops <- readHumdrum('examples/Stops.krn') Finding and reading files...     REpath-pattern 'examples/Stops.krn' matches 1 text files in 1 directory. One files read from disk.  Validating one files...all valid. Parsing one files...Assembling corpus...Done!  stops ##### vvv Stops.krn vvv #####    1:  !!!OTL: \"Stop\" example    2:    **kern    **kern    3:     *M4/4     *M4/4    4:       *C:       *C:    5:        =-        =-    6:        2G  4g cc ee    7:         .   4f b dd    8:       2C;   2e; cc;    9:         =         =   10:        *-        *- ##### ^^^ Stops.krn ^^^ #####      Data fields:              *Token :: character getHumtab(stops)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/GettingStarted.html","id":"paths","dir":"Articles","previous_headings":"The Data Model > data.frames","what":"Paths","title":"Getting started with humdrumR","text":"humdrum data contains “spine paths”—places single spine splits two. humdrumR treats spine paths “subspines” main spine split , one numbered Path field. starting path (leftmost) numbered path 0—datasets spine paths, Path field zeros. paths numbered higher integers. Let’s look simple example: complex example: Notice humdrumR prints paths way readable reading humdrum syntax directly: paths “shifted” columns align. Column field used .","code":"paths1 <- readHumdrum('examples/Paths.krn') Finding and reading files...     REpath-pattern 'examples/Paths.krn' matches 1 text files in 1 directory. One files read from disk.  Validating one files...all valid. Parsing one files...Assembling corpus...Done!  paths1 ###### vvv Paths.krn vvv ######    1:  !!!OTL: \"Path\" example    2:    **kern     **kern         3:     *M4/4      *M4/4         4:       *C:        *C:         5:        =-         =-         6:        4C    4cc 4ee         7:        4D     4b 4dd         8:        4E     2a 2cc         9:        4F          .        10:         =          =        11:         *         *^        12:        1G         8g  4cc   13:         .         8a    .   14:         .         8g   4a   15:         .        8f#    .   16:         .         4g   2b   17:         .         4f    .   18:         *         *v   *v   19:         =          =        20:        1C  1e 1g 1cc        21:        ==         ==        22:        *-         *-      ###### ^^^ Paths.krn ^^^ ######      Data fields:              *Token :: character  paths1$Path ##### vvv Paths.krn vvv #####    1:  !!!OTL: \"Path\" example    2:    **kern  **kern        3:     *M4/4   *M4/4        4:       *C:     *C:        5:        =-      =-        6:         0     0 0        7:         0     0 0        8:         0     0 0        9:         0       0       10:         =       =       11:         *      *^       12:         0       0   1   13:         0       0   1   14:         0       0   1   15:         0       0   1   16:         0       0   1   17:         0       0   1   18:         *      *v  *v   19:         =       =       20:         0   0 0 0       21:        ==      ==       22:        *-      *-     ##### ^^^ Paths.krn ^^^ #####      Data fields:               Token :: character  getHumtab(paths1) paths2 <- readHumdrum('examples/Paths2.krn') Finding and reading files...     REpath-pattern 'examples/Paths2.krn' matches 1 text files in 1 directory. One files read from disk.  Validating one files...all valid. Parsing one files...Assembling corpus...Done!  paths2 ######## vvv Paths2.krn vvv #########    1:  !!!OTL: complex \"Path\" example    2:    **path            3:         a            4:        *^            5:         b   c        6:         d   e        7:        *^   *        8:         f   g   h    9:         i   j   k   10:        *v  *v   *   11:         l   m       12:         n   o       13:         *  *^       14:         p   q   r   15:         s   t   u   16:         *  *v  *v   17:         v   w       18:         x   y       19:        *v  *v       20:         z           21:        *-         ######## ^^^ Paths2.krn ^^^ #########      Data fields:              *Token :: character  paths2$Path ######## vvv Paths2.krn vvv #########    1:  !!!OTL: complex \"Path\" example    2:    **path            3:         0            4:        *^            5:         0   2        6:         0   2        7:        *^   *        8:         0   1   2    9:         0   1   2   10:        *v  *v   *   11:         0   2       12:         0   2       13:         *  *^       14:         0   2   3   15:         0   2   3   16:         *  *v  *v   17:         0   2       18:         0   2       19:        *v  *v       20:         0           21:        *-         ######## ^^^ Paths2.krn ^^^ #########      Data fields:               Token :: character  getHumtab(paths2)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/GettingStarted.html","id":"doing-stuff","dir":"Articles","previous_headings":"","what":"Doing Stuff!","title":"Getting started with humdrumR","text":"Ok, ’ve now seen read inspect humdrumR data. ’ve also got idea humdrum data looks like surface: humdrum table. can ? create humdrumR corpus object, using readHumdrum, object encapsulates humdrum-table (data.table) object, data really stored. ’ve already seen can extract humdrum table directly using getHumtab—aleady R pro, might just want extract table work directly. However, humdrumR object give us convenient ways working table. example, ’ve already seen print humdrumR objects, print humdrum syntax, easier read complex humdrum table! humdrumR ! main thing humdrumR allow us work fields humdrum-tables way convenient powerful. First, create special “-expressions” refer humtable’s fields. create expression, use R ~ operator. instance, can write things like: ~ Spine + File ~ nchar(Token) ~ paste0(Token, Record) Notice three expressions contain names humdrumR fields. execute lines R session, nothing much happen: ’ll see saved—‘quoted’—returned R formula objects. However, can tell humdrumR evaluate expressions using fields humdrum tables. simplest way using %hum>% pipe operator, takes humdrumR object (left side), formula right side: expression evaluated, result put back place humdrum data! ’ll also notice printout, new Data field, called Pipe1—default name humdrumR assigns new fields create. want, can pick names using $<- (.e., assigning new name create using $). instance, lets use humdrumR’s semit function (see humdrum pitch vignette) calculate semitone value pitch chorales: worked! Lets , save result new field, call Semits—course, give name want, just let called Pipe1 want! now new Data field humdrum table, called Semits. Meanwhile, original Token field still , safely unchanged! Just like , can use $ operator look fields: Whats , can use Semits field just like field:","code":"~ Spine + File ~Spine + File  ~ nchar(Token) ~nchar(Token)  ~ paste0(Token, Record) ~paste0(Token, Record) chorales %hum>% ~ Spine + File ############################# vvv chor001.krn vvv #############################      1:  !!!COM: Bach, Johann Sebastian      2:  !!!CDT: 1685/02/21/-1750/07/28/      3:  !!!OTL@@DE: Aus meines Herzens Grunde      4:  !!!OTL@EN:      From the Depths of My Heart      5:  !!!SCT: BWV 269      6:  !!!PC#: 1      7:  !!!AGN: chorale    126:  !!!hum2abc: -Q ''    127:  !!!title: @{PC#}. @{OTL@@DE}    128:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B***    129:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a***    130:  !!!YOR3: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 ***    131:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1***    132:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10    133:  !!!EED:  Craig Stuart Sapp    134:  !!!EEV:  2009/05/22      8:          **kern        **kern        **kern        **kern      9:          *ICvox        *ICvox        *ICvox        *ICvox     10:          *Ibass       *Itenor        *Ialto       *Isoprn     11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano     12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B]     14:             *>A           *>A           *>A           *>A     15:         *clefF4      *clefGv2       *clefG2       *clefG2     16:          *k[f#]        *k[f#]        *k[f#]        *k[f#]     17:             *G:           *G:           *G:           *G:     18:             *F:             *             *             *     19:           *M3/4         *M3/4         *M3/4         *M3/4     20:          *MM100        *MM100        *MM100        *MM100     21:               2             3             4             5     22:              =1            =1            =1            =1     23:               2             3             4             5     24:               2             3             4             .     25:               .             3             .             .     26:               2             3             4             5     27:              =2            =2            =2            =2     28:               2             3             4             5     29:               2             3             .             .     30:               .             .             .             5     31:               2             3             4             5 32-125::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: ############################# ^^^ chor001.krn ^^^ #############################          (8 more files...)  ############################# vvv chor010.krn vvv #############################   1-51:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::     52:               .             .            13             .     53:              =7            =7            =7            =7     54:              11            12            13            14     55:              11            12            13            14     56:              11            12             .             .     57:              11            12            13            14     58:               .             .            13            14     59:              11            12            13            14     60:              =8            =8            =8            =8     61:              11            12            13            14     62:              11            12            13            14     63:              =9            =9            =9            =9     64:              11            12            13            14     65:              11            12            13            14     66:              11             .             .             .     67:              11            12            13            14     68:               .             .            13             .     69:              11            12            13            14     70:             =10           =10           =10           =10     71:              11            12            13            14     72:               .            12             .             .     73:              11             .            13            14     74:               .            12             .             .     75:              11            12            13            14     76:             =11           =11           =11           =11     77:              11            12            13            14     78:              11            12            13            14     79:              11            12            13            14     80:               .             .            13             .     81:             =12           =12           =12           =12     82:              11            12            13            14     83:              11            12            13            14     84:              11            12            13            14     85:              11            12             .            14     86:             =13           =13           =13           =13     87:              11            12            13            14     88:              11            12            13             .     89:              11            12            13             .     90:              ==            ==            ==            ==     91:              *-            *-            *-            *- ############################# ^^^ chor010.krn ^^^ #############################                        (***four global comments truncated due to screen size***)      humdrumR corpus of ten files.      Data fields:               Token :: character             *Pipe1 :: integer  chorales %hum>% ~ nchar(Token) ############################# vvv chor001.krn vvv #############################      1:  !!!COM: Bach, Johann Sebastian      2:  !!!CDT: 1685/02/21/-1750/07/28/      3:  !!!OTL@@DE: Aus meines Herzens Grunde      4:  !!!OTL@EN:      From the Depths of My Heart      5:  !!!SCT: BWV 269      6:  !!!PC#: 1      7:  !!!AGN: chorale    126:  !!!hum2abc: -Q ''    127:  !!!title: @{PC#}. @{OTL@@DE}    128:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B***    129:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a***    130:  !!!YOR3: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 ***    131:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1***    132:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10    133:  !!!EED:  Craig Stuart Sapp    134:  !!!EEV:  2009/05/22      8:          **kern        **kern        **kern        **kern      9:          *ICvox        *ICvox        *ICvox        *ICvox     10:          *Ibass       *Itenor        *Ialto       *Isoprn     11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano     12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B]     14:             *>A           *>A           *>A           *>A     15:         *clefF4      *clefGv2       *clefG2       *clefG2     16:          *k[f#]        *k[f#]        *k[f#]        *k[f#]     17:             *G:           *G:           *G:           *G:     18:             *F:             *             *             *     19:           *M3/4         *M3/4         *M3/4         *M3/4     20:          *MM100        *MM100        *MM100        *MM100     21:               3             2             2             2     22:              =1            =1            =1            =1     23:               2             2             2             2     24:               2             3             2             .     25:               .             3             .             .     26:               3             2             2             3     27:              =2            =2            =2            =2     28:               2             2             2             3     29:               2             3             .             .     30:               .             .             .             2     31:               2             2             2             2 32-125::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: ############################# ^^^ chor001.krn ^^^ #############################          (8 more files...)  ############################# vvv chor010.krn vvv #############################   1-51:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::     52:               .             .             4             .     53:              =7            =7            =7            =7     54:               2             2             2             2     55:               5             3             2             2     56:               3             3             .             .     57:               2             2             3             4     58:               .             .             3             4     59:               2             2             3             2     60:              =8            =8            =8            =8     61:               4             3             3             3     62:               2             2             2             3     63:              =9            =9            =9            =9     64:               2             2             2             2     65:               3             2             2             3     66:               3             .             .             .     67:               3             2             3             3     68:               .             .             3             .     69:               2             2             2             2     70:             =10           =10           =10           =10     71:               2             3             2             2     72:               .             2             .             .     73:               2             .             2             2     74:               .             3             .             .     75:               4             3             3             3     76:             =11           =11           =11           =11     77:               2             2             2             2     78:               3             2             2             3     79:               2             3             3             2     80:               .             .             3             .     81:             =12           =12           =12           =12     82:               2             2             2             2     83:               2             2             2             2     84:               4             2             3             2     85:               3             2             .             2     86:             =13           =13           =13           =13     87:               4             2             3             3     88:               3             2             2             .     89:               4             5             3             .     90:              ==            ==            ==            ==     91:              *-            *-            *-            *- ############################# ^^^ chor010.krn ^^^ #############################                        (***four global comments truncated due to screen size***)      humdrumR corpus of ten files.      Data fields:               Token :: character             *Pipe1 :: integer  chorales %hum>% ~ paste0(Token, Record) ############################# vvv chor001.krn vvv #############################      1:  !!!COM: Bach, Johann Sebastian      2:  !!!CDT: 1685/02/21/-1750/07/28/      3:  !!!OTL@@DE: Aus meines Herzens Grunde      4:  !!!OTL@EN:      From the Depths of My Heart      5:  !!!SCT: BWV 269      6:  !!!PC#: 1      7:  !!!AGN: chorale    126:  !!!hum2abc: -Q ''    127:  !!!title: @{PC#}. @{OTL@@DE}    128:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B***    129:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a***    130:  !!!YOR3: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 ***    131:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1***    132:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10    133:  !!!EED:  Craig Stuart Sapp    134:  !!!EEV:  2009/05/22      8:          **kern        **kern        **kern        **kern      9:          *ICvox        *ICvox        *ICvox        *ICvox     10:          *Ibass       *Itenor        *Ialto       *Isoprn     11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano     12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B]     14:             *>A           *>A           *>A           *>A     15:         *clefF4      *clefGv2       *clefG2       *clefG2     16:          *k[f#]        *k[f#]        *k[f#]        *k[f#]     17:             *G:           *G:           *G:           *G:     18:             *F:             *             *             *     19:           *M3/4         *M3/4         *M3/4         *M3/4     20:          *MM100        *MM100        *MM100        *MM100     21:           4GG21          4B21          4d21          4g21     22:              =1            =1            =1            =1     23:            4G23          4B23          4d23          2g23     24:            4E24         8cL24          4e24             .     25:               .         8BJ25             .             .     26:           4F#26          4A26          4d26         4dd26     27:              =2            =2            =2            =2     28:            4G28          4G28          2d28         4.b28     29:            4D29         4F#29             .             .     30:               .             .             .          8a30     31:            4E31          4G31          4B31          4g31 32-125::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: ############################# ^^^ chor001.krn ^^^ #############################          (8 more files...)  ############################# vvv chor010.krn vvv #############################   1-51:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::     52:               .             .        8f#J52             .     53:              =7            =7            =7            =7     54:            4G54          4d54          4g54          4b54     55:         8FnXL55         8dL55          4a55          4a55     56:           8EJ56         8eJ56             .             .     57:            4D57          4f57         8bL57        8ddL57     58:               .             .         8aJ58        8ccJ58     59:            4E59          4B59         4g#59          4b59     60:              =8            =8            =8            =8     61:          2AA;61         2c;61         2e;61         2a;61     62:            2A62          2e62          2a62         2cc62     63:              =9            =9            =9            =9     64:            4E64          4e64          4g64          4b64     65:           8DL65          4e65          4g65         4cc65     66:           8CJ66             .             .             .     67:           4BB67          4d67         8gL67         4dd67     68:               .             .         8fJ68             .     69:            4C69          4c69          4e69          4g69     70:             =10           =10           =10           =10     71:            4D71         8F#71          4d71          4b71     72:               .          4G72             .             .     73:            4D73             .          4c73          4a73     74:               .         8F#74             .             .     75:          2GG;75         2G;75         2B;75         2g;75     76:             =11           =11           =11           =11     77:            2C77          2G77          2e77          2g77     78:           4AA78          4A78          4e78         4cc78     79:            4E79         4G#79         8eL79          4b79     80:               .             .         8dJ80             .     81:             =12           =12           =12           =12     82:            4F82          4A82          4c82          4a82     83:            4C83          4G83          4c83          4e83     84:          4BB-84          4G84         [2d84          4g84     85:           4AA85          4A85             .          4f85     86:             =13           =13           =13           =13     87:          4GG#87          4B87         4d]87         1e;87     88:           4AA88          4A88          4c88             .     89:          2EE;89       2G#X;89         2B;89             .     90:              ==            ==            ==            ==     91:              *-            *-            *-            *- ############################# ^^^ chor010.krn ^^^ #############################                        (***four global comments truncated due to screen size***)      humdrumR corpus of ten files.      Data fields:               Token :: character             *Pipe1 :: character chorales %hum>% ~ semit(Token) ############################# vvv chor001.krn vvv #############################      1:  !!!COM: Bach, Johann Sebastian      2:  !!!CDT: 1685/02/21/-1750/07/28/      3:  !!!OTL@@DE: Aus meines Herzens Grunde      4:  !!!OTL@EN:      From the Depths of My Heart      5:  !!!SCT: BWV 269      6:  !!!PC#: 1      7:  !!!AGN: chorale    126:  !!!hum2abc: -Q ''    127:  !!!title: @{PC#}. @{OTL@@DE}    128:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B***    129:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a***    130:  !!!YOR3: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 ***    131:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1***    132:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10    133:  !!!EED:  Craig Stuart Sapp    134:  !!!EEV:  2009/05/22      8:          **kern        **kern        **kern        **kern      9:          *ICvox        *ICvox        *ICvox        *ICvox     10:          *Ibass       *Itenor        *Ialto       *Isoprn     11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano     12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B]     14:             *>A           *>A           *>A           *>A     15:         *clefF4      *clefGv2       *clefG2       *clefG2     16:          *k[f#]        *k[f#]        *k[f#]        *k[f#]     17:             *G:           *G:           *G:           *G:     18:             *F:             *             *             *     19:           *M3/4         *M3/4         *M3/4         *M3/4     20:          *MM100        *MM100        *MM100        *MM100     21:             -17            -1             2             7     22:              =1            =1            =1            =1     23:              -5            -1             2             7     24:              -8             0             4             .     25:               .            -1             .             .     26:              -6            -3             2            14     27:              =2            =2            =2            =2     28:              -5            -5             2            11     29:             -10            -6             .             .     30:               .             .             .             9     31:              -8            -5            -1             7 32-125::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: ############################# ^^^ chor001.krn ^^^ #############################          (8 more files...)  ############################# vvv chor010.krn vvv #############################   1-51:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::     52:               .             .             6             .     53:              =7            =7            =7            =7     54:              -5             2             7            11     55:              -7             2             9             9     56:              -8             4             .             .     57:             -10             5            11            14     58:               .             .             9            12     59:              -8            -1             8            11     60:              =8            =8            =8            =8     61:             -15             0             4             9     62:              -3             4             9            12     63:              =9            =9            =9            =9     64:              -8             4             7            11     65:             -10             4             7            12     66:             -12             .             .             .     67:             -13             2             7            14     68:               .             .             5             .     69:             -12             0             4             7     70:             =10           =10           =10           =10     71:             -10            -6             2            11     72:               .            -5             .             .     73:             -10             .             0             9     74:               .            -6             .             .     75:             -17            -5            -1             7     76:             =11           =11           =11           =11     77:             -12            -5             4             7     78:             -15            -3             4            12     79:              -8            -4             4            11     80:               .             .             2             .     81:             =12           =12           =12           =12     82:              -7            -3             0             9     83:             -12            -5             0             4     84:             -14            -5             2             7     85:             -15            -3             .             5     86:             =13           =13           =13           =13     87:             -16            -1             2             4     88:             -15            -3             0             .     89:             -20            -4            -1             .     90:              ==            ==            ==            ==     91:              *-            *-            *-            *- ############################# ^^^ chor010.krn ^^^ #############################                        (***four global comments truncated due to screen size***)      humdrumR corpus of ten files.      Data fields:               Token :: character             *Pipe1 :: integer chorales %hum>% ~ semit(Token) -> chorales$Semits chorales$Token ############################# vvv chor001.krn vvv #############################      1:  !!!COM: Bach, Johann Sebastian      2:  !!!CDT: 1685/02/21/-1750/07/28/      3:  !!!OTL@@DE: Aus meines Herzens Grunde      4:  !!!OTL@EN:      From the Depths of My Heart      5:  !!!SCT: BWV 269      6:  !!!PC#: 1      7:  !!!AGN: chorale    126:  !!!hum2abc: -Q ''    127:  !!!title: @{PC#}. @{OTL@@DE}    128:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B***    129:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a***    130:  !!!YOR3: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 ***    131:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1***    132:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10    133:  !!!EED:  Craig Stuart Sapp    134:  !!!EEV:  2009/05/22      8:          **kern        **kern        **kern        **kern      9:          *ICvox        *ICvox        *ICvox        *ICvox     10:          *Ibass       *Itenor        *Ialto       *Isoprn     11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano     12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B]     14:             *>A           *>A           *>A           *>A     15:         *clefF4      *clefGv2       *clefG2       *clefG2     16:          *k[f#]        *k[f#]        *k[f#]        *k[f#]     17:             *G:           *G:           *G:           *G:     18:             *F:             *             *             *     19:           *M3/4         *M3/4         *M3/4         *M3/4     20:          *MM100        *MM100        *MM100        *MM100     21:             4GG            4B            4d            4g     22:              =1            =1            =1            =1     23:              4G            4B            4d            2g     24:              4E           8cL            4e             .     25:               .           8BJ             .             .     26:             4F#            4A            4d           4dd     27:              =2            =2            =2            =2     28:              4G            4G            2d           4.b     29:              4D           4F#             .             .     30:               .             .             .            8a     31:              4E            4G            4B            4g 32-125::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: ############################# ^^^ chor001.krn ^^^ #############################          (8 more files...)  ############################# vvv chor010.krn vvv #############################   1-51:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::     52:               .             .          8f#J             .     53:              =7            =7            =7            =7     54:              4G            4d            4g            4b     55:           8FnXL           8dL            4a            4a     56:             8EJ           8eJ             .             .     57:              4D            4f           8bL          8ddL     58:               .             .           8aJ          8ccJ     59:              4E            4B           4g#            4b     60:              =8            =8            =8            =8     61:            2AA;           2c;           2e;           2a;     62:              2A            2e            2a           2cc     63:              =9            =9            =9            =9     64:              4E            4e            4g            4b     65:             8DL            4e            4g           4cc     66:             8CJ             .             .             .     67:             4BB            4d           8gL           4dd     68:               .             .           8fJ             .     69:              4C            4c            4e            4g     70:             =10           =10           =10           =10     71:              4D           8F#            4d            4b     72:               .            4G             .             .     73:              4D             .            4c            4a     74:               .           8F#             .             .     75:            2GG;           2G;           2B;           2g;     76:             =11           =11           =11           =11     77:              2C            2G            2e            2g     78:             4AA            4A            4e           4cc     79:              4E           4G#           8eL            4b     80:               .             .           8dJ             .     81:             =12           =12           =12           =12     82:              4F            4A            4c            4a     83:              4C            4G            4c            4e     84:            4BB-            4G           [2d            4g     85:             4AA            4A             .            4f     86:             =13           =13           =13           =13     87:            4GG#            4B           4d]           1e;     88:             4AA            4A            4c             .     89:            2EE;         2G#X;           2B;             .     90:              ==            ==            ==            ==     91:              *-            *-            *-            *- ############################# ^^^ chor010.krn ^^^ #############################                        (***four global comments truncated due to screen size***)      humdrumR corpus of ten files.      Data fields:              *Token  :: character              Semits :: integer  chorales$Semits ############################# vvv chor001.krn vvv #############################      1:  !!!COM: Bach, Johann Sebastian      2:  !!!CDT: 1685/02/21/-1750/07/28/      3:  !!!OTL@@DE: Aus meines Herzens Grunde      4:  !!!OTL@EN:      From the Depths of My Heart      5:  !!!SCT: BWV 269      6:  !!!PC#: 1      7:  !!!AGN: chorale    126:  !!!hum2abc: -Q ''    127:  !!!title: @{PC#}. @{OTL@@DE}    128:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B***    129:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a***    130:  !!!YOR3: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 ***    131:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1***    132:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10    133:  !!!EED:  Craig Stuart Sapp    134:  !!!EEV:  2009/05/22      8:          **kern        **kern        **kern        **kern      9:          *ICvox        *ICvox        *ICvox        *ICvox     10:          *Ibass       *Itenor        *Ialto       *Isoprn     11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano     12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B]     14:             *>A           *>A           *>A           *>A     15:         *clefF4      *clefGv2       *clefG2       *clefG2     16:          *k[f#]        *k[f#]        *k[f#]        *k[f#]     17:             *G:           *G:           *G:           *G:     18:             *F:             *             *             *     19:           *M3/4         *M3/4         *M3/4         *M3/4     20:          *MM100        *MM100        *MM100        *MM100     21:             -17            -1             2             7     22:              =1            =1            =1            =1     23:              -5            -1             2             7     24:              -8             0             4             .     25:               .            -1             .             .     26:              -6            -3             2            14     27:              =2            =2            =2            =2     28:              -5            -5             2            11     29:             -10            -6             .             .     30:               .             .             .             9     31:              -8            -5            -1             7 32-125::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: ############################# ^^^ chor001.krn ^^^ #############################          (8 more files...)  ############################# vvv chor010.krn vvv #############################   1-51:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::     52:               .             .             6             .     53:              =7            =7            =7            =7     54:              -5             2             7            11     55:              -7             2             9             9     56:              -8             4             .             .     57:             -10             5            11            14     58:               .             .             9            12     59:              -8            -1             8            11     60:              =8            =8            =8            =8     61:             -15             0             4             9     62:              -3             4             9            12     63:              =9            =9            =9            =9     64:              -8             4             7            11     65:             -10             4             7            12     66:             -12             .             .             .     67:             -13             2             7            14     68:               .             .             5             .     69:             -12             0             4             7     70:             =10           =10           =10           =10     71:             -10            -6             2            11     72:               .            -5             .             .     73:             -10             .             0             9     74:               .            -6             .             .     75:             -17            -5            -1             7     76:             =11           =11           =11           =11     77:             -12            -5             4             7     78:             -15            -3             4            12     79:              -8            -4             4            11     80:               .             .             2             .     81:             =12           =12           =12           =12     82:              -7            -3             0             9     83:             -12            -5             0             4     84:             -14            -5             2             7     85:             -15            -3             .             5     86:             =13           =13           =13           =13     87:             -16            -1             2             4     88:             -15            -3             0             .     89:             -20            -4            -1             .     90:              ==            ==            ==            ==     91:              *-            *-            *-            *- ############################# ^^^ chor010.krn ^^^ #############################                        (***four global comments truncated due to screen size***)      humdrumR corpus of ten files.      Data fields:               Token  :: character             *Semits :: integer chorales %hum>% ~ paste0(Token, ' = ', Semits) ############################# vvv chor001.krn vvv #############################      1:  !!!COM: Bach, Johann Sebastian      2:  !!!CDT: 1685/02/21/-1750/07/28/      3:  !!!OTL@@DE: Aus meines Herzens Grunde      4:  !!!OTL@EN:      From the Depths of My Heart      5:  !!!SCT: BWV 269      6:  !!!PC#: 1      7:  !!!AGN: chorale    126:  !!!hum2abc: -Q ''    127:  !!!title: @{PC#}. @{OTL@@DE}    128:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B***    129:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a***    130:  !!!YOR3: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 ***    131:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1***    132:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10    133:  !!!EED:  Craig Stuart Sapp    134:  !!!EEV:  2009/05/22      8:          **kern        **kern        **kern        **kern      9:          *ICvox        *ICvox        *ICvox        *ICvox     10:          *Ibass       *Itenor        *Ialto       *Isoprn     11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano     12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B]     14:             *>A           *>A           *>A           *>A     15:         *clefF4      *clefGv2       *clefG2       *clefG2     16:          *k[f#]        *k[f#]        *k[f#]        *k[f#]     17:             *G:           *G:           *G:           *G:     18:             *F:             *             *             *     19:           *M3/4         *M3/4         *M3/4         *M3/4     20:          *MM100        *MM100        *MM100        *MM100     21:       4GG = -17       4B = -1        4d = 2        4g = 7     22:              =1            =1            =1            =1     23:         4G = -5       4B = -1        4d = 2        2g = 7     24:         4E = -8       8cL = 0        4e = 4             .     25:               .      8BJ = -1             .             .     26:        4F# = -6       4A = -3        4d = 2      4dd = 14     27:              =2            =2            =2            =2     28:         4G = -5       4G = -5        2d = 2      4.b = 11     29:        4D = -10      4F# = -6             .             .     30:               .             .             .        8a = 9     31:         4E = -8       4G = -5       4B = -1        4g = 7 32-125::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: ############################# ^^^ chor001.krn ^^^ #############################          (8 more files...)  ############################# vvv chor010.krn vvv #############################   1-51:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::     52:               .             .      8f#J = 6             .     53:              =7            =7            =7            =7     54:         4G = -5        4d = 2        4g = 7       4b = 11     55:      8FnXL = -7       8dL = 2        4a = 9        4a = 9     56:        8EJ = -8       8eJ = 4             .             .     57:        4D = -10        4f = 5      8bL = 11     8ddL = 14     58:               .             .       8aJ = 9     8ccJ = 12     59:         4E = -8       4B = -1       4g# = 8       4b = 11     60:              =8            =8            =8            =8     61:      2AA; = -15       2c; = 0       2e; = 4       2a; = 9     62:         2A = -3        2e = 4        2a = 9      2cc = 12     63:              =9            =9            =9            =9     64:         4E = -8        4e = 4        4g = 7       4b = 11     65:       8DL = -10        4e = 4        4g = 7      4cc = 12     66:       8CJ = -12             .             .             .     67:       4BB = -13        4d = 2       8gL = 7      4dd = 14     68:               .             .       8fJ = 5             .     69:        4C = -12        4c = 0        4e = 4        4g = 7     70:             =10           =10           =10           =10     71:        4D = -10      8F# = -6        4d = 2       4b = 11     72:               .       4G = -5             .             .     73:        4D = -10             .        4c = 0        4a = 9     74:               .      8F# = -6             .             .     75:      2GG; = -17      2G; = -5      2B; = -1       2g; = 7     76:             =11           =11           =11           =11     77:        2C = -12       2G = -5        2e = 4        2g = 7     78:       4AA = -15       4A = -3        4e = 4      4cc = 12     79:         4E = -8      4G# = -4       8eL = 4       4b = 11     80:               .             .       8dJ = 2             .     81:             =12           =12           =12           =12     82:         4F = -7       4A = -3        4c = 0        4a = 9     83:        4C = -12       4G = -5        4c = 0        4e = 4     84:      4BB- = -14       4G = -5       [2d = 2        4g = 7     85:       4AA = -15       4A = -3             .        4f = 5     86:             =13           =13           =13           =13     87:      4GG# = -16       4B = -1       4d] = 2       1e; = 4     88:       4AA = -15       4A = -3        4c = 0             .     89:      2EE; = -20    2G#X; = -4      2B; = -1             .     90:              ==            ==            ==            ==     91:              *-            *-            *-            *- ############################# ^^^ chor010.krn ^^^ #############################                        (***four global comments truncated due to screen size***)      humdrumR corpus of ten files.      Data fields:               Token  :: character              Semits :: integer             *Pipe1  :: character"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/HumdrumSyntax.html","id":"structure-vs-content","dir":"Articles","previous_headings":"","what":"Structure vs Content","title":"The Humdrum Syntax","text":"humdrum syntax lays simple structure encoding data, says nothing content. information encoded, information represented flexible. flexibility, structure humdrum data—humdrum syntax—always , makes easy work ! fill content humdrum files, define “interpretations. Interpretations schemes represent information characters. sounds complicated/scary, can simple! instance, wanted encode drum beats humdrum invent simple scheme encoding drum beats : Kick drum = “K” Snare drum = “S” Hi-Hat = “H” treat newline text file sixteenth-note tick (read humdrum “timebase” ) start encoding. thing need make conform humdrum syntax name : call overarching interpretations like “exclusive interpretations”, prefixed **. call **drums ’d ready create humdrum data!","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/HumdrumSyntax.html","id":"syntax","dir":"Articles","previous_headings":"","what":"Syntax","title":"The Humdrum Syntax","text":"humdrum syntax , first glange, nothing simple, tab-delineated spread sheet. (“tab-delineated” just means columns spreadsheet separated TABs.) basic idea, extra features learn! Let’s take look basic humdrum file:  file can broken different types information like :  file two columns data, separated tabs. However, special terminology use: “columns” humdrum file called spines. line, row, file called record.  twenty records two spines file. character-string, located spine/record position, called token. Examples tokens file include *M4/4, 4A, =1, !Suspension.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/HumdrumSyntax.html","id":"global-vs-local","dir":"Articles","previous_headings":"Syntax","what":"Global vs Local","title":"The Humdrum Syntax","text":"’ll notice two records file (1 10) don’t seem two columns. Indeed, called “global” records—don’t belong particular column, whole row/file. image illustrates two spines file don’t include records 1 10:  real data :","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/HumdrumSyntax.html","id":"time","dir":"Articles","previous_headings":"Syntax","what":"Time","title":"The Humdrum Syntax","text":"one fundamental assumption regarding humdrum syntax encodes information: travel downward file (top bottom) encoding information order occurs time. true data records—interpetation comment records associated moment time first data record occurs . Information appears record (within one spine, different spines) assumed happen time.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/HumdrumSyntax.html","id":"record-types","dir":"Articles","previous_headings":"Syntax","what":"Record Types","title":"The Humdrum Syntax","text":"humdrum syntax recognizes four broad types records, five sub-types: Exclusive (**) Tandem (*) Reference (!!!) Global (!!) Local (!) Barlines (=) Data know type record ’re dealing looking first character token. tokens single record must type—can’t interpretation token comment token line. result, can refer type token, type whole record, tokens within record always type.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/HumdrumSyntax.html","id":"interpretations","dir":"Articles","previous_headings":"Syntax > Record Types","what":"Interpretations","title":"The Humdrum Syntax","text":"token starts *, interpretation token. Two stars ** indicates exclusive interpretation. Every spine must start exclusive interpretation, can one. exclusive interpretation spine tells us type information encoded spine, whole spine. instance, **drums interpration invented exclusive interpetation. examples ’re using , exclusive interpretation spines **kern, widely used humdrum interpretation, used encode music notation. Note humdrum file can different exclusive interpretations spine—don’t , example. read various humdrum interpretations defined, check humdrum.org.  token starts one *, called tandem interpretation. Tandem interpretations tell us specific, localized information interpret data. can different, overlapping tandem interpretations within spine. example, *C:, *Ibass, *M4/4, *M3/4, tandem interpretations. *C: used **kern indicate key C major. *Ibass indicates instrument associated spine (bass voice). *M4/4 *M3/4 indicate 4/4 3/4 meter respectively. last case brings something important tandem interprations: tandem interpretation applied subsequent data points, unless cancelled replaced another tandem intepretation type. Thus, humdrum file indicates 4/4 time starting record 5, switches 3/4 time record 13. However, *M4/4 record 4 doesn’t replace *C: record 3, different types tandem intepretations. One special token *- token. token indicates spine ends. *- missing end—one every spine—invalid humdrum file!","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/HumdrumSyntax.html","id":"comments","dir":"Articles","previous_headings":"Syntax > Record Types","what":"Comments","title":"The Humdrum Syntax","text":"token begins !, comment token. Comments used freely include comments data. global comments (!!) associated spine—apply whole file point appear—local comments (!) specific particular spine. example, !! Ritardando global comment, !Suspension local comment, specific second spine.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/HumdrumSyntax.html","id":"reference-records","dir":"Articles","previous_headings":"Syntax > Record Types > Comments","what":"Reference Records","title":"The Humdrum Syntax","text":"one final type comment: reference records. Reference records global comments placed beginning end file. Reference records encode global metadata entire file: things like composed piece title piece . Reference records specific “reference codes,” usually three digits, come !!!, followed colon, whatever content record . instance, code !!!OTL: refers original title piece. Learn various standard humdrum reference records .","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/Intervals.html","id":"intervals","dir":"Articles","previous_headings":"","what":"Intervals","title":"Rhythm and Pitch Intervals","text":"pitch time perceived relatively: relationship two points. Thus represent , conceptually, interval—difference. case pitch, interval two frequencies (abstractly, “tonal” interval circle--fifths). case rhythm, interval two time points—two onsets, onset offset. humdrumR, abstract intervals represented tonalInterval rhythmInterval objects, respectively. concretize abstract intervals, must establish relative . reference? actually multiple, useful ways can represent information. Since intervals relative, always implicit reference—origin, zero. tonalIntervals origin unison interval. rhythmIntervals origin zero. tonalIntervals rhythmIntervals constitute constitute algebraic module integers (module \\(\\mathbb{Z}\\)), appropriate arithmetic operations fully defined humdrumR. Since intervals can added/subtracted, interval can thought combination (addition) intervals. humdrumR, often “partition” interval combination useful sub-intervals.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/Intervals.html","id":"serial-and-fixed-reference","dir":"Articles","previous_headings":"Intervals","what":"Serial and Fixed Reference","title":"Rhythm and Pitch Intervals","text":"Vectors humdrumR intervals can represented two fundamental ways: serial reference representation fixed reference representation. illustrate, use two examples, one rhythmic, one pitched: major scale “tag-line” rhythm 3+3+3+3+2+2","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/Intervals.html","id":"fixed-reference","dir":"Articles","previous_headings":"Intervals > Serial and Fixed Reference","what":"Fixed reference","title":"Rhythm and Pitch Intervals","text":"fixed-reference representation, intervals interpreted relative fixed point (implicitly 0). Fixed-reference representations major scale (using semitones) tag-line rhythm follows: Note representation quite commonly used musicians, various forms, pitch. contrast, fixed-reference representations commonly used musicians rhythm. However, used contexts, essentially represent “time beginning” piece: Thus, timestamps/timelines DAWs “offsets” music21 examples fixed-reference representations time.","code":"referenceMajor   <- c(0, 2, 4, 5, 7, 9, 11, 12)  referenceTagline <- c(0, 3, 6, 9, 12, 14, 16)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/Intervals.html","id":"serial-reference","dir":"Articles","previous_headings":"Intervals > Serial and Fixed Reference","what":"Serial reference","title":"Rhythm and Pitch Intervals","text":"alternative representation serial-reference representation, interval measured relative previous one. Thus, data point represents local change (\\(\\Delta\\)) parameter. lossless (explained ) first element serial data vector measured relative implicit reference (0). Serial representations tag-line major scale follows: representations also fairly intuitive musicians—representing “melodic intervals”—music notation sequencers represent pitch. contrast, serial-reference representation rhythm normative: traditional music notation note values serial-reference representation.","code":"serialMajor   <- c(0, 2, 2, 1, 2, 2, 2, 1)  serialTagline <- c(0, 3, 3, 3, 3, 2, 2)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/Intervals.html","id":"transformations-interval-calculus","dir":"Articles","previous_headings":"Intervals > Serial and Fixed Reference","what":"Transformations (“Interval Calculus”)","title":"Rhythm and Pitch Intervals","text":"Since addition defined intervals fixed-reference serial-reference representations can translated . serial-reference representation can calculated pairwise differences elements fixed-reference data, first reference element appended beginning. Conversely, fixed-reference representation can calculated cumulative sum serial-reference data. Thus: humdrumR, refer two transformations delta (\\(\\Delta\\)) sigma (\\(\\Sigma\\)), differences sums respecticely. humdrumR, note relationship fixed- serial-reference representations analogous relationship function derivative. fixed-reference representation represents sequence independent values function (serial) index position. serial-reference representation represents sequence differences adjacent elements index—much fixed representation changes index. (Since first element serial-reference representation relative fixed (implicit) reference, normal one--many relationship derivatives functions removed, lossless one--one relationship maintained.) two transformations thus inverses : \\(x = sigma(delta(x))\\) \\(x = delta(sigma(x))\\). Derivative/Integral relationship Major Scale Derivative/Integral relationship Tagline Rhythm","code":"identical(cumsum(serialMajor), referenceMajor) ## [1] TRUE identical(cumsum(serialTagline), referenceTagline) ## [1] TRUE identical(c(referenceMajor[1], diff(referenceMajor)), serialMajor) ## [1] TRUE identical(c(referenceTagline[1], diff(referenceTagline)), serialTagline) ## [1] TRUE library(humdrumR) ## Loading required package: rlang ##  ## Attaching package: 'humdrumR' ## The following objects are masked from 'package:stats': ##  ##     integrate, lag, sigma ## The following object is masked from 'package:methods': ##  ##     signature identical(referenceMajor, sigma(delta(referenceMajor))) ## [1] TRUE identical(referenceMajor, delta(sigma(referenceMajor))) ## [1] TRUE"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/Intervals.html","id":"dynamic-reference","dir":"Articles","previous_headings":"Intervals","what":"Dynamic Reference","title":"Rhythm and Pitch Intervals","text":"Since intervals additive, another possibilty use one vector intervals reference point second vector intervals. allows us create dynamic reference points. examples Figured Bass: bass voice texture encoded (serial/reference reprsentation) voices represented relative bass voice. Chord Tones: abstract “root” chord progression represented one vector, vectors representing “chord tones” (root, 3rd, 5th, 7th, etc.) relative chord root. Scale degrees: tonic key used dynamic reference, notes calculated relative tonic. Figured Bass Calculating dynamic reference intervals lossless complete information reference intervals maintained. instance, keep track serial fixed intervals bass voice. , keep track local key (usually using fixed interval “C”).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/KeysAndChord.html","id":"diatonic-sets","dir":"Articles","previous_headings":"","what":"Diatonic Sets","title":"Diatonic and Tertian Sets in humdrumR","text":"mentioned Pitch Tonality vignette, normative diatonic key consists set seven consetutive pitch chroma Line Fifths. diatonic set can orderd either line--fifths position: “scale-order,” corresponds steps \\(+2\\) (\\(-5\\)) modulo 7.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/KeysAndChord.html","id":"tertian-sets","dir":"Articles","previous_headings":"","what":"Tertian Sets","title":"Diatonic and Tertian Sets in humdrumR","text":"set seven notes diatonic key can reimagined chord—set notes played time. Specifically, full seven-note diatonic chord refered 13th chord. However, chords used tonal music subsets full diatonic set, particular three-note triads. viewing diatonic set chord, traditionally order set sequence ascending thirds, corresponding intervals \\(+4\\) line--fifths, modulo 7. tertian steps usually wrapped octave, resulting steps 9, 11, 13, instead 2, 4, 6. \\(2^7=\\) 128 possible subsets can formed full diatonic set. , seven possiblities built consecutive tertian steps theoritically priveledged : .e., \\(\\{\\{1\\}, \\{1,3\\}, \\{1,3,5\\}, \\{1,3,5,7\\}, \\{1,3,5,7,9\\}, \\{1,3,5,7,9,11\\}, \\{1,3,5,7,9,11,13\\}\\}\\). possible sets fairly commonplace Western theory well: \\(\\{1,5, 11\\}\\) (“sus4”), \\(\\{1,3,5,9\\}\\) (“add9”), \\(\\{1,3,5,13\\}\\) (“add6”), etc.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/KeysAndChord.html","id":"concrete-representations","dir":"Articles","previous_headings":"Tertian Sets","what":"Concrete Representations","title":"Diatonic and Tertian Sets in humdrumR","text":"numerous ways tertian sets notes traditionally notated annotated character strings. Unfortunately, systems always rigorously consisistent logical, convenient shorthands common chords lead ambiguity, /practices rooted traditional practices little relavance. humdrumR aims provide general approach make reading/writing chord annotations many forms possible. chord representation consists set least one following elements: root note. bass note. subset tertian steps present. Qualities chord steps, relative implicit explicit key. Traditional chord notation symbols often conflate merge various elements various ways, numerous common shorthands. particular, common diatonic traids—abstractly different combinations qualities 3rd 5th—represented various shorthands.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/KeysAndChord.html","id":"section","dir":"Articles","previous_headings":"","what":"Diatonic and Tertian Sets in humdrumR","title":"Diatonic and Tertian Sets in humdrumR","text":"Chord symbols tonal chroma practice often used indicate bass note part ostensible chord. instance, C7/Ab. consist form, unique symbol appended indicate one four unique triad types: major, minor, diminished, augmetned. However, cases, major assumed default, can ommitted. cases, either major minor symbol ommited, case root symbol used indicate major minor. (cases, case root symbol also matched diminished (lower) augmented (major) symbols).) Roman numerals 7ths 753 7, 653 65, 643 43, 642 42 2 9ths 9753: 1111100 7653: 1111001 6543: 1110011 6432: 1100111 7642: 1001111 11ths 11","code":"753:     1111000 653:     1110001 643:     1100011 642:     1000111"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/Overview.html","id":"what-is-humdrum","dir":"Articles","previous_headings":"","what":"What is humdrum?","title":"Overview of humdrumR","text":"Humdrum system analyzing blah blah.","code":"library(humdrumR) #> Loading required package: rlang #>  #> Attaching package: 'humdrumR' #> The following objects are masked from 'package:stats': #>  #>     integrate, lag, sigma #> The following object is masked from 'package:methods': #>  #>     signature"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"tonal-intervals","dir":"Articles","previous_headings":"","what":"Tonal Intervals","title":"Pitch and Tonality in humdrumR","text":"tl;dr: humdrumR encodes tonal pitch information intervals fundamental line--fifths (tonal), combined octave value indicate pitch height,. tonalInterval class core pitch representation humdrumR. name suggests, pitch encoded tonally. means focus representation line--fifths (LoF). Pitch names (letters accidentals), intervals, diatonic keys tertian harmonies make logical sense defined line--fifths. want define specific pitches frequency space, add specific “pitch-height” information, encoded separate octaves field.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"psychoacoustics-and-the-western-tuning-system","dir":"Articles","previous_headings":"Tonal Intervals","what":"Psychoacoustics and the Western Tuning System","title":"Pitch and Tonality in humdrumR","text":"tl;dr: Tonal intervals represented combinations octaves (second harmonic, 2:1 ratio) perfect 12ths (third harmonic, ~3:1 ratio). perfect 12ths represent circle--fifths diatonic collections octaves help specific specific pitch height. first glance, pitch appears straightforward, one-dimensional phenomenon: every “pitched event” frequency (perceptually) associated . refer frequency associated event ’s “pitch”—, ’ll use term frequency pitch interchangeably. Human can percieve frequencies ranging approximately \\(20\\)–\\(20,000_{Hz}\\). (“Hz” abbreviation Hertz; e.g. cycles-per-second.)  However, perception pitch predominantly relative, absolute. words, (us) can’t identify specific frequenncies isolation; instead, percieve “distance” pitches, call interval. specfically, percieved distance/intervals frequencies rationally: distance percieve ratio pitches. example, “distance” frequencies \\(200_{Hz}\\) \\(300_{Hz}\\) distance \\(2,400_{Hz}\\) \\(3,600_{Hz}\\). ? ratios: \\(\\frac{200}{300} = \\frac{2,400}{3,600}\\)! means makes sense think enormous \\(20\\)–\\(20,000_{Hz}\\) frequency range percieve logarithmic scale, makes equal distance look equal paper:","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"octave-equivalence","dir":"Articles","previous_headings":"Tonal Intervals > Psychoacoustics and the Western Tuning System","what":"Octave Equivalence","title":"Pitch and Tonality in humdrumR","text":"perceive distance (interval) pitches based ratio frequencies. ratios created equal! simplest, integer ratios privileged perception—simply sound better, consonant, us! Integer ratios frequencies called harmonics. simplest, purest harmonic relationship 2--1 ratio, call octave. Pitches separated octave consonant actually perceive “pitch” (respects). call sameness octave equivalence. two pitches octave equivalent—.e., ratio frequencies power two—say pitch chroma. following figure, three rows frequencies represent groups pitches equivalent chroma:  Due perceptual reality octave equivalence, (essentially ) musical scales use octave bounding point—patterns pitch chroma (e.g., scales) repeated octave can perceive. Thus, even though can perceive close ten octaves worth frequencies, organization pitch music mostly based pitches can squeezed single octave.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"tonal-harmonics","dir":"Articles","previous_headings":"Tonal Intervals > Psychoacoustics and the Western Tuning System","what":"Tonal Harmonics","title":"Pitch and Tonality in humdrumR","text":"2--1 harmonic octave, however, whole story. next couple integer (harmonic) ratios also special, perceptually: third fifth harmonics—corresponding major scale degrees \\(\\hat{5}\\) (perfect fifth) \\(\\hat{3}\\) (major third) respectively—influenced development Western tonality. say, musical scales tuned way create ratios scale degrees close 3--1 5--1 possible. “Just intonation” preeminent Western example. third harmonic (\\(\\approx\\hat{5}\\)) primary factor Western tonal system—humdruMR call tonal harmonic. Western diatonic scale constructed, fundamentally, arranging 3rd-harmonic intervals within octave. logical result approach octave divided five (pentatonic), seven (diatonic), twelve (chromatic) unequal steps.  seven-note diatonic fundamental unit Western tonality several thousand years. chromatic (12-note) superset gradually grown prominence last five centuries, yet tonal contexts, chromatic set still distinctly superset diatonic, seen diatonic set plus five “alterations.”  Thus, 3rd-harmonic fundamental generator Western diatonic scale, diatonic keys, tonality general. Throughout humdrumR often refer line--fifths (circle--fifths), “fifths” stacked 3rd harmonics.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"pythagorean-tuning","dir":"Articles","previous_headings":"Tonal Intervals > Psychoacoustics and the Western Tuning System","what":"Pythagorean Tuning","title":"Pitch and Tonality in humdrumR","text":"tl;dr: sections talks abstract line--fifths “tonal harmonics” tuned actual pitches. part, doesn’t really matter much within Western music; assume equal temperament time. tonal analyses don’t really depend specific flavor Western tuning/temperament use. scale actually tuned “pure” 3rd-harmonics results pythagorean tuning. However, centuries, Western musicians systematically mistuned, tempered, 3rd-harmonic ratios order produce pure 5th harmonics (meantone temperament) minimize dissonance 2nd harmonic (equal temperament). example, twelve fifths flattened \\(\\sqrt[{12}]{\\frac{3^{19}}{2^{12}}}\\) (2 cents), result chromatic scale equally divides octave—creating semitones. equal temperament tuning system dominant West less 250 years. Despite ubiquity equal temperament modern era, Pythagorean tuning—variants incorporate pure 5th harmonic—remains conceptual basis Western tonality. Notably, Pythagorean tuning, pitches separated twelve fifths . traditional notation theory distinguishes , example, G# Ab, minor-3rd augmented-2nd. contrast, equal temperament, values “enharmonic”—.e., equivalent. Equally-tempered G# Ab played frequency within tonal organization Western music still reflect perceptually distinct categories: example, G# key E major Ab key F minor quite distinct!","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"line-of-fifths","dir":"Articles","previous_headings":"Tonal Intervals > Psychoacoustics and the Western Tuning System","what":"Line-of-Fifths","title":"Pitch and Tonality in humdrumR","text":"fifth-based tonal system results general structure known line fifths (LoF). “step” LoF corresponds fifth (.e., 3rd-harmonic ratio). LoF ranges \\(-\\infty\\)–\\(\\infty\\), zero corresponding “unison” interval, root, note C. complete chromatic set consists 12 contiguous steps LoF—apply modulo 12 transformation, chromatic twelfth step first “enharmonically.” modulus operation turns line--fifths circle--fifths (CoF). Seven contiguous values line--fifths form diatonic scale, tonal key. Shifting contiguous block /line gets us different keys Western music. perform modulo 7 operation LoF, get pure diatonic set—“chromatic” notes mapped diatonic counterpoints.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"encoding-tonal-pitches","dir":"Articles","previous_headings":"Tonal Intervals","what":"Encoding Tonal Pitches","title":"Pitch and Tonality in humdrumR","text":"mimic fundamental logic Western tonality, tonalIntervals represented combination 2nd- 3rd- harmonic powers. encoded integers Octave Fifth fields respectively. Fifth slot represents “tonal chroma”—line--fifths space diatonic chromatic structures defined. Octave slot specifies specific shifts absolute frequency. Fifth Octave fields combined represent specific notes. combination modeled way harmonic ratios combine Pythagorean tuning. Octave value represents power 2 (\\(2^n\\)), Fifth value represents power 3 (\\(3^n\\)), values multiplied together (human rational/logarithmic perception pitch works). Thus, \\(2^{Octave} * 3^{Fifth} = \\text{tonal interval}\\) example, tonalInterval (Octave = -2, Fifth = 2) represents \\(2^{-2} * 3^{2} = \\frac{1}{4} * 9 = \\frac{9}{4}\\) corresponds (Pythagorean) major-9th. tonalInterval representation sense “locked” Pythagorean tuning. “tempered fifth” can used generating “tonal harmonic” ratio: \\(2^{Octave} * \\text{tonalHarmonic}^{Fifth} = \\text{tonal interval}\\) instance, \\(\\text{tonalHarmonic} = 2^{\\frac{19}{12}}\\), result equal temperament. humdrumR functions relate precise frequency values—frequency—tonalHarmonic argument. discussion illustrates “actual” harmonic use generate frequencies largely irrelevant. combination Octave Fifth integer slots represents Western “pitch space” abstractly. many research use cases, ignore Octave field altogether, considering abstract “tonal chroma” (.e., line--fifths) described Fifth slot. (Indeed, diatonicSet tertianSet classes concerned abstract “tonal space.”) following figure illustrate dimensions tonalInterval vector map pitches labeled “scientific pitch notation.” Scientific Pitch representation tonalIntervals can see, Fifth (x) dimension simply line--fifths. However, way Octave dimension relates specific pitches intuitive. design. tonalInterval \\(2^{Octave} * 3^{Fifth}\\) scheme meant engaged directly users. Rather back-end, nice properties:","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"algebra-and-arithmetic","dir":"Articles","previous_headings":"Tonal Intervals > Encoding Tonal Pitches","what":"Algebra and Arithmetic","title":"Pitch and Tonality in humdrumR","text":"Tonal intervals defined constitute algebraic module integers (module \\(\\mathbb{Z}\\)), appropriate arithmetic operations fully defined humdrumR. module, necessarily abelian groups, requisite operations: tonalIntervals can added (+) subtracted (-), resulting new tonalIntervals. example, \\(\\text{P5} + \\text{M2} = \\text{M6}\\). tonalIntervals “negative,” inverted counterpart. Summing tonalInterval ’s negative/inversion results identity element. example, \\(-\\text{M3} + \\text{M3} = \\text{P1}\\). identify element—“reference point”, middle C, unison. (Octave\\(= 0\\) Fifth \\(=0\\).) modules, tonalIntervals can also multiplied “scalar” integer values. instance, \\(\\text{P5} * 2 = \\text{M9}\\). Finally, tonalIntervals euclidean division (%/%) modulo/remainder (%%) operations defined. (Rational division (/ R) defined.) Euclidean division tonalIntervals based tonal (fifths) space, frequency space. useful articulating tonal structures (modulo 7 example), can unintuitive applied specific pitches.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"tonal-interval-representations","dir":"Articles","previous_headings":"","what":"Tonal Interval Representations","title":"Pitch and Tonality in humdrumR","text":"Western music theory/practice rich set interrelated ways describing pitch: “C#”, “G”, “Eb” “+M3”, “+P5”, “-M2” “M3”, “P11”, “P8” “P1”, “P5”, “d5” “”, “mi”, “” humdrumR, concrete representations simply different perspectives abstract information—“tonal intervals” can represented tonalInterval objects. differ 1) fixed-reference, dynamic-reference, serial-reference interpretations; 2) whether Octave information included; 3) “tonal modulo” used. first, musicians may taken aback system: accustomed thinking values like F# “absolute” pitch representations, “” “relative” pitch representations, melodic intervals , well, melodic intervals. However, recognizing essentially equivalent powerful. Thus, “middle C” equivalent “unison”, “”, “P1”, “Tonic.” letter names really “absolute” quite evident many musical practices. Transposing instruments notated relative middle C, middle C defined relative “concert pitch.” Similarly, guitars often “drop-tuned” capoed, chords still identified using names relative open strings. following figure equivalent figure XXX, shows interval values instead. Interval Representation tonalIntervals","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"tonalinterval-partitions","dir":"Articles","previous_headings":"Tonal Interval Representations","what":"tonalInterval Partitions","title":"Pitch and Tonality in humdrumR","text":"Many practical distinctions different “concrete” representation pitch (previous section) boil different ways partition (discard) tonalInterval information. begin, can distinguish tonal height dimensions pitch. Tonal pitch information (like “Major third” “c#”) can abstract, corresponding specific frequencies. Thus, abstract c# neither “” “” g#. However, tonal intervals ordered scales—wrapped within octave. can “round” differently unison. Scaled tonal intervals still best regarded abstract. combination octave information get complex intervals. \\[ \\begin{aligned} TonalInterval = Octave \\times LoF Octave = \\mathbb{Z} LoF = \\mathbb{Z} \\end{aligned} \\] Every tonal interval combines simple interval octave offset. simple interval octave complex interval. \\[ \\begin{aligned} Complex = Simple \\times Octave  Specific = Alteration + Quality + Generic Generic = Step Alteration = Comma + Accidental \\end{aligned} \\] scale step one seven numbers line--fifths, 0 6, corresponding seven scale steps: 0 = Unison, 2 = Second, 4 = Third, 6 = Fourth, 1 = Fifth, 3 = Sixth, 5 = Seventh. \\[ \\] \\[ \\begin{aligned} Step = \\{0, 1, 2, 3, 4, 5 ,6\\} Quality(Key) \\subset Step \\times \\{7q\\ |\\ q \\\\Mathbb{z}\\} \\end{aligned} \\] \\[ \\begin{aligned} Octave + (Key + (Quality + Step) + Alteration + Comma) = Pitch Pitch - Octave = Specific (Step + Quality) + Alteration = Specific \\end{aligned} \\] \\[ Amajor_{Key} + \\hat{3}_{Step} + Major_{Quality} + Flat_{Alteration} = C natural \\]","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"simple-and-complex","dir":"Articles","previous_headings":"Tonal Interval Representations > tonalInterval Partitions","what":"Simple and Complex","title":"Pitch and Tonality in humdrumR","text":"HumdrumR tonalIntervals can represent complex interval: .e., intervals octave. instance, can distinguish “M2” “M9”. many cases, want partition intervals simple part octave part: simple part interval “within” one octave; general part simply number octaves.1 interval includes ’s octave part, called complex interval: \\(\\text{interval}_{simple} + \\text{interval}_{octave} = \\text{interval}_{complex}\\) actually four different ways make simple/octave partition, depending “round” intervals octave. four methods correspond four different ways rounding numbers general. terms base:: R functions: floor: round towards \\(-\\infty\\)—simple part always positive. common (default) approach simple intervals, used many pitch representations (notably, scale degrees). ceiling: round towards \\(\\infty\\)—simple part always negative. unusual use case. trunc: “truncate” (round) towards zero—two parts sign complex interval. method preserves direction interval. expand: “expand” (round) away zero—octave part always sign complex interval, whiel simple part opposite sign complex interval. round: round nearest octave, regardless direction. method results simple intervals always less 5th size. combined abs, result interval class (intervals equivalent inversions).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"contour","dir":"Articles","previous_headings":"Tonal Interval Representations > tonalInterval Partitions > Simple and Complex","what":"Contour","title":"Pitch and Tonality in humdrumR","text":"completely represent tonal interval, octave specific parts required. Many common analytical representations use “pure line--fifths,” simple part—solfege, scale degree, roman numerals, chord degrees, etc.. octave part discarded, (specific) original pitches reconstructed. Another useful representation combination fixed-reference simple part serial-reference (delta) octave part. representation, octave part represents contour melody. call derived contour. Throughout humdrumR, adopt representation Rolling Stone dataset use \"^\" \"v\" represent upward downward derived contours. Thus, \"vla\" means, go nearest \"la\". mentioned , tonalIntervals invertible—can positive negative. corresponds “direction” motion frequency space, relative reference. reference serial, corresponds melodic contour. Throughout humdrumR, adopt standard (obvious) **mint representation’s use \"+\" \"-\" represent true (sigma) contour.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"generic-and-specific","dir":"Articles","previous_headings":"Tonal Interval Representations > tonalInterval Partitions","what":"Generic and Specific","title":"Pitch and Tonality in humdrumR","text":"HumdrumR tonalIntervals can represent specific tonal, interval: instance, can distinguish “M2” “m2”. many cases, want partition intervals tonally, generic parts alteration parts: generic part interval within (diatonic) key—also called generic step; alteration part represents specific quality interval relative key (.e., perfect/major/minor), including shifts outside key (augment/diminish, sharp/flat, etc.). generic/alteration partition must made given key, including root mode. means generic/alteration partition can lossy key used lost—words, need know key used partition reconstruct specific interval. default key C major (\\(-1\\) \\(5\\) circle--fifths). \\(\\text{key} + \\text{interval}_{generic} + \\text{interval}_{alteration} = \\text{interval}_{specific}\\)","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"cautionary-qualities","dir":"Articles","previous_headings":"Tonal Interval Representations > tonalInterval Partitions > Generic and Specific","what":"Cautionary Qualities","title":"Pitch and Tonality in humdrumR","text":"cases want know tonally partition tonalInterval relative key, relative another key! One example “cautionary” accidentals music notation—“cautionary” accidentals involve pitches generic particular key (like major), generic C major. Another example chord quality annotations given key (instance, major IV chord minor key raised 6th scale degree, scale degrees secondary key. Condsider piece written C major, subsection modulates E major. E major section, observe D natural—generic interval ? Obviously, many analytical purposes, ’d want think Emajor, correspond \\(\\text{Emaj} + \\text{B}_{generic} + \\text{b}_{alteration}\\)—.e., flatted seventh degree E major. However, accidental note notated ? flat course, even though “flattened” seventh. (C major) key signature require accidental D natural, ’d like one clarify note’s relationship current key. first partition note E major, partition resulting generic interval C major, get: \\(\\text{Emaj} + (\\text{Cmaj} + \\text{D}_{generic} + \\text{#}_{alteration}) + \\text{b}_{alteration}\\) sharp flat—cases, use symbol natural.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"enharmonic-and-comma","dir":"Articles","previous_headings":"Tonal Interval Representations > tonalInterval Partitions","what":"Enharmonic and Comma","title":"Pitch and Tonality in humdrumR","text":"HumdrumR tonalIntervals can represent tonal pitch circle--fifths, even G#######! context equal-temperament tuning, consider tones separated 12 steps circle--fifths “”—enharmonic. Thus, equal temperament, interval diminished second—also known pythagorean comma—identical unison. can thus partition notes combinations harmonic part comma part. \\(\\text{interval}_{enharmonic} + \\text{interval}_{comma} = \\text{interval}_{tonal}\\) strictly wrap around every 12 steps line--fifths (.e., modulo 12), remove enharmonic equivalencies, creating circle--fifths. However, wrap matters: musical practice, typically aim center circle fifths around C, get roughly equal number flats sharps. However, since five accidentals, strict enharmonics either 2-flats/3 sharps, 3-flats/3-sharps. Since, natural diatonic scale spans range -1:5 line--fifths, real center 2 (D). (change key signatures, want shift accordingly, allowing higher sharps sharp key, instance.) Thus, default behavior humdrumR center set tints relative center given key, enharmonically shift notes >= 6 < -6. cases, don’t actually want strict enharmonicism. instance, might want allow Dbi—even Gb Cbi—alongside C#, F#, B, still want Bbb Gbbb ##. humdrumR, can specify wider “enharmonicWrap” value argument enharmonicpart. enharmonicWrap argument specifies width band “legal” LoF values want allow. default 12, results perfect enharmonic circle fifths (Eb:G#), enharmonic equivalences. increase 13, allow Ab G# exist; increase 14, allow Eb D# exist; etc. enharmonicWrap 21 allows single-flat single-sharp notes, double flat/sharps.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"methods","dir":"Articles","previous_headings":"","what":"Methods","title":"Pitch and Tonality in humdrumR","text":"humdrumR exports numerous functions converting /tonalIntervals various string representations, well integer/numeric representations: tonalInterval -> tonalInterval integer -> (semit) -> tonalInterval numeric -> (semit) -> tonalInterval character -> (regex) -> tonalInterval double + tonalInterval -> numeric (ratio) tonalInterval -> integer character -> integer numeric -> integer tonalInterval -> integer character -> (regex) -> integer numeric -> integer tonalInterval -> character integer -> (fifth -> tonalInterval) -> character tonalInterval -> character character -> (regex -> tonalInterval) -> character tonalInterval -> tonalInterval character -> (regex -> tonalInterval) -> character integer -> (semits) -> character numeric -> (ratio) -> character tonalInterval -> character tonalInterval -> character character -> (regex -> tonalInterval) -> character integer -> (semits -> tonalInterval) -> character numeric -> (ratio -> tonalInterval) -> character tonalInterval -> character character -> (regex -> tonalInterval) -> character integer -> (semits -> tonalInterval) -> character numeric -> (ratio -> tonalInterval) -> character tonalInterval -> character character -> (regex -> tonalInterval) -> character integer -> (fifth -> tonalInterval) -> character tonalInterval -> numeric character -> (regex -> tonalInterval) -> numeric integer -> (fifth -> tonalInterval) -> numeric numeric -> numeric tonalInterval -> character character -> (regex -> tonalInterval) -> character integer -> (fifth -> tonalInterval) -> character numeric -> character tonalInterval -> numeric character -> (regex -> tonalInterval) -> numeric integer -> (fifth -> tonalInterval) -> numeric numeric -> numeric","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"arguments","dir":"Articles","previous_headings":"Methods","what":"Arguments","title":"Pitch and Tonality in humdrumR","text":"Various tonal interval functions share number common arguments.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"diatonicset","dir":"Articles","previous_headings":"Methods","what":"diatonicSet","title":"Pitch and Tonality in humdrumR","text":"diatonicSet S4 class represents diatonic keys. Like tonalIntervals, conceptualize keys interval—distance reference point, Cmajor. means can represent key “G major” key “V” (major dominant key) way. diatonicSet contains three integer slots: Root, Mode, Alterations. addition, slot can hold another diatonicSet, allowing recursive representation, la “V/V/V.”","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"root-and-key","dir":"Articles","previous_headings":"Methods > diatonicSet","what":"Root and Key","title":"Pitch and Tonality in humdrumR","text":"Root integer slot simply line--fifths tonal chroma value representing root key relative 0 (C). Key value represents key signature: number sharps (positive integers) flats (negative integers) key. Alternatively, equivalently, can think Key like : C major represents contiguous block seven fifths (-1–5), Key argument shifts block . Key = 2, block line--fifths 1–7 (key signature two sharps). relationship Root Key determines mode diatonic set. Root == Key, mode major. modes can created : specific examples:","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"alteration","dir":"Articles","previous_headings":"Methods > diatonicSet","what":"Alteration","title":"Pitch and Tonality in humdrumR","text":"Alteration slot diatonicSet allows representation “altered” diatonic scales. One way thinking Key slot, takes one edge 7-fifth contiguous block moves opposite side. Alteration slot takes second extreme element moves 7 fifths.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"tertianset","dir":"Articles","previous_headings":"Methods","what":"TertianSet","title":"Pitch and Tonality in humdrumR","text":"Roman numerals.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/ReadWrite.html","id":"reading-humdrum-data","dir":"Articles","previous_headings":"","what":"Reading humdrum data","title":"Reading and writing data with humdrumR","text":"readHumdrum function gateway humdrumR: function use read humdrum data, encoded humdrum-syntax text files, R.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/ReadWrite.html","id":"practice-data","dir":"Articles","previous_headings":"Reading humdrum data","what":"Practice Data","title":"Reading and writing data with humdrumR","text":"following examples, make use small number raw humdrum data files included humdrumR. access files, need navigate directory computer installed humdrumR—fortunately, humdrumR records directory computer variable called humdrumRroot. load humdrumR library, just need set R “working directory” location using command setwd. humdrum data stored subdirectory called “HumdrumData”—can look contents directory using dir(recursive = TRUE): can see, five directories containing total fifty files.","code":"library(humdrumR) setwd(humdrumRroot) dir('HumdrumData', recursive = TRUE) #>  [1] \"BachChorales/chor001.krn\"                   #>  [2] \"BachChorales/chor002.krn\"                   #>  [3] \"BachChorales/chor003.krn\"                   #>  [4] \"BachChorales/chor004.krn\"                   #>  [5] \"BachChorales/chor005.krn\"                   #>  [6] \"BachChorales/chor006.krn\"                   #>  [7] \"BachChorales/chor007.krn\"                   #>  [8] \"BachChorales/chor008.krn\"                   #>  [9] \"BachChorales/chor009.krn\"                   #> [10] \"BachChorales/chor010.krn\"                   #> [11] \"BeethovenVariations/B075_00_01_a.krn\"       #> [12] \"BeethovenVariations/B075_00_02_a.krn\"       #> [13] \"BeethovenVariations/B075_00_03_a.krn\"       #> [14] \"BeethovenVariations/B075_00_04_a.krn\"       #> [15] \"BeethovenVariations/B075_00_05_a.krn\"       #> [16] \"BeethovenVariations/B075_00_06_a.krn\"       #> [17] \"BeethovenVariations/B075_01_01_a.krn\"       #> [18] \"BeethovenVariations/B075_01_02_a.krn\"       #> [19] \"BeethovenVariations/B075_01_03_a.krn\"       #> [20] \"BeethovenVariations/B075_01_04_a.krn\"       #> [21] \"BeethovenVariations/B075_01_05_a.krn\"       #> [22] \"BeethovenVariations/B075_01_06_a.krn\"       #> [23] \"MozartVariations/M354_00_01a_a.krn\"         #> [24] \"MozartVariations/M354_00_02b_a.krn\"         #> [25] \"MozartVariations/M354_00_03c_a.krn\"         #> [26] \"MozartVariations/M354_00_04d_a.krn\"         #> [27] \"MozartVariations/M354_01_01a_a.krn\"         #> [28] \"MozartVariations/M354_01_02b_a.krn\"         #> [29] \"MozartVariations/M354_01_03c_a.krn\"         #> [30] \"MozartVariations/M354_01_04d_a.krn\"         #> [31] \"RapFlow/2pac_IGetAround.rap\"                #> [32] \"RapFlow/BeastieBoys_BrassMonkey.rap\"        #> [33] \"RapFlow/Coolio_GangstasParadise.rap\"        #> [34] \"RapFlow/Ludacris_MoneyMaker.rap\"            #> [35] \"RapFlow/NotoriousBIG_Hypnotize.rap\"         #> [36] \"RapFlow/RobBase_ItTakesTwo.rap\"             #> [37] \"RapFlow/WillSmith_Summertime.rap\"           #> [38] \"RollingStoneCorpus/all_apologies.hum\"       #> [39] \"RollingStoneCorpus/back_in_black.hum\"       #> [40] \"RollingStoneCorpus/blue_suede_shoes.hum\"    #> [41] \"RollingStoneCorpus/born_to_be_wild.hum\"     #> [42] \"RollingStoneCorpus/god_only_knows.hum\"      #> [43] \"RollingStoneCorpus/hey_jude.hum\"            #> [44] \"RollingStoneCorpus/i_walk_the_line.hum\"     #> [45] \"RollingStoneCorpus/kashmir.hum\"             #> [46] \"RollingStoneCorpus/layla.hum\"               #> [47] \"RollingStoneCorpus/lets_stay_together.hum\"  #> [48] \"RollingStoneCorpus/living_for_the_city.hum\" #> [49] \"RollingStoneCorpus/me_and_bobby_mcgee.hum\"  #> [50] \"RollingStoneCorpus/your_song.hum\""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/ReadWrite.html","id":"targeting-files","dir":"Articles","previous_headings":"Reading humdrum data","what":"Targeting files","title":"Reading and writing data with humdrumR","text":"use readHumdrum call function one () character-string arguments. (function documentation (?readHumdrum), ’ll see arguments called ...—R, ... means number arguments.) arguments interpreted regular expressions, matched directories files system. call “REpath-patterns,” short Regular Expression directory-path patterns. example, uses REpath-pattern \"HumdrumData/BachChorales/chor.*.krn\" match files ‘HumdrumData/BachChorales’ directory whose name matches regular expression “chor..krn.” can see, REpath-pattern includes directory (folder) paths (relative absolute)—using operating system’s appopriate delimeter (”\" windows, ”/” everybody else)—* pattern matching file paths. directory also treated regular expression, possibly matching multiple directories. Let’s break : humdrumR splits REpath-pattern input string three parts: \"HumdrumData\", \"BachChorales\", \"chor.*.krn\", treats three regular expressions. first two expressions used match directories, last expression used match files. , readHumdrum('HumdrumData/BeethovenVariations/.*.krn') matches files ”.krn” extension “BeethovenVariations” directories readHumdrum('HumdrumData/MozartVariations/.*.krn') matches files “MozartVariations” directories, command readHumdrum('HumdrumData/.*Variations/.*.krn') match kern files directories! careful: since directory/file name always treated like regular expression, can sometimes specify something general intend. instance, command readHumdrum('MyFolder/.*') match files folder called “MyFolder,” also match folders names “MyFolder_Also”, “ThisIsMyFolder.” want sure match exactly one one directory/file, use “^” “$” regular-expression markers explicitely mark beginning end pattern: command readHumdrum('^MyFolder$/.*') read files one directory “MyFolder.” read test files can enter: Note: Since humdrumR can read files multiple directories , possible two files file name, different directories matched. happens, humdrumR identifies file enough ’s directory path make sure unique.","code":"library(humdrumR) setwd(humdrumRroot)  readHumdrum('HumdrumData/BachChorales/chor.*.krn') #> Finding and reading files... #>  REpath-pattern 'HumdrumData/BachChorales/chor.*.krn' matches 10 text files in 1 directory. #> Ten files read from disk.  #> Validating ten files...all valid. #> Parsing ten files...Assembling corpus...Done! #> ############################# vvv chor001.krn vvv ############################# #>      1:  !!!COM: Bach, Johann Sebastian #>      2:  !!!CDT: 1685/02/21/-1750/07/28/ #>      3:  !!!OTL@@DE: Aus meines Herzens Grunde #>      4:  !!!OTL@EN:      From the Depths of My Heart #>      5:  !!!SCT: BWV 269 #>      6:  !!!PC#: 1 #>      7:  !!!AGN: chorale #>    126:  !!!hum2abc: -Q '' #>    127:  !!!title: @{PC#}. @{OTL@@DE} #>    128:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** #>    129:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** #>    130:  !!!YOR3: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** #>    131:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** #>    132:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 #>    133:  !!!EED:  Craig Stuart Sapp #>    134:  !!!EEV:  2009/05/22 #>      8:          **kern        **kern        **kern        **kern #>      9:          *ICvox        *ICvox        *ICvox        *ICvox #>     10:          *Ibass       *Itenor        *Ialto       *Isoprn #>     11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano #>     12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] #>     13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] #>     14:             *>A           *>A           *>A           *>A #>     15:         *clefF4      *clefGv2       *clefG2       *clefG2 #>     16:          *k[f#]        *k[f#]        *k[f#]        *k[f#] #>     17:             *G:           *G:           *G:           *G: #>     18:             *F:             *             *             * #>     19:           *M3/4         *M3/4         *M3/4         *M3/4 #>     20:          *MM100        *MM100        *MM100        *MM100 #>     21:             4GG            4B            4d            4g #>     22:              =1            =1            =1            =1 #>     23:              4G            4B            4d            2g #>     24:              4E           8cL            4e             . #>     25:               .           8BJ             .             . #>     26:             4F#            4A            4d           4dd #>     27:              =2            =2            =2            =2 #>     28:              4G            4G            2d           4.b #>     29:              4D           4F#             .             . #>     30:               .             .             .            8a #>     31:              4E            4G            4B            4g #> 32-125::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: #> ############################# ^^^ chor001.krn ^^^ ############################# #>  #>      (8 more files...) #>  #> ############################# vvv chor010.krn vvv ############################# #>   1-51::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: #>     52:               .             .          8f#J             . #>     53:              =7            =7            =7            =7 #>     54:              4G            4d            4g            4b #>     55:           8FnXL           8dL            4a            4a #>     56:             8EJ           8eJ             .             . #>     57:              4D            4f           8bL          8ddL #>     58:               .             .           8aJ          8ccJ #>     59:              4E            4B           4g#            4b #>     60:              =8            =8            =8            =8 #>     61:            2AA;           2c;           2e;           2a; #>     62:              2A            2e            2a           2cc #>     63:              =9            =9            =9            =9 #>     64:              4E            4e            4g            4b #>     65:             8DL            4e            4g           4cc #>     66:             8CJ             .             .             . #>     67:             4BB            4d           8gL           4dd #>     68:               .             .           8fJ             . #>     69:              4C            4c            4e            4g #>     70:             =10           =10           =10           =10 #>     71:              4D           8F#            4d            4b #>     72:               .            4G             .             . #>     73:              4D             .            4c            4a #>     74:               .           8F#             .             . #>     75:            2GG;           2G;           2B;           2g; #>     76:             =11           =11           =11           =11 #>     77:              2C            2G            2e            2g #>     78:             4AA            4A            4e           4cc #>     79:              4E           4G#           8eL            4b #>     80:               .             .           8dJ             . #>     81:             =12           =12           =12           =12 #>     82:              4F            4A            4c            4a #>     83:              4C            4G            4c            4e #>     84:            4BB-            4G           [2d            4g #>     85:             4AA            4A             .            4f #>     86:             =13           =13           =13           =13 #>     87:            4GG#            4B           4d]           1e; #>     88:             4AA            4A            4c             . #>     89:            2EE;         2G#X;           2B;             . #>     90:              ==            ==            ==            == #>     91:              *-            *-            *-            *- #> ############################# ^^^ chor010.krn ^^^ ############################# #>                        (***four global comments truncated due to screen size***) #>  #>  humdrumR corpus of ten files. #>   Data fields:  #>          *Token :: character readHumdrum('HumdrumData/.*Variations/.*.krn') #> Finding and reading files... #>  REpath-pattern 'HumdrumData/.*Variations/.*.krn' matches 20 text files in 2 directories. #> Twenty files read from disk.  #> Validating twenty files...all valid. #> Parsing twenty files...Assembling corpus...Done! #> ################## vvv B075_00_01_a.krn vvv ################## #>     1:  !!!COM: Beethoven #>     2:  !!!OTL: 7 Variations on a Quartet by Winter #>     3:  !!!Variation: Theme a #>     4:    **function  **harm     **kern                 **kern #>     5:             *       *    *clefG2                *clefG2 #>     6:             *       *     *k[b-]                 *k[b-] #>     7:         *M2/4   *M2/4      *M2/4                  *M2/4 #>     8:           *F:     *F:        *F:                    *F: #>     9:            4T      4I         4r               4aa 4ccc #>    10:            =1      =1         =1                     =1 #>    11:            2T      2I         2f             8ff'L 8aa' #>    12:             .       .          .             8cc'J 8ff' #>    13:             .       .          .             8ff'L 8aa' #>    14:             .       .          .            8aa'J 8ccc' #>    15:            =2      =2         =2                     =2 #>    16:            4T     4V7  (4c 4e 4g              (4gg 4bb- #>    17:            4T      4I        4f)               4ff) 4aa #>    18:            =3      =3         =3                     =3 #>    19:            2T      2V         4c             8ee'L 8gg' #>    20:             .       .          .             8dd'J 8ff' #>    21:             .       .         4c             8cc'L 8ee' #>    22:             .       .          .             8dd'J 8ff' #>    23:            =4      =4         =4                     =4 #>    24:            4T      4V         8c                8ee 8gg #>    25:             .       .         8r                     8r #>    26:            4T      4I         4r               4aa 4ccc #>    27:            =5      =5         =5                     =5 #>    28:            2T      2I         2f             8ff'L 8aa' #>    29:             .       .          .             8cc'J 8ff' #>    30:             .       .          .             8ff'L 8aa' #>    31:             .       .          .            8aa'J 8ccc' #>    32:            =6      =6         =6                     =6 #>    33:            4T     4V7  (4c 4e 4g              (4gg 4bb- #>    34:            4T      4I     4f) 4a               4ff) 4aa #>    35:            =7      =7         =7                     =7 #>    36:            4P    4iib       8B-L               8ddL 8gg #>    37:             .       .       8B-J               8ddJ 8gg #>    38:            4D     4V7        8cL              (8b-L 8ee #>    39:             .       .        8cJ             16b-L 16dd #>    40:             .       .          .                16eeJJ) #> 41-45::::::::::::::::::::::::::::::::::::::::::::::::::::::::: #> ################## ^^^ B075_00_01_a.krn ^^^ ################## #>  #>      (18 more files...) #>  #> ################# vvv M354_01_04d_a.krn vvv ################## #>  1-14::::::::::::::::::::::::::::::::::::::::::::::::::::::::: #>    15:             .       .          .         .      (16ccLL #>    16:             .       .          .         .         16b- #>    17:             .       .         8f         .          16a #>    18:             .       .          .         .      16b-JJ) #>    19:           =41     =41        =41       =41          =41 #>    20:            2D    2V7d         8r       2A-     (16ee-LL #>    21:             .       .          .         .         16dd #>    22:             .       .     4B- 4f         .        16cc# #>    23:             .       .          .         .      16ddJJ) #>    24:             .       .          .         .      (16ccLL #>    25:             .       .          .         .         16b- #>    26:             .       .     8B- 8f         .          16a #>    27:             .       .          .         .      16b-JJ) #>    28:             *       *         *v        *v            * #>    29:           =42     =42        =42       =42              #>    30:             *       *    *clefF4         *              #>    31:            4T     4Ib         8r  (16ee-LL              #>    32:             .       .          .      16ff              #>    33:             .       .     8G 8e-     16gg)              #>    34:             .       .          .    16b'JJ              #>    35:            4P     4IV         8r   (16ccLL              #>    36:             .       .          .      16dd              #>    37:             .       .    8A- 8e-    16ee-)              #>    38:             .       .          .   16a-'JJ              #>    39:           =43     =43        =43       =43              #>    40:             *       *         *^         *              #>    41:            4D     4Cc         8r      2BB-       (16gLL #>    42:             .       .          .         .         16a- #>    43:             .       .        (8G         .        16b-) #>    44:             .       .          .         .       16e'JJ #>    45:            4D     4V7       8A-L         .       (16fLL #>    46:             .       .          .         .          16g #>    47:             .       .       8FJ)         .        16a-) #>    48:             .       .          .         .       16d'JJ #>    49:             *       *         *v        *v            * #>    50:           =44     =44        =44       =44              #>    51:            2T      2I       8E-L       4e-              #>    52:             .       .      8BB-J         .              #>    53:             .       .       4EE-        4r              #>    54:            *-      *-         *-        *-              #> ################# ^^^ M354_01_04d_a.krn ^^^ ################## #>  #>  humdrumR corpus of twenty files. #>   Data fields:  #>          *Token :: character readHumdrum('HumdrumData/.*/.*') #> Finding and reading files... #>  REpath-pattern 'HumdrumData/.*/.*' matches 50 text files in 5 directories. #> Fifty files read from disk.  #> Validating fifty files...all valid. #> Parsing fifty files...Assembling corpus...Done! #> ############################ vvv your_song.hum vvv ############################ #> NA     1:  !!!COM: Bach, Johann Sebastian #> NA     2:  !!!CDT: 1685/02/21/-1750/07/28/ #> NA     3:  !!!OTL@@DE: Aus meines Herzens Grunde #> NA     4:  !!!OTL@EN:      From the Depths of My Heart #> NA     5:  !!!SCT: BWV 269 #> NA     6:  !!!PC#: 1 #> NA     7:  !!!AGN: chorale #> NA   126:  !!!hum2abc: -Q '' #> NA   127:  !!!title: @{PC#}. @{OTL@@DE} #> NA   128:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian*** #> NA   129:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H*** #> NA   130:  !!!YOR3: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 37*** #> NA   131:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c*** #> NA   132:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 #> NA   133:  !!!EED:  Craig Stuart Sapp #> NA   134:  !!!EEV:  2009/05/22 #> NA     8:          **kern        **kern        **kern        **kern #> NA     9:          *ICvox        *ICvox        *ICvox        *ICvox #> NA    10:          *Ibass       *Itenor        *Ialto       *Isoprn #> NA    11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano #> NA    12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] #> NA    13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] #> NA    14:             *>A           *>A           *>A           *>A #> NA    15:         *clefF4      *clefGv2       *clefG2       *clefG2 #> NA    16:          *k[f#]        *k[f#]        *k[f#]        *k[f#] #> NA    17:             *G:           *G:           *G:           *G: #> NA    18:             *F:             *             *             * #> NA    19:           *M3/4         *M3/4         *M3/4         *M3/4 #> NA    20:          *MM100        *MM100        *MM100        *MM100 #> NA    21:             4GG            4B            4d            4g #> NA    22:              =1            =1            =1            =1 #> NA    23:              4G            4B            4d            2g #> NA    24:              4E           8cL            4e             . #> NA    25:               .           8BJ             .             . #> NA    26:             4F#            4A            4d           4dd #> NA    27:              =2            =2            =2            =2 #> NA    28:              4G            4G            2d           4.b #> NA    29:              4D           4F#             .             . #> NA    30:               .             .             .            8a #> NA    31:              4E            4G            4B            4g #> NA32-125::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: #> ############################ ^^^ your_song.hum ^^^ ############################ #> ############################# vvv chor001.krn vvv ############################# #> NA      :              =7            =7            =7            =7 #> NA      :             =17           =17           =17           =17 #> NA      :             =43           =43           =43           =43 #> NA      :             =47           =47           =47           =47 #> NA      :             =69           =69           =69           =69 #> NA      :             =86           =86           =86           =86 #> NA      :             =99           =99           =99           =99 #> NA      :            =103          =103          =103          =103 #> NA::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: #> ############################# ^^^ chor001.krn ^^^ ############################# #>  #>      (48 more files...) #>  #> ############################# vvv chor001.krn vvv ############################# #> NA1-1189::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: #> NA  1190:               .             .             .             . #> NA  1191:            =118          =118          =118          =118 #> NA  1192:              I6            I6             5       220.457 #> NA  1193:               .             .             .             . #> NA  1194:               .             .             .             . #> NA  1195:               .             .             3             . #> NA  1196:               .             .             .             . #> NA  1197:               .             .             2             . #> NA  1198:               .             .             1             . #> NA  1199:               .             .             .             . #> NA  1200:            =119          =119          =119          =119 #> NA  1201:            ii65            IV             2       222.340 #> NA  1202:               .             .             .             . #> NA  1203:               .             .             .             . #> NA  1204:               .             .             6             . #> NA  1205:               .             .             .             . #> NA  1206:               .             .             .             . #> NA  1207:               .             .             .             . #> NA  1208:               .             .             6             . #> NA  1209:            =120          =120          =120          =120 #> NA  1210:               .             .            b3       224.253 #> NA  1211:               .             .             2             . #> NA  1212:               .             .             .             . #> NA  1213:               .             .             1             . #> NA  1214:               .             .             .             . #> NA  1215:               .             .             1             . #> NA  1216:               .             .             1             . #> NA  1217:               .             .             .             . #> NA  1218:            =121          =121          =121          =121 #> NA  1219:            *tb1          *tb1          *tb1             * #> NA  1220:               I             I             .       226.135 #> NA  1221:            =122          =122          =122          =122 #> NA  1222:              IV          IV64             .       228.013 #> NA  1223:            =123          =123          =123          =123 #> NA  1224:               V           Vs4             .       229.838 #> NA  1225:            =124          =124          =124          =124 #> NA  1226:              IV          IV64             .       231.691 #> NA  1227:            =125          =125          =125          =125 #> NA  1228:               I             I             .       233.583 #> NA  1229:              *-            *-            *-            *- #> ############################# ^^^ chor001.krn ^^^ ############################# #>                        (***five global comments truncated due to screen size***) #>  #>  humdrumR corpus of fifty files. #>   Data fields:  #>          *Token :: character"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/ReadWrite.html","id":"multi-argument-approach","dir":"Articles","previous_headings":"Reading humdrum data > Targeting files","what":"Multi-Argument Approach","title":"Reading and writing data with humdrumR","text":"Earlier mentioned can one RE-path patterns. one? Well, can divided RE-path patterns across multiple arguments (left right): Instead writing readHumdrum(\"HumdrumData/BachChorales/chor.*.krn\"), can write readHumdrum(\"HumdrumData\", \"BachChorales\", \"chor.*.krn\"). Thus two approaches identical. ’s advantage approach? ’ll see next section.","code":"readHumdrum(\"HumdrumData/BachChorales/chor.*.krn\")  readHumdrum(\"HumdrumData\", \"BachChorales\", \"chor.*.krn\")"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/ReadWrite.html","id":"multiple-patterns","dir":"Articles","previous_headings":"Reading humdrum data > Targeting files","what":"Multiple Patterns","title":"Reading and writing data with humdrumR","text":"Sometimes, expressing files want single regular expression possible. Luckily, readHumdrum can accept many separate patterns want, just group vector. Instead writing readHumdrum('HumdrumData/.*Variations/.*.krn'), explicit write ’ve used c command create vector two REpath-patterns. However, lot (bug-prone) typing…combine multiple patterns Multi-Argument Approach ?: get result! work exactly? ’ve fed three arguments readHumdrum. first last arguments (\"HumdrumData\" \".*.krn\") length one. However, middle argument (\"...Variations\") length two. readHumdrum concatenates three arguments together, making two separate REpath-patterns: Note: possible write multiple patterns match () files. argument multipleInstances = FALSE, unique file read (first matching pattern). multipleInstances = TRUE, file(s) can read .","code":"readHumdrum(c('HumdrumData/BeethovenVariations/.*.krn', 'HumdrumData/MozartVariations/.*.krn')) #> Finding and reading files... #>  REpath-pattern 'HumdrumData/BeethovenVariations/.*.krn' matches 12 text files in 1 directory. #>  REpath-pattern 'HumdrumData/MozartVariations/.*.krn' matches 8 text files in 1 directory. #> Twenty files read from disk.  #> Validating twenty files...all valid. #> Parsing twenty files...Assembling corpus...Done! #> ################## vvv B075_00_01_a.krn vvv ################## #>     1:  !!!COM: Beethoven #>     2:  !!!OTL: 7 Variations on a Quartet by Winter #>     3:  !!!Variation: Theme a #>     4:    **function  **harm     **kern                 **kern #>     5:             *       *    *clefG2                *clefG2 #>     6:             *       *     *k[b-]                 *k[b-] #>     7:         *M2/4   *M2/4      *M2/4                  *M2/4 #>     8:           *F:     *F:        *F:                    *F: #>     9:            4T      4I         4r               4aa 4ccc #>    10:            =1      =1         =1                     =1 #>    11:            2T      2I         2f             8ff'L 8aa' #>    12:             .       .          .             8cc'J 8ff' #>    13:             .       .          .             8ff'L 8aa' #>    14:             .       .          .            8aa'J 8ccc' #>    15:            =2      =2         =2                     =2 #>    16:            4T     4V7  (4c 4e 4g              (4gg 4bb- #>    17:            4T      4I        4f)               4ff) 4aa #>    18:            =3      =3         =3                     =3 #>    19:            2T      2V         4c             8ee'L 8gg' #>    20:             .       .          .             8dd'J 8ff' #>    21:             .       .         4c             8cc'L 8ee' #>    22:             .       .          .             8dd'J 8ff' #>    23:            =4      =4         =4                     =4 #>    24:            4T      4V         8c                8ee 8gg #>    25:             .       .         8r                     8r #>    26:            4T      4I         4r               4aa 4ccc #>    27:            =5      =5         =5                     =5 #>    28:            2T      2I         2f             8ff'L 8aa' #>    29:             .       .          .             8cc'J 8ff' #>    30:             .       .          .             8ff'L 8aa' #>    31:             .       .          .            8aa'J 8ccc' #>    32:            =6      =6         =6                     =6 #>    33:            4T     4V7  (4c 4e 4g              (4gg 4bb- #>    34:            4T      4I     4f) 4a               4ff) 4aa #>    35:            =7      =7         =7                     =7 #>    36:            4P    4iib       8B-L               8ddL 8gg #>    37:             .       .       8B-J               8ddJ 8gg #>    38:            4D     4V7        8cL              (8b-L 8ee #>    39:             .       .        8cJ             16b-L 16dd #>    40:             .       .          .                16eeJJ) #> 41-45::::::::::::::::::::::::::::::::::::::::::::::::::::::::: #> ################## ^^^ B075_00_01_a.krn ^^^ ################## #>  #>      (18 more files...) #>  #> ################# vvv M354_01_04d_a.krn vvv ################## #>  1-14::::::::::::::::::::::::::::::::::::::::::::::::::::::::: #>    15:             .       .          .         .      (16ccLL #>    16:             .       .          .         .         16b- #>    17:             .       .         8f         .          16a #>    18:             .       .          .         .      16b-JJ) #>    19:           =41     =41        =41       =41          =41 #>    20:            2D    2V7d         8r       2A-     (16ee-LL #>    21:             .       .          .         .         16dd #>    22:             .       .     4B- 4f         .        16cc# #>    23:             .       .          .         .      16ddJJ) #>    24:             .       .          .         .      (16ccLL #>    25:             .       .          .         .         16b- #>    26:             .       .     8B- 8f         .          16a #>    27:             .       .          .         .      16b-JJ) #>    28:             *       *         *v        *v            * #>    29:           =42     =42        =42       =42              #>    30:             *       *    *clefF4         *              #>    31:            4T     4Ib         8r  (16ee-LL              #>    32:             .       .          .      16ff              #>    33:             .       .     8G 8e-     16gg)              #>    34:             .       .          .    16b'JJ              #>    35:            4P     4IV         8r   (16ccLL              #>    36:             .       .          .      16dd              #>    37:             .       .    8A- 8e-    16ee-)              #>    38:             .       .          .   16a-'JJ              #>    39:           =43     =43        =43       =43              #>    40:             *       *         *^         *              #>    41:            4D     4Cc         8r      2BB-       (16gLL #>    42:             .       .          .         .         16a- #>    43:             .       .        (8G         .        16b-) #>    44:             .       .          .         .       16e'JJ #>    45:            4D     4V7       8A-L         .       (16fLL #>    46:             .       .          .         .          16g #>    47:             .       .       8FJ)         .        16a-) #>    48:             .       .          .         .       16d'JJ #>    49:             *       *         *v        *v            * #>    50:           =44     =44        =44       =44              #>    51:            2T      2I       8E-L       4e-              #>    52:             .       .      8BB-J         .              #>    53:             .       .       4EE-        4r              #>    54:            *-      *-         *-        *-              #> ################# ^^^ M354_01_04d_a.krn ^^^ ################## #>  #>  humdrumR corpus of twenty files. #>   Data fields:  #>          *Token :: character readHumdrum('HumdrumData',             c('BeethovenVariations', 'MozartVariations'),             '.*.krn') #> Finding and reading files... #>  REpath-pattern 'HumdrumData/BeethovenVariations/.*.krn' matches 12 text files in 1 directory. #>  REpath-pattern 'HumdrumData/MozartVariations/.*.krn' matches 8 text files in 1 directory. #> Twenty files read from disk.  #> Validating twenty files...all valid. #> Parsing twenty files...Assembling corpus...Done! #> ################## vvv B075_00_01_a.krn vvv ################## #>     1:  !!!COM: Beethoven #>     2:  !!!OTL: 7 Variations on a Quartet by Winter #>     3:  !!!Variation: Theme a #>     4:    **function  **harm     **kern                 **kern #>     5:             *       *    *clefG2                *clefG2 #>     6:             *       *     *k[b-]                 *k[b-] #>     7:         *M2/4   *M2/4      *M2/4                  *M2/4 #>     8:           *F:     *F:        *F:                    *F: #>     9:            4T      4I         4r               4aa 4ccc #>    10:            =1      =1         =1                     =1 #>    11:            2T      2I         2f             8ff'L 8aa' #>    12:             .       .          .             8cc'J 8ff' #>    13:             .       .          .             8ff'L 8aa' #>    14:             .       .          .            8aa'J 8ccc' #>    15:            =2      =2         =2                     =2 #>    16:            4T     4V7  (4c 4e 4g              (4gg 4bb- #>    17:            4T      4I        4f)               4ff) 4aa #>    18:            =3      =3         =3                     =3 #>    19:            2T      2V         4c             8ee'L 8gg' #>    20:             .       .          .             8dd'J 8ff' #>    21:             .       .         4c             8cc'L 8ee' #>    22:             .       .          .             8dd'J 8ff' #>    23:            =4      =4         =4                     =4 #>    24:            4T      4V         8c                8ee 8gg #>    25:             .       .         8r                     8r #>    26:            4T      4I         4r               4aa 4ccc #>    27:            =5      =5         =5                     =5 #>    28:            2T      2I         2f             8ff'L 8aa' #>    29:             .       .          .             8cc'J 8ff' #>    30:             .       .          .             8ff'L 8aa' #>    31:             .       .          .            8aa'J 8ccc' #>    32:            =6      =6         =6                     =6 #>    33:            4T     4V7  (4c 4e 4g              (4gg 4bb- #>    34:            4T      4I     4f) 4a               4ff) 4aa #>    35:            =7      =7         =7                     =7 #>    36:            4P    4iib       8B-L               8ddL 8gg #>    37:             .       .       8B-J               8ddJ 8gg #>    38:            4D     4V7        8cL              (8b-L 8ee #>    39:             .       .        8cJ             16b-L 16dd #>    40:             .       .          .                16eeJJ) #> 41-45::::::::::::::::::::::::::::::::::::::::::::::::::::::::: #> ################## ^^^ B075_00_01_a.krn ^^^ ################## #>  #>      (18 more files...) #>  #> ################# vvv M354_01_04d_a.krn vvv ################## #>  1-14::::::::::::::::::::::::::::::::::::::::::::::::::::::::: #>    15:             .       .          .         .      (16ccLL #>    16:             .       .          .         .         16b- #>    17:             .       .         8f         .          16a #>    18:             .       .          .         .      16b-JJ) #>    19:           =41     =41        =41       =41          =41 #>    20:            2D    2V7d         8r       2A-     (16ee-LL #>    21:             .       .          .         .         16dd #>    22:             .       .     4B- 4f         .        16cc# #>    23:             .       .          .         .      16ddJJ) #>    24:             .       .          .         .      (16ccLL #>    25:             .       .          .         .         16b- #>    26:             .       .     8B- 8f         .          16a #>    27:             .       .          .         .      16b-JJ) #>    28:             *       *         *v        *v            * #>    29:           =42     =42        =42       =42              #>    30:             *       *    *clefF4         *              #>    31:            4T     4Ib         8r  (16ee-LL              #>    32:             .       .          .      16ff              #>    33:             .       .     8G 8e-     16gg)              #>    34:             .       .          .    16b'JJ              #>    35:            4P     4IV         8r   (16ccLL              #>    36:             .       .          .      16dd              #>    37:             .       .    8A- 8e-    16ee-)              #>    38:             .       .          .   16a-'JJ              #>    39:           =43     =43        =43       =43              #>    40:             *       *         *^         *              #>    41:            4D     4Cc         8r      2BB-       (16gLL #>    42:             .       .          .         .         16a- #>    43:             .       .        (8G         .        16b-) #>    44:             .       .          .         .       16e'JJ #>    45:            4D     4V7       8A-L         .       (16fLL #>    46:             .       .          .         .          16g #>    47:             .       .       8FJ)         .        16a-) #>    48:             .       .          .         .       16d'JJ #>    49:             *       *         *v        *v            * #>    50:           =44     =44        =44       =44              #>    51:            2T      2I       8E-L       4e-              #>    52:             .       .      8BB-J         .              #>    53:             .       .       4EE-        4r              #>    54:            *-      *-         *-        *-              #> ################# ^^^ M354_01_04d_a.krn ^^^ ################## #>  #>  humdrumR corpus of twenty files. #>   Data fields:  #>          *Token :: character \"HumdrumData/BeethovenVariations/.*.krn\" \"HumdrumData/MozartVariations/.*.krn\""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/ReadWrite.html","id":"pattern-names","dir":"Articles","previous_headings":"Reading humdrum data > Targeting files > Multiple Patterns","what":"Pattern Names","title":"Reading and writing data with humdrumR","text":"Whenever specific one REpath-pattern, humdrumR gives names can access Label field resulting humdrumR data object. can choose labels giving names patterns multi-pattern vectors: Thus, write two separate patterns matched read names \"Rap\" \"Rock\" associated resulting Label field. feature useful working multiple heterogenous datasets want able apply analyses/parsing one data subsets.","code":"readHumdrum('HumdrumData',             c(Rap  = 'Rap/.*',               Rock = 'RollingStone/.*')) -> rapAndRock #> Finding and reading files... #>  REpath-pattern Rap = 'HumdrumData/Rap/.*' matches 7 text files in 1 directory. #>  REpath-pattern Rock = 'HumdrumData/RollingStone/.*' matches 13 text files in 1 directory. #> Twenty files read from disk.  #> Validating twenty files...all valid. #> Parsing twenty files...Assembling corpus...Done!"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/ReadWrite.html","id":"contains","dir":"Articles","previous_headings":"Reading humdrum data > Targeting files","what":"Contains","title":"Reading and writing data with humdrumR","text":"Sometimes want read humdrum files contain particular data. instance, might want read files minor key. One option read files corpus filter files don’t want (see humdrumR filtering vignette learn . However, cases, can save lot time effort filter files want parsing . contains argument readHumdrum can used just way! contains argument must character vector—character string treated regular expression, files contain matches regular expressions read. Thus, read pieces minor keys writing: (regular expression matches standard humdrum tandem interpretations minor keys.)","code":"readHumdrum('HumdrumData', 'BachChorales', 'chor.*.krn',             contains = '\\\\*[a-g][-b#]*:')  #> Finding and reading files... #>  REpath-pattern 'HumdrumData/BachChorales/chor.*.krn' matches 3 text files (containing '\\*[a-g][-b#]*:') in 1 directory. #> Three files read from disk.  #> Validating three files...all valid. #> Parsing three files...Assembling corpus...Done! #> ############################# vvv chor003.krn vvv ############################# #>      1:  !!!COM: Bach, Johann Sebastian #>      2:  !!!CDT: 1685/02/21/-1750/07/28/ #>      3:  !!!OTL@@DE: Ach Gott, vom Himmel sieh darein #>      4:  !!!OTL@EN: Oh God, look down from Heaven #>      5:  !!!OPR: Cantata BWV 153: Schau, lieber Gott, wie meine Feind #>      6:  !!!SCT: BWV 153/1 #>      7:  !!!PC#: 3 #>      8:  !!!AGN: chorale #>    101:  !!!hum2abc: -Q '' #>    102:  !!!title: @{PC#}. @{OTL@@DE} #>    103:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** #>    104:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** #>    105:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** #>    106:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** #>    107:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 #>    108:  !!!PC#2: 7 (Budapest/Imre, 1982) with first part written with repeats. #>    109:  !!!EED:  Craig Stuart Sapp #>    110:  !!!EEV:  2009/05/22 #>      9:          **kern        **kern        **kern        **kern #>     10:          *ICvox        *ICvox        *ICvox        *ICvox #>     11:          *Ibass       *Itenor        *Ialto       *Isoprn #>     12:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano #>     13:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] #>     14:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] #>     15:             *>A           *>A           *>A           *>A #>     16:         *clefF4      *clefGv2       *clefG2       *clefG2 #>     17:          *k[f#]        *k[f#]        *k[f#]        *k[f#] #>     18:             *a:           *a:           *a:           *a: #>     19:         !dorian       !dorian       !dorian       !dorian #>     20:           *M4/4         *M4/4         *M4/4         *M4/4 #>     21:         *met(c)       *met(c)       *met(c)       *met(c) #>     22:          *MM100        *MM100        *MM100        *MM100 #>     23:              4E            4e           4g#            4b #>     24:              =1            =1            =1            =1 #>     25:              4A            4e            4a           4cc #>     26:              4B            4d           4g#            4b #>     27:              4c            4e            4a            4a #>     28:             8BL           8dL          8g#L           4ee #>     29:             8AJ           8cJ           8aJ             . #>     30:              =2            =2            =2            =2 #> 31-100::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: #> ############################# ^^^ chor003.krn ^^^ ############################# #>  #>      (1 more files...) #>  #> ############################# vvv chor010.krn vvv ############################# #>   1-51::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: #>     52:               .             .          8f#J             . #>     53:              =7            =7            =7            =7 #>     54:              4G            4d            4g            4b #>     55:           8FnXL           8dL            4a            4a #>     56:             8EJ           8eJ             .             . #>     57:              4D            4f           8bL          8ddL #>     58:               .             .           8aJ          8ccJ #>     59:              4E            4B           4g#            4b #>     60:              =8            =8            =8            =8 #>     61:            2AA;           2c;           2e;           2a; #>     62:              2A            2e            2a           2cc #>     63:              =9            =9            =9            =9 #>     64:              4E            4e            4g            4b #>     65:             8DL            4e            4g           4cc #>     66:             8CJ             .             .             . #>     67:             4BB            4d           8gL           4dd #>     68:               .             .           8fJ             . #>     69:              4C            4c            4e            4g #>     70:             =10           =10           =10           =10 #>     71:              4D           8F#            4d            4b #>     72:               .            4G             .             . #>     73:              4D             .            4c            4a #>     74:               .           8F#             .             . #>     75:            2GG;           2G;           2B;           2g; #>     76:             =11           =11           =11           =11 #>     77:              2C            2G            2e            2g #>     78:             4AA            4A            4e           4cc #>     79:              4E           4G#           8eL            4b #>     80:               .             .           8dJ             . #>     81:             =12           =12           =12           =12 #>     82:              4F            4A            4c            4a #>     83:              4C            4G            4c            4e #>     84:            4BB-            4G           [2d            4g #>     85:             4AA            4A             .            4f #>     86:             =13           =13           =13           =13 #>     87:            4GG#            4B           4d]           1e; #>     88:             4AA            4A            4c             . #>     89:            2EE;         2G#X;           2B;             . #>     90:              ==            ==            ==            == #>     91:              *-            *-            *-            *- #> ############################# ^^^ chor010.krn ^^^ ############################# #>                        (***five global comments truncated due to screen size***) #>  #>  humdrumR corpus of three files. #>   Data fields:  #>          *Token :: character"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/ReadWrite.html","id":"finding-files","dir":"Articles","previous_headings":"Reading humdrum data","what":"Finding Files","title":"Reading and writing data with humdrumR","text":"readHumdrum interprets REpath-patterns finds files using helper function findHumdrum. sure humdrum files , pattern want use find , might start using findHumdrum. findHumdrum takes input readHumdrum, doesn’t fully parse input humdrumR. Instead, returns data.table containing matching filenames () raw file content. use verbose = TRUE option either findHumdrum readHumdrum, complete list matches files printed. useful check reading files intend read.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/ReadWrite.html","id":"validation","dir":"Articles","previous_headings":"Reading humdrum data > Finding Files","what":"Validation","title":"Reading and writing data with humdrumR","text":"findHumdrum, extension readHumdrum, smart functions ignore non-humdrum files matched pattern. Non-text files (like .pdf .jpg) ignored. Whatsmore, text files fail conform humdrum syntax read either. see message checks files “valid humdrum,” tell many () text files read. trying read file think valid humdrum, readHumdrum won’t read , use validateHumdrum exact REpath-pattern arguments, specify errorReport.path see detailed report problem. humdrumR won’t read files humdrum-syntax violations—might minor problems data need fix. Call ?validateHumdrum read humdrum data validation vignette learn humdrumR’s data validation tools, can used identify errors humdrum data. (validateHumdrum automatically check humdrum data encoded correctly makes sense, just structurally sound, accordance humdrum syntax.)","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/ReadWrite.html","id":"reading","dir":"Articles","previous_headings":"Reading humdrum data","what":"Reading","title":"Reading and writing data with humdrumR","text":", actually happens run readHumdrum? now, ’ve seen readHumdrum prints messages describing process. First, files match search patterns () identified, text read R. Next, files checked see valid humdrum files. files parsed—.e., translated humdrumR‘s data.table backend. step takes longest far, includes parsing humdrum files’ data tokens, interpretations, reference records, (worst ) spine paths. Indeed, reading humdrum data spine paths take significantly longer reading pathless data. save time, can potentially use tandems reference arguments (see “Parsing Metadata” ).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/ReadWrite.html","id":"parsing-metadata","dir":"Articles","previous_headings":"Reading humdrum data","what":"Parsing Metadata","title":"Reading and writing data with humdrumR","text":"default, humdrumR parses metadata humdrum files reads. includes true global metadata files, encoded humdrum reference records, well local tandem interpretations.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/ReadWrite.html","id":"reference-records","dir":"Articles","previous_headings":"Reading humdrum data > Parsing Metadata","what":"Reference Records","title":"Reading and writing data with humdrumR","text":"default, humdrumR parses reference records files reads, creating unique field reference key. (one instance given key, combined string separated semicolons.) lot unique reference keys dataset, can end taking lot memory humdrum table. cases, might find useful limit readHumdrum parsing reference records actually going use. can accomplished quite easily reference argument. reference argument defaults \"\", means reference records parsed. However, reference can also character vector reference codes. Thus, parse COM reference record piece. can use rename reference fields like—case, COM reference records parsed saved field called Composer instead COM. don’t want parse reference records, specify reference = NULL.","code":"readHumdrum('HumdrumData',             c('BeethovenVariations', 'MozartVariations'),             '.*.krn',             reference = 'COM') #> Finding and reading files... #>  REpath-pattern 'HumdrumData/BeethovenVariations/.*.krn' matches 12 text files in 1 directory. #>  REpath-pattern 'HumdrumData/MozartVariations/.*.krn' matches 8 text files in 1 directory. #> Twenty files read from disk.  #> Validating twenty files...all valid. #> Parsing twenty files...Assembling corpus...Done! #> ################## vvv B075_00_01_a.krn vvv ################## #>     1:  !!!COM: Beethoven #>     2:  !!!OTL: 7 Variations on a Quartet by Winter #>     3:  !!!Variation: Theme a #>     4:    **function  **harm     **kern                 **kern #>     5:             *       *    *clefG2                *clefG2 #>     6:             *       *     *k[b-]                 *k[b-] #>     7:         *M2/4   *M2/4      *M2/4                  *M2/4 #>     8:           *F:     *F:        *F:                    *F: #>     9:            4T      4I         4r               4aa 4ccc #>    10:            =1      =1         =1                     =1 #>    11:            2T      2I         2f             8ff'L 8aa' #>    12:             .       .          .             8cc'J 8ff' #>    13:             .       .          .             8ff'L 8aa' #>    14:             .       .          .            8aa'J 8ccc' #>    15:            =2      =2         =2                     =2 #>    16:            4T     4V7  (4c 4e 4g              (4gg 4bb- #>    17:            4T      4I        4f)               4ff) 4aa #>    18:            =3      =3         =3                     =3 #>    19:            2T      2V         4c             8ee'L 8gg' #>    20:             .       .          .             8dd'J 8ff' #>    21:             .       .         4c             8cc'L 8ee' #>    22:             .       .          .             8dd'J 8ff' #>    23:            =4      =4         =4                     =4 #>    24:            4T      4V         8c                8ee 8gg #>    25:             .       .         8r                     8r #>    26:            4T      4I         4r               4aa 4ccc #>    27:            =5      =5         =5                     =5 #>    28:            2T      2I         2f             8ff'L 8aa' #>    29:             .       .          .             8cc'J 8ff' #>    30:             .       .          .             8ff'L 8aa' #>    31:             .       .          .            8aa'J 8ccc' #>    32:            =6      =6         =6                     =6 #>    33:            4T     4V7  (4c 4e 4g              (4gg 4bb- #>    34:            4T      4I     4f) 4a               4ff) 4aa #>    35:            =7      =7         =7                     =7 #>    36:            4P    4iib       8B-L               8ddL 8gg #>    37:             .       .       8B-J               8ddJ 8gg #>    38:            4D     4V7        8cL              (8b-L 8ee #>    39:             .       .        8cJ             16b-L 16dd #>    40:             .       .          .                16eeJJ) #> 41-45::::::::::::::::::::::::::::::::::::::::::::::::::::::::: #> ################## ^^^ B075_00_01_a.krn ^^^ ################## #>  #>      (18 more files...) #>  #> ################# vvv M354_01_04d_a.krn vvv ################## #>  1-14::::::::::::::::::::::::::::::::::::::::::::::::::::::::: #>    15:             .       .          .         .      (16ccLL #>    16:             .       .          .         .         16b- #>    17:             .       .         8f         .          16a #>    18:             .       .          .         .      16b-JJ) #>    19:           =41     =41        =41       =41          =41 #>    20:            2D    2V7d         8r       2A-     (16ee-LL #>    21:             .       .          .         .         16dd #>    22:             .       .     4B- 4f         .        16cc# #>    23:             .       .          .         .      16ddJJ) #>    24:             .       .          .         .      (16ccLL #>    25:             .       .          .         .         16b- #>    26:             .       .     8B- 8f         .          16a #>    27:             .       .          .         .      16b-JJ) #>    28:             *       *         *v        *v            * #>    29:           =42     =42        =42       =42              #>    30:             *       *    *clefF4         *              #>    31:            4T     4Ib         8r  (16ee-LL              #>    32:             .       .          .      16ff              #>    33:             .       .     8G 8e-     16gg)              #>    34:             .       .          .    16b'JJ              #>    35:            4P     4IV         8r   (16ccLL              #>    36:             .       .          .      16dd              #>    37:             .       .    8A- 8e-    16ee-)              #>    38:             .       .          .   16a-'JJ              #>    39:           =43     =43        =43       =43              #>    40:             *       *         *^         *              #>    41:            4D     4Cc         8r      2BB-       (16gLL #>    42:             .       .          .         .         16a- #>    43:             .       .        (8G         .        16b-) #>    44:             .       .          .         .       16e'JJ #>    45:            4D     4V7       8A-L         .       (16fLL #>    46:             .       .          .         .          16g #>    47:             .       .       8FJ)         .        16a-) #>    48:             .       .          .         .       16d'JJ #>    49:             *       *         *v        *v            * #>    50:           =44     =44        =44       =44              #>    51:            2T      2I       8E-L       4e-              #>    52:             .       .      8BB-J         .              #>    53:             .       .       4EE-        4r              #>    54:            *-      *-         *-        *-              #> ################# ^^^ M354_01_04d_a.krn ^^^ ################## #>  #>  humdrumR corpus of twenty files. #>   Data fields:  #>          *Token :: character readHumdrum('HumdrumData',             c('BeethovenVariations', 'MozartVariations'),             '.*.krn',             reference = c(Composer = 'COM')) #> Finding and reading files... #>  REpath-pattern 'HumdrumData/BeethovenVariations/.*.krn' matches 12 text files in 1 directory. #>  REpath-pattern 'HumdrumData/MozartVariations/.*.krn' matches 8 text files in 1 directory. #> Twenty files read from disk.  #> Validating twenty files...all valid. #> Parsing twenty files...Assembling corpus...Done! #> ################## vvv B075_00_01_a.krn vvv ################## #>     1:  !!!COM: Beethoven #>     2:  !!!OTL: 7 Variations on a Quartet by Winter #>     3:  !!!Variation: Theme a #>     4:    **function  **harm     **kern                 **kern #>     5:             *       *    *clefG2                *clefG2 #>     6:             *       *     *k[b-]                 *k[b-] #>     7:         *M2/4   *M2/4      *M2/4                  *M2/4 #>     8:           *F:     *F:        *F:                    *F: #>     9:            4T      4I         4r               4aa 4ccc #>    10:            =1      =1         =1                     =1 #>    11:            2T      2I         2f             8ff'L 8aa' #>    12:             .       .          .             8cc'J 8ff' #>    13:             .       .          .             8ff'L 8aa' #>    14:             .       .          .            8aa'J 8ccc' #>    15:            =2      =2         =2                     =2 #>    16:            4T     4V7  (4c 4e 4g              (4gg 4bb- #>    17:            4T      4I        4f)               4ff) 4aa #>    18:            =3      =3         =3                     =3 #>    19:            2T      2V         4c             8ee'L 8gg' #>    20:             .       .          .             8dd'J 8ff' #>    21:             .       .         4c             8cc'L 8ee' #>    22:             .       .          .             8dd'J 8ff' #>    23:            =4      =4         =4                     =4 #>    24:            4T      4V         8c                8ee 8gg #>    25:             .       .         8r                     8r #>    26:            4T      4I         4r               4aa 4ccc #>    27:            =5      =5         =5                     =5 #>    28:            2T      2I         2f             8ff'L 8aa' #>    29:             .       .          .             8cc'J 8ff' #>    30:             .       .          .             8ff'L 8aa' #>    31:             .       .          .            8aa'J 8ccc' #>    32:            =6      =6         =6                     =6 #>    33:            4T     4V7  (4c 4e 4g              (4gg 4bb- #>    34:            4T      4I     4f) 4a               4ff) 4aa #>    35:            =7      =7         =7                     =7 #>    36:            4P    4iib       8B-L               8ddL 8gg #>    37:             .       .       8B-J               8ddJ 8gg #>    38:            4D     4V7        8cL              (8b-L 8ee #>    39:             .       .        8cJ             16b-L 16dd #>    40:             .       .          .                16eeJJ) #> 41-45::::::::::::::::::::::::::::::::::::::::::::::::::::::::: #> ################## ^^^ B075_00_01_a.krn ^^^ ################## #>  #>      (18 more files...) #>  #> ################# vvv M354_01_04d_a.krn vvv ################## #>  1-14::::::::::::::::::::::::::::::::::::::::::::::::::::::::: #>    15:             .       .          .         .      (16ccLL #>    16:             .       .          .         .         16b- #>    17:             .       .         8f         .          16a #>    18:             .       .          .         .      16b-JJ) #>    19:           =41     =41        =41       =41          =41 #>    20:            2D    2V7d         8r       2A-     (16ee-LL #>    21:             .       .          .         .         16dd #>    22:             .       .     4B- 4f         .        16cc# #>    23:             .       .          .         .      16ddJJ) #>    24:             .       .          .         .      (16ccLL #>    25:             .       .          .         .         16b- #>    26:             .       .     8B- 8f         .          16a #>    27:             .       .          .         .      16b-JJ) #>    28:             *       *         *v        *v            * #>    29:           =42     =42        =42       =42              #>    30:             *       *    *clefF4         *              #>    31:            4T     4Ib         8r  (16ee-LL              #>    32:             .       .          .      16ff              #>    33:             .       .     8G 8e-     16gg)              #>    34:             .       .          .    16b'JJ              #>    35:            4P     4IV         8r   (16ccLL              #>    36:             .       .          .      16dd              #>    37:             .       .    8A- 8e-    16ee-)              #>    38:             .       .          .   16a-'JJ              #>    39:           =43     =43        =43       =43              #>    40:             *       *         *^         *              #>    41:            4D     4Cc         8r      2BB-       (16gLL #>    42:             .       .          .         .         16a- #>    43:             .       .        (8G         .        16b-) #>    44:             .       .          .         .       16e'JJ #>    45:            4D     4V7       8A-L         .       (16fLL #>    46:             .       .          .         .          16g #>    47:             .       .       8FJ)         .        16a-) #>    48:             .       .          .         .       16d'JJ #>    49:             *       *         *v        *v            * #>    50:           =44     =44        =44       =44              #>    51:            2T      2I       8E-L       4e-              #>    52:             .       .      8BB-J         .              #>    53:             .       .       4EE-        4r              #>    54:            *-      *-         *-        *-              #> ################# ^^^ M354_01_04d_a.krn ^^^ ################## #>  #>  humdrumR corpus of twenty files. #>   Data fields:  #>          *Token :: character"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/ReadWrite.html","id":"tandem-interpretations","dir":"Articles","previous_headings":"Reading humdrum data > Parsing Metadata","what":"Tandem Interpretations","title":"Reading and writing data with humdrumR","text":"Tandem interpretations used humdrum data represent “local,” real-time metainformation associated specific spines—review humdrum syntax vignette details. HumdrumR can read arbitrary tandem interpertations humdrum data. However, non-standard intrepretations used, humdrumR way knowing parse . default, humdrumR always reads tandem interpretations field called Tandem. field tabulates tandem interperations far appeared spine order, concatenating single comma-delimited, recent distant. instance, Tandem field spine parsed , interpretations pile longer longer string piece progresses. Notice \"D:\" \"C:\" intrerpretations get piled separately, just like interpretation, even though tandem class, \"D:\" supercede \"C:\". ? Well, general way know arbitrary tandem interpretations class. create humdrum data new interpretations , humdrumR doesn’t know parse , just pile like Tandem field. Fortunately, humdrumR know parse many standard tandem interpretations. run command see currently ten classes tandem interpretations humdrumR recognizes, associated regular expression. Thus, really apply readHumdrum file recognize tokens \"C:\" \"D:\" match known regular expression Key tandem interpretation, parse field called Key, look like: Likewise, ’d get TimeSignature BPM fields.","code":"**kern *C: *M4/4 *MM100 c e c g *D: d f# *- \"\" C: M4/4,C: MM100,M4/4,C: MM100,M4/4,C: MM100,M4/4,C: D:,MM100,M4/4,C: D:,MM100,M4/4,C: D:,MM100,M4/4,C: knownInterpretations[Type == 'Tandem']  #>                      Name Exclusive                              RE Pretty #>  1:                   Key                           [A-Ga-g][-#b]*:     _: #>  2:          KeySignature                    k\\\\[([a-g][#-]* *)*\\\\]   k[_] #>  3:                  Clef                         clef[A-G]v*[1-5]*  clef_ #>  4:         TimeSignature           M[1-9][0-9]*/((16)|(32)|[1248])   M_/_ #>  5:           Mensuration                            met\\\\([^)]*\\\\) met(_) #>  6:                   BPM                                  MM[0-9]+    MM_ #>  7:              Timebase           tb[1-9][0-9]*%?[1-9]?[0-9]*[.]*    tb_ #>  8:            Instrument                                   I[^C,]+     I_ #>  9:       InstrumentClass                                   IC[^,]*    IC_ #> 10: TransposingInstrument                                  ITr[^,]*   ITr_ #>       Type #>  1: Tandem #>  2: Tandem #>  3: Tandem #>  4: Tandem #>  5: Tandem #>  6: Tandem #>  7: Tandem #>  8: Tandem #>  9: Tandem #> 10: Tandem **kern *C: *M4/4 *MM100 c e c g *D: d f# *- NA C: C: C: C: C: D: D: D:"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/ReadWrite.html","id":"custom-tandems","dir":"Articles","previous_headings":"Reading humdrum data > Parsing Metadata > Tandem Interpretations","what":"Custom Tandems","title":"Reading and writing data with humdrumR","text":"readHumdrum tandems argument allows us take control tandem interpretation parsing process. tandems character vector, defaulting known, parses known interpretations fields (following knownInterpretations table). can use tandems two ways. 1.) can remove \"known\" vector specify Name specific tandem interpretations want parse. instance, write tandem = \"Clef\", Clef pattern knownInterpretations table parsed, (others). 2.) character string tandems \"known\" exact match Name knownInterpretations, instead treated regular expression match new tandem interpretation class. instance, tandems = \"[Aa]pple|[Bb]anana\" match “*Apple”, “*apple”, “*Banana”, “*banana,” parsing four patterns field (called [Aa]pple|[Bb]anana]). give field name writing tandems = c(Fruit = \"[Aa]pple|[Bb]anana\"). (fact, can rename known interpretations well, instance writing tandems = c(Meter = \"TimeSignature\".) tandems = NULL, tandem interpretations parsed —can used shorten parsing time.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Nathaniel Condit-Schultz. Author, maintainer.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Condit-Schultz N (2022). humdrumR: humdrumR. R package version 0.3.0.9000, https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR.","code":"@Manual{,   title = {humdrumR: humdrumR},   author = {Nathaniel Condit-Schultz},   year = {2022},   note = {R package version 0.3.0.9000},   url = {https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR}, }"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/index.html","id":"humdrumr","dir":"","previous_headings":"","what":"humdrumR","title":"humdrumR","text":"humdrumR R library analyzing musicological data encoded humdrum data format.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/index.html","id":"installing-r","dir":"","previous_headings":"Installation","what":"Installing R","title":"humdrumR","text":"use humdrumR, ’ll first need install R, version 4.1 later. highly recommend install Integrated Development Environment Rstudio well! link—Installing R RStudio—good starting place.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/index.html","id":"installing-humdrumr","dir":"","previous_headings":"Installation","what":"Installing humdrumR","title":"humdrumR","text":"humdrumR yet available standard R package repository, CRAN, (now) can installed github repository. install latest version (master branch) humdrumR, ’ll first need install R package devtools—devtools used creating maintaining R packages. Luckily, devtools CRAN, open R session machine type: successfuly installed devtools, now ready use install humdrumR straight github. R session, type:","code":"install.packages('devtools') devtools::install_github(\"Computational-Cognitive-Musicology-Lab/humdrumR\", build_vignettes = TRUE)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/index.html","id":"humdrumr-source","dir":"","previous_headings":"Installation","what":"humdrumR source","title":"humdrumR","text":"Another option—useful, want inspect, contribute , humdrumR source code—actually download humdrumR package source github install directly. ’ll first need install git. git installed computer, can download humdrumR repository clicking “Clone download” github page. Alternatively, can use git directly: navigate directory machine ’d like save package source type: ’ve done , can install source computer using devtools: Open R session use setwd move working directory inside repository just downloaded (.e., cloned). , type downloaded Rstudio, can use “Open Project” option select file humdrumR.Rproj repository. ’ve done can just click “Install Restart” “Build” pane. ’ve completed installtion humdrumR can used simply calling:","code":"git clone https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR devtools::install() library(humdrumR)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"humdrumR","text":"stage, humdrumR functions least partially documented, can easily read using ? operator name function. good place start : also check “vignettes” humdrumR, offer easier introduction package. installed github using build_vignettes = TRUE option, able simply call:","code":"library(humdrumR)  ?humdrumR browseVignettes(\"humdrumR\")"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/LO5th.html","id":null,"dir":"Reference","previous_headings":"","what":"Line of Fifths — LO5th","title":"Line of Fifths — LO5th","text":"function LO5th S3-generic function methods extract \"line--fifths\" value various pitch objects representations.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/LO5th.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Line of Fifths — LO5th","text":"","code":"LO5th(x, generic = FALSE, ...)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/LO5th.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Line of Fifths — LO5th","text":"Returns integer vector array, matching input.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/LO5th.html","id":"the-line-of-fifths","dir":"Reference","previous_headings":"","what":"The Line of Fifths","title":"Line of Fifths — LO5th","text":"Every interval Western music associated integer line fifths: Bb = m7 = -2 F =  P4  = -1 C =  P1 = 0 G =  P5 = 1 D =  M2 = 2 =  M6 = 3 E =  M3 = 4 B =  M7 = 5 F# = A4 = 6 etc. natural notes (C) major scale---also call generic intervals---fall range -1:5. fact, diatonic key block seven consecutive numbers line--fifths: example, Eb major -4:2. \"Sharps\" \"flats\" represent +7 -7 line--fifths respectively.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/REparser.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse String Using Regular expressions — REparser","title":"Parse String Using Regular expressions — REparser","text":"Takes input string parses sequence regular expressions.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/REparser.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse String Using Regular expressions — REparser","text":"","code":"REparser(   res,   parse.strict = TRUE,   parse.exhaust = TRUE,   parse.lead = FALSE,   parse.rest = FALSE,   toEnv = FALSE )  REparse(   str,   res,   parse.strict = TRUE,   parse.exhaust = TRUE,   parse.lead = FALSE,   parse.rest = FALSE,   reverse = FALSE,   sep = NULL,   toEnv = FALSE )"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/REparser.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parse String Using Regular expressions — REparser","text":"exhaustive TRUE, string must exhaustively broken matching regular expressions. Superfluous (non-match) characters begginning, end, bettween matches, result NA returned.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/RegexFind.html","id":null,"dir":"Reference","previous_headings":"","what":"Match strings against regular expression — RegexFind","title":"Match strings against regular expression — RegexFind","text":"infix functions simply syntactic sugar existing R regular expression matching functions. vector regexes given right argument, matches regexes returned.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/RegexFind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match strings against regular expression — RegexFind","text":"","code":"x %~l% pattern  x %~i% pattern  x %~n% pattern  x %~m% pattern  x %~% pattern"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/RegexFind.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Match strings against regular expression — RegexFind","text":"%~l%: Matches pattern x returns logical. Shorthand base::grepl(). %~%: \"default\"---%~l%. %~%: Matches pattern x returns integer indices. Shorthand base::grep(). %~n%: Matches pattern x returns integer counts (can greater one one match occurs token). Shorthand stringi::stri_count_regex(). %~m%: Matches pattern x returns matching strings (NA match). Shorthand stringi::stri_extract_first_regex()","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/chordTransformer.html","id":null,"dir":"Reference","previous_headings":"","what":"Parsing and deparsing chord information. — chordTransformer","title":"Parsing and deparsing chord information. — chordTransformer","text":"functions used work chord information.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/chordTransformer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parsing and deparsing chord information. — chordTransformer","text":"","code":"figuredBass(   x,   ...,   Key = NULL,   Exclusive = NULL,   parseArgs = list(),   transposeArgs = list(),   figurationArgs = list(),   inPlace = FALSE,   memoize = TRUE,   deparse = TRUE )"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/chordTransformer.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parsing and deparsing chord information. — chordTransformer","text":"xxx Tertian sets can read/wrote various ways.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/decimal.html","id":null,"dir":"Reference","previous_headings":"","what":"Decimal numbers — decimal","title":"Decimal numbers — decimal","text":"functions create decimal numbers identical base R numeric (real) numbers. However, numbers understood humdrumR rational numbers.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/decimal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Decimal numbers — decimal","text":"","code":"decimal(x)  as.decimal(x, ...)"},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/diatonicSet.html","id":null,"dir":"Reference","previous_headings":"","what":"Tonal (diatonic) sets — diatonicSet","title":"Tonal (diatonic) sets — diatonicSet","text":"diatonicSet one humdrumR's types tonal data, representing Western diatonic keys. part, users need interact diatonicSets directly---rather, diatonicSets work behind scene numerous humdrumR pitch functions. See keyRepresentations keyTransformations documentation details usage functionality Tonality humdrumR vignette detailed explanation theory specifics diatonicSets.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/diatonicSet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tonal (diatonic) sets — diatonicSet","text":"","code":"dset(root = 0L, signature = root, alterations = 0L)  # S4 method for diatonicSet as.character(x)  is.diatonicSet(x)  order.diatonicSet(   x,   ...,   parallel = TRUE,   na.last = TRUE,   decreasing = FALSE,   method = c(\"auto\", \"shell\", \"radix\") )  # S4 method for diatonicSet,diatonicSet ==(e1, e2)  # S4 method for diatonicSet,diatonicSet Compare(e1, e2)  # S3 method for diatonicSet diatonicSet(x, ...)  # S3 method for logical diatonicSet(x, ...)  # S3 method for numeric diatonicSet(x)  # S3 method for integer diatonicSet(x)  # S3 method for character diatonicSet(str, Exclusive = NULL, Key = NULL, ..., multiDispatch = FALSE)  # S4 method for tertianSet as.character(x)  # S4 method for tertianSet,tertianSet ==(e1, e2)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/diatonicSet.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tonal (diatonic) sets — diatonicSet","text":"diatonicSet S4 subclass humdrumR's virtual class struct, inherits lot useful \"vector-like\" behaviors/functionality. constructor function dset can used create diatonicSets directly. three arguments corespond three slots: root, mode, alteration. inputs coerced match length. root argument attempt coerce character strings tonalIntervals, use LO5th value root. default, .character method, thus (via struct) show method, diatonicSets call key(). Thus, return diatonicSet command line (call print one one), see key interpretation representation printed.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/diatonicSet.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Tonal (diatonic) sets — diatonicSet","text":"Root integers representing root key line--fifths Signature integers representing signature (number accidentals) key. Alteration integers representing alterations diatonic set key represented two integers, Root Signature. Root simply tonic note key circle fifths. Signature value circle fifths, indicating diatonic mode. can think Signature value indicating number accidentals, negative numbers flats positive numbers sharps. can also think signature indicating much \"natural key\" (C major) slid line--fifths. traditional diatonic modes Western music occur wherever Signature - Tonic range -5:1: \\(Signature - Tonic = +1 \\rightarrow\\) Lydian \\(Signature - Tonic = +0 \\rightarrow\\) Major (Ionian) \\(Signature - Tonic = -1 \\rightarrow\\) Mixolydian \\(Signature - Tonic = -2 \\rightarrow\\) Dorian \\(Signature - Tonic = -3 \\rightarrow\\) Minor (Aeolian) \\(Signature - Tonic = -5 \\rightarrow\\) Locrian \\(Signature - Tonic = -4 \\rightarrow\\) Phyrgian Note can make diatonicSets Root outside Key. unusual, may result sets predict.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/diatonicSet.html","id":"alterations","dir":"Reference","previous_headings":"","what":"Alterations","title":"Tonal (diatonic) sets — diatonicSet","text":"Alteration slots (also integer) can used represent various \"altered\" scales. integer values interpreted seven-trit balanced ternary string. (\"trits\" ternary equivalent binary \"bits.\") Balanced ternary allows three digits, 0 (unaltered degree), 1 (sharpened degree), -1 (flattened degree). seven trits correspond seven scale degrees line--fifth indicated signature---.e., ordered lowest hightest line--fifths, relative root. (instance, Signature == 0, degrees c(-1, 0, 1, 2, 3, 4, 5).) ternary arrangement maps powers three scale degree, Alteration integer: \\(\\pm 1\\): raise flatten 7th scale degree. \\(\\pm 3\\): raise flatten 3rd scale degree. \\(\\pm 9\\): raise flatten 6th scale degree. \\(\\pm 27\\): raise flatten 2nd scale degree. \\(\\pm 81\\): raise flatten 5th scale degree. \\(\\pm 243\\): raise flatten 1st scale degree. \\(\\pm 749\\): raise flatten 4th scale degree. example, consider Alteration == 26: balanced ternary representation, decimal integer 26 represented 1 0 0 1 0 -1 0. (words 1 \"27s  place\" -1 \"ones place\"---.e., 27 - 1). represents raised 2nd (27) lowered 7th (-1). Alteration integer allows us concisely represent 2,187 possible combinations raised lowered diatonic scale degrees! However, combined Signature slot, redundancy scale representation. example, melodic minor scale can represented major scale (Signature - Root == 0) lowered third degree (Alteration == -3) minor scale (Signature - Root == -3) raised 6ths 7ths (Alteration == 10). However, though two representations result set line--fifths, might consider conceptually different contexts, consider redundancy acceptable. Another case encoding redundancy Alteration - 1 (flatten 7th) exactly equivalent Signature - 1. Similarly, Alteration + 749 (raise 4th) exactly equivalent Signature + 1. Double-flat double-sharp degrees encodable diatonicSet. However, combination Signature slot, sets double-flat/sharps (like doubly-diminished 7ths) can encoded.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/diatonicSet.html","id":"arithmatic","dir":"Reference","previous_headings":"","what":"Arithmatic","title":"Tonal (diatonic) sets — diatonicSet","text":"Arithmetic diatonicSets defined. However, number useful arithmetic operations diatonicSets data types defined: XXXX Elaborate XXXX Need implement special logic adding Alterations! (Taking account Signature addition.)","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/diatonicSet.html","id":"relational-operators","dir":"Reference","previous_headings":"","what":"Relational Operators","title":"Tonal (diatonic) sets — diatonicSet","text":"diatonicSets can compared using standard relational operations ==, !=. Two diatonicSets equal (according ==) slots (Root, Signature, Alteration) exactly identical. Ordinal comparisons (e.g., >, <=) diatonicSets Signature .","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/diatonicSet.html","id":"coercion","dir":"Reference","previous_headings":"","what":"Coercion","title":"Tonal (diatonic) sets — diatonicSet","text":"humdrumR knows coerce several base-R atomic types diatonicSets. can done using function---e.g., (3, \"diatonicSet\")---intuitively using function diatonicSet(). Coercision methods defined integer: interpreted root major key numeric: rounded nearest integer intepreted root major key character: interpreted using humdrumRs regular expression dispatch system, explained fully .","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/ditto.html","id":null,"dir":"Reference","previous_headings":"","what":"------------------------------------------->             NEEDS DOCUMENTATION             <------------------------------------------- — ditto","title":"------------------------------------------->             NEEDS DOCUMENTATION             <------------------------------------------- — ditto","text":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/ditto.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"------------------------------------------->             NEEDS DOCUMENTATION             <------------------------------------------- — ditto","text":"","code":"ditto"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/ditto.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"------------------------------------------->             NEEDS DOCUMENTATION             <------------------------------------------- — ditto","text":"object class list length 2.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/fillThru.html","id":null,"dir":"Reference","previous_headings":"","what":"Propogate data points to ","title":"Propogate data points to ","text":"fillThru function allow \"fill\" null values vector non-null values earlier/later vector. default, \"foward,\" behavior fills null value previous (lower index) non-null value, . reverse argument can used cause \"backeward\" filling, next (higher index) non-null value used.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/fillThru.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Propogate data points to ","text":"","code":"fillThru(x, nonnull = function(x) !is.na(x) & x != \".\", reverse = FALSE)  fillForward(...)  fillBackwards(...)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/fillThru.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Propogate data points to ","text":"values considered \"non-null\" can controlled using nonnull argument. nonnull argument can either logical vector length input (x) argument, numeric vector positive indices, function , applied x returns appropriate logical/numeric vector.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/filterHumdrum.html","id":null,"dir":"Reference","previous_headings":"","what":"Filter humdrum data — filterHumdrum","title":"Filter humdrum data — filterHumdrum","text":"filterHumdrum command used filter humdrumR corpus Indexing humdrumR corpus (using [] [[]] operators) uses calls filterHumdrum!","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/filterHumdrum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filter humdrum data — filterHumdrum","text":"","code":"filterHumdrum(humdrumR, ...)  removeEmptyFiles(humdrumR)  removeEmptySpines(humdrumR)  removeEmptyRecords(humdrumR)  humdata[] # returns unchanged  humdata[x:y]  humdata['regex']  humdata[~expression]  humdata[[x:y]]  humdata[[ , x:y]]  humdata[['regex']]  humdata[[x:y, l:m]]"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/filterHumdrum.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Filter humdrum data — filterHumdrum","text":"filterHumdrum used similar manner withinHumdrum, taking number \"expressions\" (functions) arguments. (fact, expressions/function arguments passed directly internal call withinHumdrum.) difference expressions/functions fed filterHumdrum must predicate expressions return logical (TRUE/FALSE) vector. returned vector must also length input data (number rows humdrum table). (can use dofill~ expression want \"expand\" shorter outputs filtering pusposes.) filterHumdrum updates humdrum table's Filter field using logical (|) existing Filter field negation predicate: Filter | !Predicate. HumdrumR functions (mostly) ignore data points Filter == TRUE: print filtered humdrumR see filtered data points turned null data (.), calls withinHumdrum ignore filtered data. default, filterHumdrum completely removes files corpus data records filtered . However, can stop specifying removeEmptyFiles argumet FALSE. want remove empty files, spines, records, call removeEmptyFiles, removeEmptySpines, removeEmptyRecords.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/filterHumdrum.html","id":"indexing","dir":"Reference","previous_headings":"","what":"Indexing","title":"Filter humdrum data — filterHumdrum","text":"R, basic indexing operators, [] [[]], used select subsets data. many R data types (instance, base R lists) [single brackets] used \"shallower\" extraction [[double brackets]] used \"deeper\" extraction. HumdrumR corpus indexing follows basic pattern: [single brackets] used index humdrumR objects piece [[double brackets]] used index within pieces. (Accidentally writing [] need [[]] common error, watch !) Whether, indexing piece within, humdrumR objects can use three types indexing arguments: numeric (ordinal integers) character string (regular expressions) formula (arbitrary expressions) last option (formula) powerful option, indeed, first two options (numeric character indexing) just convenient shorthands indexing can accomplished using formula method.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/filterHumdrum.html","id":"numeric-indexing-","dir":"Reference","previous_headings":"","what":"Numeric indexing:","title":"Filter humdrum data — filterHumdrum","text":"Indexing humdrumR corpora [single brackets] accept one numeric argument. argument used pick pieces within humdrumR object ordinally. Thus, humdata[1:10] select first ten pieces data humdata[42] select 42nd piece. Indexing humdrumR objects [[double brackets]] accept one two numeric arguments, j, either can used isolation combination. (j used isolation, must placed comma, humdata[[ , j ]].) used index data records (.e., based humtable Record field) ordinally. Thus, humdata[[1:20]] indexes first twenty records file corpus, humdata[[42]] extracts 42nd record file. j used index spines  (.e., based Spine field) ordinally. Thus, humdata[[ , 3:4]] returns third fourth spines file corpus. indexing humdrumR corpora numbers, numeric (double) inputs converted integers. Note numeric humdrumR indexing entirely ordinal, meaning pieces/data records/spines matched based value respective fields, rather order among existing values. Thus, [single-bracket] indexing $i_th$ piece corpus taken, regardless FileN field associated piece. example, return 12th piece original humdata object, second piece. beacuse first call [] returns 11th 20th pieces, second call returns second piece still present (12th). Similarly, return third spine original data. normal R indexing, negative numbers can used, causing corresponding elements removed instead retained. Thus, humdata[-3:-5] remove third, fourth, fifth pieces data humdata[[ , -3:-5]] remove third, fourth, fifth spines piece. Positive negative indices mixed single argument. cases, indices outside range (value 0) ignored. E.g., corpus twenty files call corpus[21], 21st piece, 21 \"range\". input indices 0 error result. input indices range empty humdrumR object returned. instance, humdata[[401:500, ]] return empty humdrumR object pieces 400 data records.","code":"humsubset <- humdata[11:20] humsubset[2] humsubset2 <- humdata[[ , 2:4]] humsubset2[[ , 2]]"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/filterHumdrum.html","id":"character-indexing-","dir":"Reference","previous_headings":"","what":"Character indexing:","title":"Filter humdrum data — filterHumdrum","text":"Indexing humdrumR objects [single brackets] accept one vector character strings. strings treated regular expressions (regexes). tokens humdrumR object's Active fields searched matches regular expressions input. piece contains match regular expressions retained---pieces filtered . Note ([single-bracket] indexing) entire piece retained, even one match. matches occur pieces, empty humdrumR object returned. Indexing humdrumR objects [[double brackets]] accept one two vectors character strings, j, either can used isolation combination. (j used isolation, must placed comma, humdata[[ , j]].) strings treated regular expressions (regexes). tokens humdrumR object's Active fields searched matches regular expressions input. record contains least one token matching regex retained. Similarly, spine contains least one token matching regex j retained. j used together, matching spines (j) indexed first, tokens matching regular expression(s) must found matching spines. third argument, k, can also used, j arguments missing. order work, need put two commas mark \"missing\" j arguments: e.g., humdata[[ , , '[Ee]-']]. case k, matching tokens retained, regardless spine record number(s).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/filterHumdrum.html","id":"formula-indexing-","dir":"Reference","previous_headings":"","what":"Formula indexing:","title":"Filter humdrum data — filterHumdrum","text":"Indexing humdrumR objects formulae powerful, flexible indexing option. Either [single] [[double]] brackets accept (single) formula. formula fed directly arguments filterHumdrum---, music evaluate logical vector length input. case [single-bracket] indexing, one formula accepted, every piece evalues least one TRUE retained. instance, humdata[~Spine > 4] return pieces contain five () spines. [single-bracket] formula indexing especially useful indexing meta-data properties like reference records: instance, humdata[~COM == \"Paul McCartney\"] return pieces !!!COM: Paul McCartney reference record. case [[double-bracket]] indexing, one two formulas accepted, arguments j, either can used isolation combination. (j used isolation, must placed comma, humdata[[ , j]].) case formulae, record evaluates least one TRUE value retained. case j, spine evaluates least one TRUE value retained. piece contains matches dropped entirely. [[double-bracket]] formula indexing, third argument, k may used absence j. order work, need put two commas mark \"missing\" j arguments: e.g., humdata[[ , , ~formula]]. case k tokens evaluate TRUE retained, regardless piece/spine/record. Pieces, spines, records TRUE values simply dropped. Using k argument exactly \"plain\" call filterHumdrum.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/getFields.html","id":null,"dir":"Reference","previous_headings":"","what":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------\nGet named — getFields","title":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------\nGet named — getFields","text":"------------------------------------------->             NEEDS DOCUMENTATION             <------------------------------------------- Get named","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/getFields.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------\nGet named — getFields","text":"","code":"getFields(humdrumR, fieldnames = NULL, dataTypes = \"D\")"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/getTandem.html","id":null,"dir":"Reference","previous_headings":"","what":"Get tandem interpretation information from humdrum data. — getTandem","title":"Get tandem interpretation information from humdrum data. — getTandem","text":"Every humdrumRclass object field called Tandem vector strings accumulates tandem interpretations Spine. function (getTandem) extracts tandem interpretations field, based matching regular expression. obligatory '*' need included regex, added automatically. Thus, want find tandem interpretations match '*clef..', just write regex = 'clef..'.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/getTandem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get tandem interpretation information from humdrum data. — getTandem","text":"","code":"getTandem(tandem, regex)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/grapes-.-grapes.html","id":null,"dir":"Reference","previous_headings":"","what":"------------------------------------------->             NEEDS DOCUMENTATION             <------------------------------------------- — %.%","title":"------------------------------------------->             NEEDS DOCUMENTATION             <------------------------------------------- — %.%","text":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/grapes-.-grapes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"------------------------------------------->             NEEDS DOCUMENTATION             <------------------------------------------- — %.%","text":"","code":"e1 %.% e2"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humActive.html","id":null,"dir":"Reference","previous_headings":"","what":"The ","title":"The ","text":"\"Active\" expression used default value lot humdrumR code. one, data printed show calls, .e., whenever return humdrumR object terminal. expression within call ()Humdrum . automatically replaced Active expression.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humActive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The ","text":"","code":"evalActive(   humdrumR,   dataTypes = \"D\",   forceVector = FALSE,   sep = \", \",   nullAs = NA )  getActive(humdrumR)  setActive(humdrumR, form)  setActiveFields(humdrumR, fieldnames)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humActive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The ","text":"humdrumR humdrumRclass data object. dataTypes dataTypes humdrum records include. Legal values 'G', 'L', '', 'M', 'D', 'd', 'P' combination single string (e.g., \"LIM\"). (see humdrum table documentation Fields section explanation.). forceVector logical. TRUE, result forced atomic vector. sep length-one character string. forceVector == TRUE value used separator tokens collapsed. nullAsDot single atomic value. null tokens coerced value (default .).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humActive.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The ","text":"active expression can changed commands setActive $ operator. handy way quickly look different fields data. Active expression often just name field: instance, default value Token. However, can actually complex expression evaluates within humdrum table. instance, Active expression : paste0(Token, \" \", Record), automatically print Token record number pasted .","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humActive.html","id":"null-data","dir":"Reference","previous_headings":"","what":"Null data","title":"The ","text":"HumdrumR identifies \"null data\" based active field. Anywhere current active field evaluates \".\" NA considered Null data, assigned type \"d\" internal humdrum table. work, often data tokens null one field, another field. example, load **kern data, token like \"4r\" (quarter-note rest) token NA call pitch, NA call recip (rhythm). Now, change active field Pitch Rhythm see different numbers (non-null) data tokens: ntokens(kerndata$Pitch) vs ntokens(kerndata$Rhythm) return different numbers! (different number rest tokens.) Similarly, apply functions/expressions data (using withinHumdrum example), result depend active field : , get different numbers ! (Assuming rests data.) case even though -expression actually using Pitch Rhythm fields! Pitch active field rest tokens null-data ignored!","code":"kerndata <- readHumdrum(...)  kerndata$Token %hum>% pitch -> kerndata$Pitch kerndata$Token %hum>% recip -> kerndata$Rhythm kerndata$Pitch %hum<% ~length(Token) kerndata$Rhythm %hum<% ~length(Token)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humAssignment.html","id":null,"dir":"Reference","previous_headings":"","what":"Assigning new fields — humAssignment","title":"Assigning new fields — humAssignment","text":"R objects often ways assigning new values part object using indexing operators. HumdrumR objects objects different, allow us insert new fields !","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humAssignment.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Assigning new fields — humAssignment","text":"new field can inserted humdrumR object two ways: field can copied one humdrumR object another internal humdrum tables exact number data tokens (.e., rows). might seem obvious, mechanism useful can used rename existing fields within humdrumR object (explained ). vector list vectors can inserted new fields humdrumR object. Fields can assigned using two syntaxes: \"fieldname\" can whatever want , course!","code":"humdata['fieldname'] <- x # or humdata[c('fieldname1', 'fieldname2')] <- x humdata$fieldname <- x"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humAssignment.html","id":"humdrumr-gt-humdrumr-assignment-","dir":"Reference","previous_headings":"","what":"humdrumR -> humdrumR assignment:","title":"Assigning new fields — humAssignment","text":"Assigning field one humdrumR object another works like : (Recall two objects must exact numbers data tokens.) name(s) given indexing expression left side assignment (.e., humdata[c('name1', 'name2')] humdata$name) used new field names. fields extracted right side assignment little trickier: fields right-side humdrumR object named $PipeN$ ($N$ integer) copied descending order named fields left side. $PipeN$ fields right side, fields used current Active formula (right side) copied instead. system might seem odd first, useful combination withinHumdrum function, convenient pipe operator %hum>% withinHumdrum creates new fields, calls $Pipe1 ... Pipe2 ... PipeN$. Since output withinHumdrum always input except new \"Pipe\" fields, Byou can use humdrumR <- humdrumR assignment immediately assign pipe fields meaningful names original object. makes sense example: humdrumR, actually favor left--right \"piping\" style. Luckily, R allows assign left--right, proper humdrumR style actually: Calls withinHumdrum (%hum>%) keep producing new pipe fields. one pipe fields, can assign multiple fields using []<- syntax: #' IMPORTANT NOTE!: \"PipeN\" fields humdrumR object assign assign field names simply dropped. nice, often might proceed serious piped steps, want last one (two). want keep pipe fields either re-assign (.e., keep \"PipeN\" names) assign names using ->[c(\"name1\", \"name2\", \"name3\", ...)] syntax.","code":"humdata$Semits <- humdata %hum>% ~semit(Token) humdata %hum>% ~semit(Token) -> humdata$Semits humdata %hum>% ~semit(Token) %hum>% ~pitch(Token) -> humdata[c('semit', 'pitch')]"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humAssignment.html","id":"humdrumr-gt-vector-assignment-","dir":"Reference","previous_headings":"","what":"humdrumR -> vector assignment:","title":"Assigning new fields — humAssignment","text":"can assign vectors lists vectors straight humdrumR object. vectors must length number data tokens target object. provide multiple vectors assign (list data.frame vectors) must provide number fieldnames using ->[c('name1', 'name2', ...)] syntax. can use ntokens command determine right length vectors need!","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humCensus.html","id":null,"dir":"Reference","previous_headings":"","what":"Tabulate records and tokens in a humdrumR corpus — humCensus","title":"Tabulate records and tokens in a humdrumR corpus — humCensus","text":"census one humdrumR's summary functions, used tabulate raw size humdrumR corpus. census takes humdrumR object returns humCensus table. dataType argument controls types records tabulate: legal values 'G', 'L', '', 'M', 'D', 'd' combination (e.g., \"LIM\"). default \"D\".","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humCensus.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tabulate records and tokens in a humdrumR corpus — humCensus","text":"","code":"census(humdrumR, dataTypes = \"GLIMDd\", by = \"Filename\", removeEmpty = FALSE)  census(humdata)[i]  # S3 method for humCensus print(censusTable, showEach = TRUE, screenWidth = options(\"width\")$width - 10L)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humCensus.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tabulate records and tokens in a humdrumR corpus — humCensus","text":"humdrumR humdrumR object dataTypes character string length 1. character string length 1. Must field humdrumR object.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humCensus.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tabulate records and tokens in a humdrumR corpus — humCensus","text":"humCensus table five columns information: Records total number records. Tokens total number tokens. (unique) number unique tokens Characters total numder characters. includes humdrum control characters like * !!. (per token) simply Characters / Tokens, indicating mean length token. humCensus table one row file corpus. Rows labeled file's corresponding number (humTable's File field) name (Filename field). addition, humCensus object printed, totals across files printed well---(unique) (per token) across files calculated across files well, summed.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humCensus.html","id":"indexing","dir":"Reference","previous_headings":"","what":"Indexing","title":"Tabulate records and tokens in a humdrumR corpus — humCensus","text":"Rows humCensus object can selected single argument : e.g., censusTable[]. numeric, corresponding rows selected ordinally (File number). character string, string mached regular expression file names. formula, right-hand side formula evaluated within table---evaluates logical vector, files selected accordingly. instance, censusTable[~Tokens > 100] select files 100 tokens. ('(unique)' '(per token)' columns must referred names enclosed \\``---example, censusTable~\\verb(unique)\\ > 100` return files 100 unique tokens. drop argument also available. TRUE, plain data.table::data.table() returned.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humCoercion.html","id":null,"dir":"Reference","previous_headings":"","what":"humdrumR Coercion. — humCoercion","title":"humdrumR Coercion. — humCoercion","text":"Many users may wish work humdrum data without using [humdrumR:humdrumR][humdrumR] API, instead using basic R data types. purpose, humdrumRclass data objects can coerced basic R data types.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humCoercion.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"humdrumR Coercion. — humCoercion","text":"","code":"# S4 method for humdrumR as.vector(x, mode = \"any\")  as.lines(   humdrumR,   dataTypes = \"GLIMDd\",   fieldname = NULL,   alignColumns = FALSE,   padPaths = FALSE,   padder = \"\" )  # S3 method for humdrumR as.matrix(   x,   dataTypes = \"D\",   fieldnames = NULL,   alignColumns = TRUE,   padder = NA,   path.fold = TRUE )  # S4 method for humdrumR as.data.frame(   x,   dataTypes = \"D\",   fieldname = NULL,   padder = NA,   fold.path = TRUE )  as.matrices(   humdrumR,   dataTypes = \"D\",   fieldnames = NULL,   padder = NA,   path.fold = TRUE )  as.data.frames(   humdrumR,   dataTypes = \"D\",   fieldnames = NULL,   padder = NA,   path.fold = TRUE )"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humCoercion.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"humdrumR Coercion. — humCoercion","text":"mode mode argument '', can single character string naming atomic mode---output coerced mode (possible). dataTypes types humdrum records include. Legal values 'G', 'L', '', 'M', 'D', 'd' combination (e.g., \"LIM\"). (see humdrum table documentation Fields section explanation.). padder atomic value length one. par.files pad.paths true, padder argument used fill desired gaps. pad.files logical (default TRUE). pieces humdrumRclass corpus fewer [humdrumR:humTable][spines/columns] maximum, padded padder argument (par.files == TRUE) error occur (pad.files == FALSE)? Note \"padded\" points represented original humdrum data. pad.paths logical spine path splits ('*^') occur humdrumR data, padded padder argument (par.files == TRUE) error occur (pad.paths == FALSE)? Note \"padded\" points represented original humdrum data. field(s) field argument NULL, can instead character string matching humdrumRclass object's fields. , fields extracted instead Active expression. calls .vector .data.frame, one field can extracted. However, calls .matrix, multiple fields can extraced---fields returned third matrix dimension, field forming one rectangular slice.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humCoercion.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"humdrumR Coercion. — humCoercion","text":".vector(humdata) evaluates humdrumRclass object's Active expression, (attempts) force result vector mode. method essentially wrapper evalActive. .matrix(humdata also evaluates humdrumRclass object's Active expression, wraps matrix dimensions c([humdrumR:humSize][nrow(humdata), ncol(humdata)]). Note \"[humdrumR:humTable][Columns]\" humdrum data necesarily spines. .data.frame(humdata) first calls .matrix converts matrix data.frame. .data.table(humdata) first calls .matrix converts matrix data.table::data.table(). .matrices, .data.frames, .data.tables call .matrix/.data.frame/.data.table individual file humdrumRclass corpus, returning list matices/data.frames/data.tables.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humColumns.html","id":null,"dir":"Reference","previous_headings":"","what":"Spines vs Paths vs Columns — humColumns","title":"Spines vs Paths vs Columns — humColumns","text":"humdrum syntax, data placed \"spines,\" \"columns\" spreadsheet. \"column\" refers tab-delineated group values. \"Spines\" can single column, may (time) split multiple columns, can turn split , using \"*^\" interpretation token. reverse can happen well, two columns merging single column, using \"v\" token. means , humdrum data first glance looks like simple two-dimensional table, actually flexible tree structure. spines split merge, total number columns can change piece, creating \"ragged\" edge. Another similar issue corpus humdrum files may varying numbers spines/columns, pieces. (\"Global\" comment/reference records also special case, always single value, even interspersed multi-column local records.)","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humColumns.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spines vs Paths vs Columns — humColumns","text":"humdrumR, spines, columns, spine paths work like . First , actually assume slightly strict version humdrum syntax: assume spines appear beginning file (headed exlusive interpretations like \"**kern\") can never merge . Thus, humdrum file read humdrumR must end fewer columns starts. Spine merges (\"*v\") can happen within spine paths originally split spine. extra-strict specification spine paths humdrum syntax , fortunately, something informally followed humdrum datasets. strict spine-path definition makes everything work fairly simply: Within piece, spines appear beginning piece \"true\" spines rest piece, numbered left right, starting 1L. local token, value Spine field integer indicating \"true\" spines belongs ---global tokens NA value Spine field, considerd belong spine. spine path splits (\"*^\" main spines form subspines, call Paths. Every spine's paths numbered, right left, starting 0L. spine splits 0Ls Path field.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humColumns.html","id":"columns","dir":"Reference","previous_headings":"","what":"Columns","title":"Spines vs Paths vs Columns — humColumns","text":"useful sometimes turn humdrum data true two dimensional structure, ragged edges. (always requires removing global records.) order , maintaining sensible relationship spine spine paths, humRead automatically pads humdrum data complete, non-ragged 2d table. instance, given file humRead pads file : (example, Spine, Path, Column values shown data.) \"_P\" tokens stand \"padded path.\" appraoch assures every Spine contiguous block tokens, constant width. humdrumR use cases, padding tokens (Column field) can safely ignored.","code":"**kern  **kern A       E *^      * A       C       E G       B       D *v      *v      * A       C         *-      *- **kern   _P       **kern A        _P       E *^       _P       * A        C        E G        B        D *v       *v       * A        _P       C         *-       _P       *-  ########################################## 1        1        2        Spine 0        1        0        Path 1        2        3        Column"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humColumns.html","id":"corpus-padding","dir":"Reference","previous_headings":"","what":"Corpus padding","title":"Spines vs Paths vs Columns — humColumns","text":"humRead automatically pads spine paths within pieces. However, mentioned , also (sometimes) need pad across pieces, order create logical, clean 2d structure. Consider example, humdrum data two pieces: Piece 1: Piece 2: example, two pieces, one three spines, two. way squish two pieces one regular 2d table. pad missing columns, : Piece 1: Piece 2: function alignColumns used achieve just effect. example, \"_C\" token stands \"padded column.\" presence spine paths makes padding columns across pieces bit complicated. alignColumns , match pieces corpus every Spine/Path field pair allign column. example, paths already padded: Piece 1: Piece 2: two pieces, two spines, first piece, first spine splits, second piece, second spine splits. Thus, padded output four columns: Piece 1: Piece 2: Note alignColumns actually adds rows humdrumRclass object's internal humdrum tables.","code":"**kern   **kern  **kern E        D       C D        .       . C        C       E *-       *-      *- **kern   **kern A        A .        B C        C *-       *- **kern   **kern  **kern E        D       C D        .       . C        C       E *-       *-      *- **kern  **kern   _C A        A       _C .        B       _C C        C       _C *-       *-      _C **kern      _P        **kern A           _P        E B           _P        D *^          _P        * A           C         E G#          B         E *v          *v        * A           _P        E *-          _P        *- ################################################# 1           1         2         Spine 0           1         0         Path 1           2         3         Column **kern     **kern    _P A          E         _P *          *^        _P G#         D         F A          C         E *          *v        *v E          D         _P *-         *-        _P         ################################################# 1          2         2        Spine 0          0         1        Path 1          2         3        Column **kern    _P        **kern   _C A         _P        E        _C B         _P        D        _C *^        _P        *        _C A         C         E        _C G#        B         E        _C *v        *v        *        _C A         _P        E        _C *-        _P        *-       _C  ########################################################### 1         1         2        2         Spine 0         1         0        1         Path 1         2         3        4         Column **kern    _C        **kern   _P A         _C        E        _P *         _C        *^       _P G#        _C        D        F A         _C        C        E *         _C        *v       *v E         _C        D        _P *-        _C        *-       _P  #########################################################        1         1         2        2         Spine 0         1         0        1         Path 1         2         3        4         Column"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humFormulae.html","id":null,"dir":"Reference","previous_headings":"","what":"Standard humdrumR formulae. — humFormulae","title":"Standard humdrumR formulae. — humFormulae","text":"humdrumR predefines ()humdrum command combinations, R formulae lists formulae.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humFormulae.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Standard humdrumR formulae. — humFormulae","text":"","code":"ditto"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humFormulae.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Standard humdrumR formulae. — humFormulae","text":"object class list length 3.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humFormulae.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Standard humdrumR formulae. — humFormulae","text":"ditto calls fillThru() across pieces/spines/paths, replicating classic humdrum toolkit ditto command.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humInterpretations.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize humdrum corpus interpretations. — humInterpretations","title":"Summarize humdrum corpus interpretations. — humInterpretations","text":"function provides summary interpretations pieces humdrumR corpus.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humInterpretations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize humdrum corpus interpretations. — humInterpretations","text":"","code":"interpretations(humdrumR)  # S3 method for humInterpretations print(interps, showEach = TRUE, screenWidth = options(\"width\")$width - 10L)"},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humMerge.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge two (or more) humdrumR datasets — humMerge","title":"Merge two (or more) humdrumR datasets — humMerge","text":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humMerge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge two (or more) humdrumR datasets — humMerge","text":"","code":"mergeHumdrum(...)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humMeter.html","id":null,"dir":"Reference","previous_headings":"","what":"Tools for analyzing rhythm and meter. — humMeter","title":"Tools for analyzing rhythm and meter. — humMeter","text":"humdrumR includes number useful functions working rhythms meter.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humMeter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tools for analyzing rhythm and meter. — humMeter","text":"rhythmDecompose() decomposes series rhythms terms desired pulses. rhythmOffset() Calculates cummulative offset durations starting point.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humPipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Piping humdrumR data — humPipe","title":"Piping humdrumR data — humPipe","text":"infix operators make possible use [humdrumR:--Humdrum][()Humdrum] functions piping style, similar | (pipe) unix-style terminals, |>  pipe operator. R package magrittr.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humPipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Piping humdrumR data — humPipe","text":"","code":"humdrumR %hum>% formula  humdrumR %hum<% formula  humdrumR %humT% formula  e1 %s>% e2  list %hums>% formula  list %hums<% formula  list %humsT% formula  list %hums[]% formula"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humPipe.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Piping humdrumR data — humPipe","text":"key function [withinHumdrum][withinHumdrum] always returns new [humdrumR][humdrumR] data object. Thus, can always send output [withinHumdrum][withinHumdrum] back new call [withinHumdrum][withinHumdrum]. exactly %hum>% : left-hand side, input [humdrumR][humdrumR] object, right-hand side suitable arguments [withinHumdrum][withinHumdrum] (.e., formula, function, list formulae, functions, named arguments). can chain call another call %hum>% [withinHumdrum][withinHumdrum] arguments. %hum<% acts way %hum>% except calls [withHumdrum][withinHumdrum]. Since [withHumdrum][withinHumdrum] return [humdrumR][humdrumR], output piped (using %hum>% %hum<%). Thus, \\%hum<\\% used last step pipe---want extract last step pipe data's [humdrumR:humtable][Humdrum Table] normal vector list R data. ' \\%humT\\% creates \"T\" pipe, applying desired expression keeping result---unaltered humdrumR input object returned. works simply replacing ~ doplot~ call [withinHumdrum][withinHumdrum]. purpose option, want apply expressions side effects, instance, plotting. %hum[]% similar %hum>% except apply formulae right-hand side using [humdrumR][filterHumdrum]. Thus, can used filter/index [humdrumR][humdrumR] data object fly.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humPipe.html","id":"plural-pipes","dir":"Reference","previous_headings":"","what":"Plural pipes","title":"Piping humdrumR data — humPipe","text":"R often apply function list data. \"Plural pipes\" expand idea piping: take list data pipe element list expression/function. plural pipe versions singular pipe operator. Just add \"s\" make plural: |> (singular) : %s>% (plural); %hum>% (singular) : %hums>% (plural); %hum<% (singular) : %hums<% (plural); %humT% (singular) : %humsT% (plural); %hum[]% (singular) : %hums[]% (plural); Note: %s>% expansion \\> pipe operator, makes use clever meta-programming---guarantee always behave way might like!","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humPipe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Piping humdrumR data — humPipe","text":"","code":"humdata <- readHumdrum('path*.krn') #> Finding and reading files... #> \tREpath-pattern 'path*.krn' matches 0 text files in 1 directory. #> Zero files read from disk.  #> No files to validate.  humdata %hum>% ~table(.) #> Error: %hum>% pipe operator can only be called with humdrumR data on left side.  humdata %hum>%      c(by~Spine, do ~ table(.)) %hum>%      c(mfcol ~ c(2,2), doplot~barplot(.)) #> Error: %hum>% pipe operator can only be called with humdrumR data on left side.       humdata %hum>%      c(by ~ Spine, do ~ table(.)) %hum<%      (do ~ sort(.))     #> Error: %hum>% pipe operator can only be called with humdrumR data on left side."},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humPrint.html","id":null,"dir":"Reference","previous_headings":"","what":"------------------------------------------->             NEEDS DOCUMENTATION             <------------------------------------------- — humPrint","title":"------------------------------------------->             NEEDS DOCUMENTATION             <------------------------------------------- — humPrint","text":"------------------------------------------->             NEEDS DOCUMENTATION             <------------------------------------------- Show humdrumRclass object terminal.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humPrint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"------------------------------------------->             NEEDS DOCUMENTATION             <------------------------------------------- — humPrint","text":"","code":"# S4 method for humdrumR show(object)  print_humtab(   humdrumR,   dataTypes = \"GLIMDd\",   firstAndLast = FALSE,   max.records.file = 40L,   max.token.length = 30L,   collapseNull = 10L )"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humReference.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize reference records in a humdrumR corpus — humReference","title":"Summarize reference records in a humdrumR corpus — humReference","text":"reference one humdrumR's summary functions, used tabulate reference records present humdrumR corpus. reference takes humdrumR object returns humReference table. Alternatively, reference can take character string, check known reference codes print information matching codes. instance, reference('OTL') returns description standard humdrum !!!OTL reference record (original title metadata).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humReference.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize reference records in a humdrumR corpus — humReference","text":"","code":"reference(x)  reference('OTL')  reference(humdata)  # S3 method for humReference [(refTable, i, j, drop = FALSE)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humReference.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summarize reference records in a humdrumR corpus — humReference","text":"humReference table one column reference code appears humdrumR corpus. Since reference records can long (much print one screen), humdrum files can multiple type reference code (instance multiple composers annotated \"!!!COM\"), default, humReference prints number type reference record appear file. However, one type reference code present humReference table, complete reference records code printed file. Likewise, one file present table, file's complete reference records printed. Thus, want see actualy reference records, try indexing humReference table one column row (see ). humReference table one row file corpus. Rows labeled file's corresponding number (humTable's File field) name (Filename field). addition, humReference object printed, three different summary totals printed reference code: indicates many files corpus least one example code . Sum indicates total number reference code appear corpus, including multiple appearances one file (like multiple \"!!!COM\" records). Finally, Unique tabulates number unique tokens reference code---corpus hase two unique composers (encoded \"!!!COM\"), Unique total 2.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humReference.html","id":"indexing","dir":"Reference","previous_headings":"","what":"Indexing","title":"Summarize reference records in a humdrumR corpus — humReference","text":"humReference tables can indexed much like base R [data.frames][base::data.frame()],  two arguments: (rows) andj(columns). Ifiorjarenumeric, select rows columns respectively, ordinally. iis acharacter, matched regular expression filenames corpus. jis acharacter`, partially matched column names. drop argument also available. TRUE, plain [data.table][data.table::data.table()] returned.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humShape.html","id":null,"dir":"Reference","previous_headings":"","what":"HumdrumR data ","title":"HumdrumR data ","text":"functions used change \"shape\" data stored humdrum tables (held within humdrumRclass objects course). ------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humShape.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"HumdrumR data ","text":"","code":"foldHumdrum(humdrumR, byfields, foldAtomic = TRUE, sep = \" \", padPaths = FALSE)  foldStops(humdrumR, foldAtomic = TRUE, sep = \" \")  foldPaths(humdrumR, foldAtomic = TRUE, sep = \" \")  foldRecords(humdrumR, foldAtomic = TRUE, sep = \" \", padPaths = FALSE)  spinePipe(humdrumR, targetSpines, destinationSpines)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humShape.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"HumdrumR data ","text":"humdrumR humdrumRclass data object. (see humdrum table documentation Fields section explanation.). foldAtomic logical. foldAtomic == TRUE, stop collapsed single string foldAtomic == FALSE, stop collapsed list tokens. sep character. foldAtomic == TRUE, collapsed tokens separated string. pad logical. path/column padding tokens included?","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humShape.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"HumdrumR data ","text":"foldXXX family allows collapse user fields across groups another field.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humSize.html","id":null,"dir":"Reference","previous_headings":"","what":"humdrumR size and shape — humSize","title":"humdrumR size and shape — humSize","text":"functions can used quickly get basic information size \"shape\" humdrumRclass corpus. details, use census function. HumdrumR objects can divided \"subcorpora.\" anySubcorpora namesSubcorpora functions tell us subcorpora , , called.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humSize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"humdrumR size and shape — humSize","text":"","code":"nrecords(humdrumR, dataTypes = \"D\")  ntokens(humdrumR, dataTypes = \"D\")  npieces(humdrumR)  anySubcorpora(humdrumR)  namesSubcorpora(humdrumR)  nfiles(humdrumR)  # S4 method for humdrumR length(x)  # S4 method for humdrumR nrow(x)  is.empty(humdrumR)  anyPaths(humdrumR)  anyStops(humdrumR)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humSize.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"humdrumR size and shape — humSize","text":"common base R methods defined synonyms humdrumR-specific sizing functions: length(humdata) equivalent npieces(humdata); nrow(humdata) shortand nrecords(., dataTypes = 'LIMDd') (.e., local records ). ncol(humdata) returns maximum value Column field---maximum number tab-delineated columns humdrum files (irrespective Spines/Paths). results nrow ncol match dimensions matrices/data.frames produced calls .matrix/.data.frame. dim(humdata) returns c(nrow(humdata), ncol(humdata)), usual. .empty(humdata) asks ntokens(humdata, dataTypes = 'D') == 0L.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humSpines.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize spines in humdrum dataset — humSpines","title":"Summarize spines in humdrum dataset — humSpines","text":"function provides summary spines spine paths pieces humdrumR corpus.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humSpines.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize spines in humdrum dataset — humSpines","text":"","code":"spines(humdrumR)  # S3 method for humSpines [(spines, i, j)  # S3 method for humSpines print(spineTable, showEach = TRUE)"},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humSummary.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize humdrumR corpora — humSummary","title":"Summarize humdrumR corpora — humSummary","text":"humdrumR includes number built functions creating quick summaries humdrumR corpora:","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humSummary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize humdrumR corpora — humSummary","text":"","code":"# S4 method for humdrumR summary(object, ...)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humSummary.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summarize humdrumR corpora — humSummary","text":"census Tabulates raw size humdrumR corpus. reference Tabulates reference records (metadata) file. spines Tabulates number spines spine paths files corpus. interpretations Tabulates types exclusive tandem interpretations corpus. sections Tabulates formal data (*>) corpus. function takes humdrumR object returns special class data.table. summary method humdrumR objects calls functions prints condensed version .","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humTable.html","id":null,"dir":"Reference","previous_headings":"","what":"Humdrum Tables — humTable","title":"Humdrum Tables — humTable","text":"humdrumR package, fundamental data structure called Humdrum Table. humdrum table encodes information collection one humdrum-syntax files single data.table (data.table \"enhanced\" version R's standard data.frame). Humdrum tables stored \"inside\" every humdrumRclass object work , various humdrumR functions allow study manipulate . want directly access humdrum table within humdrumRclass object, use getHumtab function. getHumtab extracts humdrum table humdrumRclass object.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humTable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Humdrum Tables — humTable","text":"","code":"getHumtab(humdrumR, dataTypes = c(\"G\", \"L\", \"I\", \"M\", \"D\", \"d\"))"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humTable.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Humdrum Tables — humTable","text":"humdrumR humdrumR object. dataTypes character vector. Specifies types data tokens/records extract. See humTable documentation /humdrum syntax vignette clarification! dataTypes, values can : \"G\": global comments \"L\": local comments \"\": interpretations \"M\": barlines \"D\": non-null data \"d\": null data Multiple types can specified vector, smooshed single string: e.g., \"GLIMD\".","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humTable.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Humdrum Tables — humTable","text":"humdrum table, row represents single \"token\" original humdrum data. Even multistops---tokens separated spaces---broken onto rows. Meanwhile, column humdrum table represents single piece information associated token, call field. Throughout documentation, keep mind \"token\" refers row humdrum table \"field\" refers column: \\(Token = Row\\) \\(Field = Column\\)","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humTable.html","id":"fields-","dir":"Reference","previous_headings":"","what":"Fields:","title":"Humdrum Tables — humTable","text":"five types fields humdrum table: Data fields Structure fields Interpretation fields Formal fields Reference fields first created call readHumdrum every humdrum table least nineteen fields: one data field (Token), two interpretation fields (Tandem Exclusive), three formal fields, fifteen structure fields. Additional interpretation reference fields may present depending content humdrum file(s), users can create additional data fields assigning object.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humTable.html","id":"data-fields-","dir":"Reference","previous_headings":"","what":"Data fields:","title":"Humdrum Tables — humTable","text":"Data fields used describe individual data points humdrum data (opposed groups points). Every humdrum table starts data field called Token, contains character strings representing original strings read humdrum files. Users can create many additional data fields like. Every call withinHumdrum---can also called using humdrumR:humPipe piping operator---generates one \\(N\\) new data fields named \\({Pipe1, Pipe2, ..., PipeN}\\). fields can renamed using $<- operator.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humTable.html","id":"structure-fields-","dir":"Reference","previous_headings":"","what":"Structure fields:","title":"Humdrum Tables — humTable","text":"Every humdrum table starts fifteen Structure fields, describe data token \"located\" original humdrum data: file, spine, record, etc. See vignette humdrum syntax fully understand terms . File info: Filename :: character unique name humdrum file. may include appended path one file name read different directories (see readHumdrum docs). Filepath :: character full file name (always includes full path). Label :: character label specified call readHumdrum, associated particular readHumdrum \"REpath-pattern.\" label specified, patterns just labeled \"_n\", \"n\" number pattern. (Labels can also created merging two humdrumR objects.) File :: integer unique number associated file (ordered alphabetically, starting 1). Piece :: integer number specifying number piece corpus. identical File field except one piece read file. Location info: Spine :: integer spine, numbered (left--right) starting 1. field NA wherever Global == TRUE. Path :: integer \"spine path.\" time *^ spine path split occurs humdrum data, right side split becomes new \"path.\" original path numbered 0 additional paths numbered integers right. (spine path splits, Path field zeros.) field always NA Global == TRUE. Read humdrum columns documentation thorough explanation spine paths. Column :: integer tab-delineated column humdrum file---irrespective Spine/Paths---, numbered starting 1. field always NA Global == TRUE. See explanation columns humdrumR. Record :: integer record (.e., line) number original file. NData :: integer data record enumeration file, starting 1. Stop :: integer token multistop token, numbered starting 1. files multistops, Stop field 1s. field always NA Global == TRUE. Global :: logical token come global record (opposed local record)? Global == TRUE, Spine, Column, Stop fields always NA. Token info: Type :: character type record ? \"D\" = non-null data \"d\" = null data \"\" = interpretation \"M\" = measure/barline \"L\" = local comment \"G\" = global comment. \"P\" = null \"non-tokens\" (see humdrumR columns documentation explanation.) Null :: logical active data field null? See detailed discussion , section documentation called \"Null Data.\" Filter :: logical record/token filtered ?","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humTable.html","id":"interpretation-fields-","dir":"Reference","previous_headings":"","what":"Interpretation fields:","title":"Humdrum Tables — humTable","text":"Interpretation fields describe interpretation metadata humdrum file(s). Humdrum interpretations tokens \"carry forward\" data points , unless cancelled subsequent interpretation. (See humdrum syntax vignette detailed explanation.) humdrum data must exclusive interpretation humdrum tables always Exclusive (:: character) field indicating exclusive interpretation associated token/row active field. Humdrum data may, may , include additional tandem interpretations. universal rule parsing tandem intepretations impossible, ) tandem interpretations can \"overwrite\" B) users can create tandem interpretations. best can cases identify tandem interpretations appeared previously spine (counting recent first). previous interpretations encoded single character string Tandem field. working non-standard intrepretations, users can parse Tandem field using getTandem function. tandem interpretations occur file, Tandem field full empty strings (\"\"). Fortunately, many tandem interpretations widely used standardized, interpretations known humdrumR. Recognized interpretations (*clefG4 *k[b-]) automatically parsed fields call readHumdrum. See readHumdrum documentation details.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humTable.html","id":"formal-fields-","dir":"Reference","previous_headings":"","what":"Formal fields:","title":"Humdrum Tables — humTable","text":"Formal fields indicate musical sections, time windows within piece, including formal designations (\"verse\", \"chorus\", etc.) measures/bars. Humdrum data may may include formal metadata fields, indicated token \"*>\". Classified formal marks put fields matching name. Unclassified formal marks placed field called Formal default. Nested formal categories appended underscore number level descent: Formal_1, Formal_2, ..., Formal_N. part section given name lower hierarchical level, field simply empty (\"\") point. Humdrum data may, may , also include barlines (tokens beginning \"=\"). Humdrum tables always include three formal fields related barlines: Bar :: integer many barline records (single double) passed token? \"=\" tokens occur file, Bar zeros. Note field independent whether barlines labeled numbers humdrum file! DoubleBar :: integer many double-barline records passed token? \"==\" tokens occur file, DoubleBar zeros. BarLabel :: character characters occur barline-token initial \"=\" \"==\". include \"-\" common \"implied barline token \"=-\", repeat tokens (like \"=:||\"), also explicit bar numbers. Note Bar field always enumerate every bar record, measure-number labels humdrum data (appear BarLabel field) may weird things like skipping numbers, repeating numbers, suffixes (e.g., \"19a\"). barline tokens appear file, BarLabel empty strings (\"\").","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humTable.html","id":"reference-fields-","dir":"Reference","previous_headings":"","what":"Reference fields:","title":"Humdrum Tables — humTable","text":"Reference fields describe Reference Records humdrum data. Every reference record (records beginning \"!!!\") humdrum file corpus read readHumdrum parsed field named reference code: \"XXX\" \"!!!XXX\". Reference tokens identical throughout humdrum piece. reference code appears one file another, field NA file code. reference records appear files read readHumdrum, reference fields created. Examples common reference records \"!!!COM:\" (composer) \"!!!OTL:\" (original title). humdrum data records end COM OTL fields humdrum table.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humTable.html","id":"null-data-","dir":"Reference","previous_headings":"","what":"Null Data:","title":"Humdrum Tables — humTable","text":"humdrum syntax, requirement every spine-path contains data every record. Rather, spines often padded null tokens. cases, entire records may padded null tokens. type humdrum record uses different null token: Intepretation: * Comment: ! Barline: = Data: . Null tokens humdrum table identified logical Null field. Null field set humdrum table created (readHumdrum) updated everytime new active field set. Null set TRUE wherever, either active field character data token single \".\", \"!\", \"=\", \"*\"; active field NA (including NA_character_). parallel Null field, null data tokens (\".\") identified record type: \"d\". updates/changes Null field also propogated Type field---.e., setting Type == d wherever data record Null. important/useful withinHumdrum routines , default, applied \"D\" data, ignoring \"d\". Whenever print export humdrumRclass object, null data active field (.e., Null == TRUE) print \".\". Thus, working numeric data, NA values, NA values print \".\".","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humTable.html","id":"reshaping-","dir":"Reference","previous_headings":"","what":"Reshaping:","title":"Humdrum Tables — humTable","text":"Breaking complex syntax humdrum data \"flat\" structure humdrum table, every single token one line data.table, makes humdrum data easier analyze. course, thanks structure fields, can easily regroup reform original humdrum data use structure data (like spines) analyses. However, cases, might want work humdrum data different structure \"shape.\" HumdrumR several options \"folding\" tokens within humdrum tables, otherwise reshaping humdrum data data formats/structures might prefer.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humValidation.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate humdrum files — humValidation","title":"Validate humdrum files — humValidation","text":"function checks files violations humdrum syntax.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humValidation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate humdrum files — humValidation","text":"","code":"validateHumdrum(   ...,   contains = NULL,   recursive = FALSE,   errorReport.path = NULL )"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humValidation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate humdrum files — humValidation","text":"recursive logical. TRUE, final part search pattern (.e., file search) searched recursively sub directories. errorReport.path character. directory path , NULL, error report written file 'humdrumR_syntaxErrorReport_date.txt'. addition, files errors written directory ('errorMarkup' appended names), errors annotated inline. patterns character vector. Search pattern(s) identifying files (see [readHumdrum][readHumdrum]). files list character strings, representing record file.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humWindows.html","id":null,"dir":"Reference","previous_headings":"","what":"Applying functions across arbitrary windows.\n---------------------------------------------->      NEEDS DOCUMENTATION          <---------------------------------------------------- — humWindows","title":"Applying functions across arbitrary windows.\n---------------------------------------------->      NEEDS DOCUMENTATION          <---------------------------------------------------- — humWindows","text":"Applying functions across arbitrary windows. ---------------------------------------------->      NEEDS DOCUMENTATION          <----------------------------------------------------","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humWindows.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Applying functions across arbitrary windows.\n---------------------------------------------->      NEEDS DOCUMENTATION          <---------------------------------------------------- — humWindows","text":"","code":"windows(   df,   form,   with = list(),   ...,   start = 1L,   end = nrow(df),   bounds = \"exclude\" )  hop(vec, pattern, start = 1L, end = length(vec))  nest(vec, open, close, depth = 1)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumDispatch.html","id":null,"dir":"Reference","previous_headings":"","what":"Regular expression method dispatch and function application — humdrumDispatch","title":"Regular expression method dispatch and function application — humdrumDispatch","text":"humdrumR regular-expression method dispatch system simple system making new functions can smartly applied variety character strings. Humdrum dispatch works like normal R method dispatch, instead dispatching specific methods based class (integer, character, etc.) dispatches based regular expressions. addition, exclusive interpretations can used guide dispatch.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumDispatch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Regular expression method dispatch and function application — humdrumDispatch","text":"","code":"humdrumDispatch(   str,   dispatchDF,   Exclusive = NULL,   multiDispatch = FALSE,   ...,   outputClass = \"character\" )  makeDispatchDF(...)  makeHumdrumDispatcher(   ...,   funcName = \"humdrum-dispatch\",   outputClass = \"character\",   args = alist() )  # S3 method for humdrumDispatch print(x)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumDispatch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Regular expression method dispatch and function application — humdrumDispatch","text":"str input character string, dispatch called. dispatchDF data.frame describes function called regex input. (See details). Exclusive Defaults NULL. NULL, regexes used dispatch. multiDispatch logical, length 1. FALSE (default) \"best\" regex/exclusive match dispatched Exclusive segment. TRUE, differenet functions can dispatched within input vector. ... Arguments pass dispatch functions. outputClass Character string: default output class function return. Generally, make sense, dispatched functions return type, explicitly indicate outputClass argument. Dispatch functions also vectorized.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumDispatch.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Regular expression method dispatch and function application — humdrumDispatch","text":"Many humdrumR functions fact, humdrum-dispatch functions: example, tonalInterval.character(). call tonalInterval('ee-'), function recognize input string token  **kern representation, call appropriate parser. instead call tonalInterval(''), function recognize input string token **solfa representation, call appropriate parser .","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumDispatch.html","id":"dispatchdf","dir":"Reference","previous_headings":"","what":"dispatchDF","title":"Regular expression method dispatch and function application — humdrumDispatch","text":"dispatchDF must data.table::data.table() created using makeDispatchDF function. makeDispatchDF takes one arguments, list three components (ordered, nameed): character vector exclusive interpretations. (Specify \"\" want exclusive dispatch). regular expression (character string) function can generate regular expression, accepts ... arguments time dispatch. function dispatch.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumDispatch.html","id":"makehumdrumdispatcher","dir":"Reference","previous_headings":"","what":"makeHumdrumDispatcher","title":"Regular expression method dispatch and function application — humdrumDispatch","text":"makeHumdrumDispatcher function creates new function automatically performs humdrum-dispatch. number important humdrumR functions created makeHumdrumDispatcher: tonalInterval.character diatonicSet.character tertianSet.character rhythmInterval.character","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumDispatch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Regular expression method dispatch and function application — humdrumDispatch","text":"","code":"u <- c('A', 'B', 'CD', 'E', 'F', 'gh', 'L', 'KX') l <- c('a', 'b', 'cd', 'e', 'f', 'gh', 'l', 'kx')  lowercasefunc <- \\(x) 5L - nchar(x)  humdrumDispatch(l, outputClass = 'integer',                 makeDispatchDF(list('any', '[a-z]+',  lowercasefunc),                                list('any', '[A-Z]+',  nchar))) #> [1] 4 4 3 4 4 3 4 3 #> attr(,\"dispatch\") #> attr(,\"dispatch\")$Original #> [1] \"a\"  \"b\"  \"cd\" \"e\"  \"f\"  \"gh\" \"l\"  \"kx\" #>  #> attr(,\"dispatch\")$Regexes #>   [a-z]+  #> \"[a-z]+\"  #>  #> attr(,\"dispatch\")$Segments #> [1] 1 1 1 1 1 1 1 1 #> attr(,\"values\") #> [1] \"any\" #>  #> attr(,\"dispatch\")$Exclusives #> [1] \"any\" #>   # lowercasefunc will be called on l, nchar on u"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumPitch.html","id":null,"dir":"Reference","previous_headings":"","what":"humdrumR and pitch — humdrumPitch","title":"humdrumR and pitch — humdrumPitch","text":"humdrumR includes number intertwined data structures, associated functions, representing manipulating musical pitch information.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumPitch.html","id":"tonality","dir":"Reference","previous_headings":"","what":"Tonality","title":"humdrumR and pitch — humdrumPitch","text":"four data types extensively used humdrumR encode/process tonal musical information: integers --- used encode \"line--fifths\" tonal information tonalInterval --- embeds line--fifth tonal integers alongside octave cent information encode tonal pitch representations (solfege, intervals, letternames, etc.) diatonicSet --- combines line--fifth tonal integer representations represent diatonic tonality, including alterations basic diatonic scale(s). tertianSet --- extension diatonicSet used encode  tertian diatonic harmonies. detailed explanation theory specifics humdrumR's treatment tonality, see Tonality humdrumR vignette.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumPitch.html","id":"atonality","dir":"Reference","previous_headings":"","what":"Atonality","title":"humdrumR and pitch — humdrumPitch","text":"SECTION INCOMPLETE addition, xxx data types used encode non-tonal (atonal) pitch information. integers --- used encode semitones (well MIDI numbers). xxx --- sets? xxx --- 12-tone rows?","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumR.html","id":null,"dir":"Reference","previous_headings":"","what":"humdrumR — humdrumR","title":"humdrumR — humdrumR","text":"humdrumR toolkit analysis data encoded humdrum syntax. humdrum syntax incredibly flexible, powerful, scheme encoding musical data. Tens thousands musical scores (musical data) encoded humdrum syntax, many available online repositories KernScores.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumR.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"humdrumR — humdrumR","text":"humdrumR intended modernized replacement original humdrum toolkit, levaraging power R give us enprecedented power manipulate analyze humdrum data using concise, expressive syntax.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumR.html","id":"package-design","dir":"Reference","previous_headings":"","what":"Package design","title":"humdrumR — humdrumR","text":"package humdrumR XXX main components: represent humdrum data R, humdrumR S4 class, core component humdrum table. create humdrumR data, sophisticated humdrum data parser: readHumdrum. humdrumR data can also written back humdrum-syntax text files using writeHumdrum. filter \"index\" humdrumR data, filterHumdrum function, can also called variety short hands using R's standard indexing operators: [] [[]]. manipulate modify humdrumR data, ()Humdrum humApply functions. set \"pipe\" operators (%hum>%, %hum<%, etc.), humdrumR data can manipulated filtered concise, bash-style pipes. facilate development functions work humdrum tokens---simple character strings packed information---, useful API call regular-expression dispatch system. Several modules representing manipulating musical pitch information, including core tonalInterval class represent tonal pitch. module representing manipulating musical rhythm information, core rhythmInterval class represent rhythms.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumRclass.html","id":null,"dir":"Reference","previous_headings":"","what":"HumdrumR class — humdrumRclass","title":"HumdrumR class — humdrumRclass","text":"S4 class basic unit humdrumR package. humdrumR object represents data read one humdrum files. documentation refer collection files within humdrumRclass object \"corpus,\" file \"piece.\" However, though humdrum data usually encoded one \"piece\" per file, necessarily case: files might represent movements within piece, even just part score. Still, tend refer \"pieces.\" coding examples, name humdrumR objects \"humdata.\"","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumRclass.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"HumdrumR class — humdrumRclass","text":"","code":"is.humdrumR(x)  # S4 method for humdrumR $(x, name)  fields(   humdrumR,   fieldTypes = c(\"Data\", \"Structure\", \"Interpretation\", \"Formal\", \"Reference\") )  # S4 method for humdrumR,vector $(x, name) <- value  # S4 method for humdrumR,humdrumR $(x, name) <- value  # S4 method for humdrumR,character,ANY,vector [(x, i, j) <- value  # S4 method for humdrumR,character,ANY,humdrumR [(x, i, j) <- value  humdata[[ , 'regex']]  humdata[[ , , ~expression]] or humdata [[ , , 'regex']] or humdata[[z = ~expression]] or humdata[[z = 'regex']]  humdata[[~expression]]  humdata[[ , ~expression]]"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumRclass.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"HumdrumR class — humdrumRclass","text":"imporant part humdrumR object humdrum tables holds within . essence, humdrumR object simply wrapper around humdrum tables, helps users visualize, index, summarize, manipulate table variety ways. Basic information size shape humdrumR data can obtained calls nrecords, npieces, length, ncol, etc.. detailed summary information can obtained humdrumR corpus summary functions. HumdrumR data can also coerced basic R data types using .matrix, .data.frame, etc.. number helpful functions also defined reshape humdrumR data. powerful features humdrumR tools gives Filter humdrum data, using filterHumdrum standard R indexing operators: [] [[]]. Apply functions arbitrary commands humdrum data using ()Humdrum routines, associated piping operators.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumRclass.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"HumdrumR class — humdrumRclass","text":"Humtable list humdrum tables, fields containing data different types records (e.g., interpretations, data, barlines, comments). Files list two elements. first, \"Search\", contains single character representing pattern used call readHumdrum created humdrumR object. second, \"Names\", vector strings representing files matched pattern read humdrumR object. Fields list containing strings corresponding existing fields humdrumR object. fields divided five categories: \"Data\", \"Structure\", \"Interpretation\", \"Formal\", \"Reference\"---see humdrum table documentation. Active quosure expression extracts data field(s) humdrum table: \"active expression.\" LoadTime POSIXct value, indicating time readHumdrum called create humdrumR object. Patterns character vector original search patterns used match files system.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumRclass.html","id":"active-field","dir":"Reference","previous_headings":"","what":"Active field","title":"HumdrumR class — humdrumRclass","text":"Active slot humdrumR object contains expression refers fields internal humdrum table. Go dedicated active field documentation learn important slot!","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumRroot.html","id":null,"dir":"Reference","previous_headings":"","what":"humdrumR's root directory on your machine. — humdrumRroot","title":"humdrumR's root directory on your machine. — humdrumRroot","text":"humdrumRroot path humdrumR package install machine. simple humdrum files stored .","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumRroot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"humdrumR's root directory on your machine. — humdrumRroot","text":"","code":"humdrumRroot"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumRroot.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"humdrumR's root directory on your machine. — humdrumRroot","text":"object class character length 1.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/interpolateArguments.html","id":null,"dir":"Reference","previous_headings":"","what":"Change or insert values in an expression — interpolateArguments","title":"Change or insert values in an expression — interpolateArguments","text":"function can used modify arguments functions within existing expression (quosure/formula).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/interpolateArguments.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Change or insert values in an expression — interpolateArguments","text":"","code":"interpolateArguments(quo, namedArgs)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/interpolateArguments.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Change or insert values in an expression — interpolateArguments","text":"namedArgs list named arguments. Unnamed arguments simply ignored. expr unevaluated expression object.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/interpolateArguments.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Change or insert values in an expression — interpolateArguments","text":"interpolateArguments inteprets named value namedArgs argument one two ways: named value list, interprets name list function call, inserts/swaps arguments list instances function call within expr. Named arguments inserted substituted already present expression. Unnamed argmuments simply added call. Examples: named valued namedArgs argument list, name/value pair substituted anywhere present expression. approach often conscise, arguments added expression way, substituted already present. Examples:","code":"myexpr <- quote(dnorm(x, mean = 5)) interpolateArguments(myexpr, list(dnorm = list(mean = 2, sd = 5, TRUE)))  # result is new expresson: dnorm(x, mean = 2, sd = 5, TRUE) myexpr <- quote(dnorm(x, mean = 5)) interpolateArguments(myexpr, mean = 2)  # result is new expression: dnorm(x, mean = 2) }"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/interpolateArguments.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Change or insert values in an expression — interpolateArguments","text":"","code":"myexpr2 <- quote(A + b*x + rnorm(length(a), mean(Z), sd = 2))  interpolateArguments(myexpr2,                      list(sd = 10, mean = list(na.rm = TRUE))) #> Error: `quo` must be a quosure                         # result is new expression:  # a + b*x + rnorm(length(a), mean(Z, na.rm = TRUE), sd = 10)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/intervalCalculus.html","id":null,"dir":"Reference","previous_headings":"","what":"Interval ","title":"Interval ","text":"Interval \"calculus\"","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/intervalCalculus.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interval ","text":"","code":"integrate(intervals, skip = list(is.na))  sigma(intervals, skip = list(is.na))  derive(intervals, skip = list(is.na))  delta(intervals, skip = list(is.na))  calculus(x, n, skip = list(na))"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/is.ragged.html","id":null,"dir":"Reference","previous_headings":"","what":"Does the corpus vary in the number of spines? — is.ragged","title":"Does the corpus vary in the number of spines? — is.ragged","text":"Reference Getting started humdrumR Humdrum Syntax Rhythm Pitch Intervals HumdrumR Coders Diatonic Tertian Sets humdrumR Overview humdrumR Pitch Tonality humdrumR Reading writing data humdrumR Rhythm Meter humdrumR Validating Humdrum Data  humdrum corpora homogenous, number spines file. function returns TRUE corpora homogenous, FALSE otherwise.  Developed Nathaniel Condit-Schultz.  Site built pkgdown 2.0.2.  Developed Nathaniel Condit-Schultz.  Site built pkgdown 2.0.2.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/is.ragged.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Does the corpus vary in the number of spines? — is.ragged","text":"","code":"is.ragged(humdrumR)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/keyTransformer.html","id":null,"dir":"Reference","previous_headings":"","what":"Parsing and deparsing key information — keyTransformer","title":"Parsing and deparsing key information — keyTransformer","text":"XXX","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/keyTransformer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parsing and deparsing key information — keyTransformer","text":"","code":"key(x, ..., Key = NULL, parseArgs = list(), memoize = TRUE, deparse = TRUE)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/lag.html","id":null,"dir":"Reference","previous_headings":"","what":"Shift data within a vector/matrix/data.frame — lag","title":"Shift data within a vector/matrix/data.frame — lag","text":"lag lead functions take input vectors, matrices, data.frames shifts data n indices. similiar data.table::shift function, additional options:","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/lag.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shift data within a vector/matrix/data.frame — lag","text":"","code":"lag(x, n = 1, fill = NA, wrap = FALSE, windows = NULL, ...)  lead(x, n, ...)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/lag.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shift data within a vector/matrix/data.frame — lag","text":"x input argument. vector (including lists), array, data.frame n amount lag/lead data. fill wrap = FALSE /windows = NULL, parts output padded fill argument. Defaults NA. wrap wrap = TRUE, data end (head tail) copied end output, \"wrapping\" data within data structure. windows vector list vectors, th length x. Lags crossing boundaries indicated windows filled. margin Arrays data.frames can lagged lead multiple dimensions using margin argument.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/metricPosition.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate metric positions from duration data. — metricPosition","title":"Calculate metric positions from duration data. — metricPosition","text":"Calculate metric positions duration data.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/metricPosition.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate metric positions from duration data. — metricPosition","text":"","code":"metricPosition(rints, bars = NULL, beats = rint(c(2, 4, 8, 16, 32)))"},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":null,"dir":"Reference","previous_headings":"","what":"Pitch representations and translations — pitch","title":"Pitch representations and translations — pitch","text":"Functions creating /translating numerous representations pitch. Test","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pitch representations and translations — pitch","text":"","code":"semit(   x,   ...,   Key = NULL,   Exclusive = NULL,   deparse = TRUE,   inPlace = FALSE,   dropNA = FALSE,   parseArgs = list(),   transposeArgs = list(),   memoize = TRUE )"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Pitch representations and translations — pitch","text":"numerous ways musicians musicologists encode pitch information---solfege, scientific pitch, intervals, scale degrees, frequencies, etc.---different purposes uses. representations numeric, involve letters characters. concrete representations can translated abstract tonalInterval objects: tonalIntervals completely represent /standard representations, cocrete pitch representation -> tonalInterval guaranteed lossless. However, pitch representations encode complete tonal pitch information, tonalInterval -> concrete pitch representation may lossy. caneats asside, humdrumR can, via common tonalInterval representation, encode translate various representations: can read data reprsentation, manipulate , write different representation. documentation describes humdrumR's pitch representation translation features. (tonalIntervals also give us easy ways manipulate pitch information---see tonalTransform documentation.) humdrumR currently recognizes XXX \"standard\" pitch representations: equivalent examples standard pitch representation; representations column table represented tonalInterval---final two rows show tonalInterval slot (@Octave @Fifth) values associated interval well (users never really think ). table illustrates representations lossy, encode full pitch information. instance, degree representation drops octave information, semit drops tonal information (.e., C# != Db). means translating complete representation lossy (less complete representation) non-injective function.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"pitch-translation","dir":"Reference","previous_headings":"","what":"Pitch Translation","title":"Pitch representations and translations — pitch","text":"humdrumR exports functions read write standard representations , well custom non-standard representations (see tonalChroma ). input can converted representation calling appropriate function form .xxx: example, solfa. complete list .xxx functions pitch representations : Atonal semit midi Tonal tonalChroma step .accidental .quality octave kern lilypond pitch interval degree solfa Frequency decimal frequency fraction Note none functions plural name, semits intervals even applying multiple inputs! functions three things: Read parse input tonalInterval (details ). desired, transform tonalInterval (see tonalTransform). Deparse write tonalInterval output representation (details ). three steps numerous options can control via special arguments. details reading writing stages, associated arguments described subsequent sections. pitch translation functions also arguments perform various transformations pitch data (.e., inversion, transposition). transformation arguments tonalTransform function can applied pitch translation function. example, can write kern(x, generic = TRUE, Key = \"\") extract generic intervals key major output kernPitch format. transformation arguments listed \"common\" arguments table , explained detail tonalTransformations documentation.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"reading-pitch-information","dir":"Reference","previous_headings":"","what":"Reading Pitch Information","title":"Pitch representations and translations — pitch","text":"master function tonalInterval converts recognized pitch input tonalInterval object. main .xxx functions implicitely call tonalInterval. tonalInterval interprets input pitch information determined base R dispatch system (interpreting class input) , input character-string, humdrumR's regular expression dispatch system. process reading input tonalInterval follows two steps: First, base R dispatch system checks class input. currently methods three recognized classes: integer: integers interpreted semitones. numeric: numeric (floating point, integer values) interpreted frequency ratios. character: input character, humdrumRs dispatch system comes play (see next paragraph). Given character-string input, humdrumR regular expression dispatch system determines appropriate way parse pitch information string using two criteria: matching known regular expressions string based Exclusive argument, indicates exclusive interpretations associated (see Humdrum Syntax vingette know exclusive interpretation ). input string, humdrumR searches known regular expressions decides interpret input based whichever regular expression matches input strings. instance, call kern(\"A4\") (.xxx pitch function), dispatcher see \"A4\" string matches regular expression scientific pitch notation (.e., middle C) also regular expression intervals (.e., augmented fourth). case, one input string, humdrumR five scientific notation precedence interpret input middle C. However, input information, like kern(c(\"A4\", \"P5\")), humdrumR see inputs match intervals, first one matches scientific pitch notation---therefore, humdrumR interpret strings intervals (augmented fourth perfect 5th). Note humdrumR use two different interpretions string. Also, strings match known regular expressions, result NA (unless inPlace = TRUE; see ). want interpret kern(\"A4\") interval? Well, can use Exculusive argument. Exclusive argument gives information dispatcher, override purely-regex based decisions. instance, specify kern(\"A4\", Exclusive = 'interval'), humdrumR know exclusive interpretation \"**interval\" interpreted interval. run kern(c(\"A4\", \"P5\"), Exclusive = 'pitch'), humdrumR return (\"\", NA), second input interpreted scientfic pitch. However, Exclusive argument vectorized, gives us option using multiple input interpretations different parts input. instance, kern(c(\"A4\", \"A4\"), Exclusive = c('pitch', 'int') return (\"\", \"f#\")---'pitch' exclusive intepretation matched first \"A4\" 'int' interpretation matched second one! following regular expressions exclusive interpretations associated representation humdrumR: Exclusive           RE                                                             Example kernPitch        *kern              (-Ga-g)\\1(#-)\\2                                      c Beam             kern              ([/\\\\]?(L+K)?)|([/\\\\]?(J+k)?)                            /Jk MelodicSignifier **kern              [TtMmWw]R?|[TtMmWwS$O]                                         M Articulation     **kern              ['`\\\"~][vu]?|[vu]                                            v recip            **recip             [1-9][0-9]%?[1-9]?[0-9][.]|01,2\\.                       8. sciPitch         **pitch             [-G][b#-][-+]?[0-9][0-9]                                    C4 solfa            **solfa             [\\^v',]([sd]eoi|[fl]eai|[mt]eiy|r[aei]) interval         **mint,**hint,*int [+-]?([MmP]|[Ad#b]+)[1-9][0-9]                                +P5 scaleDegree      **deg               [\\^v',]([MmPn]|[Ad#b])[1-9][0-9]*                           P5 final useful option controlled using logical inPlace argument. inPlace = TRUE extra characters input string part matching regular expression left unchanged: example, kern(\"4.A5xxxv\", inPlace = TRUE) output \"4.aaxxxv---\"A5\" (scientific pitch) translated \"aa\" (kern pitch) \"4.\" \"xxxv\" changed. contrast, kern(\"4.A5xxxv\", inPlace = FALSE) just return \"aa\", stripping away \"4.\" \"xxxv\". (Thus, inPlace argument can used tool extract desired part strings.) Note inPlace = TRUE, inputs fail match anything just left unchanged.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"read-writing-tonal-pitch-information","dir":"Reference","previous_headings":"","what":"Read/Writing Tonal Pitch Information","title":"Pitch representations and translations — pitch","text":"pitch representations defined humdrumR based Western diatonic tonality---info atonal representations, see Read/Writing Atonal Pitch Information section . predefined kernPitch, pitch, lilyPitch, helmholtz, interval, degree, solfa encodings tonal representations---fact, represent essentially absract information,  exactly tonalIntervals encode. Specifically, condsider representations different representations call tonal chroma: , tonalChroma function master function used construct specific representations. following section(s) explain abstract principles pitch representation, function standard representations, , humdrumR, can use tonalChroma arguments create custom tonal representations pitch.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"tonal-pitch-partitions-","dir":"Reference","previous_headings":"","what":"Tonal Pitch \"Partitions\"","title":"Pitch representations and translations — pitch","text":"discussed Tonality humdrumR vignette, tonal intervals can \"partitioned\"---.e., broken constituent logical pieces. two main \"partitions\" frequently use: partitioning complex interval simple parts octave parts*. partitioning specific interval generic part alteration part. Simple intervals abstract (line--fifths ) information, without regards specific pitch frequency space---.e., actual \"pitch height.\" combination simple interval octave part creates complex interval, include information specific pitch height. Tonal \"line--fifths space\" can partitioned generic (diatonic) information specific interval information describes quality intervals, including zero alterations diatonic set. Thus, tonal interval/pitch composed octave part, generic part, quality part. Various pitch representation schemes (kern, solfege) represent three different parts (octave/generic/quality) tonalIntervals various ways, though representations lossy/incomplete, fully encode three partitions. example, scale degrees represent simple tonal information without complex octave information. schemes, tonal partition represented distinctly others, allowing us mix match different sub-representation create various full reprsentations. cases, representations blur partitions ways can broken apart. instance, solfege syllables neatly delineate generic quality information---\"e\" vowel means different qualities depending leading consonant paired (e.g., \"re\" vs \"\"). Since logic interval representation always conform abstract logic tonalInterval partitions, use different set terms refer representation distinct partitions: scale-step generic information,  quality/alteration/accidental alteration information,  octave octave information, Thus, terms step, octave, quality, alteration, accidental appear various pitch representation/translation function arguments (details ). humdrumR, tonal chroma representation combines combination three representation partions (scale, alteration, /octave). tonalChroma function master function writing tonal chroma. functionskern, pitch, lilypond, .helmholtz simply wrappers call tonalChroma various specific arguments. tonalChroma calls four constituent functions: step, .quality/.accidental, octave/octave. arguments tonalChroma, derived constituent functions (details following sections) : tonalChroma: parts: character string length 1--4, indicating parts tonalChroma print, order. Acceptable strings \"step\", \"qualities\", \"accidentals\", \"octave\". ([Partial matches][base::pmatch] matches like \"ste\" \"s\" step work .) output tonal chroma string part concatinated order appear parts argument. instance, put c(\"octave\", 'step', 'accidental') put octave simple interval, put c('step', 'accidental', \"octave\") put . sep: character string used separate elements (default \"\"). step (described ): step.labels .accidental (described ): accidental.labels accidental.maximum accidental.minimum accidental.cautionary accidental.memory Key .quality (described ): quality.labels quality.maximum quality.minimum quality.cautionary quality.memory Key octave (described ): octave.labels octave.maximum octave.minimum octave.offset octave.round octave.delta","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"scale-steps","dir":"Reference","previous_headings":"","what":"Scale Steps","title":"Pitch representations and translations — pitch","text":"particular area confusion pitch representation relationship tonal (line--fifths) space octave (frequency) space. line--fifths abstract space unrelated specific frequencies---e.g., G inherently \"\" \"\" C. Still, musicians play abstractions, must always realize line--fifths space concrete frequency space. convention, collections line--fifths conceptualized frequency-orded \"scales\": folding line--fifths sequence intervals octave \"\" unison. theoretical contexts, order/\"height\" elements scale actually completely irrelavant. Specifically, first seven (diatonic) elements line--fifths mapped generic scale-steps order [0, 2, 4, 6, 1, 3, 5]. Scale-steps strictly limited seven-step range single diatonic octave, always \"ascending\"/\"positive\"---steps pseudo-octave \"\" unison. representation line--fiths terms scale-steps basic approach representing pitch, associated arguments containing step; function step basic building block scale-step representations humdrumR. apply modulo-7 operation line--fifths space, intervals mapped seven generic steps. Alterations basic generic steps represented separately (see Qualities Alterations section ). However, note scale order defined entirely based generic interval: example, C-flat convention positioned \"\" C-natural scale, even though (often) equivalent B-natural, \"top\" scale. Generic, pseudo-ordered, scale-steps conventionally represented three forms: letters (-G), numbers (1-7 -VII), conventional syllables (, re, mi, fa...). HumdrumR predefines several representations include letters (-G) scale-step encoding: kernPitch, lilyPitch, helmholtz, pitch. also standard numeric (degree) syllable-based (solfa) based representations predefined. generic step function can used write variations scale step representations. step includes two arguments: step.labels: vector seven elements (default = c('C', 'D', 'E', 'F', 'G', '', 'B')) representing desired names seven steps scale order.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"quality-and-alterations","dir":"Reference","previous_headings":"","what":"Quality and Alterations","title":"Pitch representations and translations — pitch","text":"Generically, tonal interval's quality indicates diatonic mode relationship mode. Specifically, alterations/accidentals indicate alterations key/mode quality indicates mode . diatonic set primarily defined major mode, consisting line--fifth range -1 +5. seven intervals \"natural\" intervals---default, unless major context specifically counter-indicated, absence accidental indicates natural steps. intervals outside scale can indicated alterations natural steps using accidentals: two primary accidentals, sharp flat, though can added together create multi-sharps multi-flats. (Sharps flats mixed humdrumR.) alteration corresponds adding subtracting multiples 7 generic values (e.g., \"sharpen\" note means add 7 line--fifths value). Finally, natural accidental used default natural step needs explicitely labeled. encoding qualities subtly distinct alterations. Qualities encode information diatonic mode intervals, well alterations mode. five consonant diatonic modes---phyrigian (-5--+1), minor (-4--+2), dorian (-3--+3), mixolydian (-2--+4), major (-1--+5)---share \"perfect\" first, fourth,  fifth scale-steps---corresponding central -1--+1 line--fifths. However, five modes encompass two varieties \"imperfect\" second, third, sixth, seventh scale steps: major steps (+2--+5) minor steps (-2---5), (obviously) inverses line--fifths. minor/major pair separated line--fifths interval 7, thus one can altered . Anything line--fifths outside -5--+5 range represented one alterations perfect/imperfect degree. Postive alterations (+7)  augmented negative alterations (-7) diminished---like sharps flat, augmentations diminutions can multipled. following table illustrates relationship line--fifths, scale-steps, accidentals, qualities: Note accidentals symetrical around dorian mode (D), qualities symetrical around major mode. result, though sharp accidentals augmentation qualities always correspond, flat accidentals equivalent diminished qualities. HumdrumR's predefined tonal chroma representations (kernPitch, lilyPitch, helmholtz, pitch) include alteration information three accidental indications (sharp, flat, natural). degree interval representations encode general qualities using five categories (major, minor, diminished, augmented, perfect). solfa representation also encodes quality conventional (non-systematic) vowel modifications. generally, .quality .accidental functions can used extract quality information isolation. functions use () following arguments: _.labels: accidental.labels: [named][base::names()] character vector controls characters used represent accidentals. characters must named either flat, sharp, natural, doublesharp, doubleflat. defaults c(flat = \"b\", sharp = \"#\", natural = \"n\"). default, doubleflat doublesharp defined, doubles simply represented two normal accidental symbols. However, either double accidental defined, every pair accidentals collapsed double version. accidental.labels == FALSE, returns integer value counting number alterations (positive sharps, negative flats). quality.labels: [named][base::names()] character vector controls characters used represent qualities. characters must named either perfect, major, minor, augment, diminish, defaults c(perfect = \"P\", major = \"M\", minor = \"m\", augment = \"\", diminish = \"d\"). _.maximum _.minimum Single integer values---defaults Inf (maximum) -Inf (minimum). arguments define maximum number multi-accidentals permitted. instance, accidental.maximum == 2L, accidentals \"##\" output; triple sharp reduced just \"##\". The_.minimum argument must negative (-2 == two flats). default, minimum inverse maximum, want , just set maximum. Key: [diatonicSet] object describing key mode. Default NULL. Key specified, alterations relative key printed (unless _.cautionary _.memory arguments override ). _.cautionary: single logical value. Causes accidentals/qualities print (details ). Default FALSE accidentals TRUE qualities. _.memory: single logical value (default FALSE). Causes fewer accidentals/qualities print (details ). master tonalChroma calls functions, can thus pass arguments . example, write tonalChroma(x, accidental.maximum = 1).","code":"LO5th Step Accidental Quality    -10    E         --       d     -9    B         --       d     -8    F          -       d     -7    C          -       d     -6    G          -       d     -5    D          -       m     -4    A          -       m     -3    E          -       m     -2    B          -       m     -1    F                         0    C                         1    G                         2    D                         3    A                         4    E                         5    B                         6    F          #       A      7    C          #       A      8    G          #       A      9    D          #       A     10    A          #       A     11    E          #       A     12    B          #       A     13    F         ##      AA     14    C         ##      AA"},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"accidentals","dir":"Reference","previous_headings":"","what":"Accidentals","title":"Pitch representations and translations — pitch","text":"","code":"a-   a    b-   a    b-   a-   e    f    f#   e-   g-   f    b    c    d-   b-   e-   b-   a-   NFF  a-   a    b-   a    b-   a-   e    f    f#   e-   g-   f    b    c    d-   b-   e-   b-   a-   NFT  a-   a    b-   a    b-   a-   e    f    f#   e-   g-   f    b    c    d-   b-   e-   b-   a-   NTF  a-   a    b-   a    b-   a-   e    f    f#   e-   g-   f    b    c    d-   b-   e-   b-   a-   NTT  a-   a    b-   a    b-   a-   e    f    f#   e-   g-   f    b    c    d-   b-   e-   b-   a-   AbFF a-   a    b-   a    b-   a-   e    f    f#   e-   g-   f    b    c    d-   b-   e-   b-   a-   AbFT a-   a    b-   a    b-   a-   e    f    f#   e-   g-   f    b    c    d-   b-   e-   b-   a-   AbTF a-   a    b-   a    b-   a-   e    f    f#   e-   g-   f    b    c    d-   b-   e-   b-   a-   AbTT a-   a    b-   a    b-   a-   e    f    f#   e-   g-   f    b    c    d-   b-   e-   b-   a-"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"qualities","dir":"Reference","previous_headings":"","what":"Qualities","title":"Pitch representations and translations — pitch","text":"","code":"a-   a    b-   a    b-   a-   e    f    f#   e-   g-   f    b    c    d-   b-   e-   b-   a-   NFF  mA   A    mB   A    mB   mA   E    F    AF   mE   dG   F    B    C    mD   mB   mE   mB   mA   NFT  mA   A    mB   A    mB   mA   E    F    AF   mE   dG   F    B    C    mD   mB   mE   mB   mA   NTF  mA   A    mB   A    mB   mA   E    F    AF   mE   dG   F    B    C    mD   mB   mE   mB   mA   NTT  mA   A    mB   A    mB   mA   E    F    AF   mE   dG   F    B    C    mD   mB   mE   mB   mA   AbFF mA   A    mB   A    mB   mA   E    F    AF   mE   dG   F    B    C    mD   mB   mE   mB   mA   AbFT mA   A    mB   A    mB   mA   E    F    AF   mE   dG   F    B    C    mD   mB   mE   mB   mA   AbTF mA   A    mB   A    mB   mA   E    F    AF   mE   dG   F    B    C    mD   mB   mE   mB   mA   AbTT mA   A    mB   A    mB   mA   E    F    AF   mE   dG   F    B    C    mD   mB   mE   mB   mA"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"octave","dir":"Reference","previous_headings":"","what":"Octave","title":"Pitch representations and translations — pitch","text":"wish represent concrete, frequency-ordered information pitch, add additional octave information simple, line--fifth representation creating complex intervals. Since scale-step representations ostensibly encode frequency-space ordering already, first step take scale-ordering literally---e.g, G really \"\" D---, creating call simple octave. fully represent complex interval, can append zero octaves simple octave, call octave octave. humdrumR, symbols \"+\" \"-\" used indicate direction simple octave, various scale-step quality/alterations used indicate simple interval. (many representations, symbols implicit, thus ommitted.) contrast, octave octave interval simply integer value, can represented variety ways: either directly integer, using repetitions symbol pairs, commonly \"^\"/\"v\" \"'\"/\",\". approaches represent octave octave information changing case (upper lower) repeating parts simple-interval string. default, \"\" option (.e., unison) types octaves left blank empty string \"\". relationship simple octave octave octave determined scale step \"rounded\" octave (see Tonality humdrumR vignette), controlled octave.round argument. standard approach, scale steps ascending octave achieved floor function: call scale octave. Another approach use round function, rounds nearest octave , centering steps around unison instead : result scale like [-P4, -m3, -m2, P1, M2, M3, P4], call central octave. difference central octaves, scale octaves, simple octave options, illustrated .","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"serial-vs-fixed-octave-contour","dir":"Reference","previous_headings":"","what":"Serial vs Fixed Octave Contour","title":"Pitch representations and translations — pitch","text":"#' described Tonality humdrumR vignette, two general approaches representing intervals: fixed-reference serial-reference. pitch representations fixed-reference, token representing interval relative common reference (middle-C, tonic, unison, etc.). contrast, serial representation represents interval cummulatively, relative previous interval: common example melodic intervals. TonalIntervals can encode either fixed- serial-reference intervals, either approach can partitioned simple intervals octave offsets. common cases representing pitch, simple octave treated \"always ascending\" scale octave, octave octave simply kept fixed. Common approaches pairing octave information include: pitch style: octave offset simply printed integer, though offset +4 middle-C (unison) \"4\". kernPitch style: scale step lowercase octave octaves >= 0 uppercase otherwise. addition, scale step repeated absolute value octave octave times (offset +1 positive octaves). example, (CCC = -3, CC = -2, C = -1, c = 0, cc = 1, ccc = 2). lilyAbsolute absolute style: charactes \"'\" (positive) \",\" repeated absolute value octave octave. helmholtz style: intersection lilyPitch-absolute kernPitch style, case scale step changed kern-style, \"'\"/\",\" characters printed la lilypond absolute style. However, another particularly useful possibility encode octave part serial reference simple part fixed reference. compute serial-octave octave, set octave.round argument round, octave labels blank (\"\" marker) interval moved closest neighbor, octave octave indicating moves away \"closest note.\" instance, can say, \"play F# previous note.\" known \"relative pitch\" representation LilyPond]: relative = TRUE, lilypond compute markers labeled way. approach can combined scale-octave (octave.round = floor) representation pitch scale degrees, resulting scale degree representation lossless octave information! achieve serial octaves, use octave.delta octave.round arguments. delta = TRUE, octave serial representation input computed, octave-part octave computed using octave.round rounding function. floor create \"always ascending\" scale octave, round achieve centered octave. expand label octaves ascending/descending except unisons. following table illustrates different octave.round arguments delta = TRUE: following table illustrates three rounding functions, octave.delta = FALSE.","code":"round floor expand      0     0      0      0    -1     -1      0    -1     -1      0     0      0      0     0      1      0    -1     -1      0    -1     -1      0    -1     -1      0    -1     -1      0     0      1      0     0      1      0     0      1      0     0      1      0     0      1      0     0      1      0     0      0      1     1      2      1     1      2      1     1      2      1     1      1 Kern round floor expand     c     0     0      0     A     0    -1     -1     A     0    -1     -1     c     0     0      0     d     0     0      1     G     0    -1     -1     G     0    -1     -1     A     0    -1     -1    B-     0    -1     -1     f     0     0      1     f     0     0      1     e     0     0      1     d     0     0      1     e     0     0      1     d     0     0      1     c     0     0      0    ff     1     1      2    ee     1     1      2    dd     1     1      2    cc     1     1      1"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"complex-steps","dir":"Reference","previous_headings":"","what":"Complex Steps","title":"Pitch representations and translations — pitch","text":"final standard approach indicating complex octaves complex steps: .e., 9ths, 11ths, etc. approach directly represents full octave information scale steps, +7 added every octave octave. representation can accessed via interval function. limit intervals simple values, use tonalTransform arguments octave /roundMethod.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"octave-1","dir":"Reference","previous_headings":"","what":"octave","title":"Pitch representations and translations — pitch","text":"octave function can used directly generate representations octave/octave, can called indirectly via tonalChroma one standard pitch representation functions (kern, pitch, etc.). octave command synonym octave. following arguments defined octave: octave.labels: [named][base::names()] character vector controls characters used represent octave shifts. characters must named either , , ; defaults c(= \"^\", = \"v\", = \"\"). octave.labels = FALSE, octave offset (integer) returned. octave.labels == FALSE, returns integer value counting octave offset number. octave.maximum octave.minimum Single integer values---defaults Inf (maximum) -Inf (minimum). arguments define maximum number octave offset labels permitted. maximum == 2L, octave offsets (\"^^\") output; triple octave mark reduced just \"^^. Theminimum arguments negative. default, minimum inverse maximum, want , just set maximum. octave.offset: single integer, indicating \"center\" octave. default 0L, scientific pitch uses 4L (middle C \"C4\"). octave.delta: single logical vale. TRUE, serial octave calculated. octave.round: function, either floor, round, trunc, expand (see Tonality humdrumR vignette). default floor, standard delta = FALSE. [/\\\\]: R:/%5C%5C%5C%5C%5C%5C%5C [/\\\\]: R:/%5C%5C%5C%5C%5C%5C%5C [TtMmWw]: R:TtMmWw [TtMmWwS$O]: R:TtMmWwS$O [vu]: R:vu [vu]: R:vu [0-9]: R:0-9 [1-9]: R:1-9 [0-9]: R:0-9 [.]: R:. [b#-]: R:b#- [-+]: R:-+ [0-9]: R:0-9 [\\^v',]: R:%5C%5C%5C%5C%5Ev', [aei]: R:aei [+-]: R:+- [MmP]: R:MmP [Ad#b]: R:Ad#b [0-9]: R:0-9 [\\^v',]: R:%5C%5C%5C%5C%5Ev', [MmPn]: R:MmPn [Ad#b]: R:Ad#b [0-9]: R:0-9 [line--fifths]: R:line--fifths tonalTransformations: R:tonalTransformations [alterations]: R:alterations [base::pmatch]: R:base::pmatch [0, 2, 4, 6, 1, 3, 5]: R:0,%202,%204,%206,%201,%203,%205 [sharp]: R:sharp [flat]: R:flat [natural]: R:natural [modes]: R:modes [base::names()]: R:base::names() [base::names()]: R:base::names() [diatonicSet]: R:diatonicSet [-P4, -m3, -m2, P1, M2, M3, P4]: R:-P4,%20-m3,%20-m2,%20P1,%20M2,%20M3,%20P4 LilyPond: R:LilyPond tonalTransform: R:tonalTransform [base::names()]: R:base::names()","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"reading-writing-atonal-pitch-information","dir":"Reference","previous_headings":"","what":"Reading/Writing Atonal Pitch Information","title":"Pitch representations and translations — pitch","text":"Atonal pitch representations predefined humdrumR include semit, midi, frequency, ratio, fraction. mentioned , integer inputs interpreted semitones numeric interpreted frequency ratios.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"interpreting-frequencies-ratios","dir":"Reference","previous_headings":"","what":"Interpreting Frequencies/Ratios","title":"Pitch representations and translations — pitch","text":"Four additional arguments help humdrumR determing interpret frequencies ratios tonalIntervals. tonalHarmonic: determines assumed tuning system specifying \"tonal frequency ratio\" associated interval perfect 12th. default 3, corresponding pythagorean tuning; change 2^(19/12) use equal temeperament. centMargin: numeric argument determines close humdrumR tries get (cents) input ratio (default 10 cents). centMargin low, humdrumR may give crazy accidental like ---- get close input ratio. centMargin higher, humdrumR give reasonable (fewest accidentals) tonalInterval within margin. example, tonalInterval(1.44, centMargin = 10) return E##, pythagorean E## within 10 cents ratio 1.44. However, tonalInterval(1.44, centMargin = 20) return resonable F#. frequency.reference frequencyTint: arguments determing reference frequency note reading frequencies. standard = 440Hz corresponds (frequency.reference = 440, frequencyTint = tonalInterval('')).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"tonal-decisions","dir":"Reference","previous_headings":"","what":"Tonal Decisions","title":"Pitch representations and translations — pitch","text":"interpreting atonal representation tonal one multiple possibilities (instance, midi note 61 C# Db). process humdrumR uses determine tonal representation atonal input influenced accidental.melodic Key arguments: default (Key == NULL & accidental.melodic == FALSE), line--fifths range -3--8 (E flat G sharp) used. However, Key argument specified, line--fifths range shifted match corresponding key signature. instance, key Bb minor read accidentals range -8--3 (Fb flat natural). accidental.melodic == TRUE) atonal notes interpreted \"melodically\"---.e., ascending chromatic steps sharps descending chromatic steps flats. reading frequencies/ratios, \"pure\" tonalHarmonic value---like pure 3 pythagorean tuning---help determine appropriate accidental. However, equal temperament provide useful information, Key accidental.melodic arguments can used instead.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchFunctions.html","id":null,"dir":"Reference","previous_headings":"","what":"Manipulate pitch data — pitchFunctions","title":"Manipulate pitch data — pitchFunctions","text":"Manipulate pitch data","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchFunctions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Manipulate pitch data — pitchFunctions","text":"","code":"semit(   x,   ...,   Key = NULL,   Exclusive = NULL,   parseArgs = list(),   transposeArgs = list(),   inPlace = FALSE,   memoize = TRUE,   deparse = TRUE )  midi(   x,   ...,   Key = NULL,   Exclusive = NULL,   parseArgs = list(),   transposeArgs = list(),   inPlace = FALSE,   memoize = TRUE,   deparse = TRUE )  pitch(   x,   ...,   Key = NULL,   Exclusive = NULL,   parseArgs = list(),   transposeArgs = list(),   inPlace = FALSE,   memoize = TRUE,   deparse = TRUE )  kern(   x,   ...,   Key = NULL,   Exclusive = NULL,   parseArgs = list(),   transposeArgs = list(),   inPlace = FALSE,   memoize = TRUE,   deparse = TRUE )  lilypond(   x,   ...,   Key = NULL,   Exclusive = NULL,   parseArgs = list(),   transposeArgs = list(),   inPlace = FALSE,   memoize = TRUE,   deparse = TRUE )  interval(   x,   ...,   Key = NULL,   Exclusive = NULL,   parseArgs = list(),   transposeArgs = list(),   inPlace = FALSE,   memoize = TRUE,   deparse = TRUE )  degree(   x,   ...,   Key = NULL,   Exclusive = NULL,   parseArgs = list(),   transposeArgs = list(),   inPlace = FALSE,   memoize = TRUE,   deparse = TRUE )  solfa(   x,   ...,   Key = NULL,   Exclusive = NULL,   parseArgs = list(),   transposeArgs = list(),   inPlace = FALSE,   memoize = TRUE,   deparse = TRUE )"},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/plotRhythm.html","id":null,"dir":"Reference","previous_headings":"","what":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------\nPlotting rhythmic symbols in R base graphics — plotRhythm","title":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------\nPlotting rhythmic symbols in R base graphics — plotRhythm","text":"------------------------------------------->             NEEDS DOCUMENTATION             <------------------------------------------- Plotting rhythmic symbols R base graphics","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/plotRhythm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------\nPlotting rhythmic symbols in R base graphics — plotRhythm","text":"","code":"plotRhythm(x, y, notes, ...)  # S3 method for default plotRhythm(x, y, notes, ...)  # S3 method for rhythmInterval plotRhythm(x, y, notes, ...)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/rational.html","id":null,"dir":"Reference","previous_headings":"","what":"Rational numbers — rational","title":"Rational numbers — rational","text":"R built rational number representation; humdrumR defines one.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/rational.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rational numbers — rational","text":"","code":"rational(numerator, denominator = 1)  as.rational(x, ...)  fraction(numerator, denominator, sep = \"/\")  as.fraction(x, sep, ...)"},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/readHumdrum.html","id":null,"dir":"Reference","previous_headings":"","what":"Find and read humdrum files into R — readHumdrum","title":"Find and read humdrum files into R — readHumdrum","text":"functions find valid humdrum files local machine read humdrumR.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/readHumdrum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find and read humdrum files into R — readHumdrum","text":"","code":"findHumdrum(   ...,   contains = NULL,   recursive = FALSE,   allowDuplicates = FALSE,   verbose = FALSE )  readHumdrum(   ...,   recursive = FALSE,   contains = NULL,   allowDuplicates = FALSE,   verbose = FALSE,   tandems = \"known\",   reference = \"all\" )"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/readHumdrum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find and read humdrum files into R — readHumdrum","text":"... character: One patterns used identify files read. details: see \"REpath-patterns\" section . contains character. !.null(contains), contains argument treated regular expressions: files contain matches regular expressions read. Thus, readHumdrum('.*krn$', contains = \"EEE\") read kern files contain matches \"EE\"---kern E two octaves middle C (lower). recursive logical: TRUE, final part search pattern (.e., file search) searched recursively sub directories. allowDuplicates logical length one, indicating happen multiple search patterns match files. allowDuplicates = TRUE, files read multiple times, grouped respective corpora Label field. allowDuplicates = FALSE, redundant files read corpus first pattern match. verbose logical: TRUE, names matching files printed parsing begins. useful check make sure reading wrong files! tandems character. argument controls , , tandem interpretations parsed fields. default value \"known\". reference character. argument controls , , reference records parsed fields. default value \"\".","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/readHumdrum.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find and read humdrum files into R — readHumdrum","text":"findHumdrum work finding reading text files R. readHumdrum utilizes findHumdrum read files, parses create humTable build humdrumR data object around table.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/readHumdrum.html","id":"repath-patterns","dir":"Reference","previous_headings":"","what":"REpath-patterns","title":"Find and read humdrum files into R — readHumdrum","text":"\"REpath-patterns\" specified using ... arguments. combination, ... arguments used search file paths. part search path specify (\"dirpart/dirpart/filepart\", etc) matched regular expressions directories/files disc. Thus, can say things like findHumdrum(\"../^.*/.*krn$\"), match kern files directory beginning capital \"\" directory current working directory. conveniance, can break path across multiple arguments instead using delimited strings: example, code findHumdrum(\"..\", \"^.*\", \".*krn$\") give identical result previous example (findHumdrum(\"../^.*/,*krn$\")). useful searching one pattern (see next paragraph) directory. want search one pattern, can input character vector: instance, readHumdrum(c(\"mozart\", \"beethoven\")---command search filenames containing \"mozart\" \"beethoven.\" works directories : readHumdrum(c(\"Mozart\", \"Beethoven\"), \".*krn$\") look kern files directories containing \"Mozart\" \"Beethoven.\" patterns named, names show identifying patterns [humdrumR][humdrumR] object's Label field. Unnamed patterns simply labeled numbers. Normal (system appropriate) conventions (.e., directories separated \"/\", '~' beginning indicate home, \"..\" indicate directory working directory, etc.) followed. pattern contains solo dot followed file sep---e.g., \"./\", \"x/./y\"---treated current directory, regular expression. pattern contains two dots---e.g., \"../\"---treated directory , regular expression. want create regular expression match directory, use \".*/\". regex pattern \"\" matches file (changed \".*\"). specifiy ... argument, findHumdrum (readHumdrum) default \".*\" well. Thus, readHumdrum() read humdrum files working directory. (two files different directories share name, unique name created file appending names directories occupy, recursively names unique.) single humdrum file multiple pieces ---meaning spine paths close *-, open **---parsed separetely. distinguished Piece field. multi-piece files, Piece File identical.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/readHumdrum.html","id":"validity","dir":"Reference","previous_headings":"","what":"Validity","title":"Find and read humdrum files into R — readHumdrum","text":"findHumdrum readHumdrum automatically ignore non-text files. Whatsmore, files contain humdrum syntax errors (checked [validateHumdrum][validateHumdrum]) automatically skipped. want see specifically errors occured, call [validateHumdrum][validateHumdrum] directly errorReport.path argument.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/readHumdrum.html","id":"tandem-interpretations","dir":"Reference","previous_headings":"","what":"Tandem Interpretations","title":"Find and read humdrum files into R — readHumdrum","text":"tandems argument controls tandem interpretations parsed fields. can helpful either save processing time memory parsing interpretations need, parse interpretations humdrumR recognize. \"known\" tandem interpretations humdrumR recognizes encoded build humdrumR table called knownInterpretations. interpretation humdrumR name (\"Clef\", \"TimeSignature\", etc.) well regular expression associated . default value tandems argument \"known\". tandems argument contains \"known\" tandem interpretations built-knownInterpretations table parsed. Users may specify different interpretations parse two ways: character strings matching one name values Name column knownInterpretations. instance, specify tandems = c('Clef', 'TimeSignature'), clef (e.g., \"*clefG2\"), time signature (e.g., \"*M3/4\") intepretations parsed. chracter string(s) tandem exactly match one names knownInterpretations$Name, treated regular expressions used match tandem interpretations data. allows users parse non-standard tandem interpretations humdrumR already know . values tandems named, names used resulting fields. matches given interpretation found, field created interpretation. tandems = NULL, tandem interpretations parsed.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/readHumdrum.html","id":"reference-records","dir":"Reference","previous_headings":"","what":"Reference Records","title":"Find and read humdrum files into R — readHumdrum","text":"default (reference = \"\"), humdrumR reads reference records data. reference code record (e.g, \"OTL\", \"!!!OTL: xxx\") used name associated field. (reference record reference code (.e., lacks colon), field called \"Unkeyed.\") large datasets many reference records, reference data can actually make large portion humdrum table, eat lot memory. cases, might want read () reference records---can instead read reference records planning use analyses (). reference = NULL, reference records parsed. Otherwise, character values reference treated reference codes matching reference records parsed. instance, readHumdrum(_, reference = \"OTL\") parse OTL reference records. values reference named, names used name associated fields. Thus, specifing reference = c(Title = 'OTL'), can use \"OTL\" reference records populate field called \"Title\". one reference records reference code, either explicitely numbered (e.g., \"!!!COM1:\", \"!!!COM2:\") read rather making two fields, single field created (\"COM\" ) multiple values separated \";\".","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/readHumdrum.html","id":"result","dir":"Reference","previous_headings":"","what":"Result","title":"Find and read humdrum files into R — readHumdrum","text":"findHumdrum returns \"fileFrame\" (data.table), listing file names, patterns match, directories found , raw text content files. readHumdrum returns fully parsed humdrumR object.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/readHumdrum.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find and read humdrum files into R — readHumdrum","text":"","code":"readHumdrum() # loads all valid humdrum files in the current directory. #> Finding and reading files... #> \tREpath-pattern '.*' matches 87 text files in 1 directory. #> Eighty-Seven files read from disk.  #> Validating eighty-seven files...18,669 errors in eighty-eight files...zero valid files. #> NULL  readHumdrum(\".*krn$\") # loads all files ending with \"krn\" in the currect directory #> Finding and reading files... #> \tREpath-pattern '.*krn$' matches 0 text files in 1 directory. #> Zero files read from disk.  #> No files to validate. #> NULL  readHumdrum(\"^Composers$/^Be|^Mo/.*/^Joined$/.*krn$\")  #> Finding and reading files... #> \tREpath-pattern '^Composers$/^Be|^Mo/.*/^Joined$/.*krn$' matches 0 text files in 0 directories. #> Zero files read from disk.  #> No files to validate. #> NULL # Goes inside the directory \"Composers\". # Inside \"Composers\" looks for directories that start with \"Be\" or \"Mo\". # If there are any \"Be|Mo\" matching directories within \"Composers\", matches all directories within them. # Within these directories, looks for directories called \"Joined\". # If there are any directories called \"Joined\", loads all files (if any) that end with \"krn\".  readHumdrum(\"^Composers$\", \"^Be|^Mo\", \".*\", \"^Joined$\", \".*krn$\") #> Finding and reading files... #> \tREpath-pattern '^Composers$/^Be|^Mo/.*/^Joined$/.*krn$' matches 0 text files in 0 directories. #> Zero files read from disk.  #> No files to validate. #> NULL # exactly the same as the previous!  readHumdrum(\"^Composers$\", c(Beethoven = \"^Be\", Mozart = \"^Mo\"), \".*\", \"^Joined$\", \".*krn$\")  #> Finding and reading files... #> \tREpath-pattern Beethoven = '^Composers$/^Be/.*/^Joined$/.*krn$' matches 0 text files in 0 directories. #> \tREpath-pattern Mozart = '^Composers$/^Mo/.*/^Joined$/.*krn$' matches 0 text files in 0 directories. #> Zero files read from disk.  #> No files to validate. #> NULL # exactly the same as the previous, except now the two matching patterns (\"^Be\", or \"^Mo\") will be grouped # in the Label field as \"Beethoven\" and \"Mozart\" respectively."},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/regexConstruction.html","id":null,"dir":"Reference","previous_headings":"","what":"Making Regular Expressions — regexConstruction","title":"Making Regular Expressions — regexConstruction","text":"humdrumR includes helpful functions creating new regular expressions work stringr package.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/regexConstruction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Making Regular Expressions — regexConstruction","text":"","code":"captureRE(strs, n = \"\")  captureUniq(strs, zero = TRUE)  orRE(...)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/regexConstruction.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Making Regular Expressions — regexConstruction","text":"captureRE take character vector collapse \"capture group.\" n argument can used append number tag, instance '*' (zero ) group. .e., captureRE(c(\"\", \"b\", \"c\"), '*') output \"[abc]*\". captureUniq make similar capture group captureRE, expression makes sure 1 character repeats. instance, captureUniq(c('', 'b','c')) return \"([abc])\\\\1*\"---expression match \"aaa\" \"bb\" \"aabb\".","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/regexDispatch.html","id":null,"dir":"Reference","previous_headings":"","what":"Regular expression method dispatch and function application — regexDispatch","title":"Regular expression method dispatch and function application — regexDispatch","text":"humdrumR regular-expression method dispatch system simple system making new functions can smartly applied complex character strings.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/regexDispatch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Regular expression method dispatch and function application — regexDispatch","text":"","code":"func %predate% predicate  regexDispatch(..., defaultClass = \"character\")  REapply(x, regex, .func, inPlace = TRUE, ...)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/regexDispatch.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Regular expression method dispatch and function application — regexDispatch","text":"function do2RE accepts arbitrary function regular expression (regex) makes new function applies original function part string matches regex. function regexDispatch accepts list functions, matching regular expression, creates new function applies whichever function based regexs finds input.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/rhythmDecompose.html","id":null,"dir":"Reference","previous_headings":"","what":"Decompose durations in terms of other durations — rhythmDecompose","title":"Decompose durations in terms of other durations — rhythmDecompose","text":"Decompose durations terms durations","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/rhythmDecompose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Decompose durations in terms of other durations — rhythmDecompose","text":"","code":"rhythmDecompose(rhythmInterval, into = rint(c(1, 2, 4, 8, 16, 32)))"},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/rhythmFunctions.html","id":null,"dir":"Reference","previous_headings":"","what":"Manipulate pitch data — rhythmFunctions","title":"Manipulate pitch data — rhythmFunctions","text":"Manipulate pitch data","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/rhythmFunctions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Manipulate pitch data — rhythmFunctions","text":"","code":"recip(   x,   ...,   Exclusive = NULL,   parseArgs = list(),   timeArgs = list(),   inPlace = FALSE,   memoize = TRUE,   deparse = TRUE )  duration(   x,   ...,   Exclusive = NULL,   parseArgs = list(),   timeArgs = list(),   inPlace = FALSE,   memoize = TRUE,   deparse = TRUE )"},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/rhythmInterval.html","id":null,"dir":"Reference","previous_headings":"","what":"Representation of rhythmic information — rhythmInterval","title":"Representation of rhythmic information — rhythmInterval","text":"S4 class core rhythm representation humdrumR package. object used represent rhythmic durations metric positions. duration represented whole note units. Numerically, whole note units represented ratio integers, held slots @Numerator @Denominator. allows use represent rational number loss precision due rounding errors weak decimal expansions (like 0.333333). Rhythm intervals similar standard musical termoniology (.e, \"three eighth-notes\" ratio (3/8).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/rhythmInterval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Representation of rhythmic information — rhythmInterval","text":"","code":"rhythmInterval(x, ...)  rint(denominator, numerator = 1L)  # S4 method for rhythmInterval as.character(x)  # S3 method for rhythmInterval as.double(x)  is.rhythmInterval(x)  # S4 method for rhythmInterval is.numeric(x)  order.rhythmInterval(   x,   ...,   na.last = TRUE,   decreasing = FALSE,   method = c(\"auto\", \"shell\", \"radix\") )  # S4 method for rhythmInterval,rhythmInterval Compare(e1, e2)  # S4 method for rhythmInterval Summary(x)  rhythmInterval(x, ...)  # S3 method for logical rhythmInterval(x, ...)  # S3 method for `NULL` rhythmInterval(x, ...)  # S3 method for numeric rhythmInterval(n)  # S3 method for rational rhythmInterval(x)  # S3 method for fraction rhythmInterval(x)  # S3 method for integer rhythmInterval(x)  # S3 method for character rhythmInterval(str, Exclusive = NULL, ..., multiDispatch = FALSE)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/rhythmInterval.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Representation of rhythmic information — rhythmInterval","text":"Numerator Integers Octave Integers","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/rhythmInterval.html","id":"vectorization","dir":"Reference","previous_headings":"","what":"Vectorization","title":"Representation of rhythmic information — rhythmInterval","text":"rhythmInterval inherits virtual class struct. means can apply normal vectorized commands rhythmIntervals, even put base::data.frame().","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/rhythmInterval.html","id":"arithmetic","dir":"Reference","previous_headings":"","what":"Arithmetic","title":"Representation of rhythmic information — rhythmInterval","text":"rhythmInterval objects arithmetic operations defined. Addition subtraction straightword intuitive (.e., (1/8) + (3/8) = (1/2)). Multiplication division slightly complicated: scalar multiplication defined rational numbers: (3/8) * 2 = (3/4) (result always new rhythmInterval). However, note rhythmInterval multiplied another rhythmInterval---afterall, quarter-note times quarter-note ? rhythmInterval can divided another rhythmInterval produce real number: (1/2) / (1/4) = 2. Like rational values R can also either ``true'' (rational) division (using / operator) Euclidean division (using %% operator). Rational division (/) `rhythmInterval` another `rhythmInterval` results rational number. instance, $(1/2) / (1/4) = 2$. Rational division `rhythmInterval` rational number results new `rhythmInterval`: $(1/2) / 2 = (1/4)$. Eucliean (.k.., integer) division can applied `rhythmInterval`s resulting integer quotient---remainder, `rhythmInterval`, can calculated %% operator. remainder (.k.., modulo) operator (`%%`) especially useful, instance calculating metric positions.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/rhythmInterval.html","id":"relational-operators","dir":"Reference","previous_headings":"","what":"Relational Operators","title":"Representation of rhythmic information — rhythmInterval","text":"rhythmIntervals can compared using standard relational operators---==, !=, >, >=, etc.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/rhythmOffset.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate rhythmic ","title":"Calculate rhythmic ","text":"Borrowing term music21, rhythmic \"offset\" refers duration time since starting point (usually, beginning piece). rhythmOffset takes vector numbers representing durations (maybe [rhythmInterval][rhythmInterval]s, maybe numeric values) cummulatively sums starting value. output vector durations type input output value corresponds duration time elapsed point.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/rhythmOffset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate rhythmic ","text":"","code":"rhythmOffset(durations, start = 0, bars = NULL, tatum = 1, as = as.decimal)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/rhythmOffset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate rhythmic ","text":"durations vector numeric values representing durations. start duration value (coerced class durations), offset begins. groups vector equal length durations representing grouping factor, usable [base][tapply]. !.null(groups), offsets calculated duration values within group. start argument recycle match length number groups, different start value can applied group. .null(groups), offsets calculated whole durations vector, first start value.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/romanNumerals.html","id":null,"dir":"Reference","previous_headings":"","what":"Roman Numeral — romanNumerals","title":"Roman Numeral — romanNumerals","text":"Roman numerals can calculated diatonicSets (keys) tertian sets (chords). later case standard meaning \"roman numeral.\" However, former case used well, instance represent modulation schemes analyses classical music. instance, modulate -V, vi/V. importantly, many \"roman numerals\" harmonic analyses implicitely combine tertian diatonic roman numerals: \"applied\" roman numerals. Given roman numeral like \"V65/V\", \"V65\" represents chord \"/V\" represents key.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/spinePipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Collapse spines into new fields — spinePipe","title":"Collapse spines into new fields — spinePipe","text":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/spinePipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Collapse spines into new fields — spinePipe","text":"","code":"spinePipe(humdrumR, targetSpines, destinationSpines)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/spines.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize humdrum corpus spine paths. — spines","title":"Summarize humdrum corpus spine paths. — spines","text":"function provides summary spines spine paths pieces humdrumR corpus.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/spines.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize humdrum corpus spine paths. — spines","text":"","code":"spines(humdrumR)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/struct.html","id":null,"dir":"Reference","previous_headings":"","what":"struct — struct","title":"struct — struct","text":"Virtual class help create atomic-vector-like composite data objects.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/struct.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"struct — struct","text":"","code":"is.struct(x)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/struct.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"struct — struct","text":"humdrumR defines number S4 classes , underneath surface, composite data types made collections base-R atomic vectors, stuck together. \"vectorized\" nature R's atomic types one R's key strengths, humdrumR try ) mostly use standard atomic types B) make new types define act much like atomic vectors possible. struct virtual S4 class serves purpose: creating composite atomic vectors act (mostly) like base-R atomic vectors. \"virtual class\" structs really exist independent objects, struct class defines (abstractly) necessarry methods treat collection atomic vectors single vector/matrix-like object---simply make new subclass inherit struct taken care . (, specify contains = \"struct\" call setClass.) Important humdrumR classes inherit struct include: tonalInterval diatonicSet tertianSet rhythmInterval warned, R's S4 object-system limited regard: really define S4 classes act fully like R atomics, many features hard-coded R replicated. important limitation struct may encounter , though struct classes work (ok) data.frames, data.tables tibbles either work give strange behaviors put structs .","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/struct.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"struct — struct","text":"dim Either NULL non-negative integer-vector length == 2L, representing number rows columns respectively. Dimensions can zero. rownames Either NULL integer/character-vector length either ) dim == NULL, length struct B) dim != NULL, number rows struct. colnames Either NULL (must NULL dim == NULL) integer/character-vector length equal number columns struct.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/struct.html","id":"behavior","dir":"Reference","previous_headings":"","what":"Behavior","title":"struct — struct","text":"struct subclasses (.e., classes inherit struct) behave similarly normal R atomic vectors/matrices. However, differ respects, mostly ways intended avoid quirky behaviors R matrices: general, distinction dimensionless vectors dimensioned vectors (matrices) slightly weaker structs normal R atomic vectors/matrices. importantly, dimensioned structs drop dimensions various common operations (c, [], etc.), way base-R matrices . general, easier interact multi-column (matrix-)struct way dimensionless (vector-)struct. example, struct dimensions length(struct) == nrow(struct), instead length(matrix) == nrow(matrix) * ncol(matrix)---.e., \"height\" struct (number rows) length. Another big difference behaviors c: c always cause structs lose dimensions c can used concatinated multi-column structs, even mixes dimensionless dimensioned structs: struct arguments c dimensions, structs concatinated via call rbind, dimensionless vectors coerced 1-column matrices. course, (resulting) number columns must error occur! differences: structs can either dimensions (dim(struct) == NULL) two dimensions. Higher dimensional structs supported (yet). rowSums colSums coerce dimensionless struct column matrix. structs always throw error try index index value greater length/nrow struct. different atomic vectors, pad vector length index give---sometimes useful quirky behavior. structs two dimensions cartesian indexing argument. cartesian = TRUE, j arguments treated cartesian coordinates. (behavior can achieved base R matrices (structs) inputing matrix two columns.)","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/struct.html","id":"requirements","dir":"Reference","previous_headings":"","what":"Requirements","title":"struct — struct","text":"work, struct makes assumptions class. class must one slots vectors, length. struct's indexing method cause vectors indexed one. define new subclass struct, inherit validObject method assures elements dimension. Thus, writing validObject method (using setValidity) just worry specifically validity information slots, slots length.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/struct.html","id":"initialize","dir":"Reference","previous_headings":"","what":"Initialize","title":"struct — struct","text":"initialize method automatically makes slots length predefined structs. want make specialized initialize method, can still take advantage inherited method using callNextMethod beginning method.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/struct.html","id":"predefined-methods","dir":"Reference","previous_headings":"","what":"Predefined methods","title":"struct — struct","text":"main purpose struct virtual class defines many basic methods need manipulate subclass objects. importantly, indexing methods fully defined (mimic base-R atomic vector/matrix indexing), well basic \"structural\" methods like (col/row)names, dim, length, ncol, nrow, etc. addition: define > >=, < <= automatically defined. define .character subclass, show format methods automatically defined. , default arithmetic methods addition, subtraction, (scalar-integer) multiplication, negation (-x) defined. default addition behavior numeric (base::integer base::numeric) slot subclasses added together. Thus, struct1 + struct2 extract numeric/integer slot struct, add together create new struct result. -struct negate numeric fields, subtraction simply defined adding negation. Since scalar multiplication defined, two structs multiplied, struct can multiplied integer (numeric fields multiplied integer(s)). definitions work subclass, need create , specific, method!","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/struct.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"struct — struct","text":"","code":"setClass('mynewsubclass', contains = 'struct', slots = c(X= 'numeric', Y = 'numeric'))  test <- new('mynewsubclass', X = 1:10, Y = 10:1)  # all of these should work: test[1:5] #> mynewsubclass[ , ] #> [1] 1,10 2,9  3,8  4,7  5,6  rev(test)  == test #>  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE cbind(test, test) #> mynewsubclass #>       [,1] [,2] #>  [1,] 1,10 1,10 #>  [2,] 2,9  2,9  #>  [3,] 3,8  3,8  #>  [4,] 4,7  4,7  #>  [5,] 5,6  5,6  #>  [6,] 6,5  6,5  #>  [7,] 7,4  7,4  #>  [8,] 8,3  8,3  #>  [9,] 9,2  9,2  #> [10,] 10,1 10,1 c(test, test) #> mynewsubclass[ , ] #>  [1] 1,10 2,9  3,8  4,7  5,6  6,5  7,4  8,3  9,2  10,1 1,10 2,9  3,8  4,7  5,6  #> [16] 6,5  7,4  8,3  9,2  10,1 test * 3 #> mynewsubclass[ , ] #>  [1] 3,30  6,27  9,24  12,21 15,18 18,15 21,12 24,9  27,6  30,3  test - test #> mynewsubclass[ , ] #>  [1] 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tertianRepresentations.html","id":null,"dir":"Reference","previous_headings":"","what":"Tertian set representations — tertianRepresentations","title":"Tertian set representations — tertianRepresentations","text":"Tertian sets can read/wrote various ways.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tertianSet.html","id":null,"dir":"Reference","previous_headings":"","what":"Tertian set — tertianSet","title":"Tertian set — tertianSet","text":"tertianSet one humdrumR's types tonal data, representing Western tertian harmonies. tertianSet subclass diatonicSet (thence, struct).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tertianSet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tertian set — tertianSet","text":"","code":"tertianSet(...)  tset(   root = 0L,   signature = 0L,   alterations = 0L,   cardinality = 3L,   extension = NULL,   inversion = 0L )  is.tertianSet(x)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tertianSet.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tertian set — tertianSet","text":"structural addition, compared diatonicSet, Extensions slot. slot indicates tertian chord members active chord. seven possible chord members: root, third, fifth, seventh, ninth, eleventh, thirteenth. Every possible combination seven degrees represented single integer, corresponding 7-bit representation /offs seven degrees reverse order (13, 11, 9, 7, 5, 3, 1). example, integer 15 corresponds seventh chord: binary, 15 0001111. initial three zeros indicate 13th, 11th, 9th part harmony, four ones indicate root, third, fifth, seventh part harmony. Ultimately, adding removing chord degree harmony can achieved adding power two associated degree: Root: \\(\\pm 1\\) Third: \\(\\pm 2\\) Fifth: \\(\\pm 4\\) Seventh: \\(\\pm 8\\) Ninth: \\(\\pm 16\\) Eleventh: \\(\\pm 32\\) Thirteenth: \\(\\pm 64\\) tertianSet many specific methods defined reading/writing harmonic information.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/time.html","id":null,"dir":"Reference","previous_headings":"","what":"Time transformations — time","title":"Time transformations — time","text":"Time transformations","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/time.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Time transformations — time","text":"","code":"bpm2ms(bpm)  ms2bpm(ms)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalInterval.html","id":null,"dir":"Reference","previous_headings":"","what":"Representation of tonal pitch information — tonalInterval","title":"Representation of tonal pitch information — tonalInterval","text":"tonalInterval core tonal pitch representation humdrumR. tonalInterval abstract representation tonal pitch, can translated /standard \"concrete\" pitch representations: solfege, scientific pitch, semitones, frequencies, scale degrees, intervals, etc. part, users need interact tonalIntervals directly---rather, tonalIntervals work behind scene numerous humdrumR pitch functions. See pitchRepresentations tonalTransformations documentation details usage functionality Tonality humdrumR vignette detailed explanation theory specifics tonalIntervals.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalInterval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Representation of tonal pitch information — tonalInterval","text":"","code":"tonalInterval(...)  tint(   octave,   LO5th = 0L,   cent = numeric(length(octave)),   partition = FALSE,   Key = NULL,   roundContour = floor )  is.tonalInterval(x)  tonalInterval(...)  # S3 method for tonalInterval tonalInterval(x, ...)  # S3 method for logical tonalInterval(x, ...)  # S3 method for `NULL` tonalInterval(x, ...)  # S3 method for numeric tonalInterval(   x,   tonalHarmonic = 3,   centMargin = 10,   accidental.melodic = FALSE,   ... )  # S3 method for rational tonalInterval(x, tonalHarmonic = 3, accidental.melodic = FALSE, ...)  # S3 method for fraction tonalInterval(x, tonalHarmonic = 3)  # S3 method for integer tonalInterval(n, accidental.melodic = FALSE, ...)  # S3 method for character tonalInterval(str, Exclusive = NULL, ..., multiDispatch = FALSE)  # S3 method for rhythmInterval rhythmInterval(x, ...)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalInterval.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Representation of tonal pitch information — tonalInterval","text":"tonalInterval S4 subclass humdrumR's virtual class struct, inherits lot useful \"vector-like\" behaviors/functionality. constructor function tint can used create tonalIntervals directly. three arguments corespond three slots: octave, LO5th (Fifth), cent. inputs coerced match length. , octave argument can left blank, case appropriate octave automatically computed place interval octave middle-C. default, .character method, thus (via struct) show method, tonalIntervals call kern(). Thus, return tonalInterval command line (call print one one) see kern pitch representation printed.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalInterval.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Representation of tonal pitch information — tonalInterval","text":"Octave integers representing octave offset. Fifth integers representing \"line--fifths\" value. Cent numeric values representing cents (1200th octave).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalInterval.html","id":"arithmetic","dir":"Reference","previous_headings":"","what":"Arithmetic","title":"Representation of tonal pitch information — tonalInterval","text":"Technically, tonalIntervals examples algebraic modules integers. means certain arithmetic operations defined tonalIntervals can called using standard arithmetic operators (+, -, etc.): Addition: tonalIntervals can added together, acting exactly expect (.e., \\(M3 + m3 = P5\\)). Subtraction: tonalIntervals can subtracted just added. Also, can negated single - operator (like -M3). Multiplication: tonalIntervals can multiplied together. However, scalar (integer) multiplication defined: thus, tonalIntervals can multiplied integers create new tonalIntervals: e.g., \\(M2 * 3L = A4\\). Division: natural inverse scale multiplication, Euclidean division defined tonalIntervals---.e., division /whole (integer) pieces, often leftover \"remainders\" (modulo). R, Euclidean division achieved %/% operator---/---, associated %% used remainder/modulo. Two tonalIntervals can divided produced integer; Conversely, tonalInterval can divided integer produce tonalInterval. Take note way humdrumR defines Euclidean division based tonal space---.e., line--fifths---frequency atonal-semitone space. example, augmented-fourth divided major-second 3L, diminished-fifth divided major-second 3L---d5 %/% M2 equals -3L remainder P8 (plus octave)! division algorithm works applying standard Euclidean division @Fifth slot (line--fifths tonal space), shifting @Octave value remainder match appropriate octave. definition useful properties specificinterval %% A1 = genericinterval interval %% d2 = enharmonicinterval. Since basic data types can parsed tonalInterval (see ), humdrumR attempt automatically coerce data tonalIntervals asked perform arithmetic. means arithmetic can applied one two arguments tonalInterval coercable atomic. instance, M3 + 2L interpret 2L two semitones add major-second major-third! clever dispatch system even ignore character strings recognized (see examples)! useful combined \"Predifined Intervals\" (like M3), described .","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalInterval.html","id":"relational-operators","dir":"Reference","previous_headings":"","what":"Relational Operators","title":"Representation of tonal pitch information — tonalInterval","text":"tonalIntervals can compared using standard relational operations---==, !=, >, >=, etc. Two tonalIntervals equal (according ==) slots (Octave, Fifth, Cent) exactly identical. Thus, enharmonic notes (like C# Db) equal. contrast, ordinal comparisons (e.g., >, <=) tonalIntervals based semitone (equal temperament) size, enharmonicity irrelevant. Thus, m3 >= A2 A2 >= m3 TRUE, even though m3 == A2 .","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalInterval.html","id":"predefined-intervals-","dir":"Reference","previous_headings":"","what":"Predefined Intervals:","title":"Representation of tonal pitch information — tonalInterval","text":"humdrumR automatically exports bunch tonalIntervals, named musical interval representation. Every generic interval 1 15 combined every interval quality dd (doubly diminished), d (diminished), m (minor), M (major), (augumented) AA (doubly augmented). Thus, loading humdrumR, can type things like M3 + M3 get A5. addition, variables unison (= P1 = tint(0, 0)),  pythagorean.comma (= d2 = tint(-19,12)), octave (tint(1, 0)) exported well.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalInterval.html","id":"parsing","dir":"Reference","previous_headings":"","what":"Parsing","title":"Representation of tonal pitch information — tonalInterval","text":"humdrumR includes easy--use powerful system parsing pitch information tonalInterval representation. Basic methods defined numeric values representing atonal pitch information: integer values interpreted semitones. Watch ! R, need append L number make explicit integer: example, tonalInterval(3L). numeric/decimal() rational() values interpreted frequency ratios, assuming Pythagorean tuning. example, value 2.0 interpreted octave (two one ratio.) However, useful tool humdrum data parsing pitch representations encoded character tokens. humdrumR regex/exclusive parsing system used interpret character strings tonalIntervals. includes character tokens pitch information embedded alongside information, like \"4.ee kern token. six regex-patterns tonalInterval known parse automatically: call tonalInterval (function uses tonalInterval parser) character string, regex-system automatically (attempt) interpret tokens pitch types ---conflict representations favored order presented table . matching exclusive interpretation (see table ) provided using Exclusive argument, choice overrides regex-dispatch. match, NA tonalInterval returned.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalInterval.html","id":"parsing-with-options","dir":"Reference","previous_headings":"","what":"Parsing with Options","title":"Representation of tonal pitch information — tonalInterval","text":"six tonal representations listed function common parsing interface.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalInterval.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Representation of tonal pitch information — tonalInterval","text":"","code":"M3 <- tint(   , 4L)  M2 <- tint(   , 2L) M9 <- tint(-1L, 2L)  M9 - M2  #> tonalInterval[ , ] #> [1] ccc # = octave M9 - 2L #> tonalInterval[ , ] #> [1] ccc # = octave  M3 %/% M2  #> [1] 2 # = 2  ###  cMajor <- sort(tint( , -1:5)) eMajor <- cMajor + M3 eMajor + 2L  #> tonalInterval[ , ] #> [1] f#  g#  a#  b   cc# dd# ee# # f# g# a# b cc# dd# ee#  eMajor[4:5] - octave  #> tonalInterval[ , ] #> [1] A B # = A B  \"4.ee\" + P5  #> [1] \"4.bb\" # = \"4.bb\""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalTransformations.html","id":null,"dir":"Reference","previous_headings":"","what":"Invert or transpose tonal intervals. — tonalTransformations","title":"Invert or transpose tonal intervals. — tonalTransformations","text":"Invert transpose tonal intervals.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalTransformations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Invert or transpose tonal intervals. — tonalTransformations","text":"","code":"invert(tint, around, Key, ...)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/transpose.html","id":null,"dir":"Reference","previous_headings":"","what":"Transpose pitches and keys — transpose","title":"Transpose pitches and keys — transpose","text":"function transposes pitches keys various intervals target keys. Inside box, inputs transpositions take place tonalIntervals diatonicSets, numeric character string representation pitches can transposed well. function incorporated directly tonalTransform, thence, pitch translation functions, probably call directly often.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/transpose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transpose pitches and keys — transpose","text":"","code":"transpose(x, by, Key, to, real, relative, ...)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/transpose.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transpose pitches and keys — transpose","text":"x input pitch(es) transpose. tonalInterval something intepretable tonalInterval. tonalInterval something intepretable tonalInterval. input x transposed interval. Key diatonicSet something intepretable diatonicSet. tonal /transpositions, \"\" key. value NULL, defaults C major. diatonicSet something intepretable diatonicSet. input x transposed key. real logical. TRUE (default), transposition real. FALSE, transposition tonal. relative logical. TRUE transposition relative. FALSE (default), transposition parallel.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/transpose.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Transpose pitches and keys — transpose","text":"two distinct types transposition (real tonal). also two different approaches specifying transpositions: \"\" \"\". \"\" transpositions can also either parallel relative.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/transpose.html","id":"types-of-transposition","dir":"Reference","previous_headings":"","what":"Types of Transposition","title":"Transpose pitches and keys — transpose","text":"two different types transposition: real transposition tonal transposition. real transposition, inputs transposed specific interval. example, pitches {C D E F G} transposed major second {C D E F# G}. tonal transposition, inputs transposed generic intervals, within key. example, sequence {C D E F G}, key C major, translated generic second {D E F G }. choose real tonal transposition, use real argument: real = TRUE real transposition, real = FALSE tonal transposition.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/transpose.html","id":"alterations","dir":"Reference","previous_headings":"","what":"Alterations","title":"Transpose pitches and keys — transpose","text":"Tonal transposition complicated presence alterations input pitches. instance, given pitches {C F# G D# E}`` key C major, tonally transposed second, within C major? one obvious, correct answer answer, can easily identified. algorithm implemented humdrumR` follows: Alterations/accidentals input identified. (case, F# D#). generic pitches transposed within key, resulting {D G E F}. Alterations input added output unless resulting pitches interpreted comma call tintPartion, given enharmonic wrap value (default 12). example, adding first accidental results {G#} comma. However, second accidental results {E#} comma away natural {F}. Thus, accidental added output, resulting {E}, {E#}. resulting output {D G# E F}. size enharmonicWrap effectively determines extreme accidentals allowed. default value, 12, assures output notes enharmonically equivalent notes key. illustrate, sequence {C F# G D# E, B- - G C# D, B D- C} transposed tonally within C major seven possible generic intervals, enharmonicWrap = 12:","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/transpose.html","id":"specifying-transpositions","dir":"Reference","previous_headings":"","what":"Specifying Transpositions","title":"Transpose pitches and keys — transpose","text":"two approaches specifying transpositions, arguments. argument must interval, input translated interval. interval specific real = FALSE, input treated generic interval, tranposition takes place within key indicated Key argument. argument translates input desired key. example, input key E major want transposed G major, say = '*E:'. real = TRUE, input simply translated root key, exact intervals. real = FALSE, input translated root new key, intervals changed match new key well. either case, result depends input's key , indicated standard Key argument. Key arguments like \"\" key. Key = NULL, input key interpreted C major. Consider input notes {D B C # B, D C# D E D} key G major. specify = e:, real = TRUE, output {B G# F## G#, B # B C# B}. (Notice even though key minor, output still clearly E major). specify = e:, real = FALSE, output instead {B G F# G, B # B C B}. Building previous example, consider input key matters well. use input notes ({D B C # B, D C# D E D}) input Key C major, : specify = e:, real = TRUE, output {F# D# E C## D#, F# E# F# G# F#}. specify = e:, real = FALSE, output instead {F# D E C# D, F# E F# G F#}. specified, transposition applied first, followed transposition. real = FALSE, transposition happens within key, Key key.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/transpose.html","id":"relative-vs-parallel","dir":"Reference","previous_headings":"","what":"Relative vs Parallel","title":"Transpose pitches and keys — transpose","text":"transposing , diferent approaches determining relationship \"\" key (Key argument) \"\" key (argument). think \"parallel\" relationships keys, match roots keys regardless modes. instance, C major C minor parallel keys. instead think \"relative\" relationships keys, match modes keys, roots. instance, C major minor relative keys. similar distinction \"la-based minor\" solfege (relative) vs \"fixed-\" solfege (parallel). transposing using argument, relative = FALSE input key (Key argument) transposed match root argument. example, input key G minor `` key C major, output transposed G minor. However, relative = TRUEthe input key transposed match mode thetokey: G minor input C majortowould translated minor, parallel minor thetokey. theKey(key) andto` (key) arguments mode, parallel relative transpositions .","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/transpose.html","id":"special-operators-","dir":"Reference","previous_headings":"","what":"Special Operators +-","title":"Transpose pitches and keys — transpose","text":"note, real transposition interval can achieved concisely using + - operators, long least one side operators actual tonalInterval object. humdrumR preassigns common tonalIntervals objects global environment. Thus, can type commands like \"c#\" + M2 get d#, c(\"C4\", \"E4\", \"C5\") - m6 get \"E3\" \"G#3\" \"E4\".","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/withinHumdrum.html","id":null,"dir":"Reference","previous_headings":"","what":"with(in)Humdrum — withinHumdrum","title":"with(in)Humdrum — withinHumdrum","text":"Apply arbitrary expressions fields within [S4class][humdrumRclass] data.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/withinHumdrum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"with(in)Humdrum — withinHumdrum","text":"","code":"withinHumdrum(humdrumR, ...)  withHumdrum(humdrumR, ..., drop = TRUE)  inHumdrum(humdrumR, ...)  humApply(humdrumR, FUN, ..., within = TRUE, doplot = FALSE)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/withinHumdrum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"with(in)Humdrum — withinHumdrum","text":"humdrumR humdrumRclass data object. ... arguments can fed [humdrumR:--Humdrum][()Humdrum] formulae (except expressions, replaced FUN argument!). However, rather writinging formula format Keyword ~ Expression, humApply arguments written normal R arguments: Keyword = Expression. Unnamed arguments ignored. #' @param within logical. TRUE (default), [humdrumR:--Humdrum][withinHumdrum] used apply function---meaning output reconstituted new field humdrumR object. within == FALSE, [humdrumR:--Humdrum][withHumdrum] used instead, results function's output returned inprocessed. drop argument concetually similar drop argument R matrices data.frames. drop = TRUE, output withHumdrum simplified much possible (trying return \"raw\" vector, list, table, etc. within ). drop = FALSE, result always data.table. default value (drop = TRUE) usually want intuitive, complex code, can helpful set drop = FALSE output consistent. FUN function apply humdrumR:humdrumRfield(s) thehumdrumR` object. doplot Boolean. TRUE FUN argument treated doplot expression [humdrumR:--Humdrum][()Humdrum], result ignored (plotting side-effects purposes).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/withinHumdrum.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"with(in)Humdrum — withinHumdrum","text":"withinHumdrum inHumdrum, new humdrumR data object. withHumdrum, whatever value returned expression.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/withinHumdrum.html","id":"overview","dir":"Reference","previous_headings":"","what":"Overview","title":"with(in)Humdrum — withinHumdrum","text":"functions primary means working humdrumR data. (analogous base functions [base][] [base][within] applied [base:data.frame][data.frames].) Specifically allow evaluate arbitrary expressions involving fields humdrumR data object. also includes number special evaluation options: Evaluate expression matching parts data. Evaluate expression separately subsets data. Evaluate expression across windows data (e.g., ngrams, rolling windows). Evaluate expression produces plot, particular plotting parameters set using [graphics][par]. difference withHumdrum withinHumdrum analogous difference [base][] [base][within]. withHumdrum evaluates expression(s) simply returns result evaluation. withinHumdrum evaluates expression(s) (attempts) insert results back humdrumR object, generating new fields called PipeX (see details). inHumdrum simply short hand withinHumdrum.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/withinHumdrum.html","id":"formulae","dir":"Reference","previous_headings":"","what":"Formulae","title":"with(in)Humdrum — withinHumdrum","text":"Every formula formulae argument treated Keyword ~ Expression(s) pairing. Multiple expressions can input using multiple ~ operators: Keyword ~ Expression1 [~ Expression2 ~ ... ~ ExpressionN] (leftmost expression treated keyword.) leftmost expression (.e., ~ Expression), Keyword defaults \".\" keyword expression must single, simple name/symbol, following standard R rules (.e., \".foobar\" acceptable \"3 + foobar\" ). Legal keywords, meanings : expression evaluated within humdrumR data object (see \"Expression evaluation\"). doplot expression evaluated within humdrumR data object ignoring result expression (see \"Expression evaluation\" \"Plotting\". expression used break data groups, expression(s) evaluated separately group (see \"Partitioning\"). expression indicating subset data evaluate expression (see \"Partitioning\"). ngrams positive number n. expression evaluated across overlapping length-n windows. recordtypes string vector characters drawn c(\"D\", \"d\", \"\", \"L\", \"M\",\"G\"). characters correspond types humdrum records: Data, null data, Interpretations, Measures, Local comments, Global comments respectively. expression evaluated data drawn specified record types (defaults \"D\"). pre expression evaluate evaluating expression(s). Useful, instance, taking logs opening graphing window. pre expression evaluated global environment. post expression evaluate evaluating expression(s). Always evaluated global environment.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/withinHumdrum.html","id":"expression-evaluation","dir":"Reference","previous_headings":"","what":"Expression evaluation","title":"with(in)Humdrum — withinHumdrum","text":"right-hand side formula formulae argument keyword doplot (keyword specified) evaluated within humdrumR data object. expression can, thus, refer field humdrumR object (Record, Token, File, etc.). can also include . anywhere expression, interpreted humdrumR object's current [dest=humdrumR][Active] expression. multiple expressions provided, evaluated one time, result piped next. , non-, formulae (like ~ ngrams~) reused expression evaluated.","code":"humdata <- readHumdrum('directorywithdata/*.krn') # read some data  withinHumdrum(humdata, ~getPitch(Token)) # The most basic pattern withinHumdrum(humdata, ~getPitch(.)) # Same as previous (unless `Active` field has been changed))  withinHumdrum(humdata, ~solfa(getPitch(Token), key = Key))  # Assumes that the Key field was parsed during the call to `[readHumdrum][readHumdrum]`  withinHumdrum(humdata, ~getSemits(Token) - mean(getSemits(Token)))"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/withinHumdrum.html","id":"partitioning","dir":"Reference","previous_headings":"","what":"Partitioning","title":"with(in)Humdrum — withinHumdrum","text":"expression used break data subsets, expression(s) evaluated separately within subset. works similarly argument [data.table][data.table]s, INDEX argument [base][tapply], INDICES argument [base][]. expression must evaluate, within humdrumR data object, vector (list vectors equal length) categories group data . commonly, expression(s) simply field(s) data: instance, apply function [base][table] Token field separately file humdrumR data. However, can also use complex expressions like evaluate expression two groups, one either spine number three less record number even, another group opposite true. expression evaluates list grouping vectors, expressions evaulated across every combination categories vectors. Thus, withinHumdrum(humdata, ~ table(Token), ~ list(File, Spine)) apply table Token across spine file. syntactic sugar, expression two parts, parts except (leftmost) keyword part combined list (.e., ~ File ~ Spine becomes ~ list(File, Spine)}. Thus previous example can also written: withinHumdrum(humdata, ~ table(Token), ~ File ~ Spine) expression used identify subset data evaluate expression(s) subset. expressions must evaluated, within humdrumR data object, single logical vector. expression(s) evaluated logical vector TRUE. Wherever expression evaluates FALSE, original humdrumR data kept unchanged. multiple partitioning formulae (.e, ) expressions evaluated recursively, order left right. Thus specify withinHumdrum(humdata, ~ sd(semits), ~ File, ~ semits > mean(semits)) standard deviation semits field calculated file, semits field greater mean semits value within file. Contrast call: withinHumdrum(humdata, ~ sd(semits) ~ semits > mean(semits), ~ File) wherein standard deviation semits , , calculated file, time wherever semits field greater mean value across data.","code":"withinHumdrum(humdata,          do ~ table(Token),          by ~ File) withinHumdrum(humdata,          do ~ table(Token),           by ~ Spine > 3 | Record \\%\\% 2 == 0)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/withinHumdrum.html","id":"plotting","dir":"Reference","previous_headings":"","what":"Plotting","title":"with(in)Humdrum — withinHumdrum","text":"doplot keyword behaves exactly like keyword, except result evaluation ignored. useful plotting well side-effects (like writing file). doplot used withHumdrum, function simply returns NULL (executing doplot expression doplot used withinHumdrum (inHumdrum), function simply returns unaltered humdrumR argument. withinHumdrum also allows specify plotting options line, without make separate call [graphics][par]. [graphics][par] argument can specified Keyword ~ Expression pair formulae argument. instance, call doplot expression expression creates four groups, R create four plots---see last one! Normally, need call par(mfcol = c(2,2)) calling plotting function. However, withinHumdrum can soecific mfcol = c(2,2) right formulae formula: withinHumdrum(humdata, doplot ~ fooplot(.), ~ list(Two, byTwo), mfcol ~ c(2, 2)) best part withinHumdrum reset par previous state withinHumdrum done.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/withinHumdrum.html","id":"tandem-interpretations","dir":"Reference","previous_headings":"","what":"Tandem interpretations","title":"with(in)Humdrum — withinHumdrum","text":"function [readHumdrum][readHumdrum] automatically parses tandem interpretations (recognizes) fields resulting [humdrumR][humdrumRclass] data. instance, data '*clefF4' show Clef field. However, users might read humdrum data custom tandem interpretations built humdrumR. humdrumR includes function [getTandem][getTandem] help us extract arbitrary tandem intrpretation data. Luckily, withinHumdrum knows syntactic sugar makes easy anywhere expressions, simply putting named object beginning symbol *. course, R normally allow names begin symbols like *, can force placing grave symbols around name *name. withinHumdrum expression, withinHumdrum treat name regular expression substitute call getTandem(Tandem, 'regular expression') expression. means can something like withinHumdrum(humdata, ~ myFunction(Token, *mytandempattern)) myFunction called first argument Token field, second argument tandem interpretations match 'mytandempattern' (extracted Tandem field).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/withinHumdrum.html","id":"splatting","dir":"Reference","previous_headings":"","what":"Splatting","title":"with(in)Humdrum — withinHumdrum","text":"(\"Splatting\" refers feeding function list/vector arguments.) Sometimes want divide data pieces (l\\'partition option), rather applying expression piece, want feed separate pieces separate arguments function. withinHumdrum can use syntactic sugar just , using @ symbol format myFunction(TargetExpr@GroupingExpr). make call withinHumdrum(humdata, ~ myFunction(Token@Spine)) four spines withinHumdrum intepret expression: withinHumdrum(humData, ~ myFunction(TokenSpine == 1, # first argument Spine == 1 TokenSpine == 2, # second argument Spine == 2 TokenSpine == 3, # etc. TokenSpine == 4))","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/withinHumdrum.html","id":"argument-interpolation","dir":"Reference","previous_headings":"","what":"Argument interpolation","title":"with(in)Humdrum — withinHumdrum","text":"named arguments withinHumdrum [humdrumR:interpolateArguments][interpolated] expressions. useful already created list formulas like, like make small changes function call within expressions, without starting scratch. Examples:","code":"mycommand <- c(do ~ mean(., na.rm = TRUE), by ~ Spine ~ File) withinHumdrum(humdata,               mycommand,               na.rm = FALSE) # mycommand is executed with na.rm changed to FALSE"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/withinHumdrum.html","id":"piping","dir":"Reference","previous_headings":"","what":"Piping","title":"with(in)Humdrum — withinHumdrum","text":"calls withinHumdrum, result expression insterted back [humtable][humdrum table]. results put new field(s) labeled Pipe1, PipeX, ..., PipeN. results expression shorter rows humtable, object, humdrum table shrunk fit .","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/withinHumdrum.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"with(in)Humdrum — withinHumdrum","text":"","code":"humdata <- readHumdrum('directorywithdata/*.krn') #> Finding and reading files... #> \tREpath-pattern 'directorywithdata/*.krn' matches 0 text files in 0 directories. #> Zero files read from disk.  #> No files to validate.  withinHumdrum(humdata, ~nchar(.)) # counts characters in each data token. #> Warning: `call_stack()` is deprecated as of rlang 0.3.0. #> This warning is displayed once per session. #> Warning: `global_frame()` is deprecated as of rlang 0.3.0. #> This warning is displayed once per session. #> HumdrumR error in call stack: #> \t  NULL #> \t    (function (..., crayon_enabled, crayon_colors, pkgdown_internet) { options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, pkgdown.internet = pkgdown_internet) pkgdown::build_site(...) })(pkg = base::quote(structure(list(package = \"humdrumR\", version = \"0.3.0.9000\", lang = \"en\", src_path = structure(\"/home/nat/Bridge/Coding/R/Packages/humdrumR\", class = c(\"fs_path\", \"character\")), dst_path = structure(\"/home/nat/Bridge/Coding/R/Packages/humdrumR/docs\", class = c(\"fs_path\", \"character\")), install_metadata = FALSE, desc = <environment>, meta = list(authors = list(`Nathaniel Condit-Schultz` = list( href = \"http://fathermckenzie.net/\"), `Claire Arthur` = list( href = \"https://clairearthur.com/\")), url = \"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR\", home = list(sidebar = list(structure = c(\"links\", \"license\", \"community\", \"citation\", \"authors\", \"dev\", \"toc\"))), template = list(bootstrap = 5L, bootswatch = \"flatly\"), reference = list(list(title = \"Musical Tools\", desc = \"These pages describe the classes and functions that directly represent or engage musical/music-theoretic concepts.\\n\", contents = \"intervalCalculus\"), list(subtitle = \"Pitch\", desc = \"Pitch and tonality classes and functions.\", contents = c(\"humdrumPitch\", \"pitch\", \"tonalInterval\", \"tonalTransformations\", \"LO5th\", \"diatonicSet\", \"tertianSet\", \"romanNumerals\", \"transpose\", \"chordTransformer\", \"keyTransformer\", \"pitchFunctions\")), list(subtitle = \"Rhythm\", desc = \"Rhythm and meter classes and functions.\", contents = c(\"humMeter\", \"rhythmInterval\", \"time\", \"metricPosition\", \"rhythmDecompose\", \"rhythmFunctions\", \"rhythmOffset\", \"plotRhythm\")), list(title = \"Reading and Summarizing Data\", desc = \"These tools allow you to import, validate, and abstractly summarize the content of humdrum data.\"), list(subtitle = \"Reading and Writing\", contents = c(\"humValidation\", \"readHumdrum\", \"writeHumdrum\")), list(subtite = \"Summarizing\", contents = c(\"humSummary\", \"humCensus\", \"humReference\", \"humSpines\")), list(title = \"Working with Data\", desc = \"These pages describe tools used to manipulate the musical data ensconced within humdrumR data structures.\\n\"), list(subtitle = \"Manipulating Humdrum Data\", contents = c(\"withinHumdrum\", \"humPipe\", \"filterHumdrum\", \"humWindows\", \"interpolateArguments\", \"humFormulae\")), list(subtitle = \"Manipulating Vectors\", contents = c(\"fillThru\", \"lag\")), list(subtitle = \"Regular Expressions\", desc = \"[Regular Expressions](https://en.wikipedia.org/wiki/Regular_expression) are essential tools for working with humdrum data. These functions provide functionality for working with regular expressions.\\n\", contents = c(\"RegexFind\", \"humdrumDispatch\", \"regexConstruction\", \"REparser\")), list(title = \"Data Structures\", desc = \"These are pages describe the data structures of humdrumR---which contain the musical data.\\n\", contents = c(\"humdrumRclass\", \"getFields\", \"getTandem\", \"humActive\", \"humAssignment\", \"humCoercion\", \"humColumns\", \"humMerge\", \"humInterpretations\", \"humPrint\", \"humShape\", \"humSize\", \"humTable\", \"struct\")), list(title = \"Other Functions\", desc = \"Other useful tools\"), list(subtitle = \"Numeric values\", contents = c(\"rational\", \"decimal\", \"humdrumRroot\")))), figures = structure(list( dev = \"ragg::agg_png\", dpi = 96L, dev.args = list(), fig.ext = \"png\", fig.width = 7.29166666666667, fig.height = NULL, fig.retina = 2L, fig.asp = 0.618046971569839, bg = NULL, other.parameters = list()), class = \"print_yaml\"), repo = list( url = list(home = \"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/\", source = \"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/blob/HEAD/\", issue = \"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/issues/\", user = \"https://github.com/\")), development = list( destination = \"dev\", mode = \"default\", version_label = \"muted\", in_dev = FALSE), topics = structure(list(name = c(LO5th.Rd = \"LO5th\", REparser.Rd = \"REparser\", RegexFind.Rd = \"RegexFind\", chordTransformer.Rd = \"chordTransformer\", decimal.Rd = \"decimal\", diatonicSet.Rd = \"diatonicSet\", fillThru.Rd = \"fillThru\", filterHumdrum.Rd = \"filterHumdrum\", getFields.Rd = \"getFields\", getTandem.Rd = \"getTandem\", humActive.Rd = \"humActive\", humAssignment.Rd = \"humAssignment\", humCensus.Rd = \"humCensus\", humCoercion.Rd = \"humCoercion\", humColumns.Rd = \"humColumns\", humFormulae.Rd = \"humFormulae\", humInterpretations.Rd = \"humInterpretations\", humMerge.Rd = \"humMerge\", humMeter.Rd = \"humMeter\", humPipe.Rd = \"humPipe\", humPrint.Rd = \"humPrint\", humReference.Rd = \"humReference\", humShape.Rd = \"humShape\", humSize.Rd = \"humSize\", humSpines.Rd = \"humSpines\", humSummary.Rd = \"humSummary\", humTable.Rd = \"humTable\", humValidation.Rd = \"humValidation\", humWindows.Rd = \"humWindows\", humdrumDispatch.Rd = \"humdrumDispatch\", humdrumPitch.Rd = \"humdrumPitch\", humdrumR.Rd = \"humdrumR\", humdrumRclass.Rd = \"humdrumRclass\", humdrumRroot.Rd = \"humdrumRroot\", interpolateArguments.Rd = \"interpolateArguments\", intervalCalculus.Rd = \"intervalCalculus\", keyTransformer.Rd = \"keyTransformer\", lag.Rd = \"lag\", metricPosition.Rd = \"metricPosition\", pitchFunctions.Rd = \"pitchFunctions\", plotRhythm.Rd = \"plotRhythm\", rational.Rd = \"rational\", readHumdrum.Rd = \"readHumdrum\", regexConstruction.Rd = \"regexConstruction\", rhythmDecompose.Rd = \"rhythmDecompose\", rhythmFunctions.Rd = \"rhythmFunctions\", rhythmInterval.Rd = \"rhythmInterval\", rhythmOffset.Rd = \"rhythmOffset\", romanNumerals.Rd = \"romanNumerals\", struct.Rd = \"struct\", tertianSet.Rd = \"tertianSet\", time.Rd = \"time\", tonalInterval.Rd = \"tonalInterval\", tonalTransformations.Rd = \"tonalTransformations\", transpose.Rd = \"transpose\", withinHumdrum.Rd = \"withinHumdrum\", writeHumdrum.Rd = \"writeHumdrum\"), file_in = c(\"LO5th.Rd\", \"REparser.Rd\", \"RegexFind.Rd\", \"chordTransformer.Rd\", \"decimal.Rd\", \"diatonicSet.Rd\", \"fillThru.Rd\", \"filterHumdrum.Rd\", \"getFields.Rd\", \"getTandem.Rd\", \"humActive.Rd\", \"humAssignment.Rd\", \"humCensus.Rd\", \"humCoercion.Rd\", \"humColumns.Rd\", \"humFormulae.Rd\", \"humInterpretations.Rd\", \"humMerge.Rd\", \"humMeter.Rd\", \"humPipe.Rd\", \"humPrint.Rd\", \"humReference.Rd\", \"humShape.Rd\", \"humSize.Rd\", \"humSpines.Rd\", \"humSummary.Rd\", \"humTable.Rd\", \"humValidation.Rd\", \"humWindows.Rd\", \"humdrumDispatch.Rd\", \"humdrumPitch.Rd\", \"humdrumR.Rd\", \"humdrumRclass.Rd\", \"humdrumRroot.Rd\", \"interpolateArguments.Rd\", \"intervalCalculus.Rd\", \"keyTransformer.Rd\", \"lag.Rd\", \"metricPosition.Rd\", \"pitchFunctions.Rd\", \"plotRhythm.Rd\", \"rational.Rd\", \"readHumdrum.Rd\", \"regexConstruction.Rd\", \"rhythmDecompose.Rd\", \"rhythmFunctions.Rd\", \"rhythmInterval.Rd\", \"rhythmOffset.Rd\", \"romanNumerals.Rd\", \"struct.Rd\", \"tertianSet.Rd\", \"time.Rd\", \"tonalInterval.Rd\", \"tonalTransformations.Rd\", \"transpose.Rd\", \"withinHumdrum.Rd\", \"writeHumdrum.Rd\"), file_out = c(\"LO5th.html\", \"REparser.html\", \"RegexFind.html\", \"chordTransformer.html\", \"decimal.html\", \"diatonicSet.html\", \"fillThru.html\", \"filterHumdrum.html\", \"getFields.html\", \"getTandem.html\", \"humActive.html\", \"humAssignment.html\", \"humCensus.html\", \"humCoercion.html\", \"humColumns.html\", \"humFormulae.html\", \"humInterpretations.html\", \"humMerge.html\", \"humMeter.html\", \"humPipe.html\", \"humPrint.html\", \"humReference.html\", \"humShape.html\", \"humSize.html\", \"humSpines.html\", \"humSummary.html\", \"humTable.html\", \"humValidation.html\", \"humWindows.html\", \"humdrumDispatch.html\", \"humdrumPitch.html\", \"humdrumR.html\", \"humdrumRclass.html\", \"humdrumRroot.html\", \"interpolateArguments.html\", \"intervalCalculus.html\", \"keyTransformer.html\", \"lag.html\", \"metricPosition.html\", \"pitchFunctions.html\", \"plotRhythm.html\", \"rational.html\", \"readHumdrum.html\", \"regexConstruction.html\", \"rhythmDecompose.html\", \"rhythmFunctions.html\", \"rhythmInterval.html\", \"rhythmOffset.html\", \"romanNumerals.html\", \"struct.html\", \"tertianSet.html\", \"time.html\", \"tonalInterval.html\", \"tonalTransformations.html\", \"transpose.html\", \"withinHumdrum.html\", \"writeHumdrum.html\" ), alias = list(LO5th.Rd = \"LO5th\", REparser.Rd = c(\"REparser\", \"REparse\"), RegexFind.Rd = c(\"RegexFind\", \"%~l%\", \"%~i%\", \"%~n%\", \"%~m%\", \"%~%\"), chordTransformer.Rd = c(\"chordTransformer\", \"figuredBass\"), decimal.Rd = c(\"decimal\", \"as.decimal\"), diatonicSet.Rd = c(\"diatonicSet\", \"dset\", \"as.character,diatonicSet-method\", \"is.diatonicSet\", \"order.diatonicSet\", \"==,diatonicSet,diatonicSet-method\", \"Compare,diatonicSet,diatonicSet-method\", \"diatonicSet.diatonicSet\", \"diatonicSet.logical\", \"diatonicSet.numeric\", \"diatonicSet.integer\", \"diatonicSet.character\"), fillThru.Rd = c(\"fillThru\", \"fillForward\", \"fillBackwards\"), filterHumdrum.Rd = c(\"filterHumdrum\", \"removeEmptyFiles\", \"removeEmptySpines\", \"removeEmptyRecords\", \"[,humdrumR,missing,ANY-method\", \"[,humdrumR,numeric,ANY-method\", \"[,humdrumR,character,ANY-method\", \"[,humdrumR,formula,ANY-method\", \"[[,humdrumR,numeric,missing-method\", \"[[,humdrumR,missing,numeric-method\", \"[[,humdrumR,character,missing-method\", \"[[,humdrumR,ANY,ANY-method\" ), getFields.Rd = \"getFields\", getTandem.Rd = \"getTandem\", humActive.Rd = c(\"humActive\", \"evalActive\", \"getActive\", \"setActive\", \"setActiveFields\"), humAssignment.Rd = \"humAssignment\", humCensus.Rd = c(\"humCensus\", \"census\", \"[.humCensus\", \"print.humCensus\"), humCoercion.Rd = c(\"humCoercion\", \"as.lines\", \"as.matrix.humdrumR\", \"as.matrices\", \"as.data.frames\" ), humColumns.Rd = \"humColumns\", humFormulae.Rd = c(\"humFormulae\", \"ditto\"), humInterpretations.Rd = c(\"humInterpretations\", \"interpretations\", \"print.humInterpretations\"), humMerge.Rd = c(\"humMerge\", \"mergeHumdrum\"), humMeter.Rd = \"humMeter\", humPipe.Rd = c(\"humPipe\", \"%hum>%\", \"%hum<%\", \"%humT%\", \"%s>%\", \"%hums>%\", \"%hums<%\", \"%humsT%\", \"%hums[]%\"), humPrint.Rd = c(\"humPrint\", \"print_humtab\" ), humReference.Rd = c(\"humReference\", \"reference\", \"reference.character\", \"reference.humdrumR\", \"[.humReference\", \"print.humReference\" ), humShape.Rd = c(\"humShape\", \"foldHumdrum\", \"foldStops\", \"foldPaths\", \"foldRecords\", \"spinePipe\"), humSize.Rd = c(\"humSize\", \"nrecords\", \"ntokens\", \"npieces\", \"anySubcorpora\", \"namesSubcorpora\", \"nfiles\", \"is.empty\", \"anyPaths\", \"anyStops\"), humSpines.Rd = c(\"humSpines\", \"spines\", \"[.humSpines\", \"print.humSpines\"), humSummary.Rd = \"humSummary\", humTable.Rd = c(\"humTable\", \"getHumtab\"), humValidation.Rd = c(\"humValidation\", \"validateHumdrum\"), humWindows.Rd = c(\"humWindows\", \"windows\", \"hop\", \"nest\"), humdrumDispatch.Rd = c(\"humdrumDispatch\", \"makeDispatchDF\", \"makeHumdrumDispatcher\", \"print.humdrumDispatch\" ), humdrumPitch.Rd = \"humdrumPitch\", humdrumR.Rd = \"humdrumR\", humdrumRclass.Rd = c(\"humdrumRclass\", \"makeHumdrumR\", \"humdrumRS4\", \"is.humdrumR\", \"$,humdrumR-method\", \"fields\", \"$<-,humdrumR,vector-method\", \"$<-,humdrumR,humdrumR-method\", \"[<-,humdrumR,character,ANY,vector-method\", \"[<-,humdrumR,character,ANY,humdrumR-method\", \"[[,humdrumR,missing,character-method\", \"[[,humdrumR,missing,missing-method\", \"[[,humdrumR,formula,missing-method\", \"[[,humdrumR,missing,formula-method\" ), humdrumRroot.Rd = \"humdrumRroot\", interpolateArguments.Rd = \"interpolateArguments\", intervalCalculus.Rd = c(\"intervalCalculus\", \"integrate\", \"sigma\", \"derive\", \"delta\", \"calculus\"), keyTransformer.Rd = c(\"keyTransformer\", \"key\"), lag.Rd = c(\"lag\", \"lead\"), metricPosition.Rd = \"metricPosition\", pitchFunctions.Rd = c(\"pitchFunctions\", \"semit\", \"midi\", \"pitch\", \"kern\", \"lilypond\", \"interval\", \"degree\", \"solfa\" ), plotRhythm.Rd = c(\"plotRhythm\", \"plotRhythm.default\", \"plotRhythm.rhythmInterval\"), rational.Rd = c(\"rational\", \"as.rational\", \"fraction\", \"as.fraction\"), readHumdrum.Rd = c(\"readHumdrum\", \"findHumdrum\"), regexConstruction.Rd = c(\"regexConstruction\", \"captureRE\", \"captureUniq\", \"orRE\"), rhythmDecompose.Rd = \"rhythmDecompose\", rhythmFunctions.Rd = c(\"rhythmFunctions\", \"recip\", \"duration\" ), rhythmInterval.Rd = c(\"rhythmInterval\", \"rint\", \"as.character,rhythmInterval-method\", \"as.double.rhythmInterval\", \"is.rhythmInterval\", \"is.numeric,rhythmInterval-method\", \"order.rhythmInterval\", \"Compare,rhythmInterval,rhythmInterval-method\", \"Summary,rhythmInterval-method\", \"rhythmInterval.logical\", \"rhythmInterval.NULL\", \"rhythmInterval.numeric\", \"rhythmInterval.rational\", \"rhythmInterval.fraction\", \"rhythmInterval.integer\", \"rhythmInterval.character\"), rhythmOffset.Rd = \"rhythmOffset\", romanNumerals.Rd = \"romanNumerals\", struct.Rd = c(\"struct\", \"is.struct\"), tertianSet.Rd = c(\"tertianSet\", \"tset\", \"is.tertianSet\"), time.Rd = c(\"time\", \"bpm2ms\", \"ms2bpm\" ), tonalInterval.Rd = c(\"tonalInterval\", \"tint\", \"is.tonalInterval\", \"tonalInterval.tonalInterval\", \"tonalInterval.logical\", \"tonalInterval.NULL\", \"tonalInterval.numeric\", \"tonalInterval.rational\", \"tonalInterval.fraction\", \"tonalInterval.integer\", \"tonalInterval.character\", \"rhythmInterval.rhythmInterval\"), tonalTransformations.Rd = c(\"tonalTransformations\", \"invert\"), transpose.Rd = \"transpose\", withinHumdrum.Rd = c(\"withinHumdrum\", \"withHumdrum\", \"inHumdrum\", \"humApply\"), writeHumdrum.Rd = \"writeHumdrum\"), funs = list(LO5th.Rd = \"LO5th()\", REparser.Rd = c(\"REparser()\", \"REparse()\"), RegexFind.Rd = c(\"`%~l%`\", \"`%~i%`\", \"`%~n%`\", \"`%~m%`\", \"`%~%`\"), chordTransformer.Rd = \"figuredBass()\", decimal.Rd = c(\"decimal()\", \"as.decimal()\"), diatonicSet.Rd = c(\"dset()\", \"as.character(<i>&lt;diatonicSet&gt;<\/i>)\", \"is.diatonicSet()\", \"order.diatonicSet()\", \"`==`(<i>&lt;diatonicSet&gt;<\/i>,<i>&lt;diatonicSet&gt;<\/i>)\", \"Compare(<i>&lt;diatonicSet&gt;<\/i>,<i>&lt;diatonicSet&gt;<\/i>)\", \"diatonicSet(<i>&lt;diatonicSet&gt;<\/i>)\", \"diatonicSet(<i>&lt;logical&gt;<\/i>)\", \"diatonicSet(<i>&lt;numeric&gt;<\/i>)\", \"diatonicSet(<i>&lt;integer&gt;<\/i>)\", \"diatonicSet(<i>&lt;character&gt;<\/i>)\", \"as.character(<i>&lt;tertianSet&gt;<\/i>)\", \"`==`(<i>&lt;tertianSet&gt;<\/i>,<i>&lt;tertianSet&gt;<\/i>)\" ), fillThru.Rd = c(\"fillThru()\", \"fillForward()\", \"fillBackwards()\"), filterHumdrum.Rd = c(\"filterHumdrum()\", \"removeEmptyFiles()\", \"removeEmptySpines()\", \"removeEmptyRecords()\", \"`[`\", \"`[`\", \"`[`\", \"`[`\", \"`[[`\", \"`[[`\", \"`[[`\", \"`[[`\"), getFields.Rd = \"getFields()\", getTandem.Rd = \"getTandem()\", humActive.Rd = c(\"evalActive()\", \"getActive()\", \"setActive()\", \"setActiveFields()\"), humAssignment.Rd = character(0), humCensus.Rd = c(\"census()\", \"`[`\", \"print(<i>&lt;humCensus&gt;<\/i>)\" ), humCoercion.Rd = c(\"as.vector(<i>&lt;humdrumR&gt;<\/i>)\", \"as.lines()\", \"as.matrix(<i>&lt;humdrumR&gt;<\/i>)\", \"as.data.frame(<i>&lt;humdrumR&gt;<\/i>)\", \"as.matrices()\", \"as.data.frames()\"), humColumns.Rd = character(0), humFormulae.Rd = \"ditto\", humInterpretations.Rd = c(\"interpretations()\", \"print(<i>&lt;humInterpretations&gt;<\/i>)\"), humMerge.Rd = \"mergeHumdrum()\", humMeter.Rd = character(0), humPipe.Rd = c(\"`%hum&gt;%`\", \"`%hum&lt;%`\", \"`%humT%`\", \"`%s&gt;%`\", \"`%hums&gt;%`\", \"`%hums&lt;%`\", \"`%humsT%`\", \"`%hums[]%`\"), humPrint.Rd = c(\"show(<i>&lt;humdrumR&gt;<\/i>)\", \"print_humtab()\"), humReference.Rd = c(\"reference()\", \"reference()\", \"reference()\", \"`[`(<i>&lt;humReference&gt;<\/i>)\" ), humShape.Rd = c(\"foldHumdrum()\", \"foldStops()\", \"foldPaths()\", \"foldRecords()\", \"spinePipe()\"), humSize.Rd = c(\"nrecords()\", \"ntokens()\", \"npieces()\", \"anySubcorpora()\", \"namesSubcorpora()\", \"nfiles()\", \"length(<i>&lt;humdrumR&gt;<\/i>)\", \"nrow(<i>&lt;humdrumR&gt;<\/i>)\", \"is.empty()\", \"anyPaths()\", \"anyStops()\"), humSpines.Rd = c(\"spines()\", \"`[`(<i>&lt;humSpines&gt;<\/i>)\", \"print(<i>&lt;humSpines&gt;<\/i>)\" ), humSummary.Rd = \"summary(<i>&lt;humdrumR&gt;<\/i>)\", humTable.Rd = \"getHumtab()\", humValidation.Rd = \"validateHumdrum()\", humWindows.Rd = c(\"windows()\", \"hop()\", \"nest()\"), humdrumDispatch.Rd = c(\"humdrumDispatch()\", \"makeDispatchDF()\", \"makeHumdrumDispatcher()\", \"print(<i>&lt;humdrumDispatch&gt;<\/i>)\" ), humdrumPitch.Rd = character(0), humdrumR.Rd = character(0), humdrumRclass.Rd = character(0), humdrumRroot.Rd = \"humdrumRroot\", interpolateArguments.Rd = \"interpolateArguments()\", intervalCalculus.Rd = c(\"integrate()\", \"sigma()\", \"derive()\", \"delta()\", \"calculus()\"), keyTransformer.Rd = \"key()\", lag.Rd = c(\"lag()\", \"lead()\"), metricPosition.Rd = \"metricPosition()\", pitchFunctions.Rd = c(\"semit()\", \"midi()\", \"pitch()\", \"kern()\", \"lilypond()\", \"interval()\", \"degree()\", \"solfa()\"), plotRhythm.Rd = \"plotRhythm()\", rational.Rd = c(\"rational()\", \"as.rational()\", \"fraction()\", \"as.fraction()\"), readHumdrum.Rd = c(\"findHumdrum()\", \"readHumdrum()\" ), regexConstruction.Rd = c(\"captureRE()\", \"captureUniq()\", \"orRE()\"), rhythmDecompose.Rd = \"rhythmDecompose()\", rhythmFunctions.Rd = c(\"recip()\", \"duration()\"), rhythmInterval.Rd = character(0), rhythmOffset.Rd = \"rhythmOffset()\", romanNumerals.Rd = character(0), struct.Rd = \"is.struct()\", tertianSet.Rd = c(\"tertianSet()\", \"tset()\", \"is.tertianSet()\" ), time.Rd = c(\"bpm2ms()\", \"ms2bpm()\"), tonalInterval.Rd = character(0), tonalTransformations.Rd = \"invert()\", transpose.Rd = \"transpose()\", withinHumdrum.Rd = c(\"withinHumdrum()\", \"withHumdrum()\", \"inHumdrum()\", \"humApply()\"), writeHumdrum.Rd = \"writeHumdrum()\"), title = c(LO5th.Rd = \"Line of Fifths\", REparser.Rd = \"Parse String Using Regular expressions\", RegexFind.Rd = \"Match strings against regular expression\", chordTransformer.Rd = \"Parsing and deparsing chord information.\", decimal.Rd = \"Decimal numbers\", diatonicSet.Rd = \"Tonal (diatonic) sets\", fillThru.Rd = \"Propogate data points to \\\"fill\\\" null data.\", filterHumdrum.Rd = \"Filter humdrum data\", getFields.Rd = \"-------------------------------------------&gt; NEEDS DOCUMENTATION &lt;-------------------------------------------\\nGet named\", getTandem.Rd = \"Get tandem interpretation information from humdrum data.\", humActive.Rd = \"The \\\"Active expression\\\" of a humdrumR object.\", humAssignment.Rd = \"Assigning new fields\", humCensus.Rd = \"Tabulate records and tokens in a humdrumR corpus\", humCoercion.Rd = \"humdrumR Coercion.\", humColumns.Rd = \"Spines vs Paths vs Columns\", humFormulae.Rd = \"Standard humdrumR formulae.\", humInterpretations.Rd = \"Summarize humdrum corpus interpretations.\", humMerge.Rd = \"Merge two (or more) humdrumR datasets\", humMeter.Rd = \"Tools for analyzing rhythm and meter.\", humPipe.Rd = \"Piping humdrumR data\", humPrint.Rd = \"-------------------------------------------&gt; NEEDS DOCUMENTATION &lt;-------------------------------------------\", humReference.Rd = \"Summarize reference records in a humdrumR corpus\", humShape.Rd = \"HumdrumR data \\\"Shape\\\"\", humSize.Rd = \"humdrumR size and shape\", humSpines.Rd = \"Summarize spines in humdrum dataset\", humSummary.Rd = \"Summarize humdrumR corpora\", humTable.Rd = \"Humdrum Tables\", humValidation.Rd = \"Validate humdrum files\", humWindows.Rd = \"Applying functions across arbitrary windows.\\n----------------------------------------------&gt; NEEDS DOCUMENTATION &lt;----------------------------------------------------\", humdrumDispatch.Rd = \"Regular expression method dispatch and function application\", humdrumPitch.Rd = \"humdrumR and pitch\", humdrumR.Rd = \"humdrumR\", humdrumRclass.Rd = \"HumdrumR class\", humdrumRroot.Rd = \"<code>humdrumR<\/code>'s root directory on your machine.\", interpolateArguments.Rd = \"Change or insert values in an expression\", intervalCalculus.Rd = \"Interval \\\"calculus\\\"\", keyTransformer.Rd = \"Parsing and deparsing key information\", lag.Rd = \"Shift data within a vector/matrix/data.frame\", metricPosition.Rd = \"Calculate metric positions from duration data.\", pitchFunctions.Rd = \"Manipulate pitch data\", plotRhythm.Rd = \"-------------------------------------------&gt; NEEDS DOCUMENTATION &lt;-------------------------------------------\\nPlotting rhythmic symbols in R base graphics\", rational.Rd = \"Rational numbers\", readHumdrum.Rd = \"Find and read humdrum files into R\", regexConstruction.Rd = \"Making Regular Expressions\", rhythmDecompose.Rd = \"Decompose durations in terms of other durations\", rhythmFunctions.Rd = \"Manipulate pitch data\", rhythmInterval.Rd = \"Representation of rhythmic information\", rhythmOffset.Rd = \"Calculate rhythmic \\\"offset\\\"\", romanNumerals.Rd = \"Roman Numeral\", struct.Rd = \"struct\", tertianSet.Rd = \"Tertian set\", time.Rd = \"Time transformations\", tonalInterval.Rd = \"Representation of tonal pitch information\", tonalTransformations.Rd = \"Invert or transpose tonal intervals.\", transpose.Rd = \"Transpose pitches and keys\", withinHumdrum.Rd = \"with(in)Humdrum\", writeHumdrum.Rd = \"Write <code>humdrumR<\/code> data to humdrum files.\" ), rd = list(LO5th.Rd = structure(list(structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/tonalInterval.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"LO5th\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"LO5th\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"Line of Fifths\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"LO5th(x, generic = FALSE, ...)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Returns an integer vector or array, matching the input.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_value\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The function \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"LO5th\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is a S3-generic function with methods to extract\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the \\\"line-of-fifths\\\" value from various pitch objects and representations.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"The Line of Fifths\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Every interval in Western music is associated with a integer on the line of fifths:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\" )), structure(\" Bb = m7 = -2\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" F = P4 = -1\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(), class = c(\"tag_item\", \"tag\" )), structure(\" C = P1 = 0\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" G = P5 = 1\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" D = M2 = 2\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" A = M6 = 3\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" E = M3 = 4\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" B = M7 = 5\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" F# = A4 = 6\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" etc.\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The natural notes of (C) major scale---which we also call the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"generic intervals\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\"---fall in the range \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"-1:5\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In fact, any diatonic key is a block of seven consecutive numbers of the line-of-fifths: for example, Eb major is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"-4:2\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\\"Sharps\\\" and \\\"flats\\\" represent \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"+7\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"-7\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" on the line-of-fifths respectively.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"tint()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=tint\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Other \", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"core pitch representation\", class = c(\"TEXT\", \"tag\"))), class = c(\"LIST\", \"tag\")), structure(\": \\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"tonalInterval\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"core pitch representation\", class = c(\"TEXT\", \"tag\"))), class = c(\"LIST\", \"tag\"))), class = c(\"tag_concept\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), REparser.Rd = structure(list(structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Regex.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"REparser\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"REparser\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"REparse\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"Parse String Using Regular expressions\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"REparser(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" res,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" parse.strict = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parse.exhaust = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parse.lead = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parse.rest = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" toEnv = FALSE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"REparse(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" str,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" res,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parse.strict = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parse.exhaust = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parse.lead = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parse.rest = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" reverse = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" sep = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" toEnv = FALSE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Takes an input string and parses it into a sequence of regular expressions.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"exhaustive\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is TRUE, the string must be exhaustively broken up by the matching regular expressions.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Superfluous (non-match) characters at the begginning, end, or in bettween matches, will result in\\n\", class = c(\"TEXT\", \"tag\")), structure(\"all \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"NA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" being returned.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), RegexFind.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Regex.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"RegexFind\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"RegexFind\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%~l%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%~i%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%~n%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%~m%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%~%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Match strings against regular expression\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"x %~l% pattern\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"x %~i% pattern\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"x %~n% pattern\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"x %~m% pattern\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"x %~% pattern\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"These infix functions are simply syntactic sugar for\\n\", class = c(\"TEXT\", \"tag\")), structure(\"existing \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"R\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" regular expression matching functions.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If the a vector of regexes is given as the right argument, matches to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"any\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" of the regexes are returned.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%~l%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\": Matches \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pattern\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"x\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and returns \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"logical\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". Shorthand for \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"base::grepl()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:grep\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"%~%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\": The \\\"default\\\"---same as \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%~l%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"%~i%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\": Matches \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pattern\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"x\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and returns \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" indices. Shorthand for \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"base::grep()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:grep\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"%~n%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\": Matches \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pattern\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"x\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and returns \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" counts (can be greater than one if more\\n\", class = c(\"TEXT\", \"tag\")), structure(\"than one match occurs in the same token). Shorthand for \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"stringi::stri_count_regex()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"stringi:stri_count\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"%~m%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\": Matches \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pattern\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"x\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and returns matching strings (or NA if no match). Shorthand for \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"stringi::stri_extract_first_regex()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"stringi:stri_extract\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), chordTransformer.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/tertianSet.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"chordTransformer\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"chordTransformer\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"figuredBass\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Parsing and deparsing chord information.\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"figuredBass(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" Key = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" Exclusive = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parseArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" transposeArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" figurationArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" inPlace = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" memoize = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" deparse = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"These functions are used to work with chord information.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"xxx\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Tertian sets can be read/wrote in various ways.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), decimal.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/tools.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"decimal\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"decimal\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.decimal\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Decimal numbers\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"decimal(x)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"as.decimal(x, ...)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"These functions create decimal numbers that are identical to base R\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"numeric\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (real) numbers.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, these numbers are understood by the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rational numbers\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=rational\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"rational()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=rational\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Other \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR numeric functions\", class = c(\"TEXT\", \"tag\"))), class = c(\"LIST\", \"tag\")), structure(\": \\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"rational\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"()\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"humdrumR numeric functions\", class = c(\"TEXT\", \"tag\"))), class = c(\"LIST\", \"tag\"))), class = c(\"tag_concept\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), diatonicSet.Rd = structure(list(structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/diatonicSet.R, R/tertianSet.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"diatonicSet\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"diatonicSet\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"dset\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"as.character,diatonicSet-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"is.diatonicSet\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"order.diatonicSet\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"==,diatonicSet,diatonicSet-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Compare,diatonicSet,diatonicSet-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet.diatonicSet\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet.logical\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet.numeric\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet.integer\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet.character\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Tonal (diatonic) sets\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"dset(root = 0L, signature = root, alterations = 0L)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list(structure(list(structure(\"as.character\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"diatonicSet\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(x)\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"is.diatonicSet(x)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"order.diatonicSet(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" parallel = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" na.last = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" decreasing = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" method = c(\\\"auto\\\", \\\"shell\\\", \\\"radix\\\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list( structure(list(structure(\"==\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"diatonicSet,diatonicSet\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(e1, e2)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"Compare\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"diatonicSet,diatonicSet\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(e1, e2)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"diatonicSet\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"diatonicSet\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"diatonicSet\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"logical\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"diatonicSet\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"numeric\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x)\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list( structure(list(structure(\"diatonicSet\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"integer\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x)\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list( structure(list(structure(\"diatonicSet\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"character\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(str, Exclusive = NULL, Key = NULL, ..., multiDispatch = FALSE)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"as.character\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"tertianSet\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(x)\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list( structure(list(structure(\"==\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"tertianSet,tertianSet\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(e1, e2)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is one of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"'s\\n\", class = c(\"TEXT\", \"tag\")), structure(\"types of tonal data, representing Western diatonic keys.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For the most part, users should not need to interact with diatonicSets directly---rather, diatonicSets work behind the scene in numerous \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" pitch functions.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"See the \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"keyRepresentations\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"keyTransformations\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" documentation for details of usage and functionality or the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Tonality in humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" vignette for\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a detailed explanation of the theory and specifics of diatonicSets.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://adv-r.had.co.nz/S4.html\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"S4\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\" )), structure(\" subclass of \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"'s virtual class \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(\"from which it inherits a lot of useful \\\"vector-like\\\" behaviors/functionality.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The constructor function \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"dset\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" can be used to create \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSets\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" directly.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The three arguments corespond to the three slots: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"root\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"mode\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"alteration\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"All inputs will be coerced to match in length.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"root\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument will attempt to coerce character strings to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalIntervals\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=tonalInterval\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\", and use their \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"LO5th\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" value as the root.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"By default, the \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"as.character\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:character\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" method, and thus (via \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\") the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"show\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"methods:show\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" method,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"for diatonicSets call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"key()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=diatonicRepresentations\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Thus, if you return a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" on the command line (or call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"print\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:print\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" one one),\\n\", class = c(\"TEXT\", \"tag\")), structure(\"you'll see the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"key interpretation\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=diatonicRepresentations\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" representation printed.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Slots\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(list(structure(\"Root\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"integers representing the root of the key on the line-of-fifths\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(list(structure(\"Signature\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"integers representing the signature (number of accidentals) of the key.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(list(structure(\"Alteration\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"integers representing alterations of the diatonic set\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"A key is represented by two integers, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Root\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Signature\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Root is simply the tonic note of the key on the circle of fifths.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Signature is a value on the circle of fifths, indicating the diatonic mode.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"You can think of the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Signature\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" value as indicating the number of accidentals, with negative numbers\\n\", class = c(\"TEXT\", \"tag\")), structure(\"for flats and positive numbers for sharps.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"You can also think of the signature as indicating how much the \\\"natural key\\\" (C major) is\\n\", class = c(\"TEXT\", \"tag\")), structure(\"slid up and down the line-of-fifths.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Mode_(music)\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"traditional diatonic modes\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" of Western music occur wherever \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Signature - Tonic\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is in the range \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"-5:1\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\":\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"Signature - Tonic = +1 \\\\rightarrow\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\" Lydian\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"Signature - Tonic = +0 \\\\rightarrow\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\" Major (Ionian)\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"Signature - Tonic = -1 \\\\rightarrow\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\" Mixolydian\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"Signature - Tonic = -2 \\\\rightarrow\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\" Dorian\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"Signature - Tonic = -3 \\\\rightarrow\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\" Minor (Aeolian)\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"Signature - Tonic = -5 \\\\rightarrow\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\" Locrian\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"Signature - Tonic = -4 \\\\rightarrow\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\" Phyrgian\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Note that you can make diatonicSets where the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Root\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is outside the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Key\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". This is unusual, and may result in sets you wouldn't predict.\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_describe\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Alterations\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Alteration\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" slots (also integer) can be used to represent various\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\\"altered\\\" scales.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The integer values are interpreted as a seven-trit \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Balanced_ternary\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"balanced ternary\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" string.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(\\\"trits\\\" are the ternary equivalent of binary \\\"bits.\\\")\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Balanced ternary allows for three digits, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"0\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (unaltered degree), \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"1\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (sharpened degree), and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"-1\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (flattened degree).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The seven trits correspond to the seven scale degrees on the line-of-fifth indicated by the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"signature\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\"---i.e., ordered from\\n\", class = c(\"TEXT\", \"tag\")), structure(\"lowest to hightest on the line-of-fifths, not relative to the root.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(For instance, when \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Signature == 0\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the degrees are \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"c(-1, 0, 1, 2, 3, 4, 5)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The ternary arrangement maps powers of three to each scale degree, as so that in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Alteration\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" integer:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"\\\\pm 1\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\": raise or flatten the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"7th\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" scale degree.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"\\\\pm 3\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\": raise or flatten the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"3rd\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" scale degree.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"\\\\pm 9\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\": raise or flatten the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"6th\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" scale degree.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"\\\\pm 27\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\": raise or flatten the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"2nd\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" scale degree.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"\\\\pm 81\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\": raise or flatten the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"5th\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" scale degree.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"\\\\pm 243\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\": raise or flatten the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"1st\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" scale degree.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"\\\\pm 749\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\": raise or flatten the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"4th\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" scale degree.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For example, consider \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Alteration == 26\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\":\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In a balanced ternary representation, the decimal integer 26 is represented as \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"1 0 0 1 0 -1 0\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(In other words 1 in the \\\"27s place\\\" and -1 in the \\\"ones place\\\"---i.e., 27 - 1).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This represents a raised 2nd (the 27) and a lowered 7th (the -1).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"Alteration\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\")), structure(\" integer allows us to concisely represent all the 2,187 possible combinations of raised and lowered diatonic scale degrees!\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, combined with the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Signature\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" slot, there is some redundancy in scale representation.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For example, a melodic minor scale can be represented as a major scale (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Signature - Root == 0\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") with a lowered third degree (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Alteration == -3\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"or\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" as\\n\", class = c(\"TEXT\", \"tag\")), structure(\"minor scale (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Signature - Root == -3\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") with raised 6ths and 7ths (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Alteration == 10\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, though these two representations result in the same set on the line-of-fifths, some might consider them to be\\n\", class = c(\"TEXT\", \"tag\")), structure(\"conceptually different in some contexts, so we consider the redundancy acceptable.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Another case of encoding redundancy \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"is\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" that \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Alteration - 1\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (flatten the 7th) is exactly equivalent to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Signature - 1\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Similarly, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Alteration + 749\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (raise the 4th) is exactly equivalent to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Signature + 1\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Double-flat and double-sharp degrees are \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"not\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" encodable in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, in combination with the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Signature\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" slot, sets with double-flat/sharps (like doubly-diminished 7ths) can be encoded.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Arithmatic\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Arithmetic between diatonicSets is not defined.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, a number of useful arithmetic operations between diatonicSets and other data types \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"are\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" defined:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"XXXX Elaborate\\n\", class = c(\"TEXT\", \"tag\")), structure(\"XXXX Need to implement special logic for adding Alterations! (Taking into account Signature addition.)\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Relational Operators\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"diatonicSets can be compared using the standard \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"relational operations\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:Comparison\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"==\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"!=\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Two diatonicSets are equal (according to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"==\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") only if all their slots (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Root\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Signature\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Alteration\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\")\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are exactly identical.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Ordinal comparisons (e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\">\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"<=\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") between diatonicSets are on their \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Signature\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" only.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Coercion\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" knows how to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Type_conversion\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"coerce\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\" )), structure(\" several \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"base-R atomic types\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:vector\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" into diatonicSets.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This can be done using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"methods:as\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" function---e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as(3, \\\"diatonicSet\\\")\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"---or more intuitively using the function \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet()\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Coercision methods are defined for\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:integer\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\": interpreted as root of major key\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"numeric\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:numeric\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\": rounded to nearest integer and intepreted as root of major key\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"character\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:character\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\": interpreted using \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"regular expression dispatch system\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=regexDispatch\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\", as\\n\", class = c(\"TEXT\", \"tag\")), structure(\"explained fully \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"here\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=diatonicRepresentations\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), fillThru.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/tools.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"fillThru\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"fillThru\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"fillForward\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"fillBackwards\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Propogate data points to \\\"fill\\\" null data.\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"fillThru(x, nonnull = function(x) !is.na(x) & x != \\\".\\\", reverse = FALSE)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"fillForward(...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"fillBackwards(...)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"fillThru\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is a function that allow you to \\\"fill\\\" null values in a vector\\n\", class = c(\"TEXT\", \"tag\")), structure(\"with non-null values from earlier/later in the same vector.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The default, \\\"foward,\\\" behavior fills each null value with the previous (lower index) non-null value, if there are any.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"reverse\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument can be used to cause \\\"backeward\\\" filling, where the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"next\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" (higher index) non-null value is used.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Which values are considered \\\"non-null\\\" can be controlled using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"nonnull\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"nonnull\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument can either be a logical vector which is the same length as the input (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"x\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") argument, a numeric\\n\", class = c(\"TEXT\", \"tag\")), structure(\"vector of positive indices, or a function which, when applied to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"x\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" returns an appropriate logical/numeric vector.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), filterHumdrum.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Filter.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"filterHumdrum\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"filterHumdrum\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"removeEmptyFiles\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"removeEmptySpines\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"removeEmptyRecords\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[,humdrumR,missing,ANY-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[,humdrumR,numeric,ANY-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[,humdrumR,character,ANY-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[,humdrumR,formula,ANY-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[,humdrumR,numeric,missing-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[,humdrumR,missing,numeric-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[,humdrumR,character,missing-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[,humdrumR,ANY,ANY-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Filter humdrum data\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"filterHumdrum(humdrumR, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"removeEmptyFiles(humdrumR)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"removeEmptySpines(humdrumR)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"removeEmptyRecords(humdrumR)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdata[] # returns unchanged\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdata[x:y]\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdata['regex']\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdata[~expression]\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdata[[x:y]]\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdata[[ , x:y]]\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdata[['regex']]\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdata[[x:y, l:m]]\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"filterHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is a command used to filter a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR corpus\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Indexing a humdrumR corpus (using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[]]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" operators)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"uses calls to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"filterHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"!\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"filterHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is used in a similar manner as \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(\"taking any number of \\\"do expressions\\\" (or functions) as arguments.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(In fact, do expressions/function arguments are passed directly to an internal call to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The only difference is that the expressions/functions fed to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"filterHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"must\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" be \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"predicate\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" expressions\\n\", class = c(\"TEXT\", \"tag\")), structure(\"which return a logical (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"/\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") vector.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The returned vector must also be the same length as the input data (the number\\n\", class = c(\"TEXT\", \"tag\")), structure(\"of rows in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum table\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(You can use a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"dofill~\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" expression if you want to \\\"expand\\\" shorter outputs for filtering pusposes.)\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"filterHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" updates the humdrum table's \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Filter\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field using an logical OR (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"|\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") between the existing \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Filter\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field and the negation of your predicate: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Filter | !Predicate\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"HumdrumR functions (mostly) ignore all data points where \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Filter == TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\": when you print a filtered \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" you'll see all the filtered data points turned to null data (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\".\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"), and\\n\", class = c(\"TEXT\", \"tag\")), structure(\"any calls to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=with(in)Humdrum\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" will ignore the filtered data.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"By default, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"filterHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" completely removes any files in the corpus where \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"all\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" the data records are filtered out.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, you can stop this by specifying the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"removeEmptyFiles\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argumet as \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If you \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"want\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" to remove empty files, spines, or records, you should call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"removeEmptyFiles\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"removeEmptySpines\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"removeEmptyRecords\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Indexing\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In R, the basic \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"indexing operators\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:Extract\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"[]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[]]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are used to select subsets of data.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For many R data types (for instance, base R \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"lists\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:list\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\")\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"the \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"single brackets\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" are used for \\\"shallower\\\" extraction while the\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"[[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"double brackets\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" are used for \\\"deeper\\\" extraction.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"HumdrumR corpus\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" indexing follows this same basic pattern:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"single brackets\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" are used to index \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" objects\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by piece\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" while \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"[[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"double brackets\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" are used to index\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"within pieces\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\". (Accidentally writing \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" when you need\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[]]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" is a very common error, so watch out!)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Whether, indexing by piece or within, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" objects can use\\n\", class = c(\"TEXT\", \"tag\")), structure(\"three types of indexing arguments:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" By \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"numeric\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (ordinal integers)\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" By \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" string (regular expressions)\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" By \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"formula\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (arbitrary expressions)\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"The last option (by \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"formula\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") is the most powerful option,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"and indeed, the first two options (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"numeric\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" indexing)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are just convenient shorthands for indexing that can be accomplished using\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"formula\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" method.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Numeric indexing:\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Indexing \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" corpora with\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"single brackets\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" will accept\\n\", class = c(\"TEXT\", \"tag\")), structure(\"one numeric argument.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This argument will be used to pick pieces within the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object ordinally.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[1:10]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will select the first ten pieces in the data while \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[42]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"will select only the 42nd piece.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Indexing \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" objects with\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"[[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"double brackets\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" will accept\\n\", class = c(\"TEXT\", \"tag\")), structure(\"one or two numeric arguments, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", either of which can\\n\", class = c(\"TEXT\", \"tag\")), structure(\"be used in isolation or in combination.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is used in isolation, it must be placed after a comma, as in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[[ , j ]]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".)\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is used to index data records (i.e., based on the humtable \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Record\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field) ordinally.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[[1:20]]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" indexes the first twenty records \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"from each file\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in the corpus, and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[[42]]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" extracts the 42nd record \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"from each file\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is used to index spines (i.e., based on the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Spine\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field) ordinally.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[[ , 3:4]]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" returns the third and fourth spines \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"from each\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"file in the corpus.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"When indexing \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR corpora\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" with numbers,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"all \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"numeric\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (double) inputs are converted to integers.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Note that numeric \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" indexing is entirely \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"ordinal\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\", meaning\\n\", class = c(\"TEXT\", \"tag\")), structure(\"that pieces/data records/spines are not matched based on their value in their\\n\", class = c(\"TEXT\", \"tag\")), structure(\"respective fields, but rather on their order among all existing values.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, for \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"single-bracket\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" indexing the $i_\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"th\", class = c(\"TEXT\", \"tag\"))), class = c(\"LIST\", \"tag\")), structure(\"$ piece in the\\n\", class = c(\"TEXT\", \"tag\")), structure(\"corpus is taken, regardless of that \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"FileN\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field associated\\n\", class = c(\"TEXT\", \"tag\")), structure(\"with that piece.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For example,\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humsubset <- humdata[11:20]\\n\", class = c(\"VERB\", \"tag\")), structure(\"humsubset[2]\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"will return the 12th piece from the original \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"not\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" the second piece.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This is beacuse the first call to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" returns the 11th through 20th pieces, and the second call\\n\", class = c(\"TEXT\", \"tag\")), structure(\"returns the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"second\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" piece that is still present (the 12th).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Similarly,\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humsubset2 <- humdata[[ , 2:4]]\\n\", class = c(\"VERB\", \"tag\")), structure(\"humsubset2[[ , 2]]\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"will return the third spine from the original data.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"As in normal R indexing, negative numbers can be used, causing corresponding elements to be\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"removed\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" instead of retained. Thus, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[-3:-5]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will remove the third, fourth, and fifth pieces from the data\\n\", class = c(\"TEXT\", \"tag\")), structure(\"while \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[[ , -3:-5]]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will remove the third, fourth, and fifth spines from each piece.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Positive and negative indices cannot be mixed in a single argument.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In all cases, indices outside of range (or of value \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"0\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") are ignored.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"E.g., if you have a corpus of twenty files and you call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"corpus[21]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", there is no 21st piece, so \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"21\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is \\\"out of range\\\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If all your input indices are \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"0\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and error will result.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If all your input indices are out of range then\\n\", class = c(\"TEXT\", \"tag\")), structure(\"an empty \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object is returned.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For instance, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[[401:500, ]]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will return an empty\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object if there are no pieces with more than 400\\n\", class = c(\"TEXT\", \"tag\")), structure(\"data records.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Character indexing:\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Indexing \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR objects\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumR:humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" with\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"single brackets\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" will accept one\\n\", class = c(\"TEXT\", \"tag\")), structure(\"vector of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" strings. These strings are\\n\", class = c(\"TEXT\", \"tag\")), structure(\"treated as\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Regular_expression\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"regular expressions\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" (regexes).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"The tokens from the humdrumR object's \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Active\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" fields are searched\\n\", class = c(\"TEXT\", \"tag\")), structure(\"for matches to any of the regular expressions you input. Any piece that contains\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"any\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" match to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"any\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" of the regular expressions is retained---all other pieces\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are filtered out. Note that (because this is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"single-bracket\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" indexing) the entire piece is retained, even if there is only one match.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If no matches occur in any pieces, an empty \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object is returned.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Indexing \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" objects with \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"double brackets\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" will\\n\", class = c(\"TEXT\", \"tag\")), structure(\"accept one or two vectors of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" strings, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(\"either of which can\\n\", class = c(\"TEXT\", \"tag\")), structure(\"be used in isolation or in combination.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is used in isolation, it must be placed after a comma,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"as in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[[ , j]]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"These strings are\\n\", class = c(\"TEXT\", \"tag\")), structure(\"treated as \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Regular_expression\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"regular expressions\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" (regexes).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The tokens from the humdrumR object's \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Active\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" fields are searched\\n\", class = c(\"TEXT\", \"tag\")), structure(\"for matches to any of the regular expressions you input.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Any record which contains at least one token matching any regex in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"will be retained.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Similarly, any spine which contains at least one token matching any\\n\", class = c(\"TEXT\", \"tag\")), structure(\"regex in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is retained.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" are used together,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"matching spines (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") are indexed first, so that\\n\", class = c(\"TEXT\", \"tag\")), structure(\"tokens matching the regular expression(s) in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"must be found in the matching spines.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"A third argument, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"k\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", can also be used, but only if\\n\", class = c(\"TEXT\", \"tag\")), structure(\"both the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" arguments are missing.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In order for this to work, you need to put two commas to mark the \\\"missing\\\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" arguments:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[[ , , '[Ee]-']]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In the case of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"k\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", only matching tokens are retained,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"regardless of their spine or record number(s).\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Formula indexing:\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Indexing \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR objects\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumR:humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" with\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"formulae\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is the most powerful, flexible indexing option.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Either \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"single\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"double\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" brackets will accept\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a (single) formula. The formula are fed directly as arguments to\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"filterHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"---as such, they music evaluate to a logical vector of the same\\n\", class = c(\"TEXT\", \"tag\")), structure(\"length as the input.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"In the case of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"single-bracket\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" indexing, only one \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"formula\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"is accepted, and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"every piece\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" that evalues with at least one\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will be retained.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For instance, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[~Spine > 4]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will return all pieces\\n\", class = c(\"TEXT\", \"tag\")), structure(\"which contain five (or more) spines.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"single-bracket\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" formula indexing is especially useful for indexing\\n\", class = c(\"TEXT\", \"tag\")), structure(\"meta-data properties like reference records:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"for instance, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[~COM == \\\"Paul McCartney\\\"]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will return\\n\", class = c(\"TEXT\", \"tag\")), structure(\"all pieces with a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"!!!COM: Paul McCartney\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" reference record.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"In the case of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"double-bracket\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" indexing, one or two formulas are accepted,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in arguments \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", either of which can\\n\", class = c(\"TEXT\", \"tag\")), structure(\"be used in isolation or in combination.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is used in isolation, it must be placed after a comma,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"as in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[[ , j]]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In the case of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" formulae, any record which evaluates to\\n\", class = c(\"TEXT\", \"tag\")), structure(\"at least one \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" value is retained.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In the case of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", any spine which evaluates to\\n\", class = c(\"TEXT\", \"tag\")), structure(\"at least one \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" value is retained.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Any piece which contains no matches is dropped entirely.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"For \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"[[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"double-bracket\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" formula indexing, a third argument, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"k\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"may be used in the absence of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In order for this to work, you need to put two commas to mark the \\\"missing\\\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" arguments:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[[ , , ~formula]]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In the case of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"k\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" all tokens which evaluate to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are retained, regardless of piece/spine/record.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Pieces, spines, or records with no \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" values\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are simply dropped.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"k\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument is exactly the same a \\\"plain\\\" call to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"filterHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), getFields.Rd = structure(list(structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/humdrumR-class.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"getFields\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"getFields\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"-------------------------------------------> NEEDS DOCUMENTATION <-------------------------------------------\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Get named\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"getFields(humdrumR, fieldnames = NULL, dataTypes = \\\"D\\\")\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"-------------------------------------------> NEEDS DOCUMENTATION <-------------------------------------------\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Get named\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), getTandem.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Apply.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"getTandem\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"getTandem\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Get tandem interpretation information from humdrum data.\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"getTandem(tandem, regex)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Every \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" object has a field called\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Tandem\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" which is a vector of strings which accumulates\\n\", class = c(\"TEXT\", \"tag\")), structure(\"tandem interpretations in each Spine. This function (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"getTandem\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\")\\n\", class = c(\"TEXT\", \"tag\")), structure(\"extracts tandem interpretations from this field, based on a matching\\n\", class = c(\"TEXT\", \"tag\")), structure(\"regular expression. The obligatory \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"'*'\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"does not\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" need to\\n\", class = c(\"TEXT\", \"tag\")), structure(\"be included in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"regex\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", as it is added automatically. Thus,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"if you want to find tandem interpretations that match '*clef..', you\\n\", class = c(\"TEXT\", \"tag\")), structure(\"just have to write \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"regex = 'clef..'\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humActive.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/humdrumR-class.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humActive\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humActive\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"evalActive\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"getActive\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"setActive\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"setActiveFields\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"The \\\"Active expression\\\" of a humdrumR object.\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"evalActive(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" humdrumR,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" dataTypes = \\\"D\\\",\\n\", class = c(\"RCODE\", \"tag\")), structure(\" forceVector = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" sep = \\\", \\\",\\n\", class = c(\"RCODE\", \"tag\")), structure(\" nullAs = NA\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"getActive(humdrumR)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"setActive(humdrumR, form)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"setActiveFields(humdrumR, fieldnames)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" data object.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"dataTypes\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Which dataTypes of humdrum records to include. Legal values are \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"'G', 'L', 'I', 'M', 'D', 'd', 'P'\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"or any combination of these in a single string (e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"LIM\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(see the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum table\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" documentation \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Fields\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" section for an explanation.).\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"forceVector\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(list( structure(\"logical\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\")), structure(\". If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the result is forced to be an atomic vector.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"sep\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A length-one \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" string. If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"forceVector == TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" this value is used as a separator\\n\", class = c(\"TEXT\", \"tag\")), structure(\"between tokens that are collapsed.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"nullAsDot\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A single \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"atomic\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" value. Any null tokens are coerced to this value (default is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\".\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_arguments\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This \\\"Active\\\" expression is used as the default value in a lot of humdrumR code.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For one, it is the data which is printed by \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"show\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"methods:show\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" calls,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"i.e., whenever you return a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object in the terminal.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In any expression within a call to\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"with(in)Humdrum\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=withinHumdrum\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\".\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is automatically replaced with the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Active\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The active expression can be changed with the commands\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"setActive or the $ operator\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"This is a handy way to quickly look at different fields in your data.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"The \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Active\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression is often just the name of a\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"field\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\":\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"for instance, the default value is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Token\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, it can actually be any complex expression which evaluates\\n\", class = c(\"TEXT\", \"tag\")), structure(\"within the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum table\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"For instance, the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Active\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression could be:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"paste0(Token, \\\" \\\", Record)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", which would automatically\\n\", class = c(\"TEXT\", \"tag\")), structure(\"print each Token with its record number pasted to it.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Null data\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"HumdrumR identifies \\\"null data\\\" based on the active field.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Anywhere the current active field evaluates to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\".\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is considered Null data, and assigned the type \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"d\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" in the internal\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum table\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"As you work, there will often be data tokens which are null in one field, but not in another field.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For example, if you load \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"**kern\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" data, a token like \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"4r\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (quarter-note rest) token will be \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" if you call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pitch\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", but\\n\", class = c(\"TEXT\", \"tag\")), structure(\"not \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" if you call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"recip\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (rhythm).\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"VERB\", \"tag\")), structure(\"kerndata <- readHumdrum(...)\\n\", class = c(\"VERB\", \"tag\")), structure(\"\\n\", class = c(\"VERB\", \"tag\" )), structure(\"kerndata$Token %hum>% pitch -> kerndata$Pitch\\n\", class = c(\"VERB\", \"tag\")), structure(\"kerndata$Token %hum>% recip -> kerndata$Rhythm\\n\", class = c(\"VERB\", \"tag\")), structure(\"\\n\", class = c(\"VERB\", \"tag\" ))), class = c(\"tag_preformatted\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Now, if you change the active field between \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Pitch\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Rhythm\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" you'll see that there\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are different numbers of (non-null) data tokens: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"ntokens(kerndata$Pitch)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" vs \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"ntokens(kerndata$Rhythm)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will return different numbers!\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(The different would be the number of rest tokens.)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Similarly, if you apply functions/expressions to this data (using \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" for example), the result will depend on\\n\", class = c(\"TEXT\", \"tag\")), structure(\"what the active field is:\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"VERB\", \"tag\")), structure(\"kerndata$Pitch %hum<% ~length(Token)\\n\", class = c(\"VERB\", \"tag\")), structure(\"kerndata$Rhythm %hum<% ~length(Token)\\n\", class = c(\"VERB\", \"tag\")), structure(\"\\n\", class = c(\"VERB\", \"tag\" ))), class = c(\"tag_preformatted\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Once again, we'll get different numbers here! (Assuming there are rests in the data.)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This is the case even though the do-expression isn't actually using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Pitch\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Rhythm\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" fields!\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Pitch\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is the active field the rest tokens are null-data and will be ignored!\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humAssignment.Rd = structure(list(structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/humdrumR-class.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humAssignment\", class = c(\"VERB\", \"tag\" ))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humAssignment\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Assigning new fields\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"R objects often have ways of assigning new values to\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"part\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" of the object using \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"indexing operators\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:Extract\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"HumdrumR objects\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumR:humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" objects are no different, as they allow us to insert\\n\", class = c(\"TEXT\", \"tag\")), structure(\"new fields into them!\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A new field can be inserted into a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object in two ways:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\" )), structure(\" A field can be copied from one humdrumR object to another if their\\n\", class = c(\"TEXT\", \"tag\")), structure(\"internal \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"humdrum tables\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" have the exact same number of data tokens (i.e., rows).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"It might not seem obvious, but this mechanism is very useful because it can be used to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rename\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" existing fields\\n\", class = c(\"TEXT\", \"tag\")), structure(\"within a humdrumR object (explained below).\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\" )), structure(\" A \", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"vector\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:vector\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"list of vectors\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:list\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" can be inserted as\\n\", class = c(\"TEXT\", \"tag\")), structure(\"new fields in a humdrumR object.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_enumerate\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Fields can be assigned using two syntaxes:\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata['fieldname'] <- x\\n\", class = c(\"VERB\", \"tag\")), structure(\"# or\\n\", class = c(\"VERB\", \"tag\")), structure(\"humdata[c('fieldname1', 'fieldname2')] <- x\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"or\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata$fieldname <- x\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"where \\\"fieldname\\\" can be whatever you want it to be, of course!\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(list( structure(\"humdrumR -> humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" assignment:\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Assigning a field from one \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR object\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumR:humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"to another works like this:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(Recall that the two objects must have the exact same numbers of data tokens.)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The name(s) given in the indexing expression on the left side of the assignment (i.e., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[c('name1', 'name2')]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata$name\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") are used as new field names.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"How fields are extracted from the right side of the assignment is a little trickier:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Any fields in the right-side \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object which are named $PipeN$ (where $N$ is an integer) are copied\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in descending order into the named fields on the left side.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If there are no $PipeN$ fields on the right side, any fields used in the current Active formula (on the right side)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are copied instead.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This system might seem odd at first, but it is very useful in combination with the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" function,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"or its convenient pipe operator \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hum>%\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humPipe\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"When \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" creates new fields, it calls them $Pipe1 \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_ldots\", \"tag\")), structure(\" Pipe2 \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_ldots\", \"tag\")), structure(\" PipeN$.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Since the output of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is always the same as the input except with these new \\\"Pipe\\\" fields,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Byou can use \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR <- humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" assignment to immediately assign these pipe fields more meaningful names in the original object.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This makes the most sense with an example:\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata$Semits <- humdata %hum>% ~semit(Token) \\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In humdrumR, we actually favor the left-to-right \\\"piping\\\" style.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Luckily, R allows you to assign left-to-right, so the proper humdrumR style is actually:\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata %hum>% ~semit(Token) -> humdata$Semits\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Calls to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hum>%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\") keep producing new pipe fields.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If there are more than one pipe fields, you can assign multiple fields at once using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[]<-\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" syntax:\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"VERB\", \"tag\")), structure(\"humdata %hum>% ~semit(Token) %hum>% ~pitch(Token) -> humdata[c('semit', 'pitch')]\\n\", class = c(\"VERB\", \"tag\")), structure(\"\\n\", class = c(\"VERB\", \"tag\" ))), class = c(\"tag_preformatted\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"#' \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"IMPORTANT NOTE!\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\": Any \\\"PipeN\\\" fields in the humdrumR object you assign from\\n\", class = c(\"TEXT\", \"tag\")), structure(\"that you don't assign field names are simply dropped.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This is nice, because often you might proceed through a serious of piped steps, but you only\\n\", class = c(\"TEXT\", \"tag\")), structure(\"want the last one (or two).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If you want to keep all your pipe fields either don't re-assign them at all (i.e., keep the \\\"PipeN\\\" names)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"or assign them all names using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"->[c(\\\"name1\\\", \\\"name2\\\", \\\"name3\\\", ...)]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" syntax.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(list(structure(\"humdrumR -> vector\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" assignment:\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"You can assign vectors or lists of vectors straight into a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR object\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumR:humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"All vectors must be the same length as the number of data tokens\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in the target object.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If you provide multiple vectors to assign (as a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"list\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"data.frame\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" of vectors)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"you must provide the same number of fieldnames using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"->[c('name1', 'name2', ...)]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" syntax.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"You can use the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"ntokens\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" command to determine the right length of vectors you need!\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humCensus.Rd = structure(list(structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Summary.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humCensus\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humCensus\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"census\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"[.humCensus\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"print.humCensus\", class = c(\"VERB\", \"tag\" ))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Tabulate records and tokens in a humdrumR corpus\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"census(humdrumR, dataTypes = \\\"GLIMDd\\\", by = \\\"Filename\\\", removeEmpty = FALSE)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"census(humdata)[i]\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"print\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humCensus\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(censusTable, showEach = TRUE, screenWidth = options(\\\"width\\\")$width - 10L)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A humdrumR object\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"dataTypes\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" string of length 1.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"by\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" string of length 1. Must be a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"field\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" in the humdrumR object.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_arguments\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"census\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is one of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"'s\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"summary functions\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humSummary\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\", used to\\n\", class = c(\"TEXT\", \"tag\")), structure(\"tabulate the raw size of a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" corpus.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"census\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" takes a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" object\\n\", class = c(\"TEXT\", \"tag\")), structure(\"and and returns a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humCensus\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" table.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"dataType\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument controls what types of records to tabulate:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"legal values are \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"'G', 'L', 'I', 'M', 'D', 'd'\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"or any combination of these (e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"LIM\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The default is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"D\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humCensus\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" table has five columns of information:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\" )), structure(\" Records\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" The total number of records.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Tokens\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" The total number of tokens.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" (unique)\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" The number of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"unique\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" tokens\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Characters\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" The total numder of characters. This includes humdrum control characters like \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"*\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"!!\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" (per token)\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" This is simply \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Characters / Tokens\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", indicating the mean length of each token.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_enumerate\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humCensus\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" table has one row for each file in the corpus.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Rows are labeled with each file's corresponding\\n\", class = c(\"TEXT\", \"tag\")), structure(\"number (from the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humTable's\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"File\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" field) and name (the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Filename\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" field).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In addition, when a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humCensus\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object is printed,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the totals across all files are printed as well---(unique) and (per token)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"across all files are calculated across all files as well, not summed.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Indexing\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Rows of a \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"humCensus\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object can be selected with a single argument \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\": e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"censusTable[i]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"numeric\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the corresponding rows are selected ordinally (not by \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"File\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" number).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" string, this string is mached as a regular expression against file names.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is a formula, the right-hand side of the formula is evaluated within the table---if it evaluates to a logical vector,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"files are selected accordingly. For instance,\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"censusTable[~Tokens > 100]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will select all files\\n\", class = c(\"TEXT\", \"tag\")), structure(\"with more than 100 tokens. (The '(unique)' and '(per token)' columns\\n\", class = c(\"TEXT\", \"tag\")), structure(\"must be referred to with their names enclosed in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\\``---for example, \", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"censusTable\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"~\\\\verb\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"(unique)\\\\\", class = c(\"TEXT\", \"tag\"))), class = c(\"LIST\", \"tag\")), structure(\" > 100\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=~\\\\`(unique)\\\\` > 100\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"` will return all files with\\n\", class = c(\"TEXT\", \"tag\")), structure(\"more than 100 unique tokens.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"drop\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument is also available. If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", a plain\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"data.table::data.table()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"data.table:data.table\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is returned.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Other humdrum data summary functions: \\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"humInterpretations\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"humSpines\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"humSummary\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humdrum data summary functions\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_concept\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humCoercion.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/humdrumR-class.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humCoercion\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humCoercion\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.lines\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.matrix.humdrumR\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.matrices\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.data.frames\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR Coercion.\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list(structure(list(structure(\"as.vector\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(x, mode = \\\"any\\\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"as.lines(\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" humdrumR,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" dataTypes = \\\"GLIMDd\\\",\\n\", class = c(\"RCODE\", \"tag\")), structure(\" fieldname = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" alignColumns = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" padPaths = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" padder = \\\"\\\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list( structure(list(structure(\"as.matrix\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" dataTypes = \\\"D\\\",\\n\", class = c(\"RCODE\", \"tag\")), structure(\" fieldnames = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" alignColumns = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" padder = NA,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" path.fold = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"as.data.frame\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" dataTypes = \\\"D\\\",\\n\", class = c(\"RCODE\", \"tag\")), structure(\" fieldname = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" padder = NA,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" fold.path = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"as.matrices(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" humdrumR,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" dataTypes = \\\"D\\\",\\n\", class = c(\"RCODE\", \"tag\")), structure(\" fieldnames = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" padder = NA,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" path.fold = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"as.data.frames(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" humdrumR,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" dataTypes = \\\"D\\\",\\n\", class = c(\"RCODE\", \"tag\")), structure(\" fieldnames = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" padder = NA,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" path.fold = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"mode\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"If the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"mode\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument is not \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"'any'\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", it can be a single \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"string naming an atomic mode---the output will be coerced to this mode (if possible).\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"dataTypes\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Which types of humdrum records to include. Legal values are \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"'G', 'L', 'I', 'M', 'D', 'd'\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"or any combination of these (e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"LIM\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(see the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum table\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" documentation \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Fields\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" section for explanation.).\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"padder\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"An atomic value of length one. If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"par.files\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pad.paths\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" are true, the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"padder\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"argument is used to fill in the desired gaps.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"pad.files\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(list( structure(\"logical\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\")), structure(\" (default \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"). If any pieces in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" corpus have fewer\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humdrumR:humTable][spines/columns]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" than the maximum, should they be padded with the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"padder\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"par.files == TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") or\\n\", class = c(\"TEXT\", \"tag\")), structure(\"should an an error occur (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pad.files == FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\")? Note that these \\\"padded\\\" points are not represented in the original humdrum data.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"pad.paths\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(list( structure(\"logical\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\")), structure(\" If any spine path splits (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"'*^'\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") occur in the humdrumR data, should they be padded\\n\", class = c(\"TEXT\", \"tag\")), structure(\"with the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"padder\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"par.files == TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") or\\n\", class = c(\"TEXT\", \"tag\")), structure(\"should an an error occur (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pad.paths == FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\")?\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Note that these \\\"padded\\\" points are not represented in the original humdrum data.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"field(s)\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"If the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"field\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"not\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", it can instead be a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" string matching\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" object's fields. If so, these fields are extracted instead of the\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Active expression\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humActive\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"For calls to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.vector\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.data.frame\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", only one field can be extracted.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, for calls to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.matrix\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", multiple fields can be extraced---these fields will be\\n\", class = c(\"TEXT\", \"tag\")), structure(\"returned in a third matrix dimension, each field forming one rectangular slice.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_arguments\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Many users may wish to work with humdrum data without\\n\", class = c(\"TEXT\", \"tag\")), structure(\"using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humdrumR:humdrumR][humdrumR]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" API, instead using\\n\", class = c(\"TEXT\", \"tag\")), structure(\"basic \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"R\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data types.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For this purpose, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" data objects can be coerced to\\n\", class = c(\"TEXT\", \"tag\")), structure(\"basic \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"R\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data types.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.vector(humdata)\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:vector\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" evaluates the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" object's\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Active\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" expression, and (attempts) to force the result to a vector of mode. This\\n\", class = c(\"TEXT\", \"tag\")), structure(\"method is essentially a wrapper for \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"evalActive\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.matrix(humdata\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:matrix\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" also evaluates the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" object's\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Active\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" expression, but wraps it into a matrix of dimensions \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"c([humdrumR:humSize][nrow(humdata), ncol(humdata)])\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Note that \\\"\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humdrumR:humTable][Columns]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"\\\" in humdrum data are not necesarily the same as spines.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"as.data.frame(humdata)\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:as.data.frame\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" first calls \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.matrix\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" then converts the matrix to a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"data.frame\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:data.frame\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"as.data.table(humdata)\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"data.table:as.data.table\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" first calls \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.matrix\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" then converts the matrix to a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"data.table::data.table()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"data.table:data.table\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"as.matrices\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.data.frames\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.data.tables\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.matrix\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"/\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.data.frame\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"/\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.data.table\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"on each individual file in a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" corpus, returning a list of matices/data.frames/data.tables.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humColumns.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/humdrumR-class.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humColumns\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humColumns\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Spines vs Paths vs Columns\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In the \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"http://www.humdrum.org/guide/ch05/\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrum syntax\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\", data is placed in \\\"spines,\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"which are not the same as \\\"columns\\\" in a spreadsheet. A \\\"column\\\" refers to a\\n\", class = c(\"TEXT\", \"tag\")), structure(\"tab-delineated group of values.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\\"Spines\\\" can be a single column, or they may (at any time) split into multiple columns,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"which can in turn split again, using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"*^\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" interpretation token. The reverse can happen as well,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"with two or more columns merging into a single column, using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"v\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" token.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This means that, while humdrum data at first glance looks like a simple two-dimensional table,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"it is actually a flexible tree structure. As spines split and merge, the total number of columns\\n\", class = c(\"TEXT\", \"tag\")), structure(\"can change during a piece, creating a \\\"ragged\\\" edge.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Another similar issue is that a corpus of humdrum files may have varying numbers of spines/columns, between pieces.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(\\\"Global\\\" comment/reference records are also a special case, as that are always a single value, even if interspersed with\\n\", class = c(\"TEXT\", \"tag\")), structure(\"multi-column local records.)\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\", spines, columns, and spine paths work like this.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"First of all, we actually assume a slightly more strict version of the humdrum syntax:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"we assume that all the spines which appear at the beginning of a file (headed with exlusive interpretations\\n\", class = c(\"TEXT\", \"tag\")), structure(\"like \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\\"**kern\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") can never merge into each other. Thus, a humdrum file read into \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"must not end with fewer columns than it starts.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Spine merges (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"*v\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") can only happen within spine paths that originally split off the same spine.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This extra-strict specification of spine paths in the humdrum syntax is, fortunately, something that has been\\n\", class = c(\"TEXT\", \"tag\")), structure(\"informally followed in most humdrum datasets.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Our strict spine-path definition makes everything work fairly simply:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Within a piece, the spines which appear at the beginning of the piece are the \\\"true\\\" spines through the rest of the piece, numbered\\n\", class = c(\"TEXT\", \"tag\")), structure(\"from left to right, starting from \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"1L\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For each local token, the value in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Spine\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field is an integer indicating which of these\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\\"true\\\" spines it belongs to---global tokens have a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" value in their \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Spine\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field, because they are considerd to not belong to any spine.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Any spine path splits (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"*^\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" from the main spines form subspines, which we call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Paths\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Every spine's paths are numbered, from right to left, starting from \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"0L\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A spine with no splits will have all \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"0L\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s in its \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Path\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Columns\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"It is very useful to sometimes turn humdrum data into a true two dimensional structure, with no ragged edges.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(This always requires removing global records.)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In order to do this, while maintaining a sensible relationship between spine which have spine paths,\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humRead\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" automatically \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pads\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" humdrum data into a complete, non-ragged 2d table.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For instance, given this file\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"**kern **kern\\n\", class = c(\"VERB\", \"tag\")), structure(\"A E\\n\", class = c(\"VERB\", \"tag\")), structure(\"*^ *\\n\", class = c(\"VERB\", \"tag\")), structure(\"A C E\\n\", class = c(\"VERB\", \"tag\")), structure(\"G B D\\n\", class = c(\"VERB\", \"tag\")), structure(\"*v *v *\\n\", class = c(\"VERB\", \"tag\")), structure(\"A C \\n\", class = c(\"VERB\", \"tag\")), structure(\"*- *-\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humRead\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_link\", \"tag\")), structure(\" pads the file as so:\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"**kern _P **kern\\n\", class = c(\"VERB\", \"tag\")), structure(\"A _P E\\n\", class = c(\"VERB\", \"tag\")), structure(\"*^ _P *\\n\", class = c(\"VERB\", \"tag\")), structure(\"A C E\\n\", class = c(\"VERB\", \"tag\")), structure(\"G B D\\n\", class = c(\"VERB\", \"tag\")), structure(\"*v *v *\\n\", class = c(\"VERB\", \"tag\")), structure(\"A _P C \\n\", class = c(\"VERB\", \"tag\")), structure(\"*- _P *-\\n\", class = c(\"VERB\", \"tag\")), structure(\"\\n\", class = c(\"VERB\", \"tag\" )), structure(\"##########################################\\n\", class = c(\"VERB\", \"tag\")), structure(\"1 1 2 Spine\\n\", class = c(\"VERB\", \"tag\")), structure(\"0 1 0 Path\\n\", class = c(\"VERB\", \"tag\")), structure(\"1 2 3 Column\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(In this example, the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Spine\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Path\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Column\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" values are shown below the data.)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"_P\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" tokens stand for \\\"padded path.\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This appraoch assures that every \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Spine\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" is a contiguous block of tokens, of constant width.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In most humdrumR use cases, these padding tokens (and the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Column\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field) can be safely ignored.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Corpus padding\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humRead\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" automatically pads spine paths \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"within pieces\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, as mentioned above, there is also (sometimes) a need to pad across pieces, in order\\n\", class = c(\"TEXT\", \"tag\")), structure(\"to create a logical, clean 2d structure.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Consider this example, with humdrum data from two pieces:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Piece 1\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\":\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"**kern **kern **kern\\n\", class = c(\"VERB\", \"tag\")), structure(\"E D C\\n\", class = c(\"VERB\", \"tag\")), structure(\"D . .\\n\", class = c(\"VERB\", \"tag\")), structure(\"C C E\\n\", class = c(\"VERB\", \"tag\")), structure(\"*- *- *-\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Piece 2\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\":\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"**kern **kern\\n\", class = c(\"VERB\", \"tag\")), structure(\"A A\\n\", class = c(\"VERB\", \"tag\")), structure(\". B\\n\", class = c(\"VERB\", \"tag\")), structure(\"C C\\n\", class = c(\"VERB\", \"tag\")), structure(\"*- *-\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In this example, we have two pieces, one with three spines, the other with two.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"There is no way to squish these two pieces into one regular 2d table.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"But we \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"could\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" pad any missing columns, as so:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Piece 1\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\":\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"**kern **kern **kern\\n\", class = c(\"VERB\", \"tag\")), structure(\"E D C\\n\", class = c(\"VERB\", \"tag\")), structure(\"D . .\\n\", class = c(\"VERB\", \"tag\")), structure(\"C C E\\n\", class = c(\"VERB\", \"tag\")), structure(\"*- *- *-\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Piece 2\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\":\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"**kern **kern _C\\n\", class = c(\"VERB\", \"tag\")), structure(\"A A _C\\n\", class = c(\"VERB\", \"tag\")), structure(\". B _C\\n\", class = c(\"VERB\", \"tag\")), structure(\"C C _C\\n\", class = c(\"VERB\", \"tag\")), structure(\"*- *- _C\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The function \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"alignColumns\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is used to achieve just this effect.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In this example, the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"_C\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" token stands for \\\"padded column.\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The presence of spine paths makes padding columns across pieces a bit more complicated.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"What \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"alignColumns\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will do, is match up all pieces in a corpus so that\\n\", class = c(\"TEXT\", \"tag\")), structure(\"every \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Spine\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\"/\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"Path\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_strong\", \"tag\")), structure(\" field pair allign in the same column.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Here is an example, with its paths already padded:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Piece 1\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\":\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"**kern _P **kern\\n\", class = c(\"VERB\", \"tag\")), structure(\"A _P E\\n\", class = c(\"VERB\", \"tag\")), structure(\"B _P D\\n\", class = c(\"VERB\", \"tag\")), structure(\"*^ _P *\\n\", class = c(\"VERB\", \"tag\")), structure(\"A C E\\n\", class = c(\"VERB\", \"tag\")), structure(\"G# B E\\n\", class = c(\"VERB\", \"tag\")), structure(\"*v *v *\\n\", class = c(\"VERB\", \"tag\")), structure(\"A _P E\\n\", class = c(\"VERB\", \"tag\")), structure(\"*- _P *-\\n\", class = c(\"VERB\", \"tag\")), structure(\"#################################################\\n\", class = c(\"VERB\", \"tag\")), structure(\"1 1 2 Spine\\n\", class = c(\"VERB\", \"tag\")), structure(\"0 1 0 Path\\n\", class = c(\"VERB\", \"tag\")), structure(\"1 2 3 Column\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Piece 2\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\":\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"**kern **kern _P\\n\", class = c(\"VERB\", \"tag\")), structure(\"A E _P\\n\", class = c(\"VERB\", \"tag\")), structure(\"* *^ _P\\n\", class = c(\"VERB\", \"tag\")), structure(\"G# D F\\n\", class = c(\"VERB\", \"tag\")), structure(\"A C E\\n\", class = c(\"VERB\", \"tag\")), structure(\"* *v *v\\n\", class = c(\"VERB\", \"tag\")), structure(\"E D _P\\n\", class = c(\"VERB\", \"tag\")), structure(\"*- *- _P \\n\", class = c(\"VERB\", \"tag\")), structure(\"#################################################\\n\", class = c(\"VERB\", \"tag\")), structure(\"1 2 2 Spine\\n\", class = c(\"VERB\", \"tag\")), structure(\"0 0 1 Path\\n\", class = c(\"VERB\", \"tag\")), structure(\"1 2 3 Column\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"We have two pieces, each with two spines,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"but in the first piece, the first spine splits, while in the second piece, the\\n\", class = c(\"TEXT\", \"tag\")), structure(\"second spine splits. Thus, the padded output will have four columns:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Piece 1\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\":\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"**kern _P **kern _C\\n\", class = c(\"VERB\", \"tag\")), structure(\"A _P E _C\\n\", class = c(\"VERB\", \"tag\")), structure(\"B _P D _C\\n\", class = c(\"VERB\", \"tag\")), structure(\"*^ _P * _C\\n\", class = c(\"VERB\", \"tag\")), structure(\"A C E _C\\n\", class = c(\"VERB\", \"tag\")), structure(\"G# B E _C\\n\", class = c(\"VERB\", \"tag\")), structure(\"*v *v * _C\\n\", class = c(\"VERB\", \"tag\")), structure(\"A _P E _C\\n\", class = c(\"VERB\", \"tag\")), structure(\"*- _P *- _C \\n\", class = c(\"VERB\", \"tag\")), structure(\"###########################################################\\n\", class = c(\"VERB\", \"tag\")), structure(\"1 1 2 2 Spine\\n\", class = c(\"VERB\", \"tag\")), structure(\"0 1 0 1 Path\\n\", class = c(\"VERB\", \"tag\")), structure(\"1 2 3 4 Column\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Piece 2\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\":\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"**kern _C **kern _P\\n\", class = c(\"VERB\", \"tag\")), structure(\"A _C E _P\\n\", class = c(\"VERB\", \"tag\")), structure(\"* _C *^ _P\\n\", class = c(\"VERB\", \"tag\")), structure(\"G# _C D F\\n\", class = c(\"VERB\", \"tag\")), structure(\"A _C C E\\n\", class = c(\"VERB\", \"tag\")), structure(\"* _C *v *v\\n\", class = c(\"VERB\", \"tag\")), structure(\"E _C D _P\\n\", class = c(\"VERB\", \"tag\")), structure(\"*- _C *- _P \\n\", class = c(\"VERB\", \"tag\")), structure(\"######################################################### \\n\", class = c(\"VERB\", \"tag\")), structure(\"1 1 2 2 Spine\\n\", class = c(\"VERB\", \"tag\")), structure(\"0 1 0 1 Path\\n\", class = c(\"VERB\", \"tag\")), structure(\"1 2 3 4 Column\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Note that \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"alignColumns\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" actually adds rows to the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" object's\\n\", class = c(\"TEXT\", \"tag\")), structure(\"internal \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum tables\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humFormulae.Rd = structure(list(structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Formulae.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"data\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_docType\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humFormulae\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humFormulae\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"ditto\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"Standard humdrumR formulae.\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"An object of class \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"list\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" of length 3.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_format\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"ditto\\n\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" predefines a few \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"with(in)humdrum\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=withinHumdrum\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" command combinations, as R formulae or lists of formulae.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\" )), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"ditto\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" calls \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"fillThru()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=fillThru\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" across pieces/spines/paths, replicating the classic humdrum toolkit ditto command.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"datasets\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_keyword\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humInterpretations.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Summary.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humInterpretations\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humInterpretations\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"interpretations\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"print.humInterpretations\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Summarize humdrum corpus interpretations.\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"interpretations(humdrumR)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"print\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humInterpretations\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(interps, showEach = TRUE, screenWidth = options(\\\"width\\\")$width - 10L)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This function provides a summary of the interpretations in the pieces of a humdrumR corpus.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Other humdrum data summary functions: \\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"humCensus\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"humSpines\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"humSummary\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum data summary functions\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_concept\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humMerge.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/humdrumR-class.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humMerge\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humMerge\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"mergeHumdrum\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Merge two (or more) humdrumR datasets\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"mergeHumdrum(...)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"-------------------------------------------> NEEDS DOCUMENTATION <-------------------------------------------\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humMeter.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/rhythmInterval.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humMeter\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humMeter\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Tools for analyzing rhythm and meter.\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" includes a number of useful\\n\", class = c(\"TEXT\", \"tag\")), structure(\"functions for working with rhythms and meter.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"rhythmDecompose()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=rhythmDecompose\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" decomposes a series of rhythms in terms of desired pulses.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"rhythmOffset()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=rhythmOffset\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" Calculates the cummulative offset of durations from a starting point.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humPipe.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Piping.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humPipe\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humPipe\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hum>%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hum<%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%humT%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%s>%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hums>%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hums<%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%humsT%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hums[]%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Piping humdrumR data\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"humdrumR %hum>% formula\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdrumR %hum<% formula\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdrumR %humT% formula\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"e1 %s>% e2\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"list %hums>% formula\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"list %hums<% formula\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"list %humsT% formula\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"list %hums[]% formula\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"These infix operators make it possible to use\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"[humdrumR:with-in-Humdrum][with(in)Humdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"functions in a piping style, similar to the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"|\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (pipe)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in unix-style terminals, or the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"|>\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" pipe operator.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"from the R package \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://cran.r-project.org/web/packages/magrittr/index.html\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"magrittr\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The key is that the function \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[withinHumdrum][withinHumdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" always returns a new\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humdrumR][humdrumR]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" data object. Thus, you can always send the output\\n\", class = c(\"TEXT\", \"tag\")), structure(\"of \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"[withinHumdrum][withinHumdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" back in to a new call of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[withinHumdrum][withinHumdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This is exactly what the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hum>%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" is for: on the left-hand side,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"input a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humdrumR][humdrumR]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" object, on the right-hand side suitable\\n\", class = c(\"TEXT\", \"tag\")), structure(\"arguments to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[withinHumdrum][withinHumdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" (i.e., a formula, a function, or list of formulae,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"functions, and named arguments). You can then chain this call with another call to\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hum>%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" and more \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[withinHumdrum][withinHumdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" arguments.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hum<%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" acts the same way as \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hum>%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" except it calls \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[withHumdrum][withinHumdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Since \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[withHumdrum][withinHumdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" does \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"not\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" return a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humdrumR][humdrumR]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the output can't be piped any further (using \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hum>%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hum<%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\\%hum<\\\\%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" should only be used as the last step in a pipe---you would do this\\n\", class = c(\"TEXT\", \"tag\")), structure(\"if you want to extract the last step in your pipe from the data's \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humdrumR:humtable][Humdrum Table]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" into\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a normal vector or list of R data.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"' \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\\%humT\\\\%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" creates a \\\"T\\\" in the pipe, applying the desired expression but not keeping the result---the unaltered\\n\", class = c(\"TEXT\", \"tag\")), structure(\"humdrumR input object is returned. This works simply by replacing all \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do~\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" with \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"doplot~\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" in a call to\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[withinHumdrum][withinHumdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\". The purpose of this option, is if you want to apply expressions for their\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Side_effect_(computer_science)\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"side effects\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"for instance, for plotting.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"%hum[]%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" is similar to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hum>%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" except it apply the formulae on its right-hand\\n\", class = c(\"TEXT\", \"tag\")), structure(\"side using \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humdrumR][filterHumdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\". Thus, it can be used to filter/index\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"[humdrumR][humdrumR]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" data object on the fly.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Plural pipes\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In R we often apply the same function to a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"list\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" of data.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\\"Plural pipes\\\" expand this idea to piping: take a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"list\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" of data\\n\", class = c(\"TEXT\", \"tag\")), structure(\"and pipe each element in the list to an expression/function.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"There are plural pipe versions of each singular pipe operator.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Just add an \\\"s\\\" to make them plural:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"|>\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" (singular) : \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%s>%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" (plural);\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"%hum>%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" (singular) : \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hums>%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" (plural);\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"%hum<%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" (singular) : \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hums<%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" (plural);\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"%humT%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" (singular) : \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%humsT%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" (plural);\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"%hum[]%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" (singular) : \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hums[]%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" (plural);\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Note: \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"%s>%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" is an expansion of the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\\>\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" pipe operator, which\\n\", class = c(\"TEXT\", \"tag\")), structure(\"makes use of some clever meta-programming---we can't guarantee it will\\n\", class = c(\"TEXT\", \"tag\")), structure(\"always behave the way we might like!\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"humdata <- readHumdrum('path*.krn')\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdata %hum>% ~table(.)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdata %hum>%\\n\", class = c(\"RCODE\", \"tag\")), structure(\" c(by~Spine, do ~ table(.)) %hum>%\\n\", class = c(\"RCODE\", \"tag\")), structure(\" c(mfcol ~ c(2,2), doplot~barplot(.))\\n\", class = c(\"RCODE\", \"tag\")), structure(\" \\n\", class = c(\"RCODE\", \"tag\")), structure(\"humdata %hum>%\\n\", class = c(\"RCODE\", \"tag\")), structure(\" c(by ~ Spine, do ~ table(.)) %hum<%\\n\", class = c(\"RCODE\", \"tag\")), structure(\" (do ~ sort(.)) \\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_examples\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humPrint.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/humdrumR-class.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humPrint\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humPrint\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"print_humtab\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"-------------------------------------------> NEEDS DOCUMENTATION <-------------------------------------------\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list(structure(list(structure(\"show\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(object)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"print_humtab(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" humdrumR,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" dataTypes = \\\"GLIMDd\\\",\\n\", class = c(\"RCODE\", \"tag\")), structure(\" firstAndLast = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" max.records.file = 40L,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" max.token.length = 30L,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" collapseNull = 10L\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"-------------------------------------------> NEEDS DOCUMENTATION <-------------------------------------------\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Show a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" object in the terminal.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humReference.Rd = structure(list(structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Summary.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humReference\", class = c(\"VERB\", \"tag\" ))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humReference\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"reference\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"reference.character\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"reference.humdrumR\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[.humReference\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"print.humReference\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Summarize reference records in a humdrumR corpus\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"reference(x)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"reference('OTL')\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"reference(humdata)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"[\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humReference\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(refTable, i, j, drop = FALSE)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"reference\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is one of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"'s\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"summary functions\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humSummary\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\", used to\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"tabulate the reference records\\n\", class = c(\"TEXT\", \"tag\")), structure(\"present in a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" corpus.\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"reference\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" takes a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" object\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"and and returns a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humReference\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" table.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Alternatively, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"reference\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" can take a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" string,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"which it will check against known reference codes and print a\\n\", class = c(\"TEXT\", \"tag\")), structure(\"information about matching codes. For instance, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"reference('OTL')\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"returns a description of the standard humdrum \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"!!!OTL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" reference record\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(original title metadata).\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humReference\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\")), structure(\" table has one column for\\n\", class = c(\"TEXT\", \"tag\")), structure(\"each reference code that appears in a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" corpus.\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Since reference records can be long (too much to print on one screen),\\n\", class = c(\"TEXT\", \"tag\")), structure(\"and humdrum files can have multiple of the same type of reference code\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(for instance multiple composers annotated with \\\"!!!COM\\\"),\\n\", class = c(\"TEXT\", \"tag\")), structure(\"by default, a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humReference\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" only prints the number of each type of\\n\", class = c(\"TEXT\", \"tag\")), structure(\"reference record to appear in each file.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, if only one type of reference code is present in a\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humReference\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" table, the complete reference records for that code\\n\", class = c(\"TEXT\", \"tag\")), structure(\"will be printed for each file. Likewise, if only one file is present\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in the table, all of that file's complete reference records are printed.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, if you want to see actualy reference records, try indexing the\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humReference\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" table down to one column or row (see below).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humReference\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" table has one row for each file in the corpus.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Rows are labeled with each file's corresponding\\n\", class = c(\"TEXT\", \"tag\")), structure(\"number (from the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humTable\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"'s \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"File\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" field) and name (the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Filename\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" field).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In addition, when a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humReference\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object is printed,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"three different summary totals are printed for each reference code:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Any\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" indicates how many files in the corpus have at least\\n\", class = c(\"TEXT\", \"tag\")), structure(\"one example of each code in them.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Sum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" indicates the total number of each reference code to appear\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in the corpus, including multiple appearances in one file (like multiple \\\"!!!COM\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"records).\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Finally, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Unique\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" tabulates the number of unique tokens in each reference\\n\", class = c(\"TEXT\", \"tag\")), structure(\"code---if your corpus only hase two unique composers (encoded in \\\"!!!COM\\\"),\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Unique\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" total will be \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"2\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Indexing\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humReference\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" tables can be indexed much like base \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"R\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[data.frames][base::data.frame()], with two arguments: \", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"i\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"(rows) and\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"j\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"(columns). If\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"i\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"or\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"j\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"are\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"numeric\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\", they select rows or columns respectively, ordinally. If \", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"i\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"is a\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"character\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\", it is matched as a regular expression against filenames in the corpus. If \", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"j\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"is a\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"character`, it is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"partially matched\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:pmatch\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"against column names.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"drop\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument is also available. If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", a plain\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[data.table][data.table::data.table()]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" is returned.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humShape.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/humdrumR-class.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humShape\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humShape\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"foldHumdrum\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"foldStops\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"foldPaths\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"foldRecords\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"spinePipe\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"HumdrumR data \\\"Shape\\\"\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"foldHumdrum(humdrumR, byfields, foldAtomic = TRUE, sep = \\\" \\\", padPaths = FALSE)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"foldStops(humdrumR, foldAtomic = TRUE, sep = \\\" \\\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"foldPaths(humdrumR, foldAtomic = TRUE, sep = \\\" \\\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"foldRecords(humdrumR, foldAtomic = TRUE, sep = \\\" \\\", padPaths = FALSE)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"spinePipe(humdrumR, targetSpines, destinationSpines)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" data object.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(see the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum table\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" documentation \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Fields\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" section for explanation.).\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"foldAtomic\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(list( structure(\"logical\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\")), structure(\". If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"foldAtomic == TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", each stop is collapsed to a single string\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"foldAtomic == FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", each stop is collapsed to a list of tokens.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"sep\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(list( structure(\"character\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\")), structure(\". If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"foldAtomic == TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", collapsed tokens are separated by this string.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"pad\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(list( structure(\"logical\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\")), structure(\". Should \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"path/column padding tokens\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humColumns\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" be included?\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_arguments\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"These functions are used to change the \\\"shape\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"of data stored in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum tables\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(held within \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" objects of course).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"-------------------------------------------> NEEDS DOCUMENTATION <-------------------------------------------\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"foldXXX\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" family allows you collapse all\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"user fields\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"across groups in another field.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humSize.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/humdrumR-class.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humSize\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humSize\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"nrecords\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"ntokens\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"npieces\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"anySubcorpora\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"namesSubcorpora\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"nfiles\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"is.empty\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"anyPaths\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"anyStops\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR size and shape\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"nrecords(humdrumR, dataTypes = \\\"D\\\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"ntokens(humdrumR, dataTypes = \\\"D\\\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"npieces(humdrumR)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"anySubcorpora(humdrumR)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"namesSubcorpora(humdrumR)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"nfiles(humdrumR)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"length\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(x)\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list( structure(list(structure(\"nrow\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(x)\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"is.empty(humdrumR)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"anyPaths(humdrumR)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"anyStops(humdrumR)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"These functions can be used to quickly\\n\", class = c(\"TEXT\", \"tag\")), structure(\"get basic information about the size and \\\"shape\\\" of\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" corpus.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For more details, use the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"census\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humSummary\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" function.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"HumdrumR\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" objects can be divided into \\\"subcorpora.\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"anySubcorpora\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"namesSubcorpora\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" functions tell us if there are any subcorpora and, if so, what they are called.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A few common base \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"R\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" methods are defined\\n\", class = c(\"TEXT\", \"tag\")), structure(\"as synonyms for the humdrumR-specific sizing functions:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"length(humdata)\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:length\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" is equivalent to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"npieces(humdata)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\";\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"nrow(humdata)\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:nrow\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" is shortand for \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"nrecords(., dataTypes = 'LIMDd')\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (i.e., local records only).\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"ncol(humdata)\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:nrow\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" returns the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"maximum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" value of the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Column\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" field---the maximum number of\\n\", class = c(\"TEXT\", \"tag\")), structure(\"tab-delineated columns in the humdrum files (irrespective of Spines/Paths).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The results of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"nrow\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"ncol\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will match\\n\", class = c(\"TEXT\", \"tag\")), structure(\"up with the dimensions of matrices/data.frames produced by calls to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.matrix/as.data.frame\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=as.matrix\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"dim(humdata)\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:dim\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" returns \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"c(nrow(humdata), ncol(humdata))\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", as usual.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"is.empty(humdata)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" asks if \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"ntokens(humdata, dataTypes = 'D') == 0L\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humSpines.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Summary.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humSpines\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humSpines\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"spines\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[.humSpines\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"print.humSpines\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Summarize spines in humdrum dataset\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"spines(humdrumR)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"[\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humSpines\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(spines, i, j)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"print\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humSpines\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(spineTable, showEach = TRUE)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This function provides summary of the spines and spine paths in the pieces of a humdrumR corpus.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Other humdrum data summary functions: \\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"humCensus\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"humInterpretations\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"humSummary\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum data summary functions\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_concept\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humSummary.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Summary.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humSummary\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humSummary\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Summarize humdrumR corpora\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list(structure(list(structure(\"summary\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(object, ...)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" includes a number of built in functions for creating quick summaries of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"corpora:\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"census\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humCensus\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Tabulates the raw size of the humdrumR corpus.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"reference\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humReference\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Tabulates reference records (metadata) for each file.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"spines\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humSpines\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Tabulates the number of spines and spine paths in files in the corpus.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"interpretations\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humInterpretations\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Tabulates the types of exclusive and tandem interpretations in the corpus.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"sections\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humSections\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Tabulates any formal data (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"*>\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\") in the corpus.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_enumerate\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Each function takes a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" object and returns a\\n\", class = c(\"TEXT\", \"tag\")), structure(\"special class of data.table.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"summary\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" method for \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR objects\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" calls all of the above functions and prints a condensed version of each.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Other humdrum data summary functions: \\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"humCensus\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"humInterpretations\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"humSpines\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum data summary functions\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_concept\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humTable.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/humdrumR-class.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humTable\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humTable\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"getHumtab\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Humdrum Tables\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"getHumtab(humdrumR, dataTypes = c(\\\"G\\\", \\\"L\\\", \\\"I\\\", \\\"M\\\", \\\"D\\\", \\\"d\\\"))\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"dataTypes\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" vector. Specifies which types of data tokens/records to extract.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"See the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humTable\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" documentation and/or the humdrum syntax vignette for clarification!\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"dataTypes\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", values can be:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\\"G\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\": global comments\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\\"L\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\": local comments\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\\"I\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\": interpretations\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\\"M\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\": barlines\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\\"D\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\": non-null data\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\\"d\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\": null data\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Multiple types can be specified as a vector, or smooshed into a single string: e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"GLIMD\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_arguments\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In the \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" package, the fundamental data structure is called a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Humdrum Table\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A humdrum table encodes all the information in a collection of one or more humdrum-syntax files\\n\", class = c(\"TEXT\", \"tag\")), structure(\"as a single \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"data.table\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"data.table:data.table\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(A \", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"data.table\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is an \\\"enhanced\\\" version of R's standard \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"data.frame\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Humdrum tables are stored \\\"inside\\\" every \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" object that you will work with, and various \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"functions allow you to study or manipulate the them.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If you want to directly access the humdrum table within a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" object, use the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"getHumtab\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" function.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"getHumtab\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" extracts a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum table\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" from a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" object.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In a humdrum table, each row represents a single \\\"token\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in the original humdrum data. Even multistops---tokens separated by spaces---are broken onto\\n\", class = c(\"TEXT\", \"tag\")), structure(\"their own rows. Meanwhile, each column in the humdrum table represents a single\\n\", class = c(\"TEXT\", \"tag\")), structure(\"piece of information associated with each token, which we call a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"field\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Throughout this documentation, you should keep in mind that a \\\"token\\\" refers\\n\", class = c(\"TEXT\", \"tag\")), structure(\"to a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"row\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" in the humdrum table while a \\\"field\\\" refers to a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"column\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\":\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"Token = Row\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(), class = c(\"tag_item\", \"tag\" )), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Field = Column\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Fields:\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"There are five types of fields in a humdrum table:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Data fields\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Structure fields\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Interpretation fields\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Formal fields\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Reference fields\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_enumerate\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"When first created by a call to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" every\\n\", class = c(\"TEXT\", \"tag\")), structure(\"humdrum table has at least nineteen fields: one data field (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Token\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"), two interpretation\\n\", class = c(\"TEXT\", \"tag\")), structure(\"fields (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Tandem\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Exclusive\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"), three formal fields, and fifteen structure fields. Additional\\n\", class = c(\"TEXT\", \"tag\")), structure(\"interpretation or reference fields\\n\", class = c(\"TEXT\", \"tag\")), structure(\"may be present depending on the content of the humdrum file(s), and users can create additional data fields\\n\", class = c(\"TEXT\", \"tag\")), structure(\"by \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"assigning to the object\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humAssignment\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"Data fields:\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Data fields are used to describe individual data points\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in humdrum data (as opposed to groups of points).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Every humdrum table starts with a data\\n\", class = c(\"TEXT\", \"tag\")), structure(\"field called \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Token\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\", which\\n\", class = c(\"TEXT\", \"tag\")), structure(\"contains character strings representing the original strings read from the humdrum files.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Users can create as many additional data fields as they like. Every call to\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"---which can also be called using the\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR:humPipe\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=\\\\%hum>\\\\%\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" piping\\n\", class = c(\"TEXT\", \"tag\")), structure(\"operator---generates one or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"N\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\" new data fields named \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"{Pipe1, Pipe2, ..., PipeN}\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"These fields can be renamed using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"$<-\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" operator.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Structure fields:\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Every humdrum table starts with fifteen Structure fields,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"which describe where each data token was \\\"located\\\" in the original humdrum data: which file, which spine, which record, etc.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"See the vignette on humdrum syntax to fully understand the terms here.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"File info\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\":\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Filename\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" The unique name of the humdrum file. This may include an appended path\\n\", class = c(\"TEXT\", \"tag\")), structure(\"if more than one file with the same name were read from different directories (see the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" docs).\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Filepath\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" The full file name (always includes its full path).\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Label\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" A label specified during the call to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\", associated with a particular\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" \\\"REpath-pattern.\\\" If no label was specified, patterns are just labeled \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"_n\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", where \\\"\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\\" is the\\n\", class = c(\"TEXT\", \"tag\")), structure(\"number of the pattern. (Labels can also be created when \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"merging two humdrumR objects\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humMerge\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".)\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"File\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" A unique number associated with each file (ordered alphabetically, starting from \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"1\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Piece\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" A number specifying the number of the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"piece\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" in the corpus.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This is identical to the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"File\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field except when\\n\", class = c(\"TEXT\", \"tag\")), structure(\"more than one piece were read from the same file.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Location info\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\":\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Spine\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" The spine, numbered (from left-to-right) starting from \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"1\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" This field is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" wherever \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Global == TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Path\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" The \\\"spine path.\\\" Any time a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"*^\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" spine path split occurs in\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the humdrum data, the right side of the split becomes a new \\\"path.\\\" The original path\\n\", class = c(\"TEXT\", \"tag\")), structure(\"is numbered \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"0\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" with additional paths numbered with integers to the right.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(If there are no spine path splits, the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Path\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field is all zeros.)\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" This field is always \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" when \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Global == TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Read the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum columns documentation\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humColumns\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" for a more thorough explanation\\n\", class = c(\"TEXT\", \"tag\")), structure(\"of spine paths.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Column\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" The tab-delineated column in the humdrum file---irrespective of Spine/Paths---, numbered starting from \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"1\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" This field is always \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" when \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Global == TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" See this \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"explanation of columns in humdrumR\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humColumns\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Record\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" The record (i.e., line) number in the original file.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"NData\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"data\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" record enumeration in the file, starting from \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"1\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Stop\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Which token in a multistop token, numbered starting from \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"1\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" In files with no multistops, the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Stop\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field is all \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"1\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" This field is always \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" when \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Global == TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Global\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"logical\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Did the token come from a global record (as opposed to a local record)?\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" When \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Global == TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Spine\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Column\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Stop\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" fields are always \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Token info\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\":\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Type\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" What type of record is it?\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\\"D\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" = non-null data\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\\"d\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" = null data\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\\"I\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" = interpretation\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\\"M\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" = measure/barline\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\\"L\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" = local comment\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\\"G\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" = global comment.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\\"P\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" = null \\\"non-tokens\\\" (see the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR columns\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humColumns\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" documentation for an explanation.)\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Null\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"logical\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Is the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"active\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumR\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" data field null?\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" See the detailed discussion below, in the section of this documentation called \\\"Null Data.\\\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Filter\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"logical\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Has this record/token been \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"filtered out\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=filterHumdrum\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"?\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Interpretation fields:\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Interpretation fields describe interpretation metadata in the humdrum file(s).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Humdrum interpretations are tokens that \\\"carry forward\\\" to data points after them, unless cancelled out by a\\n\", class = c(\"TEXT\", \"tag\")), structure(\"subsequent interpretation. (See the humdrum syntax vignette for a detailed explanation.)\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"All\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" humdrum data must have an \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"exclusive\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" interpretation\\n\", class = c(\"TEXT\", \"tag\")), structure(\"so humdrum tables always have an \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Exclusive\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (:: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") field indicating the\\n\", class = c(\"TEXT\", \"tag\")), structure(\"exclusive interpretation associated with each token/row of the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"active\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumR\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" field.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Humdrum data may, or may not, include additional \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tandem\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" interpretations. A universal rule for parsing\\n\", class = c(\"TEXT\", \"tag\")), structure(\"tandem intepretations is impossible, because A) tandem interpretations can \\\"overwrite\\\" each other and B)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"users can create their own tandem interpretations. The best we can do in all cases is\\n\", class = c(\"TEXT\", \"tag\")), structure(\"identify \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"all\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" tandem interpretations that have appeared previously in the spine\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(counting most recent first). All these previous interpretations are encoded in a single\\n\", class = c(\"TEXT\", \"tag\")), structure(\"character string in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Tandem\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If working with non-standard intrepretations, users can parse the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Tandem\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field using the\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"getTandem\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" function.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If no tandem interpretations occur in a file, the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Tandem\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field is full of empty strings (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Fortunately, many tandem interpretations are widely used and standardized, and these\\n\", class = c(\"TEXT\", \"tag\")), structure(\"interpretations are known by \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". Recognized interpretations (such as \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"*clefG4\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"*k[b-]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\")\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are automatically parsed into their own fields by a call to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"See the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" documentation for more details.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Formal fields:\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Formal fields indicate musical sections, or time windows within\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a piece, including formal designations (\\\"verse\\\", \\\"chorus\\\", etc.) and measures/bars.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Humdrum data may or may not include formal metadata fields, indicated by the token \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"*>\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Classified formal marks are put into fields matching their name.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Unclassified formal marks are placed in a field called \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Formal\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" as a default.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Nested formal categories are appended with an underscore and a number for each level of descent:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Formal_1, Formal_2, ..., Formal_N\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If part of a section is not given a name in a lower hierarchical level, the field is simply\\n\", class = c(\"TEXT\", \"tag\")), structure(\"empty (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") at that point.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Humdrum data may, or may not, also include barlines (tokens beginning \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"=\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Humdrum tables \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"always\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" include three formal fields related to barlines:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Bar\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" How many barline records (single or double) have passed before this token?\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" If no \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"=\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" tokens occur in a file, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Bar\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is all zeros.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Note that this field is independent of whether the barlines are labeled with numbers in the humdrum file!\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"DoubleBar\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" How many \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"double\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\"-barline records have passed before this token?\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" If no \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"==\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" tokens occur in a file, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"DoubleBar\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is all zeros.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"BarLabel\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Any characters that occur in a barline-token \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"after\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" an initial \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"=\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"==\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"These include the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"-\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" in the common \\\"implied barline token \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"=-\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(\"repeat tokens (like \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"=:||\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"), and also any \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"explicit\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" bar numbers.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Note that the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Bar\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field always enumerate \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"every\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" bar record, while\\n\", class = c(\"TEXT\", \"tag\")), structure(\"measure-number labels in humdrum data (which appear in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"BarLabel\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field) may\\n\", class = c(\"TEXT\", \"tag\")), structure(\"do weird things like skipping numbers, repeating numbers, or having suffixes (e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"19a\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If no barline tokens appear in the file, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"BarLabel\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is all empty strings (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Reference fields:\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Reference fields describe any \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Reference Records\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in the humdrum data. Every reference record (records beginning \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"!!!\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") in any\\n\", class = c(\"TEXT\", \"tag\")), structure(\"humdrum file in a corpus read by \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" is parsed into a field named\\n\", class = c(\"TEXT\", \"tag\")), structure(\"by the reference code: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"XXX\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"!!!XXX\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Reference tokens are all identical throughout\\n\", class = c(\"TEXT\", \"tag\")), structure(\"any humdrum piece. If a reference code appears in one file but not another, the field is\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" in the file which does not have the code. If no reference records appear in any\\n\", class = c(\"TEXT\", \"tag\")), structure(\"files read by \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\", no reference fields are created.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Examples of common reference records are \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"!!!COM:\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (composer) and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"!!!OTL:\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (original title).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Any humdrum data with these records will end up having \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"COM\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"OTL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" fields in its humdrum table.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Null Data:\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In humdrum syntax, there is no requirement that every spine-path contains data\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in every record. Rather, spines are often padded with \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"null tokens\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In some cases, entire records may be padded with null tokens.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Each type of humdrum record uses a different null token:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Intepretation\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\": \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"*\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Comment\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\": \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"!\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Barline\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\": \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"=\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Data\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\": \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\".\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Null tokens in a humdrum table are identified in the logical \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Null\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Null\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field is set when a humdrum table is created (by \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\") and is updated everytime\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a new \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"active\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumR\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" field is set.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Null\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is set to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" wherever, either\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" the active field is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data and the token is a single \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\".\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"!\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"=\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"*\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\";\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" the active field is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (including \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NA_character_\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"In parallel to the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Null\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field, null \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"data\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" tokens (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\".\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") are identified as their own record type: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"d\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"All updates/changes to the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Null\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field are also propogated to the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Type\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field---i.e., setting \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Type == d\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" wherever\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a data record is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Null\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This is important/useful because \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" routines are, by default, only applied to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"D\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data, ignoring \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"d\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Whenever you \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"print\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humPrint\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"export\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=writeHumdrum\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" a \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" object, null data in the active field\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(i.e., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Null == TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") print as \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\".\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, if you are working with numeric data, with \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" values, these \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" values will print as \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\".\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Reshaping:\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Breaking the complex syntax of humdrum data into the \\\"flat\\\" structure of a humdrum table, with every single token on one line\\n\", class = c(\"TEXT\", \"tag\")), structure(\"of a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"data.table\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", makes humdrum data easier to analyze.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Of course, thanks to the structure fields, we can easily\\n\", class = c(\"TEXT\", \"tag\")), structure(\"regroup and reform the original humdrum data or use the structure of the data (like spines) in our analyses.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, in some cases, you might want to work with humdrum data in a different structure or \\\"shape.\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"HumdrumR has several options for \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"folding\\\"\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humShape\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" tokens within humdrum tables,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"or otherwise \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"reshaping humdrum data\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humCoercion\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" into data formats/structures you might prefer.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humValidation.Rd = structure(list(structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Validation.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humValidation\", class = c(\"VERB\", \"tag\" ))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humValidation\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"validateHumdrum\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Validate humdrum files\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"validateHumdrum(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" contains = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" recursive = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" errorReport.path = NULL\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"recursive\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(list( structure(\"logical\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\")), structure(\". If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the final part of the search pattern (i.e., the file search)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"is searched for recursively through all sub directories.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"errorReport.path\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(list( structure(\"character\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\")), structure(\". A directory path which, if not \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", an error report is written\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in the file \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"'humdrumR_syntaxErrorReport_date.txt'\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". In addition, all files with errors\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are written to this directory (with \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"'errorMarkup'\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" appended to their names), with\\n\", class = c(\"TEXT\", \"tag\")), structure(\"errors annotated inline.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"patterns\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(list( structure(\"character\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\")), structure(\" vector. Search pattern(s) for identifying files\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(see \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[readHumdrum][readHumdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\").\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"files\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A list of character strings, each representing a record in a file.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_arguments\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This function checks files for violations of the\\n\", class = c(\"TEXT\", \"tag\")), structure(\"humdrum syntax.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humWindows.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Windows.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humWindows\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humWindows\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"windows\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"hop\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"nest\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Applying functions across arbitrary windows.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"----------------------------------------------> NEEDS DOCUMENTATION <----------------------------------------------------\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"windows(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" df,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" form,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" with = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" start = 1L,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" end = nrow(df),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" bounds = \\\"exclude\\\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"hop(vec, pattern, start = 1L, end = length(vec))\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"nest(vec, open, close, depth = 1)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Applying functions across arbitrary windows.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"----------------------------------------------> NEEDS DOCUMENTATION <----------------------------------------------------\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humdrumDispatch.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Compose.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumDispatch\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumDispatch\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"makeDispatchDF\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"makeHumdrumDispatcher\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"print.humdrumDispatch\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Regular expression method dispatch and function application\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"humdrumDispatch(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" str,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" dispatchDF,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" Exclusive = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" multiDispatch = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" outputClass = \\\"character\\\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"makeDispatchDF(...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"makeHumdrumDispatcher(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" funcName = \\\"humdrum-dispatch\\\",\\n\", class = c(\"RCODE\", \"tag\")), structure(\" outputClass = \\\"character\\\",\\n\", class = c(\"RCODE\", \"tag\")), structure(\" args = alist()\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list( structure(list(structure(\"print\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrumDispatch\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x)\\n\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"str\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"The input \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" string, on which dispatch is called.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"dispatchDF\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A data.frame which describes what function should be called for\\n\", class = c(\"TEXT\", \"tag\")), structure(\"which regex input. (See details).\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Exclusive\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Defaults to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", only the regexes are used for dispatch.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"multiDispatch\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(list( structure(\"logical\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\")), structure(\", length 1. If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (the default) the \\\"best\\\" regex/exclusive match\\n\", class = c(\"TEXT\", \"tag\")), structure(\"is dispatched for each Exclusive segment. If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", differenet functions can be dispatched\\n\", class = c(\"TEXT\", \"tag\")), structure(\"within the same input vector.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"...\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Arguments to pass to dispatch functions.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"outputClass\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Character string: the default output class which the function should return.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Generally, to make sense, all dispatched functions should return the same type, which you should explicitly\\n\", class = c(\"TEXT\", \"tag\")), structure(\"indicate with the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"outputClass\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Dispatch functions should also be \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"vectorized\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:Vectorize\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\", class = c(\"TEXT\", \"tag\" ))), class = \"tag\")), class = c(\"tag_item\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_arguments\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"regular-expression method dispatch system\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"is a simple system for making new functions which can by smartly\\n\", class = c(\"TEXT\", \"tag\")), structure(\"applied to a variety of character strings.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Humdrum dispatch works like normal R method dispatch, but instead of dispatching specific methods\\n\", class = c(\"TEXT\", \"tag\")), structure(\"based on their class (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", etc.) it dispatches based on regular expressions.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In addition, exclusive interpretations can be used to guide dispatch.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Many \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" functions are in fact, humdrum-dispatch functions: for example, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"tonalInterval.character()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=tonalInterval.character\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If you call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval('ee-')\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the function will recognize that the input string is a token in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"**kern\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"representation, and call the appropriate parser.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If you instead call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval('me')\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the function will recognize that the input string is a token in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"**solfa\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"representation, and call the appropriate parser for that.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"dispatchDF\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"dispatchDF\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" must be a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"data.table::data.table()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"data.table:data.table\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" created using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"makeDispatchDF\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" function.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"makeDispatchDF\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" takes one or more arguments, each a list with three components (ordered, not nameed):\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" A character vector of exclusive interpretations. (Specify \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"any\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" if you don't want exclusive dispatch).\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" A regular expression (character string) or a function which can generate a regular expression, which accepts \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"...\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"arguments at the time of dispatch.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" A function to dispatch.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_enumerate\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"makeHumdrumDispatcher\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"makeHumdrumDispatcher\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is a function which creates a new function which automatically performs humdrum-dispatch.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A number of important \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" functions are created with \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"makeHumdrumDispatcher\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\":\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"tonalInterval.character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"diatonicSet.character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"tertianSet.character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"rhythmInterval.character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"u <- c('A', 'B', 'CD', 'E', 'F', 'gh', 'L', 'KX')\\n\", class = c(\"RCODE\", \"tag\")), structure(\"l <- c('a', 'b', 'cd', 'e', 'f', 'gh', 'l', 'kx')\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"lowercasefunc <- \\\\(x) 5L - nchar(x)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdrumDispatch(l, outputClass = 'integer',\\n\", class = c(\"RCODE\", \"tag\")), structure(\" makeDispatchDF(list('any', '[a-z]+', lowercasefunc),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" list('any', '[A-Z]+', nchar)))\\n\", class = c(\"RCODE\", \"tag\")), structure(\" # lowercasefunc will be called on l, nchar on u\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_examples\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humdrumPitch.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/humdrumR-package.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumPitch\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumPitch\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR and pitch\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumR\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" includes a number of intertwined data structures, and associated functions, for representing and manipulating musical pitch information.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Tonality\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"There are four data types extensively used in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" to encode/process \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Tonality\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"tonal\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" musical information:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"integers\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:integer\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" --- used to encode \\\"\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"line-of-fifths\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"\\\" tonal information\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"tonalInterval\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" --- embeds line-of-fifth tonal integers alongside \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Octave\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"octave\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"\\\"https://en.wikipedia.org/wiki/Cent_(music)\\\"\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"cent\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" information to encode most tonal pitch representations (solfege, intervals, letternames, etc.)\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"diatonicSet\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" --- combines line-of-fifth tonal integer representations to represent diatonic tonality, including alterations of basic diatonic scale(s).\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"tertianSet\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" --- an extension of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" used to encode \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Tertian\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"tertian\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" diatonic harmonies.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"For a detailed explanation of the theory and specifics of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"'s treatment of tonality, see the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Tonality in humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" vignette.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Atonality\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"THIS SECTION IS INCOMPLETE\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In addition, there are xxx data types used to encode non-tonal (or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Atonality\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"atonal\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\") pitch information.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"integers\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:integer\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" --- used to encode \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Semitone\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"semitones\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" (as well as \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/MIDI\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"MIDI\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" numbers).\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"xxx\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" --- sets?\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"xxx\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" --- 12-tone rows?\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humdrumR.Rd = structure(list(structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/humdrumR-package.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"package\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_docType\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humdrumR\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humdrumR\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humdrumR\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\")), structure(\" is a toolkit for the analysis of data encoded in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"http://www.humdrum.org/guide/ch05/\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrum syntax\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"The humdrum syntax is an incredibly flexible, and powerful, scheme for encoding musical data.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Tens of thousands of musical scores (and other musical data) have been encoded in the humdrum syntax, many available online through repositories such as\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"http://kern.ccarh.org/\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"KernScores\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is intended as a modernized replacement for the original \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"http://www.humdrum.org/\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrum toolkit\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\" )), structure(\", levaraging\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"the power of R to give us enprecedented power to manipulate and analyze humdrum data using concise, expressive syntax.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Package design\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The package \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" has XXX main components:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\" )), structure(\" To represent humdrum data in R, we have the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"http://adv-r.had.co.nz/S4.html\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"S4 class\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\", and it's core component\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum table\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(), class = c(\"tag_item\", \"tag\" )), structure(\" To create \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data, a sophisticated humdrum data parser: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data can also be written back to humdrum-syntax text files using \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"writeHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" To filter and \\\"index\\\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data, we have the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"filterHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" function, which can also be called in a variety of\\n\", class = c(\"TEXT\", \"tag\")), structure(\"short hands using R's standard \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"indexing operators\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:Extract\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\": \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[]]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" To manipulate and modify \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data, we have the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"with(in)Humdrum\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=with-in-Humdrum\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"humApply\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" functions.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" A set of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"pipe\\\" operators\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humPipe\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hum>%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hum<%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\", etc.), so that \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data can be manipulated and filtered in concise,\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Vertical_bar#Pipe\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"bash-style pipes\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(), class = c(\"tag_item\", \"tag\" )), structure(\" To facilate the development of functions to work with humdrum tokens---which are simple character strings packed with information---,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a useful API we call our \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"regular-expression dispatch system\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumDispatch\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(), class = c(\"tag_item\", \"tag\" )), structure(\" Several \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"modules\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumPitch\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" for representing and manipulating musical pitch information,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"including our core \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" class to represent tonal pitch.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" A \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"module\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humRhythm\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" for representing and manipulating musical rhythm information,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"with a core \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" class to represent rhythms.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"internal\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_keyword\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humdrumRclass.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/humdrumR-class.R, R/Filter.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"class\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_docType\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"makeHumdrumR\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRS4\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"is.humdrumR\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"$,humdrumR-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"fields\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"$<-,humdrumR,vector-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"$<-,humdrumR,humdrumR-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[<-,humdrumR,character,ANY,vector-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[<-,humdrumR,character,ANY,humdrumR-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[,humdrumR,missing,character-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[,humdrumR,missing,missing-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[,humdrumR,formula,missing-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[,humdrumR,missing,formula-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"HumdrumR class\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"is.humdrumR(x)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"$\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(x, name)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"fields(\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" humdrumR,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" fieldTypes = c(\\\"Data\\\", \\\"Structure\\\", \\\"Interpretation\\\", \\\"Formal\\\", \\\"Reference\\\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list( structure(list(structure(\"$\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrumR,vector\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(x, name) <- value\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"$\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrumR,humdrumR\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(x, name) <- value\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"[\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrumR,character,ANY,vector\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(x, i, j) <- value\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"[\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrumR,character,ANY,humdrumR\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(x, i, j) <- value\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdata[[ , 'regex']]\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdata[[ , , ~expression]] or humdata [[ , , 'regex']] or humdata[[z = ~expression]] or humdata[[z = 'regex']]\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdata[[~expression]]\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdata[[ , ~expression]]\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"S4\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" class is the basic unit of the\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" package.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Each \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object represents data \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"read\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=readHumdrum\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" from one or\\n\", class = c(\"TEXT\", \"tag\")), structure(\"more humdrum files.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In the documentation we refer to the collection of files within a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" object\\n\", class = c(\"TEXT\", \"tag\")), structure(\"as a \\\"\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"corpus\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\",\\\" and each file as a \\\"\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"piece\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\".\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, though humdrum data is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"usually\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" encoded as one \\\"piece\\\" per file, this is not necessarily the case:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"files might represent movements within a piece, or even just a part of a score. Still, we tend to refer\\n\", class = c(\"TEXT\", \"tag\")), structure(\"to them as \\\"pieces.\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In coding examples, we name humdrumR objects \\\"\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The most imporant part of a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object is the\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum tables\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" it holds within it.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In essence, an \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object is simply a wrapper around these\\n\", class = c(\"TEXT\", \"tag\")), structure(\"humdrum tables, which helps users to\\n\", class = c(\"TEXT\", \"tag\")), structure(\"to visualize, index, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"summarize\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humSummary\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\", and \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"manipulate\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=withinHumdrum\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the table in a variety of ways.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Basic information about the size and shape of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data can be\\n\", class = c(\"TEXT\", \"tag\")), structure(\"obtained with calls to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"nrecords, npieces, length, ncol, etc.\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humSize\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"More detailed summary information can be obtained with the humdrumR \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"corpus summary functions\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humSummary\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"HumdrumR data can also be coerced to more basic R data types using \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.matrix, as.data.frame, etc.\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humCoercion\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"A number of helpful functions are also defined to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"reshape\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humShape\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" humdrumR data.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"The most powerful features of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" are the tools it gives you to\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Filter humdrum data, using \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"filterHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" and the standard R \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"indexing operators\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:Extract\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\": \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"[]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[]]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Apply functions and arbitrary commands to humdrum data using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"with(in)Humdrum\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=withinHumdrum\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" routines,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"and their associated \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"piping operators\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humPipe\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_enumerate\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Slots\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(list( structure(\"Humtable\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A list of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum tables\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\", each having the same fields\\n\", class = c(\"TEXT\", \"tag\")), structure(\"but containing data from different types of records (e.g., interpretations, data, barlines, comments).\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(list( structure(\"Files\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A list of two elements. The first, \\\"Search\\\", contains a single character representing\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pattern\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" used in the call to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" which created this humdrumR object.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The second, \\\"Names\\\", is a vector of strings representing all the files which matched the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pattern\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"and were read into the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(list( structure(\"Fields\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A list containing strings corresponding to the existing fields in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The fields are divided into five categories: \\\"Data\\\", \\\"Structure\\\", \\\"Interpretation\\\", \\\"Formal\\\", and \\\"Reference\\\"---see\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum table\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" documentation.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(list( structure(\"Active\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A quosure expression which\\n\", class = c(\"TEXT\", \"tag\")), structure(\"extracts data from field(s) in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum table\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\": the \\\"active expression.\\\"\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(list( structure(\"LoadTime\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"POSIXct\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:DateTimeClasses\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" value, indicating the time at which \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" was\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"called to create this \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(list( structure(\"Patterns\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A character vector of the original search patterns used to match files in the system.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_describe\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Active field\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Active\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" slot of a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" object contains an \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"expression\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"rlang:quosure\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"which refers to fields in the internal \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum table\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Go to the dedicated \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"active field\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humActive\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" documentation to learn more about this important slot!\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humdrumRroot.Rd = structure(list(structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/humdrumR-package.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"data\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_docType\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humdrumRroot\", class = c(\"VERB\", \"tag\" ))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRroot\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"'s root directory on your machine.\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"An object of class \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" of length 1.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_format\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"humdrumRroot\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRroot\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is the path to where the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" package is install on your machine.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A few simple humdrum files are stored here.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"datasets\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_keyword\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), interpolateArguments.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Apply.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"interpolateArguments\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"interpolateArguments\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Change or insert values in an expression\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"interpolateArguments(quo, namedArgs)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"namedArgs\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A list of named arguments. Unnamed arguments are simply ignored.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"expr\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A unevaluated expression object.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_arguments\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This function can be used to modify arguments to a functions\\n\", class = c(\"TEXT\", \"tag\")), structure(\"within an existing expression (or quosure/formula).\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"interpolateArguments\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" inteprets named value in its \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"namedArgs\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"argument in one of two ways: If the named value is a list, it interprets\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the name of the list as a function call, and inserts/swaps any arguments\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in that list into any instances of that function call within the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"expr\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Named arguments are inserted or substituted if already present in expression.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Unnamed argmuments are simply added to the call.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Examples:\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"myexpr <- quote(dnorm(x, mean = 5))\\n\", class = c(\"VERB\", \"tag\")), structure(\"interpolateArguments(myexpr, list(dnorm = list(mean = 2, sd = 5, TRUE)))\\n\", class = c(\"VERB\", \"tag\")), structure(\"\\n\", class = c(\"VERB\", \"tag\")), structure(\"# result is new expresson: dnorm(x, mean = 2, sd = 5, TRUE)\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If a named valued in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"namedArgs\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument is not a list,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"that name/value pair is substituted anywhere it is present in the expression.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This approach is often more conscise, but arguments cannot be added to an\\n\", class = c(\"TEXT\", \"tag\")), structure(\"expression this way, only substituted if already present.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Examples:\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"myexpr <- quote(dnorm(x, mean = 5))\\n\", class = c(\"VERB\", \"tag\")), structure(\"interpolateArguments(myexpr, mean = 2)\\n\", class = c(\"VERB\", \"tag\")), structure(\"\\n\", class = c(\"VERB\", \"tag\")), structure(\"# result is new expression: dnorm(x, mean = 2)\\n\", class = c(\"VERB\", \"tag\")), structure(\"}\\n\", class = c(\"VERB\", \"tag\" ))), class = c(\"tag_preformatted\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"myexpr2 <- quote(A + b*x + rnorm(length(a), mean(Z), sd = 2))\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"interpolateArguments(myexpr2,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" list(sd = 10, mean = list(na.rm = TRUE)))\\n\", class = c(\"RCODE\", \"tag\")), structure(\" \\n\", class = c(\"RCODE\", \"tag\")), structure(\"# result is new expression: \\n\", class = c(\"RCODE\", \"tag\")), structure(\"# a + b*x + rnorm(length(a), mean(Z, na.rm = TRUE), sd = 10)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_examples\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), intervalCalculus.Rd = structure(list(structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/tools.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"intervalCalculus\", class = c(\"VERB\", \"tag\" ))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"intervalCalculus\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integrate\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"sigma\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"derive\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"delta\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"calculus\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Interval \\\"calculus\\\"\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"integrate(intervals, skip = list(is.na))\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"sigma(intervals, skip = list(is.na))\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"derive(intervals, skip = list(is.na))\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"delta(intervals, skip = list(is.na))\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"calculus(x, n, skip = list(na))\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Interval \\\"calculus\\\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), keyTransformer.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/diatonicSet.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"keyTransformer\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"keyTransformer\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"key\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Parsing and deparsing key information\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"key(x, ..., Key = NULL, parseArgs = list(), memoize = TRUE, deparse = TRUE)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"XXX\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), lag.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/tools.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"lag\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"lag\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"lead\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Shift data within a vector/matrix/data.frame\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"lag(x, n = 1, fill = NA, wrap = FALSE, windows = NULL, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"lead(x, n, ...)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"x\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"The input argument. Should be vector (including lists), array, or data.frame\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"The amount to lag/lead the data.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"fill\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"wrap = FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and/or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"windows = NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", parts of the output are padded with the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"fill\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument. Defaults to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"wrap\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"wrap = TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", data from the end (head or tail) is copied to the other end of the output, \\\"wrapping\\\" the data\\n\", class = c(\"TEXT\", \"tag\")), structure(\"within the data structure.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"windows\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A vector or list of vectors, all of th same length as \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"x\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". Lags crossing the boundaries indicated in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"windows\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are filled.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"margin\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Arrays and data.frames can be lagged lead in multiple dimensions using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"margin\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_arguments\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"lag\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"lead\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" functions take input vectors, matrices, or data.frames and shifts their data\\n\", class = c(\"TEXT\", \"tag\")), structure(\"by \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" indices.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"They are similiar to the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"data.table::shift\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"data.table:shift\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" function, but with a few additional options:\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"data.table::shift()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"data.table:shift\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), metricPosition.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/rhythmInterval.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"metricPosition\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"metricPosition\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Calculate metric positions from duration data.\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"metricPosition(rints, bars = NULL, beats = rint(c(2, 4, 8, 16, 32)))\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Calculate metric positions from duration data.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Other rhythm analysis tools: \\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"rhythmDecompose\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"()\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"rhythmOffset\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"()\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythm analysis tools\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_concept\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), pitchFunctions.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/tonalInterval.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pitchFunctions\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pitchFunctions\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"semit\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"midi\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pitch\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"kern\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"lilypond\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"interval\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"degree\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"solfa\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Manipulate pitch data\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"semit(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" Key = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" Exclusive = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parseArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" transposeArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" inPlace = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" memoize = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" deparse = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"midi(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" Key = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" Exclusive = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parseArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" transposeArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" inPlace = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" memoize = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" deparse = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"pitch(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" Key = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" Exclusive = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parseArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" transposeArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" inPlace = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" memoize = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" deparse = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"kern(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" Key = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" Exclusive = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parseArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" transposeArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" inPlace = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" memoize = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" deparse = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"lilypond(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" Key = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" Exclusive = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parseArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" transposeArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" inPlace = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" memoize = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" deparse = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"interval(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" Key = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" Exclusive = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parseArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" transposeArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" inPlace = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" memoize = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" deparse = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"degree(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" Key = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" Exclusive = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parseArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" transposeArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" inPlace = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" memoize = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" deparse = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"solfa(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" Key = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" Exclusive = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parseArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" transposeArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" inPlace = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" memoize = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" deparse = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Manipulate pitch data\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"tonalInterval\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), plotRhythm.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Graphics.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"plotRhythm\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"plotRhythm\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"plotRhythm.default\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"plotRhythm.rhythmInterval\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"-------------------------------------------> NEEDS DOCUMENTATION <-------------------------------------------\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Plotting rhythmic symbols in R base graphics\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"plotRhythm(x, y, notes, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"plotRhythm\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"default\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x, y, notes, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"plotRhythm\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x, y, notes, ...)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"-------------------------------------------> NEEDS DOCUMENTATION <-------------------------------------------\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Plotting rhythmic symbols in R base graphics\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), rational.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/tools.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rational\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rational\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.rational\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"fraction\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.fraction\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Rational numbers\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"rational(numerator, denominator = 1)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"as.rational(x, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"fraction(numerator, denominator, sep = \\\"/\\\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"as.fraction(x, sep, ...)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"R has no built in rational number representation; \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" defines one.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"as.decimal()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=as.decimal\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"as.numeric()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=as.numeric\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Other \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR numeric functions\", class = c(\"TEXT\", \"tag\"))), class = c(\"LIST\", \"tag\")), structure(\": \\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"decimal\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"()\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"humdrumR numeric functions\", class = c(\"TEXT\", \"tag\"))), class = c(\"LIST\", \"tag\"))), class = c(\"tag_concept\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), readHumdrum.Rd = structure(list(structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Read.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"readHumdrum\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"readHumdrum\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"findHumdrum\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"Find and read humdrum files into R\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"findHumdrum(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" contains = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" recursive = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" allowDuplicates = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" verbose = FALSE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"readHumdrum(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" recursive = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" contains = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" allowDuplicates = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" verbose = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" tandems = \\\"known\\\",\\n\", class = c(\"RCODE\", \"tag\")), structure(\" reference = \\\"all\\\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"...\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"character: One or more patterns used to identify files to read.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For details: see the \\\"REpath-patterns\\\" section below.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"contains\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(list( structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"!is.null(contains)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"contains\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument is\\n\", class = c(\"TEXT\", \"tag\")), structure(\"is treated as regular expressions: only files which contain matches to\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"all\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" of these regular expressions are read.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"readHumdrum('.*krn$', contains = \\\"EEE\\\")\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will only read kern files which contain matches\\n\", class = c(\"TEXT\", \"tag\")), structure(\"to \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\\"EE\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"---which is kern for the E two octaves below middle C (or lower).\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"recursive\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"logical: If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the final part of the search pattern (i.e., the file search) is searched for\\n\", class = c(\"TEXT\", \"tag\")), structure(\"recursively through all sub directories.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"allowDuplicates\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(list( structure(\"logical\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" of length one, indicating what should happen if multiple search patterns match the same files.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"allowDuplicates = TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(\"any such files are read multiple times, grouped into their respective corpora by the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Label\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"allowDuplicates = FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", any redundant files are only read into the corpus of the first pattern they\\n\", class = c(\"TEXT\", \"tag\")), structure(\"match.\", class = c(\"TEXT\", \"tag\" ))), class = \"tag\")), class = c(\"tag_item\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"verbose\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"logical: If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the names of matching files are printed before parsing begins. This is very\\n\", class = c(\"TEXT\", \"tag\")), structure(\"useful as a check to make sure you aren't reading the wrong files!\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"tandems\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(list( structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". This argument controls which, if any, tandem interpretations\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are parsed into their own fields. The default value is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"known\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"reference\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(list( structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". This argument controls which, if any, reference records\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are parsed into their own fields. The default value is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"all\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_arguments\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"These functions find valid humdrum files on your local machine and read them into \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"findHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" does the work of finding and reading the text files into R.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" utilizes \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"findHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" to read files, then parses them to\\n\", class = c(\"TEXT\", \"tag\")), structure(\"create a \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"humTable\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" and build\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a \", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" data object around the table.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"REpath-patterns\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\\"REpath-patterns\\\" are specified using \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"...\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" arguments.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In combination, all the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"...\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" arguments are used to search for file paths.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Each part of the search path you specify (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"dirpart/dirpart/filepart\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", etc) are matched as regular expressions\\n\", class = c(\"TEXT\", \"tag\")), structure(\"against directories/files on your disc.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, we can say things like \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"findHumdrum(\\\"../^A.*/.*krn$\\\")\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", which would\\n\", class = c(\"TEXT\", \"tag\")), structure(\"match any kern files in any directory beginning with a capital \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"A\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" in the\\n\", class = c(\"TEXT\", \"tag\")), structure(\"directory above the current working directory.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For conveniance, you can break the path across multiple arguments instead of using delimited strings: For example, the code\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"findHumdrum(\\\"..\\\", \\\"^A.*\\\", \\\".*krn$\\\")\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will give an identical result as the previous example\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"findHumdrum(\\\"../^A.*/,*krn$\\\")\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This is useful when searching for more than one pattern (see next paragraph) in the same directory.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If you want to search for \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"more than one\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" pattern, you can input them as a character vector:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For instance, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum(c(\\\"mozart\\\", \\\"beethoven\\\")\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"---this command will search for\\n\", class = c(\"TEXT\", \"tag\")), structure(\"filenames containing \\\"mozart\\\" OR \\\"beethoven.\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This works for directories too: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum(c(\\\"Mozart\\\", \\\"Beethoven\\\"), \\\".*krn$\\\")\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will\\n\", class = c(\"TEXT\", \"tag\")), structure(\"look for any kern files in directories containing \\\"Mozart\\\" OR \\\"Beethoven.\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If patterns are named, these names will show up as identifying patterns in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humdrumR][humdrumR]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" object's\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Label\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field. Unnamed patterns are simply labeled with numbers.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Normal (system appropriate) conventions (i.e., directories separated by \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"/\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"'~'\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" at beginning to indicate home, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"..\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" to indicate directory above working directory, etc.)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are followed.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If a pattern contains a solo dot followed by a file sep---e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"./\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"x/./y\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"---this is\\n\", class = c(\"TEXT\", \"tag\")), structure(\"treated as the current directory, not a regular expression.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If a pattern contains two dots---e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"../\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"---this is treated as the directory above, not a regular expression.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If you want to create a regular expression to match any directory, use \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\".*/\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The regex pattern \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" matches any file (it is changed to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\".*\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"). If you don't specifiy any \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"...\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument,\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"findHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") will default to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\".*\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" as well.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum()\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will read any humdrum files in the working directory.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(If two or more files in different directories share the same name, a unique name is created for\\n\", class = c(\"TEXT\", \"tag\")), structure(\"each file by appending the names of the directories they occupy, recursively\\n\", class = c(\"TEXT\", \"tag\")), structure(\"until the names are unique.)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If a single humdrum file has multiple pieces in it---meaning that all spine paths close with \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"*-\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\", then\\n\", class = c(\"TEXT\", \"tag\")), structure(\"open again with \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"**\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"---then they are parsed separetely.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"They are distinguished in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Piece\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If there are no multi-piece files, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Piece\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"File\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will be identical.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Validity\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"findHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" automatically ignore non-text files.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Whatsmore, any files which contain humdrum syntax errors (checked by \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[validateHumdrum][validateHumdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\") are automatically\\n\", class = c(\"TEXT\", \"tag\")), structure(\"skipped. If you want to see specifically what errors occured, call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[validateHumdrum][validateHumdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"directly and its \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"errorReport.path\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Tandem Interpretations\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tandems\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument controls which tandem interpretations\\n\", class = c(\"TEXT\", \"tag\")), structure(\"parsed into their own fields. This can be helpful to either save processing time and memory\\n\", class = c(\"TEXT\", \"tag\")), structure(\"by \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"not\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" parsing interpretations you won't need, or to parse interpretations that\\n\", class = c(\"TEXT\", \"tag\")), structure(\"humdrumR doesn't recognize.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \\\"known\\\" tandem interpretations that humdrumR recognizes are encoded in a build humdrumR\\n\", class = c(\"TEXT\", \"tag\")), structure(\"table called \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"knownInterpretations\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Each interpretation has a humdrumR name (\\\"Clef\\\", \\\"TimeSignature\\\", etc.) as well as a regular expression\\n\", class = c(\"TEXT\", \"tag\")), structure(\"associated with it.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The default value for the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tandems\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"known\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". If the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tandems\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument\\n\", class = c(\"TEXT\", \"tag\")), structure(\"contains \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"known\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"all\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" tandem interpretations in the built-in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"knownInterpretations\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"table are parsed.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Users may specify different interpretations to parse in two ways:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" character strings\\n\", class = c(\"TEXT\", \"tag\")), structure(\"matching one of the name values from the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Name\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" column of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"knownInterpretations\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For instance, if you specify \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tandems = c('Clef', 'TimeSignature')\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", only clef (e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"*clefG2\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"),\\n\", class = c(\"TEXT\", \"tag\")), structure(\"and time signature (e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"*M3/4\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") intepretations will be parsed.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" if the chracter string(s) in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tandem\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" do not exactly match one of the names in\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"knownInterpretations$Name\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", they are treated as regular expressions and used to match\\n\", class = c(\"TEXT\", \"tag\")), structure(\"tandem interpretations in the data. This allows users to parse non-standard tandem interpretations\\n\", class = c(\"TEXT\", \"tag\")), structure(\"that humdrumR doesn't already know about.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_enumerate\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If any values in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tandems\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" are named, these names will be used for resulting fields.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If no matches to an given interpretation are found, no field is created for that interpretation.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"tandems = NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", then no tandem interpretations are parsed.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Reference Records\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"By default (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"reference = \\\"all\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"), humdrumR reads all reference records in the data.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The reference code for each record (e.g, the \\\"OTL\\\", in \\\"!!!OTL: xxx\\\") is used as the name of\\n\", class = c(\"TEXT\", \"tag\")), structure(\"an associated field.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(If a reference record has no reference code (i.e., it lacks a colon), the field is called \\\"Unkeyed.\\\")\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In large datasets with many reference records, the reference data can actually make up a large portion\\n\", class = c(\"TEXT\", \"tag\")), structure(\"of the humdrum table, and eat up a lot of memory. In these cases, we might not want to read\\n\", class = c(\"TEXT\", \"tag\")), structure(\"all (or any) reference records---we can instead read only the reference records that we are planning to use\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in our analyses (if any).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"reference = NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", no reference records are parsed.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Otherwise, the character values of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"reference\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" are treated as reference codes and only\\n\", class = c(\"TEXT\", \"tag\")), structure(\"matching reference records are parsed.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For instance, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum(_, reference = \\\"OTL\\\")\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" will \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"only\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" parse OTL reference records.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If the values of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"reference\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" are named, these names are used to name associated fields.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, by specifing \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"reference = c(Title = 'OTL')\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", you can use \\\"OTL\\\" reference records to populate\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a field called \\\"Title\\\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If there are more than one reference records with the same reference code,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"either explicitely numbered (e.g., \\\"!!!COM1:\\\", \\\"!!!COM2:\\\") all are read and rather than making two\\n\", class = c(\"TEXT\", \"tag\")), structure(\"or more fields, a single field is created (\\\"COM\\\" in this) with the multiple values separated by \\\";\\\".\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Result\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"findHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" returns a \\\"fileFrame\\\" (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"data.table\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"), listing all file names,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the patterns they match, the directories they were found in, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"and\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" the raw text content of these files.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"readHumdrum\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\")), structure(\" returns a fully parsed \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"readHumdrum() # loads all valid humdrum files in the current directory.\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"readHumdrum(\\\".*krn$\\\") # loads all files ending with \\\"krn\\\" in the currect directory\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"readHumdrum(\\\"^Composers$/^Be|^Mo/.*/^Joined$/.*krn$\\\") \\n\", class = c(\"RCODE\", \"tag\")), structure(\"# Goes inside the directory \\\"Composers\\\".\\n\", class = c(\"RCODE\", \"tag\")), structure(\"# Inside \\\"Composers\\\" looks for directories that start with \\\"Be\\\" or \\\"Mo\\\".\\n\", class = c(\"RCODE\", \"tag\")), structure(\"# If there are any \\\"Be|Mo\\\" matching directories within \\\"Composers\\\", matches all directories within them.\\n\", class = c(\"RCODE\", \"tag\")), structure(\"# Within these directories, looks for directories called \\\"Joined\\\".\\n\", class = c(\"RCODE\", \"tag\")), structure(\"# If there are any directories called \\\"Joined\\\", loads all files (if any) that end with \\\"krn\\\".\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"readHumdrum(\\\"^Composers$\\\", \\\"^Be|^Mo\\\", \\\".*\\\", \\\"^Joined$\\\", \\\".*krn$\\\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\"# exactly the same as the previous!\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"readHumdrum(\\\"^Composers$\\\", c(Beethoven = \\\"^Be\\\", Mozart = \\\"^Mo\\\"), \\\".*\\\", \\\"^Joined$\\\", \\\".*krn$\\\") \\n\", class = c(\"RCODE\", \"tag\")), structure(\"# exactly the same as the previous, except now the two matching patterns (\\\"^Be\\\", or \\\"^Mo\\\") will be grouped\\n\", class = c(\"RCODE\", \"tag\")), structure(\"# in the Label field as \\\"Beethoven\\\" and \\\"Mozart\\\" respectively.\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_examples\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), regexConstruction.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Regex.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"regexConstruction\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"regexConstruction\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"captureRE\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"captureUniq\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"orRE\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Making Regular Expressions\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"captureRE(strs, n = \\\"\\\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"captureUniq(strs, zero = TRUE)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"orRE(...)\\n\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" includes some helpful functions for creating new regular expressions which work with the\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"stringr\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" package.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"captureRE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will take a character vector and collapse it to a \\\"capture group.\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument can be used to append a number tag, for instance \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"'*'\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (zero or more) to the group.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"I.e., \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"captureRE(c(\\\"a\\\", \\\"b\\\", \\\"c\\\"), '*')\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will output \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"[abc]*\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"captureUniq\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will make a similar capture group to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"captureRE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", but with an expression\\n\", class = c(\"TEXT\", \"tag\")), structure(\"that makes sure that only 1 or more \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"of the same character\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" repeats.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For instance, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"captureUniq(c('a', 'b','c'))\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will return \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"([abc])\\\\\\\\1*\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"---this expression will match\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"aaa\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"bb\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" but not \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"aabb\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), rhythmDecompose.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/rhythmInterval.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmDecompose\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmDecompose\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Decompose durations in terms of other durations\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"rhythmDecompose(rhythmInterval, into = rint(c(1, 2, 4, 8, 16, 32)))\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Decompose durations in terms of other durations\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Other rhythm analysis tools: \\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"metricPosition\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"()\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"rhythmOffset\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"()\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythm analysis tools\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_concept\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), rhythmFunctions.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/rhythmInterval.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmFunctions\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmFunctions\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"recip\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"duration\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Manipulate pitch data\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"recip(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" Exclusive = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parseArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" timeArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" inPlace = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" memoize = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" deparse = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"duration(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" Exclusive = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parseArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" timeArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" inPlace = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" memoize = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" deparse = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Manipulate pitch data\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"rhythmInterval\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), rhythmInterval.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/rhythmInterval.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rint\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.character,rhythmInterval-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.double.rhythmInterval\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"is.rhythmInterval\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"is.numeric,rhythmInterval-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"order.rhythmInterval\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Compare,rhythmInterval,rhythmInterval-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Summary,rhythmInterval-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval.logical\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval.NULL\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval.numeric\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval.rational\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval.fraction\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval.integer\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval.character\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Representation of rhythmic information\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"rhythmInterval(x, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"rint(denominator, numerator = 1L)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"as.character\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(x)\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list( structure(list(structure(\"as.double\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x)\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"is.rhythmInterval(x)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"is.numeric\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(x)\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"order.rhythmInterval(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" na.last = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" decreasing = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" method = c(\\\"auto\\\", \\\"shell\\\", \\\"radix\\\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list( structure(list(structure(\"Compare\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"rhythmInterval,rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(e1, e2)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"Summary\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(x)\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"rhythmInterval(x, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"logical\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"`NULL`\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"numeric\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(n)\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list( structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"rational\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x)\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list( structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"fraction\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x)\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list( structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"integer\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x)\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list( structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"character\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(str, Exclusive = NULL, ..., multiDispatch = FALSE)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"S4\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" class is the core rhythm representation in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" package.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The object is used to represent rhythmic durations\\n\", class = c(\"TEXT\", \"tag\")), structure(\"and metric positions.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Each duration is represented in\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Whole_note\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"whole note\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" units.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Numerically, these whole note units are represented as a ratio\\n\", class = c(\"TEXT\", \"tag\")), structure(\"between integers, held in the slots \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"@Numerator\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"@Denominator\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This allows use to represent any rational number with no loss of precision\\n\", class = c(\"TEXT\", \"tag\")), structure(\"due to rounding errors and weak decimal expansions (like \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"0.333333\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Rhythm intervals are similar to standard musical\\n\", class = c(\"TEXT\", \"tag\")), structure(\"termoniology (i.e, \\\"three eighth-notes\\\" is the ratio (3/8).\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Slots\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(list( structure(\"Numerator\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Integers\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(list( structure(\"Octave\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Integers\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_describe\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Vectorization\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" inherits from the virtual class\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This means you can apply normal vectorized commands to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"and even put them in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"base::data.frame()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:data.frame\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Arithmetic\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" objects have arithmetic operations defined.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Addition and subtraction are straightword and intuitive (i.e., (1/8) + (3/8) = (1/2)).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Multiplication and division are slightly more complicated:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Scalar_multiplication\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"scalar multiplication\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"is defined \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"for rational numbers\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\": (3/8) * 2 = (3/4)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(the result is always a new \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, note that a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" cannot be multiplied by another\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"---afterall, what would a quarter-note times a quarter-note be?\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" can be divided by another \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" to produce\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a real number: (1/2) / (1/4) = 2.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Like other rational values in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"R\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" we can also do either\\n\", class = c(\"TEXT\", \"tag\")), structure(\"``true'' (rational) division (using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"/\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:Arithmetic\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" operator)\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"or\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Euclidean_division\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Euclidean\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"division (using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%%\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:Arithmetic\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" operator).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Rational division (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"/\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") of a `rhythmInterval` by another `rhythmInterval`\\n\", class = c(\"TEXT\", \"tag\")), structure(\"results in a rational number. For instance, $(1/2) / (1/4) = 2$.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Rational division of a `rhythmInterval` by a rational number results in a\\n\", class = c(\"TEXT\", \"tag\")), structure(\"new `rhythmInterval`: $(1/2) / 2 = (1/4)$.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Eucliean (a.k.a., integer) division can only be applied between `rhythmInterval`s\\n\", class = c(\"TEXT\", \"tag\")), structure(\"resulting in an integer quotient---the remainder, which is a `rhythmInterval`,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"can be calculated with the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%%\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:Arithmetic\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" operator.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The remainder (a.k.a., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"modulo\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\") operator (`%%`) is especially\\n\", class = c(\"TEXT\", \"tag\")), structure(\"useful, for instance in calculating metric positions.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Relational Operators\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s can be compared using the standard\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"relational operators\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:Comparison\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"---\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"==\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"!=\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\">\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\">=\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", etc.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"core rhythm representation\", class = c(\"TEXT\", \"tag\"))), class = c(\"LIST\", \"tag\"))), class = c(\"tag_concept\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), rhythmOffset.Rd = structure(list(structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/rhythmInterval.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"rhythmOffset\", class = c(\"VERB\", \"tag\" ))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmOffset\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Calculate rhythmic \\\"offset\\\"\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"rhythmOffset(durations, start = 0, bars = NULL, tatum = 1, as = as.decimal)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"durations\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A vector of numeric values representing durations.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"start\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A duration value (coerced to same class as \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"durations\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"), from which the\\n\", class = c(\"TEXT\", \"tag\")), structure(\"offset begins.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"groups\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A vector of equal length as \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"durations\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" representing a grouping factor,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"usable by \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"[base][tapply]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\". If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"!is.null(groups)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", offsets are calculated\\n\", class = c(\"TEXT\", \"tag\")), structure(\"for duration values within each group. The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"start\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument is recycle to match\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the length of the number of groups, so a different start value can be applied to each group.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"is.null(groups)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", offsets are calculated for the whole \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"durations\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" vector, from the\\n\", class = c(\"TEXT\", \"tag\")), structure(\"first \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"start\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" value.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_arguments\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Borrowing the term from \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"music21\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", rhythmic \\\"offset\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"refers to a duration of time since a starting point (usually, the beginning\\n\", class = c(\"TEXT\", \"tag\")), structure(\"of a piece).\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmOffset\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" takes a vector of numbers representing durations\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(maybe \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"[rhythmInterval][rhythmInterval]s\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\", maybe other\\n\", class = c(\"TEXT\", \"tag\")), structure(\"numeric values) and cummulatively sums them from a starting value.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The output is a vector of durations of the same type as the input\\n\", class = c(\"TEXT\", \"tag\")), structure(\"where each output value corresponds to the duration of time elapsed\\n\", class = c(\"TEXT\", \"tag\")), structure(\"at that point.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Other rhythm analysis tools: \\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"metricPosition\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"()\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"rhythmDecompose\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"()\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythm analysis tools\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_concept\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), romanNumerals.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/diatonicSet.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"romanNumerals\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"romanNumerals\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Roman Numeral\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Roman numerals can be calculated for diatonicSets (keys) and\\n\", class = c(\"TEXT\", \"tag\")), structure(\"for tertian sets (chords).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The later case is the standard meaning of \\\"roman numeral.\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, the former case is used as well, for instance\\n\", class = c(\"TEXT\", \"tag\")), structure(\"to represent modulation schemes in\\n\", class = c(\"TEXT\", \"tag\")), structure(\"analyses of classical music. For instance, modulate from I-V,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the to vi/V.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"More importantly, many \\\"roman numerals\\\" in harmonic analyses\\n\", class = c(\"TEXT\", \"tag\")), structure(\"implicitely combine tertian and diatonic roman numerals:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in \\\"applied\\\" roman numerals.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Given a roman numeral like \\\"V65/V\\\", the \\\"V65\\\" represents a\\n\", class = c(\"TEXT\", \"tag\")), structure(\"chord while the \\\"/V\\\" represents a key.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), struct.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Vector.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"is.struct\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"is.struct(x)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Virtual class to help create atomic-vector-like composite data objects.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" defines a number of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"http://adv-r.had.co.nz/S4.html\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"S4 classes\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" which are, underneath the surface, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Composite_data_type\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"composite data types\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"made up of collections of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"base-R atomic vectors\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:vector\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\", stuck together.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \\\"vectorized\\\" nature of R's atomic types is one of R's key strengths, so in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" we try to A) mostly use the standard atomic types B)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"make all the new types we \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" define act as much like atomic vectors as possible.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"virtual\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" S4 class which serves this purpose: creating composite atomic vectors which act (mostly) like base-R atomic vectors.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"As a \\\"virtual class\\\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s themselves don't really exist as independent objects, but the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" class defines (abstractly) all the necessarry methods to treat a collection of\\n\", class = c(\"TEXT\", \"tag\")), structure(\"atomic vectors as a single vector/matrix-like object---simply make your new subclass \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"inherit\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"and it is all taken care of. (To do this, specify \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"contains = \\\"struct\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" in your call to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"setClass\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"methods:setClass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Important \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" classes which inherit from \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" include:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"tonalInterval\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"diatonicSet\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"tertianSet\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Be warned, R's S4 object-system is limited in this regard: you can't really define S4 classes that act \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"fully\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" like R atomics, as\\n\", class = c(\"TEXT\", \"tag\")), structure(\"many of their features are hard-coded into R itself and can't be replicated.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The most important limitation of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" that you may encounter is that, though \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" classes work (ok) in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"data.frames\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:data.frame\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"data.tables\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"data.table:data.table\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tibbles\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"tibble:tibble\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" will either not work or give strange behaviors if you put \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s into them.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Slots\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(list( structure(\"dim\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Either \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or a non-negative \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer-vector\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:integer\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"length == 2L\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", representing the number of rows and columns respectively. Dimensions \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"can\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" be zero.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(list( structure(\"rownames\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Either \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or a \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"integer\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:integer\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"/\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:character\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"-vector which is the same length as either\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A) if \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"dim == NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the length of the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" B) if \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"dim != NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the number of rows in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(list( structure(\"colnames\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Either \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (it \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"must\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" be \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" if \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"dim == NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") or a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:integer\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"/\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:character\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"-vector of length equal to the number of columns in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_describe\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Behavior\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" subclasses (i.e., classes which inherit from \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") behave very similarly to normal \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"R atomic vectors/matrices\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:vector\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, they do differ in a few respects, mostly in ways that are intended to avoid some of the quirky behaviors of R matrices:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In general, the distinction between dimensionless vectors and dimensioned vectors (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"matrices\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:matrix\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\") is slightly weaker in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"structs\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" than with normal R atomic vectors/matrices.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Most importantly, dimensioned \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s won't drop their dimensions under various common operations (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"c\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:c\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\", etc.), the way base-R matrices do.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In general, it is easier to interact with a multi-column (matrix-)\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" in the same way as a dimensionless (vector-)\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For example, if the struct has dimensions then \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"length(struct) == nrow(struct)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", instead of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"length(matrix) == nrow(matrix) * ncol(matrix)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"---i.e., the \\\"height\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"of the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (the number of rows) is its length.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Another big difference is in the behaviors of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"c\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:c\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\": \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"c\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" doesn't always cause \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s to lose their dimensions and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"c\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" can be used to concatinated multi-column \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"or even mixes of dimensionless and dimensioned \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If any \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" arguments to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"c\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" have dimensions, the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s are concatinated via a call to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rbind\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:cbind\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\", with any dimensionless vectors coerced to\\n\", class = c(\"TEXT\", \"tag\")), structure(\"1-column matrices.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Of course, the (resulting) number of columns must all be the same or an error will occur!\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Other differences:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s can have either no dimensions (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"dim(struct) == NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") or two dimensions. Higher dimensional \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s are not supported (yet).\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"rowSums\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"colSums\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will coerce a dimensionless struct to a column matrix.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s always throw an error if you try to index them with a index value that is greater than the length/nrow of the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This is different than atomic vectors, which will pad the vector up to the length of the index you give---a sometimes useful but quirky behavior.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s with two dimensions have a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"cartesian\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" indexing argument.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"cartesian = TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" arguments are treated as cartesian coordinates.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(This behavior can be achieved with base R matrices (or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s) by inputing a matrix with two columns.)\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Requirements\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"To work, \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" makes a few assumptions about your class.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Your class must have one or more slots which are vectors, all of which are the same length.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"'s indexing method will cause all of these vectors to be indexed as one.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"When you define a new subclass of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", it will inherit a\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"validObject\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"methods:validObject\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" method which assures that all elements are the same dimension.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, if you are writing your own \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"validObject\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" method (using \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"setValidity\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"methods:validObject\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\")\\n\", class = c(\"TEXT\", \"tag\")), structure(\"you just have to worry specifically about the validity of the information in your slots,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"not that the slots are all the same length.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Initialize\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"An initialize method which automatically makes all slots the same length is predefined\\n\", class = c(\"TEXT\", \"tag\")), structure(\"for \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"structs\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". If you want to make a more specialized \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"initialize\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"methods:new\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" method,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"you can still take advantage of the inherited method by using \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"callNextMethod\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"methods:NextMethod\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" at the\\n\", class = c(\"TEXT\", \"tag\")), structure(\"beginning of your method.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Predefined methods\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The main purpose of the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" virtual class is that it defines many of the basic methods you need to manipulate subclass objects.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Most importantly, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"indexing\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:Extract\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" methods are fully defined (that mimic base-R atomic vector/matrix indexing), as well as\\n\", class = c(\"TEXT\", \"tag\")), structure(\"basic \\\"structural\\\" methods like \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"(col/row)names\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:colnames\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"dim\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:dim\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"length\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:length\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"ncol, nrow\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:nrow\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\", etc.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In addition:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" If you define \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"> and >=\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:Comparison\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"<\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"<=\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will be automatically defined.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" If you define \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.character\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:character\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" for your subclass, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"show\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"methods:show\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"format\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:format\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" methods are automatically defined.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"What's more, default arithmetic methods for addition, subtraction, (scalar-integer) multiplication, and negation (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"-x\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") are defined.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The default addition behavior is that each numeric (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"base::integer\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:integer\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"base::numeric\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:numeric\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\") slot from your subclasses will be added together.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct1 + struct2\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will extract each numeric/integer slot from each \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", add them together and create a new \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" from the result.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"-struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will negate all numeric fields, and subtraction is simply defined as adding the negation.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Since \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"scalar\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" multiplication is defined, two \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s cannot be multiplied, but a struct can be multiplied by an integer (all numeric fields are multiplied by the integer(s)).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If these definitions don't work for your subclass, you'll need to create your own, more specific, method!\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"setClass('mynewsubclass', contains = 'struct', slots = c(X= 'numeric', Y = 'numeric'))\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"test <- new('mynewsubclass', X = 1:10, Y = 10:1)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"# all of these should work:\\n\", class = c(\"RCODE\", \"tag\")), structure(\"test[1:5]\\n\", class = c(\"RCODE\", \"tag\")), structure(\"rev(test) == test\\n\", class = c(\"RCODE\", \"tag\")), structure(\"cbind(test, test)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"c(test, test)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"test * 3\\n\", class = c(\"RCODE\", \"tag\")), structure(\"test - test\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_examples\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Examples of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" subclasses: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tertianSet\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), tertianSet.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/tertianSet.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tertianSet\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tertianSet\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tset\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"is.tertianSet\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Tertian set\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"tertianSet(...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"tset(\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" root = 0L,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" signature = 0L,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" alterations = 0L,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" cardinality = 3L,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" extension = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" inversion = 0L\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"is.tertianSet(x)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tertianSet\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is one of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR's\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumR\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"types of tonal data, representing Western tertian harmonies.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tertianSet\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is a subclass of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (and thence, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The only structural addition, compared to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", is the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Extensions\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" slot.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This slot indicates which tertian chord members are active in the chord.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"There are seven possible chord members:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the root, third, fifth, seventh, ninth, eleventh, and thirteenth.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Every possible combination of these seven degrees is represented by a single integer, corresponding\\n\", class = c(\"TEXT\", \"tag\")), structure(\"to the 7-bit representation of on/offs on the seven degrees in reverse order (13, 11, 9, 7, 5, 3, 1).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For example, the integer \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"15\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" corresponds to a seventh chord: in binary, 15 is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"0001111\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The initial three zeros indicate that the 13th, 11th, and 9th are \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"not\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" part of the harmony, while the four ones\\n\", class = c(\"TEXT\", \"tag\")), structure(\"indicate that the root, third, fifth, and seventh \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"are\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" part of the harmony.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Ultimately, adding or removing a chord degree from a harmony can be achieved by adding the power of\\n\", class = c(\"TEXT\", \"tag\")), structure(\"two associated with that degree:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Root\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\": \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"\\\\pm 1\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(), class = c(\"tag_item\", \"tag\" )), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Third\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\": \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"\\\\pm 2\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Fifth\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\": \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"\\\\pm 4\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Seventh\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\": \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"\\\\pm 8\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Ninth\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\": \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"\\\\pm 16\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Eleventh\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\": \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"\\\\pm 32\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Thirteenth\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\": \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"\\\\pm 64\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tertianSet\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" has many specific methods defined for reading/writing harmonic information.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"diatonicSet humTonality\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), time.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/rhythmInterval.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"time\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"time\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"bpm2ms\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"ms2bpm\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Time transformations\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"bpm2ms(bpm)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"ms2bpm(ms)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Time transformations\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), tonalInterval.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/tonalInterval.R, R/rhythmInterval.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tint\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"is.tonalInterval\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval.tonalInterval\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval.logical\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval.NULL\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval.numeric\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval.rational\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval.fraction\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval.integer\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval.character\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval.rhythmInterval\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Representation of tonal pitch information\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"tonalInterval(...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"tint(\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" octave,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" LO5th = 0L,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" cent = numeric(length(octave)),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" partition = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" Key = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" roundContour = floor\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"is.tonalInterval(x)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"tonalInterval(...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"tonalInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"tonalInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"tonalInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"logical\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"tonalInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"`NULL`\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"tonalInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"numeric\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" tonalHarmonic = 3,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" centMargin = 10,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" accidental.melodic = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" ...\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"tonalInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"rational\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x, tonalHarmonic = 3, accidental.melodic = FALSE, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"tonalInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"fraction\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x, tonalHarmonic = 3)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"tonalInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"integer\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(n, accidental.melodic = FALSE, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"tonalInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"character\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(str, Exclusive = NULL, ..., multiDispatch = FALSE)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x, ...)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is the core tonal pitch representation in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumR\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is an abstract representation of tonal pitch, which can be translated to/from all standard \\\"concrete\\\" pitch representations:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"solfege, scientific pitch, semitones, frequencies, scale degrees, intervals, etc.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For the most part, users should not need to interact with \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s directly---rather, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s work behind the scene in numerous \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" pitch functions.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"See the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pitchRepresentations\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalTransformations\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" documentation for details of usage and functionality or the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Tonality in humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" vignette for\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a detailed explanation of the theory and specifics of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"http://adv-r.had.co.nz/S4.html\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"S4\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" subclass of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"'s virtual class \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\", from which it inherits a lot of useful \\\"vector-like\\\" behaviors/functionality.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The constructor function \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tint\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" can be used to create \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalIntervals\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" directly.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The three arguments corespond to the three slots: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"octave\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"LO5th\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (Fifth), and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"cent\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"All inputs will be coerced to match in length.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"What's more, the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"octave\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument can be left blank, in which case the appropriate octave will automatically be computed\\n\", class = c(\"TEXT\", \"tag\")), structure(\"to place the interval in the octave above middle-C.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"By default, the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.character\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:character\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" method, and thus (via \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\") the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"show\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"methods:show\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" method, for \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"kern()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=pitchRepresentations\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Thus, if you return a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" on the command line (or call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"print\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:print\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" one one) you'll see the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"kern pitch\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=pitchRepresentations\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" representation printed.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Slots\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(list( structure(\"Octave\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"integers representing the octave offset.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(list( structure(\"Fifth\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"integers representing the \\\"line-of-fifths\\\" value.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(list( structure(\"Cent\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"numeric values representing cents (1200th of an octave).\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_describe\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Arithmetic\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Technically, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s are examples of algebraic \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Module_(mathematics)\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"modules over integers\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This means that certain arithmetic operations are defined for \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalIntervals\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and can be called using standard arithmetic operators (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"+\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"-\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", etc.):\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Addition: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalIntervals\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" can be added together, acting exactly as you'd expect (i.e., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"M3 + m3 = P5\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Subtraction: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalIntervals\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" can be subtracted just as they are added. Also, they can be negated with a single \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"-\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"operator (like \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"-M3\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Multiplication: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s can \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"not\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" be multiplied together.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Scalar_multiplication\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"scalar (integer) multiplication\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" is defined:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"thus, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalIntervals\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" can be multiplied by integers to create new \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s: e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"M2 * 3L = A4\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Division: as the natural inverse of scale multiplication, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Euclidean_division\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Euclidean division\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"is defined for \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalIntervals\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"---i.e., division by/into whole (integer) pieces, often with leftover \\\"remainders\\\" (modulo).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In R, Euclidean division is achieved with the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%/%\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:Arithmetic\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" operator---\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"not\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"/\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"---, with the associated \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%%\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:Arithmetic\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" used for the remainder/modulo.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Two \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s can be divided to produced an integer; Conversely, a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" can be divided by an integer to produce a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Take note that the way \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" defines Euclidean division is based in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonal space\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\"---i.e., the line-of-fifths---not frequency or atonal-semitone space.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For example, an augmented-fourth divided by a major-second \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"is\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"3L\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", but a diminished-fifth divided by a major-second is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"not\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" 3L---\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"d5 %/% M2\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" equals \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"-3L\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" with a remainder of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"P8\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (plus an octave)!\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The division algorithm works by applying standard Euclidean division to the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"@Fifth\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" slot (line-of-fifths tonal space), and shifting the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"@Octave\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" value in\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the remainder to the match the appropriate octave.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This definition has the useful properties that \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"specificinterval %% A1 = genericinterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"interval %% d2 = enharmonicinterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Since basic data types can be parsed into \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (see below), \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will attempt to automatically \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Type_conversion\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"coerce\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"data to tonalIntervals when asked to perform arithmetic.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This means that arithmetic can be applied when one of the two arguments is a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and the other is a coercable atomic.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For instance, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"M3 + 2L\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will interpret \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"2L\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" as two semitones and add a major-second to the major-third!\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The clever \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"dispatch system\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=regexDispatch\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" will even ignore character strings that are not recognized (see examples)!\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This is useful when combined with the \\\"Predifined Intervals\\\" (like \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"M3\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"), described below.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Relational Operators\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s can be compared using the standard \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"relational operations\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:Comparison\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"---\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"==\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"!=\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\">\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\">=\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", etc.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Two \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s are equal (according to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"==\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") only if all their slots (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Octave\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Fifth\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Cent\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\")\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are exactly identical.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, enharmonic notes (like C# and Db) are \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"not\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" equal.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In contrast, ordinal comparisons (e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\">\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"<=\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") between \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s are based on their semitone (equal temperament) size, so enharmonicity is irrelevant.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"m3 >= A2\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"A2 >= m3\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" are both \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", even though \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"m3 == A2\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is not.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Predefined Intervals:\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" automatically exports a bunch of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s, named by their musical interval representation.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Every generic interval from 1 to 15 is combined with every interval quality \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"dd\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (doubly diminished), \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"d\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (diminished), \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"m\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (minor), \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"M\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (major), \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"A\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (augumented)\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"AA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (doubly augmented).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, after loading \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", you can type things like \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"M3 + M3\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and get \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"A5\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In addition, the variables \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"unison\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"= P1 = tint(0, 0)\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"), \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pythagorean.comma\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"= d2 = tint(-19,12)\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"), and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"octave\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tint(1, 0)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") are exported as well.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Parsing\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" includes a easy-to-use but powerful system for parsing pitch information into the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" representation.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Basic methods are defined for numeric values representing atonal pitch information:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"integer\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:integer\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" values are interpreted as semitones. Watch out! In R, you need to append an \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"L\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" to a number to make it an explicit integer:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For example, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval(3L)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"numeric\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:numeric\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"/\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"decimal()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=decimal\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"rational()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=rational\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" values are interpreted as frequency ratios, assuming a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Pythagorean_tuning\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Pythagorean tuning\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For example, the value \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"2.0\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will be interpreted as an octave (two to one ratio.)\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, the most useful tool for humdrum data is parsing pitch representations encoded in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" tokens.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" regex/exclusive parsing system is used to interpret character strings as tonalIntervals.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This includes character tokens with pitch information embedded alongside other information, like \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"4.ee\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" in a kern token.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"There are six regex-patterns that \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" known how to parse automatically:\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"lcr\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\" Representation \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_tab\", \"tag\")), structure(\" Exclusive \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_tab\", \"tag\")), structure(\" Example \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_cr\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\" Kern \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_tab\", \"tag\")), structure(\" **kern \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_tab\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"ee-\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_cr\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Scientific_pitch\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Scientific Pitch\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(), class = c(\"tag_tab\", \"tag\")), structure(\" **pitch \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_tab\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Eb5\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_cr\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\" Interval \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_tab\", \"tag\")), structure(\" **hint/**mint/**int \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_tab\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"+m3\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_cr\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\" Scale degree \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_tab\", \"tag\")), structure(\" **deg \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_tab\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"b3\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_cr\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\" Solfege \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_tab\", \"tag\")), structure(\" **solfa \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_tab\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"me\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_cr\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://lilypond.org/doc/v2.22/Documentation/notation/pitches\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Lilypond pitch\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(), class = c(\"tag_tab\", \"tag\")), structure(\" none \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_tab\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"ees'\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_cr\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_tabular\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If you call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"any function that uses tonalInterval as a parser\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=pitch\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\") on a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" string,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the regex-system will automatically (attempt) to interpret the tokens as on the pitch types above---if there is a conflict\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the representations are favored in the order they are presented in the table above.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If a matching exclusive interpretation (see table above) is provided using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Exclusive\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"this choice overrides the regex-dispatch.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If there is no match, an NA \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is returned.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Parsing with Options\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The six tonal representations listed above function through a common parsing interface.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"M3 <- tint( , 4L)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"M2 <- tint( , 2L)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"M9 <- tint(-1L, 2L)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"M9 - M2 \\n\", class = c(\"RCODE\", \"tag\")), structure(\"# = octave\\n\", class = c(\"RCODE\", \"tag\")), structure(\"M9 - 2L\\n\", class = c(\"RCODE\", \"tag\")), structure(\"# = octave\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"M3 %/% M2 \\n\", class = c(\"RCODE\", \"tag\")), structure(\"# = 2\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"###\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"cMajor <- sort(tint( , -1:5))\\n\", class = c(\"RCODE\", \"tag\")), structure(\"eMajor <- cMajor + M3\\n\", class = c(\"RCODE\", \"tag\")), structure(\"eMajor + 2L \\n\", class = c(\"RCODE\", \"tag\")), structure(\"# f# g# a# b cc# dd# ee#\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"eMajor[4:5] - octave \\n\", class = c(\"RCODE\", \"tag\")), structure(\"# = A B\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\\"4.ee\\\" + P5 \\n\", class = c(\"RCODE\", \"tag\")), structure(\"# = \\\"4.bb\\\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_examples\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Other \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"core pitch representation\", class = c(\"TEXT\", \"tag\"))), class = c(\"LIST\", \"tag\")), structure(\": \\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"LO5th\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"()\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"core pitch representation\", class = c(\"TEXT\", \"tag\"))), class = c(\"LIST\", \"tag\"))), class = c(\"tag_concept\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), tonalTransformations.Rd = structure(list(structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/tonalInterval.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"tonalTransformations\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalTransformations\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"invert\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Invert or transpose tonal intervals.\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"invert(tint, around, Key, ...)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Invert or transpose tonal intervals.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), transpose.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/tonalInterval.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"transpose\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"transpose\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Transpose pitches and keys\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"transpose(x, by, Key, to, real, relative, ...)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"x\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"The input pitch(es) to transpose. A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or something intepretable as a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"by\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or something intepretable as a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The input \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"x\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is transposed by this interval.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Key\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or something intepretable as a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". For tonal and/or to transpositions,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"this is the \\\"from\\\" key. If this value is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", it defaults to C major.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"to\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or something intepretable as a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". The input \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"x\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is transposed\\n\", class = c(\"TEXT\", \"tag\")), structure(\"to this key.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"real\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A logical. If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (the default), transposition is real. If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", transposition is tonal.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"relative\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A logical. If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" transposition is relative. If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (the default), transposition is parallel.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_arguments\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This function \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"transposes\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=https://en.wikipedia.org/wiki/Transposition_(music)\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" pitches or keys\\n\", class = c(\"TEXT\", \"tag\")), structure(\"by various intervals or to target keys.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Inside the box, inputs and transpositions take place as \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"but any numeric or character string representation of pitches can be transposed as well.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This function is incorporated directly into \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalTransform\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\", and thence, all \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pitch translation\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=pitchRepresentations\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"functions, so you probably won't call it directly very often.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"There are two distinct types of transposition (real and tonal).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"There are also two different approaches to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"specifying\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" transpositions: \\\"to\\\" and \\\"by\\\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\\"To\\\" transpositions can also be either \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"parallel\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"relative\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Types of Transposition\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"There are two different types of transposition: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"real\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" transposition and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonal\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" transposition.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"real\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" transposition, all inputs are transposed by the same \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"specific\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" interval.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For example, the pitches \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{C D E F G}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" could be transposed up a major second to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{C D E F# G}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"tonal\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" transposition, inputs are transposed by \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"generic\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" intervals, within a key.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For example, the sequence \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{C D E F G}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\", in the key of C major, could be translated up a generic second\\n\", class = c(\"TEXT\", \"tag\")), structure(\"to \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"{D E F G A}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"To choose between real and tonal transposition, use the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"real\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"real = TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" for real transposition, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"real = FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" for tonal transposition.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Alterations\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Tonal transposition is complicated by the presence of any alterations in the input pitches.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For instance, if we are given the pitches \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{C F# G D# E}`` in the key of C major, how should they by tonally transposed up a second, within C major? There is not one obvious, correct answer answer, which can be easily identified. The algorithm implemented by \", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"humdrumR` is as follows:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Alterations/accidentals in the input are identified. (In this case, F# and D#).\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" The generic pitches are transposed within the key, resulting in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{D G A E F}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Alterations in the input are added to the output \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"unless\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" the resulting pitches are interpreted as a comma\\n\", class = c(\"TEXT\", \"tag\")), structure(\"by a call to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tintPartion\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\", with a given enharmonic wrap value (the default is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"12\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In this example, adding the first accidental results in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{G#}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" which is not a comma.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, the second accidental results in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{E#}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" which \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"is\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" a comma away from the natural \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{F}\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, this accidental is not added to the output, resulting in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{E}\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", not \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{E#}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The resulting output is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{D G# A E F}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_enumerate\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The size of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"enharmonicWrap\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" effectively determines how extreme accidentals are allowed.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The default value, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"12\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", assures that no output notes are enharmonically equivalent to notes in the key.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"To further illustrate, here is the sequence \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{C F# G D# E, B- A A- G C# D, B D- C}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" transposed\\n\", class = c(\"TEXT\", \"tag\")), structure(\"tonally within C major by all seven possible generic intervals, with \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"enharmonicWrap = 12\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\":\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Specifying Transpositions\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"There are two approaches to specifying transpositions, the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" arguments.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument must be an interval, and the input is translated by that interval.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" interval is specific but \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"real = FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the input is treated as a generic interval,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"and tranposition takes place within the key indicated by the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Key\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"The \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"to\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument translates an input \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" a desired key.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For example, if the input is in the key of E major but we want it transposed to G major, we could say \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to = '*E:'\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"real = TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", input is simply translated to the root of the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" key, with all the exact same intervals.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"real = FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the input is translated to the root of the new key, with its intervals changed to match the new key as well.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In either case, the result depends on what the input's key is, which is indicated by the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"standard\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=tonalTransform\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Key\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Key\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" arguments is like the \\\"from\\\" key.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Key = NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the input key is interpreted as C major.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Consider the input notes \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{D B C A# B, D C# D E D}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" in the key of the G major.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If we specify \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to = e:, real = TRUE\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\", the output will be \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{B G# A F## G#, B A# B C# B}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(Notice that even though the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" key is minor, the output is still clearly in E major).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If we specify \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to = e:, real = FALSE\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\", the output will instead be \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{B G A F# G, B A# B C B}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Building off the previous example, consider how the input \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"key\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" matters as well.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If we use the same input notes (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{D B C A# B, D C# D E D}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\") but the input \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Key\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is C major, then:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If we specify \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to = e:, real = TRUE\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\", the output will be \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{F# D# E C## D#, F# E# F# G# F#}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If we specify \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to = e:, real = FALSE\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\", the output will instead be \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{F# D E C# D, F# E F# G F#}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"both\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" are specified, the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" transposition is applied first, followed by the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" transposition.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"real = FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" transposition happens within the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" key, not the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Key\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" key.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Relative vs Parallel\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"When transposing to, we have diferent approaches about to determining the relationship between the\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\\"from\\\" key (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Key\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument) and the \\\"to\\\" key (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If we think of \\\"parallel\\\" relationships between keys, we match the roots of the keys regardless of modes.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For instance, C major and C minor are parallel keys.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If we instead think of \\\"relative\\\" relationships between keys, we match the modes of the keys, not the roots.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For instance, C major and A minor are relative keys.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This is similar to the distinction between \\\"la-based minor\\\" solfege (relative) vs \\\"fixed-do\\\" solfege (parallel).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"When transposing using a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument, if \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"relative = FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" the input key (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Key\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument) is transposed to match the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"root\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"of the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For example, if the input key is G minor and the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to`` key is C major, the output is transposed to G minor. However, if \", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"relative = TRUE\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"the input key is transposed to match the mode of the\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"to\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"key: A G minor input with a C major\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"to\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"would be translated to A minor, the parallel minor of the\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"to\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"key. If the\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"Key\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"(from key) and\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"to` (to key) arguments have the same mode, the parallel and relative transpositions\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are the same.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Special Operators +-\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"As a note, real transposition \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and interval can be achieved more concisely using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"+\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"-\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" operators,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"as long as at least one side of the operators is an actual \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" preassigns all common tonalIntervals to objects in your global environment.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, you can type commands like \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"c#\\\" + M2\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" to get \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"d#\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"c(\\\"C4\\\", \\\"E4\\\", \\\"C5\\\") - m6\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" to get \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"E3\\\" \\\"G#3\\\" \\\"E4\\\"\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"tonalTransformations\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), withinHumdrum.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Apply.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withHumdrum\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"inHumdrum\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humApply\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"with(in)Humdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"withinHumdrum(humdrumR, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"withHumdrum(humdrumR, ..., drop = TRUE)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"inHumdrum(humdrumR, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humApply(humdrumR, FUN, ..., within = TRUE, doplot = FALSE)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" data object.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"...\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Any arguments which can be fed to\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humdrumR:with-in-Humdrum][with(in)Humdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" as formulae (except for\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expressions, which are replaced by the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"FUN\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument!).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, rather that writinging formula in the format \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Keyword ~ Expression\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humApply\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" arguments should be written as normal \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"R\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" arguments:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Keyword = Expression\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Unnamed arguments are ignored.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"#' @param within A logical. If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (the default),\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humdrumR:with-in-Humdrum][withinHumdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" is used to apply the\\n\", class = c(\"TEXT\", \"tag\")), structure(\"function---meaning that the output is reconstituted into a new field in the\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object. If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"within == FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humdrumR:with-in-Humdrum][withHumdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" is used instead,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"which results in the function's output being returned inprocessed.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"drop\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"This argument is concetually similar to the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"drop\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument in R matrices and data.frames.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"drop = TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the output of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is simplified as much as possible (trying to return\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the \\\"raw\\\" vector, list, table, etc. within it). If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"drop = FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the result is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"always\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"data.table\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". The default value (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"drop = TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") is usually what we want because it is more\\n\", class = c(\"TEXT\", \"tag\")), structure(\"intuitive, but in more complex code, it can be helpful to set \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"drop = FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" so that\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the output is consistent.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"FUN\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A function to apply to the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR:humdrumR\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=Active\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(list(structure(\"field(s) in the\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"humdrumR` object.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"doplot\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Boolean. If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"FUN\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument is treated\\n\", class = c(\"TEXT\", \"tag\")), structure(\"as a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"doplot\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression by \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humdrumR:with-in-Humdrum][with(in)Humdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(\"so the result is ignored (for plotting or side-effects purposes).\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_arguments\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"From \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"inHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", a new humdrumR data object.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"From \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"withHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", whatever value is returned by expression.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_value\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Apply arbitrary expressions to fields within \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[S4class][humdrumRclass]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" data.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Overview\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"These functions are the primary means of working with\\n\", class = c(\"TEXT\", \"tag\")), structure(\"humdrumR data. (They are analogous to the base functions\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[base][with]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[base][within]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"as applied to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[base:data.frame][data.frames]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Specifically they allow you to evaluate arbitrary\\n\", class = c(\"TEXT\", \"tag\")), structure(\"expressions involving fields in a humdrumR data object.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"They also includes a number of special evaluation options:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Evaluate an expression in only matching parts of the data.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Evaluate an expression separately in subsets of the data.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Evaluate an expression across windows in the data (e.g., ngrams, rolling windows).\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Evaluate an expression which produces a plot, with particular plotting parameters set using \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[graphics][par]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"The difference between \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is\\n\", class = c(\"TEXT\", \"tag\")), structure(\"analogous to the difference between \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[base][with]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[base][within]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" evaluates your expression(s) and then simply returns the result of\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the evaluation. \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" evaluates your expression(s) and then\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(attempts) to insert the results back into the humdrumR object, generating new\\n\", class = c(\"TEXT\", \"tag\")), structure(\"fields called \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"PipeX\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (see details).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"inHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is simply a short hand for \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(list(structure(\"Formulae\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Every formula in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"formulae\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument\\n\", class = c(\"TEXT\", \"tag\")), structure(\"is treated as a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Keyword ~ Expression(s)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"pairing. Multiple expressions can be input using multiple \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"~\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" operators:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Keyword ~ Expression1 [~ Expression2 ~ ... ~ ExpressionN]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(the leftmost expression is treated as the keyword.)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If there is no leftmost expression (i.e., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"~ Expression\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"), the Keyword\\n\", class = c(\"TEXT\", \"tag\")), structure(\"defaults to \\\"\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\\" The keyword expression must be a single, simple name/symbol, following\\n\", class = c(\"TEXT\", \"tag\")), structure(\"standard R rules (i.e., \\\"\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\".foobar\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\\" is acceptable but \\\"\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"3 + foobar\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\\" is not).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Legal keywords, and their meanings are:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" An expression to be evaluated within the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data object (see \\\"Expression evaluation\\\").\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"doplot\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" An expression to be evaluated within the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data object while ignoring the result of the expression (see \\\"Expression evaluation\\\" and \\\"Plotting\\\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" An expression used to break the data into groups, with the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression(s) evaluated\\n\", class = c(\"TEXT\", \"tag\")), structure(\"separately in each group (see \\\"Partitioning\\\").\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"where\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" An expression indicating a subset of the data in which to evaluate the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression (see \\\"Partitioning\\\").\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"ngrams\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" A positive number \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\". The expression is evaluated across overlapping length-\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" windows.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"recordtypes\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" A string or vector of characters drawn from \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"c(\\\"D\\\", \\\"d\\\", \\\"I\\\", \\\"L\\\", \\\"M\\\",\\\"G\\\")\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". These characters\\n\", class = c(\"TEXT\", \"tag\")), structure(\"correspond to types of humdrum records: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"D\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\"ata, null \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"d\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\"ata, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"I\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\"nterpretations,\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"M\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\"easures, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"L\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\"ocal comments, and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"G\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\"lobal comments respectively. The expression\\n\", class = c(\"TEXT\", \"tag\")), structure(\"is only evaluated on data drawn from the specified record types (defaults to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"D\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"pre\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" An expression to evaluate once before evaluating the do expression(s). Useful, for instance, for taking logs\\n\", class = c(\"TEXT\", \"tag\")), structure(\"or opening a graphing window. The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pre\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression is evaluated in the global environment.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"post\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" An expression evaluate once after evaluating the do expression(s). Always evaluated in the global environment.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_enumerate\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Expression evaluation\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The right-hand side of any formula in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"formulae\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument with the keyword \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"doplot\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(or with no keyword specified) is evaluated within the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data object.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The expression can, thus, refer to any field in the humdrumR object (Record, Token, File, etc.).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"You can also include a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\".\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" anywhere in the expression, which will be\\n\", class = c(\"TEXT\", \"tag\")), structure(\"interpreted as the humdrumR object's current \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[dest=humdrumR][Active]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"expression.\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata <- readHumdrum('directorywithdata/*.krn') # read some data\\n\", class = c(\"VERB\", \"tag\")), structure(\"\\n\", class = c(\"VERB\", \"tag\")), structure(\"withinHumdrum(humdata, ~getPitch(Token)) # The most basic pattern\\n\", class = c(\"VERB\", \"tag\")), structure(\"withinHumdrum(humdata, ~getPitch(.)) # Same as previous (unless `Active` field has been changed))\\n\", class = c(\"VERB\", \"tag\")), structure(\"\\n\", class = c(\"VERB\", \"tag\")), structure(\"withinHumdrum(humdata, ~solfa(getPitch(Token), key = Key)) \\n\", class = c(\"VERB\", \"tag\")), structure(\"# Assumes that the Key field was parsed during the call to `[readHumdrum][readHumdrum]`\\n\", class = c(\"VERB\", \"tag\")), structure(\"\\n\", class = c(\"VERB\", \"tag\")), structure(\"withinHumdrum(humdata, ~getSemits(Token) - mean(getSemits(Token))) \\n\", class = c(\"VERB\", \"tag\")), structure(\"\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"If multiple \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expressions are provided, they are each evaluated one at a time,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"with the result of each piped into the next. Other, non-\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", formulae (like \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by~\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" or\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"ngrams~\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\") are reused for each expression evaluated.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Partitioning\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression is used to break the data into subsets, with the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression(s) evaluated\\n\", class = c(\"TEXT\", \"tag\")), structure(\"separately within each subset. This works the similarly to the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument in\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[data.table][data.table]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"s, the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"INDEX\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"argument of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[base][tapply]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\", or the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"INDICES\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[base][by]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Each \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression must evaluate, within the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data object, to a vector (or a list of vectors\\n\", class = c(\"TEXT\", \"tag\")), structure(\"of equal length) of categories to group the data by.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Most commonly, the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression(s) are simply field(s) in the data:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"for instance,\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum(humdata,\\n\", class = c(\"VERB\", \"tag\")), structure(\" do ~ table(Token),\\n\", class = c(\"VERB\", \"tag\")), structure(\" by ~ File)\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"will apply the function \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[base][table]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" to the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Token\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"separately\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" for each file in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, we can also use more complex expressions like\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum(humdata,\\n\", class = c(\"VERB\", \"tag\")), structure(\" do ~ table(Token), \\n\", class = c(\"VERB\", \"tag\")), structure(\" by ~ Spine > 3 | Record \\\\%\\\\% 2 == 0)\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"which will evaluate the do expression in two groups, one where either the spine number is\\n\", class = c(\"TEXT\", \"tag\")), structure(\"three or less \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"or\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" the record number is even, and another group where the opposite is true.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression evaluates to a list of grouping vectors,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expressions are evaulated across every combination of categories in all the vectors.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"withinHumdrum(humdata,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"do ~ table(Token),\\n\", class = c(\"TEXT\", \"tag\")), structure(\"by ~ list(File, Spine))\\n\", class = c(\"TEXT\", \"tag\")), structure(\"will apply \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"table\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Token\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" across each spine \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"in\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" each file.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"As some \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Syntactic_sugarsyntactic\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"syntactic sugar\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\", if the\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression has more than two parts, all parts except\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the (leftmost) keyword part are combined in a list (i.e., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by ~ File ~ Spine\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"becomes \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by ~ list(File, Spine)}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus the previous example can also be written:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"withinHumdrum(humdata,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"do ~ table(Token),\\n\", class = c(\"TEXT\", \"tag\")), structure(\"by ~ File ~ Spine)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"where\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression is used to identify a subset of the data and evaluate\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression(s) \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"only\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" in that subset.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"where\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expressions must evaluated, within the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data object, to\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a single logical vector. The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression(s) are only evaluated where this logical\\n\", class = c(\"TEXT\", \"tag\")), structure(\"vector is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Wherever the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"where\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression evaluates to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the original \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data is\\n\", class = c(\"TEXT\", \"tag\")), structure(\"kept unchanged.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If multiple partitioning formulae (i.e, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"where\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") expressions\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are evaluated recursively, in order from left to right. Thus if you specify\\n\", class = c(\"TEXT\", \"tag\")), structure(\"withinHumdrum(humdata,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"do ~ sd(semits),\\n\", class = c(\"TEXT\", \"tag\")), structure(\"by ~ File,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"where ~ semits > mean(semits))\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a the standard deviation of the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"semits\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field will be calculated only in each file,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"but only where the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"semits\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field is greater than the mean \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"semits\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" value\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"within that file\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\". Contrast this with this call:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"withinHumdrum(humdata,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"do ~ sd(semits)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"where ~ semits > mean(semits),\\n\", class = c(\"TEXT\", \"tag\")), structure(\"by ~ File)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"wherein the standard deviation of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"semits\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is, again, calculated for each file,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"but this time wherever the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"semits\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field is greater than the mean value \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"across all the data\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Plotting\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"The \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"doplot\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" keyword behaves exactly like the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" keyword, except that the result of the\\n\", class = c(\"TEXT\", \"tag\")), structure(\"evaluation is ignored. This is useful for plotting \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as well as\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" other side-effects (like writing to a file).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"doplot\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is used with \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the function simply returns \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (after executing the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"doplot\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"expression\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"doplot\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is used with \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"inHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"), the function simply returns the unaltered\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" also allows you to specify plotting options in line, without having to make a separate call\\n\", class = c(\"TEXT\", \"tag\")), structure(\"to \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"[graphics][par]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\". Any \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[graphics][par]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" argument can be specified as a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Keyword ~ Expression\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" pair\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"formulae\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument. For instance, if you call a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"doplot\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression with a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression\\n\", class = c(\"TEXT\", \"tag\")), structure(\"that creates four groups, R will create four plots---but you will only see the last one! Normally, you would need to\\n\", class = c(\"TEXT\", \"tag\")), structure(\"call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"par(mfcol = c(2,2))\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"before\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" calling your plotting function. However, with \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" you can\\n\", class = c(\"TEXT\", \"tag\")), structure(\"soecific \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"mfcol = c(2,2)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" right in a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"formulae\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" formula:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"withinHumdrum(humdata,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"doplot ~ fooplot(.),\\n\", class = c(\"TEXT\", \"tag\")), structure(\"by ~ list(Two, byTwo),\\n\", class = c(\"TEXT\", \"tag\")), structure(\"mfcol ~ c(2, 2))\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The best part is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will reset \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"par\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" to it's previous state after \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is done.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Tandem interpretations\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The function \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[readHumdrum][readHumdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" automatically parses\\n\", class = c(\"TEXT\", \"tag\")), structure(\"tandem interpretations (that it recognizes) into\\n\", class = c(\"TEXT\", \"tag\")), structure(\"their own fields in the resulting \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humdrumR][humdrumRclass]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" data.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For instance, data with a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"'*clefF4'\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will show\\n\", class = c(\"TEXT\", \"tag\")), structure(\"up as a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Clef\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field. However, users might read humdrum data with their\\n\", class = c(\"TEXT\", \"tag\")), structure(\"own custom tandem interpretations that are not built into \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" includes the function \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[getTandem][getTandem]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" to help us\\n\", class = c(\"TEXT\", \"tag\")), structure(\"extract arbitrary tandem intrpretation data.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Luckily, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" knows some\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Syntactic_sugarsyntactic\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"syntactic sugar\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"which makes it easy to do this anywhere in our expressions, simply by putting a\\n\", class = c(\"TEXT\", \"tag\")), structure(\"named object beginning with the symbol \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"*\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". Of course, R doesn't normally\\n\", class = c(\"TEXT\", \"tag\")), structure(\"allow names to begin with symbols like \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"*\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", but you can force it by\\n\", class = c(\"TEXT\", \"tag\")), structure(\"placing grave symbols around the name \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"*name\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\". If you do this in a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"expression, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will treat this name as a\\n\", class = c(\"TEXT\", \"tag\")), structure(\"regular expression and substitute a call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"getTandem(Tandem, 'regular expression')\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" in the expression.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This means you can could do something like\\n\", class = c(\"TEXT\", \"tag\")), structure(\"withinHumdrum(humdata,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"do ~ myFunction(Token, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"*mytandempattern\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"))\\n\", class = c(\"TEXT\", \"tag\")), structure(\"and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"myFunction\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will be called with the first argument being the\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Token\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field, and the second argument being tandem interpretations\\n\", class = c(\"TEXT\", \"tag\")), structure(\"which match \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"'mytandempattern'\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (extracted from the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Tandem\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field).\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Splatting\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(\\\"Splatting\\\" refers to feeding a function a list/vector of arguments.)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Sometimes we want to divide our data into pieces (a l\\\\'a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"partition\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" option), but\\n\", class = c(\"TEXT\", \"tag\")), structure(\"rather than applying the same expression to each piece, we want to feed\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the separate pieces as separate arguments to the same function.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" you can use some\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Syntactic_sugarsyntactic\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"syntactic sugar\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"to do just this, using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"@\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" symbol in the format \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"myFunction(TargetExpr@GroupingExpr)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If we make this call\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"withinHumdrum(humdata,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"do ~ myFunction(Token@Spine))\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"and there are four spines\\n\", class = c(\"TEXT\", \"tag\")), structure(\"this is how \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will intepret the expression:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"withinHumdrum(humData,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"do ~ myFunction(Token\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Spine == 1\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\", # first argument when Spine == 1\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Token\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Spine == 2\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\", # second argument when Spine == 2\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Token\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Spine == 3\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\", # etc.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Token\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Spine == 4\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"))\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Argument interpolation\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Any named arguments to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" are \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humdrumR:interpolateArguments][interpolated]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" into the\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expressions. This is useful if you've already created a list of formulas that you like, but would like\\n\", class = c(\"TEXT\", \"tag\")), structure(\"to make small changes to a function call within the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expressions, without starting from scratch.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Examples:\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"mycommand <- c(do ~ mean(., na.rm = TRUE), by ~ Spine ~ File)\\n\", class = c(\"VERB\", \"tag\")), structure(\"withinHumdrum(humdata,\\n\", class = c(\"VERB\", \"tag\")), structure(\" mycommand,\\n\", class = c(\"VERB\", \"tag\")), structure(\" na.rm = FALSE)\\n\", class = c(\"VERB\", \"tag\")), structure(\"# mycommand is executed with na.rm changed to FALSE \\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Piping\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For calls to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the result of each \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression\\n\", class = c(\"TEXT\", \"tag\")), structure(\"is insterted back into the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humtable][humdrum table]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\". The results\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are put into new field(s) labeled Pipe1, PipeX, ..., PipeN. If the results\\n\", class = c(\"TEXT\", \"tag\")), structure(\"of the expression are shorter than the rows in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humtable\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrum table\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(\"or an \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"object\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the humdrum table is shrunk to fit them.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"humdata <- readHumdrum('directorywithdata/*.krn')\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"withinHumdrum(humdata, ~nchar(.)) # counts characters in each data token.\\n\", class = c(\"RCODE\", \"tag\")), structure(\"withinHumdrum(humdata, ~table(.), by ~ Spine) # Tabulates data tokens in each Spine.\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_examples\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), writeHumdrum.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Write.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"writeHumdrum\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"writeHumdrum\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Write \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data to humdrum files.\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"writeHumdrum(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" humdrumR,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" fieldname = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" affix = \\\"_humdrumR\\\",\\n\", class = c(\"RCODE\", \"tag\")), structure(\" prefix = \\\"\\\",\\n\", class = c(\"RCODE\", \"tag\")), structure(\" rename = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" extension = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" directory = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" EMD = paste0(\\\"Edited in humdrumR \\\", packageVersion(\\\"humdrumR\\\"), \\\" on \\\", Sys.date()),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" overwrite = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" verbose = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"----------NEEDS DOCUMENTATION------------\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\"))), source = list( LO5th.Rd = \"R/tonalInterval.R\", REparser.Rd = \"R/Regex.R\", RegexFind.Rd = \"R/Regex.R\", chordTransformer.Rd = \"R/tertianSet.R\", decimal.Rd = \"R/tools.R\", diatonicSet.Rd = c(\"R/diatonicSet.R\", \"R/tertianSet.R\"), fillThru.Rd = \"R/tools.R\", filterHumdrum.Rd = \"R/Filter.R\", getFields.Rd = \"R/humdrumR-class.R\", getTandem.Rd = \"R/Apply.R\", humActive.Rd = \"R/humdrumR-class.R\", humAssignment.Rd = \"R/humdrumR-class.R\", humCensus.Rd = \"R/Summary.R\", humCoercion.Rd = \"R/humdrumR-class.R\", humColumns.Rd = \"R/humdrumR-class.R\", humFormulae.Rd = \"R/Formulae.R\", humInterpretations.Rd = \"R/Summary.R\", humMerge.Rd = \"R/humdrumR-class.R\", humMeter.Rd = \"R/rhythmInterval.R\", humPipe.Rd = \"R/Piping.R\", humPrint.Rd = \"R/humdrumR-class.R\", humReference.Rd = \"R/Summary.R\", humShape.Rd = \"R/humdrumR-class.R\", humSize.Rd = \"R/humdrumR-class.R\", humSpines.Rd = \"R/Summary.R\", humSummary.Rd = \"R/Summary.R\", humTable.Rd = \"R/humdrumR-class.R\", humValidation.Rd = \"R/Validation.R\", humWindows.Rd = \"R/Windows.R\", humdrumDispatch.Rd = \"R/Compose.R\", humdrumPitch.Rd = \"R/humdrumR-package.R\", humdrumR.Rd = \"R/humdrumR-package.R\", humdrumRclass.Rd = c(\"R/humdrumR-class.R\", \"R/Filter.R\" ), humdrumRroot.Rd = \"R/humdrumR-package.R\", interpolateArguments.Rd = \"R/Apply.R\", intervalCalculus.Rd = \"R/tools.R\", keyTransformer.Rd = \"R/diatonicSet.R\", lag.Rd = \"R/tools.R\", metricPosition.Rd = \"R/rhythmInterval.R\", pitchFunctions.Rd = \"R/tonalInterval.R\", plotRhythm.Rd = \"R/Graphics.R\", rational.Rd = \"R/tools.R\", readHumdrum.Rd = \"R/Read.R\", regexConstruction.Rd = \"R/Regex.R\", rhythmDecompose.Rd = \"R/rhythmInterval.R\", rhythmFunctions.Rd = \"R/rhythmInterval.R\", rhythmInterval.Rd = \"R/rhythmInterval.R\", rhythmOffset.Rd = \"R/rhythmInterval.R\", romanNumerals.Rd = \"R/diatonicSet.R\", struct.Rd = \"R/Vector.R\", tertianSet.Rd = \"R/tertianSet.R\", time.Rd = \"R/rhythmInterval.R\", tonalInterval.Rd = c(\"R/tonalInterval.R\", \"R/rhythmInterval.R\"), tonalTransformations.Rd = \"R/tonalInterval.R\", transpose.Rd = \"R/tonalInterval.R\", withinHumdrum.Rd = \"R/Apply.R\", writeHumdrum.Rd = \"R/Write.R\"), keywords = list(character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), \"datasets\", character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), \"internal\", character(0), \"datasets\", character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0)), concepts = list(\"core pitch representation\", character(0), character(0), character(0), \"humdrumR numeric functions\", character(0), character(0), character(0), character(0), character(0), character(0), character(0), \"humdrum data summary functions\", character(0), character(0), character(0), \"humdrum data summary functions\", character(0), character(0), character(0), character(0), character(0), character(0), character(0), \"humdrum data summary functions\", \"humdrum data summary functions\", character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), \"rhythm analysis tools\", character(0), character(0), \"humdrumR numeric functions\", character(0), character(0), \"rhythm analysis tools\", character(0), \"core rhythm representation\", \"rhythm analysis tools\", character(0), character(0), character(0), character(0), \"core pitch representation\", character(0), character(0), character(0), character(0)), internal = c(FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE )), class = c(\"tbl_df\", \"tbl\", \"data.frame\"), row.names = c(NA, -57L)), tutorials = structure(list(name = character(0), file_out = character(0), title = character(0), pagetitle = character(0), url = character(0)), class = c(\"tbl_df\", \"tbl\", \"data.frame\"), row.names = integer(0)), vignettes = structure(list( name = structure(c(\"GettingStarted\", \"HumdrumSyntax\", \"Intervals\", \"IntroForCoders\", \"KeysAndChord\", \"Overview\", \"PitchAndTonality\", \"ReadWrite\", \"RhythmAndMeter\", \"Validation\" ), class = c(\"fs_path\", \"character\")), file_in = structure(c(\"vignettes/GettingStarted.Rmd\", \"vignettes/HumdrumSyntax.Rmd\", \"vignettes/Intervals.Rmd\", \"vignettes/IntroForCoders.Rmd\", \"vignettes/KeysAndChord.Rmd\", \"vignettes/Overview.Rmd\", \"vignettes/PitchAndTonality.Rmd\", \"vignettes/ReadWrite.Rmd\", \"vignettes/RhythmAndMeter.Rmd\", \"vignettes/Validation.Rmd\"), class = c(\"fs_path\", \"character\" )), file_out = structure(c(\"articles/GettingStarted.html\", \"articles/HumdrumSyntax.html\", \"articles/Intervals.html\", \"articles/IntroForCoders.html\", \"articles/KeysAndChord.html\", \"articles/Overview.html\", \"articles/PitchAndTonality.html\", \"articles/ReadWrite.html\", \"articles/RhythmAndMeter.html\", \"articles/Validation.html\"), class = c(\"fs_path\", \"character\" )), title = c(\"Getting started with humdrumR\", \"The Humdrum Syntax\", \"Rhythm and Pitch Intervals\", \"HumdrumR for Coders\", \"Diatonic and Tertian Sets in humdrumR\", \"Overview of humdrumR\", \"Pitch and Tonality in humdrumR\", \"Reading and writing data with humdrumR\", \"Rhythm and Meter in humdrumR\", \"Validating Humdrum Data\" ), description = c(NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, NA_character_), depth = c(1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L)), class = c(\"tbl_df\", \"tbl\", \"data.frame\"), row.names = c(NA, -10L)), bs_version = 5L, prefix = \"\"), class = \"pkgdown\")), examples = base::quote(TRUE), run_dont_run = base::quote(FALSE), seed = base::quote(1014), lazy = base::quote(FALSE), override = base::quote(list()), install = base::quote(FALSE), preview = base::quote(FALSE), new_process = base::quote(FALSE), devel = base::quote(FALSE), crayon_enabled = base::quote(TRUE), crayon_colors = base::quote(256L), pkgdown_internet = base::quote(TRUE)) #> \t      pkgdown::build_site(...) #> \t        build_site_local(pkg = pkg, examples = examples, run_dont_run = run_dont_run, seed = seed, lazy = lazy, override = override, preview = preview, devel = devel) #> \t          build_reference(pkg, lazy = lazy, examples = examples, run_dont_run = run_dont_run, seed = seed, override = override, preview = FALSE, devel = devel) #> \t            purrr::map(topics, build_reference_topic, pkg = pkg, lazy = lazy, examples_env = examples_env, run_dont_run = run_dont_run) #> \t              .f(.x[[i]], ...) #> \t                data_reference_topic(topic, pkg, examples_env = examples_env, run_dont_run = run_dont_run) #> \t                  run_examples(tags$tag_examples[[1]], env = if (is.null(examples_env)) NULL else new.env(parent = examples_env), topic = tools::file_path_sans_ext(topic$file_in), run_dont_run = run_dont_run) #> \t                    highlight_examples(code, topic, env = env) #> \t                      downlit::evaluate_and_highlight(code, fig_save = fig_save_topic, env = child_env(env), output_handler = evaluate::new_output_handler(value = pkgdown_print)) #> \t                        evaluate::evaluate(code, child_env(env), new_device = TRUE, output_handler = output_handler) #> \t                          evaluate_call(expr, parsed$src[[i]], envir = envir, enclos = enclos, debug = debug, last = i == length(out), use_try = stop_on_error != 2L, keep_warning = keep_warning, keep_message = keep_message, output_handler = output_handler, include_timing = include_timing) #> \t                            eval(expr, envir, enclos) #> \t                              withinHumdrum(humdata, ~nchar(.)) #> \t                                .withHumdrum(humdrumR, ..., withfunc = \"withinHumdrum\") #> \t                                  checkhumdrumR(humdrumR, withfunc) #> Error: In the call withinHumdrum(humdrumR = _), the argument humdrumR must be a humdrumR object. withinHumdrum(humdata, ~table(.), by ~ Spine) # Tabulates data tokens in each Spine. #> HumdrumR error in call stack: #> \t  NULL #> \t    (function (..., crayon_enabled, crayon_colors, pkgdown_internet) { options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, pkgdown.internet = pkgdown_internet) pkgdown::build_site(...) })(pkg = base::quote(structure(list(package = \"humdrumR\", version = \"0.3.0.9000\", lang = \"en\", src_path = structure(\"/home/nat/Bridge/Coding/R/Packages/humdrumR\", class = c(\"fs_path\", \"character\")), dst_path = structure(\"/home/nat/Bridge/Coding/R/Packages/humdrumR/docs\", class = c(\"fs_path\", \"character\")), install_metadata = FALSE, desc = <environment>, meta = list(authors = list(`Nathaniel Condit-Schultz` = list( href = \"http://fathermckenzie.net/\"), `Claire Arthur` = list( href = \"https://clairearthur.com/\")), url = \"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR\", home = list(sidebar = list(structure = c(\"links\", \"license\", \"community\", \"citation\", \"authors\", \"dev\", \"toc\"))), template = list(bootstrap = 5L, bootswatch = \"flatly\"), reference = list(list(title = \"Musical Tools\", desc = \"These pages describe the classes and functions that directly represent or engage musical/music-theoretic concepts.\\n\", contents = \"intervalCalculus\"), list(subtitle = \"Pitch\", desc = \"Pitch and tonality classes and functions.\", contents = c(\"humdrumPitch\", \"pitch\", \"tonalInterval\", \"tonalTransformations\", \"LO5th\", \"diatonicSet\", \"tertianSet\", \"romanNumerals\", \"transpose\", \"chordTransformer\", \"keyTransformer\", \"pitchFunctions\")), list(subtitle = \"Rhythm\", desc = \"Rhythm and meter classes and functions.\", contents = c(\"humMeter\", \"rhythmInterval\", \"time\", \"metricPosition\", \"rhythmDecompose\", \"rhythmFunctions\", \"rhythmOffset\", \"plotRhythm\")), list(title = \"Reading and Summarizing Data\", desc = \"These tools allow you to import, validate, and abstractly summarize the content of humdrum data.\"), list(subtitle = \"Reading and Writing\", contents = c(\"humValidation\", \"readHumdrum\", \"writeHumdrum\")), list(subtite = \"Summarizing\", contents = c(\"humSummary\", \"humCensus\", \"humReference\", \"humSpines\")), list(title = \"Working with Data\", desc = \"These pages describe tools used to manipulate the musical data ensconced within humdrumR data structures.\\n\"), list(subtitle = \"Manipulating Humdrum Data\", contents = c(\"withinHumdrum\", \"humPipe\", \"filterHumdrum\", \"humWindows\", \"interpolateArguments\", \"humFormulae\")), list(subtitle = \"Manipulating Vectors\", contents = c(\"fillThru\", \"lag\")), list(subtitle = \"Regular Expressions\", desc = \"[Regular Expressions](https://en.wikipedia.org/wiki/Regular_expression) are essential tools for working with humdrum data. These functions provide functionality for working with regular expressions.\\n\", contents = c(\"RegexFind\", \"humdrumDispatch\", \"regexConstruction\", \"REparser\")), list(title = \"Data Structures\", desc = \"These are pages describe the data structures of humdrumR---which contain the musical data.\\n\", contents = c(\"humdrumRclass\", \"getFields\", \"getTandem\", \"humActive\", \"humAssignment\", \"humCoercion\", \"humColumns\", \"humMerge\", \"humInterpretations\", \"humPrint\", \"humShape\", \"humSize\", \"humTable\", \"struct\")), list(title = \"Other Functions\", desc = \"Other useful tools\"), list(subtitle = \"Numeric values\", contents = c(\"rational\", \"decimal\", \"humdrumRroot\")))), figures = structure(list( dev = \"ragg::agg_png\", dpi = 96L, dev.args = list(), fig.ext = \"png\", fig.width = 7.29166666666667, fig.height = NULL, fig.retina = 2L, fig.asp = 0.618046971569839, bg = NULL, other.parameters = list()), class = \"print_yaml\"), repo = list( url = list(home = \"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/\", source = \"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/blob/HEAD/\", issue = \"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/issues/\", user = \"https://github.com/\")), development = list( destination = \"dev\", mode = \"default\", version_label = \"muted\", in_dev = FALSE), topics = structure(list(name = c(LO5th.Rd = \"LO5th\", REparser.Rd = \"REparser\", RegexFind.Rd = \"RegexFind\", chordTransformer.Rd = \"chordTransformer\", decimal.Rd = \"decimal\", diatonicSet.Rd = \"diatonicSet\", fillThru.Rd = \"fillThru\", filterHumdrum.Rd = \"filterHumdrum\", getFields.Rd = \"getFields\", getTandem.Rd = \"getTandem\", humActive.Rd = \"humActive\", humAssignment.Rd = \"humAssignment\", humCensus.Rd = \"humCensus\", humCoercion.Rd = \"humCoercion\", humColumns.Rd = \"humColumns\", humFormulae.Rd = \"humFormulae\", humInterpretations.Rd = \"humInterpretations\", humMerge.Rd = \"humMerge\", humMeter.Rd = \"humMeter\", humPipe.Rd = \"humPipe\", humPrint.Rd = \"humPrint\", humReference.Rd = \"humReference\", humShape.Rd = \"humShape\", humSize.Rd = \"humSize\", humSpines.Rd = \"humSpines\", humSummary.Rd = \"humSummary\", humTable.Rd = \"humTable\", humValidation.Rd = \"humValidation\", humWindows.Rd = \"humWindows\", humdrumDispatch.Rd = \"humdrumDispatch\", humdrumPitch.Rd = \"humdrumPitch\", humdrumR.Rd = \"humdrumR\", humdrumRclass.Rd = \"humdrumRclass\", humdrumRroot.Rd = \"humdrumRroot\", interpolateArguments.Rd = \"interpolateArguments\", intervalCalculus.Rd = \"intervalCalculus\", keyTransformer.Rd = \"keyTransformer\", lag.Rd = \"lag\", metricPosition.Rd = \"metricPosition\", pitchFunctions.Rd = \"pitchFunctions\", plotRhythm.Rd = \"plotRhythm\", rational.Rd = \"rational\", readHumdrum.Rd = \"readHumdrum\", regexConstruction.Rd = \"regexConstruction\", rhythmDecompose.Rd = \"rhythmDecompose\", rhythmFunctions.Rd = \"rhythmFunctions\", rhythmInterval.Rd = \"rhythmInterval\", rhythmOffset.Rd = \"rhythmOffset\", romanNumerals.Rd = \"romanNumerals\", struct.Rd = \"struct\", tertianSet.Rd = \"tertianSet\", time.Rd = \"time\", tonalInterval.Rd = \"tonalInterval\", tonalTransformations.Rd = \"tonalTransformations\", transpose.Rd = \"transpose\", withinHumdrum.Rd = \"withinHumdrum\", writeHumdrum.Rd = \"writeHumdrum\"), file_in = c(\"LO5th.Rd\", \"REparser.Rd\", \"RegexFind.Rd\", \"chordTransformer.Rd\", \"decimal.Rd\", \"diatonicSet.Rd\", \"fillThru.Rd\", \"filterHumdrum.Rd\", \"getFields.Rd\", \"getTandem.Rd\", \"humActive.Rd\", \"humAssignment.Rd\", \"humCensus.Rd\", \"humCoercion.Rd\", \"humColumns.Rd\", \"humFormulae.Rd\", \"humInterpretations.Rd\", \"humMerge.Rd\", \"humMeter.Rd\", \"humPipe.Rd\", \"humPrint.Rd\", \"humReference.Rd\", \"humShape.Rd\", \"humSize.Rd\", \"humSpines.Rd\", \"humSummary.Rd\", \"humTable.Rd\", \"humValidation.Rd\", \"humWindows.Rd\", \"humdrumDispatch.Rd\", \"humdrumPitch.Rd\", \"humdrumR.Rd\", \"humdrumRclass.Rd\", \"humdrumRroot.Rd\", \"interpolateArguments.Rd\", \"intervalCalculus.Rd\", \"keyTransformer.Rd\", \"lag.Rd\", \"metricPosition.Rd\", \"pitchFunctions.Rd\", \"plotRhythm.Rd\", \"rational.Rd\", \"readHumdrum.Rd\", \"regexConstruction.Rd\", \"rhythmDecompose.Rd\", \"rhythmFunctions.Rd\", \"rhythmInterval.Rd\", \"rhythmOffset.Rd\", \"romanNumerals.Rd\", \"struct.Rd\", \"tertianSet.Rd\", \"time.Rd\", \"tonalInterval.Rd\", \"tonalTransformations.Rd\", \"transpose.Rd\", \"withinHumdrum.Rd\", \"writeHumdrum.Rd\"), file_out = c(\"LO5th.html\", \"REparser.html\", \"RegexFind.html\", \"chordTransformer.html\", \"decimal.html\", \"diatonicSet.html\", \"fillThru.html\", \"filterHumdrum.html\", \"getFields.html\", \"getTandem.html\", \"humActive.html\", \"humAssignment.html\", \"humCensus.html\", \"humCoercion.html\", \"humColumns.html\", \"humFormulae.html\", \"humInterpretations.html\", \"humMerge.html\", \"humMeter.html\", \"humPipe.html\", \"humPrint.html\", \"humReference.html\", \"humShape.html\", \"humSize.html\", \"humSpines.html\", \"humSummary.html\", \"humTable.html\", \"humValidation.html\", \"humWindows.html\", \"humdrumDispatch.html\", \"humdrumPitch.html\", \"humdrumR.html\", \"humdrumRclass.html\", \"humdrumRroot.html\", \"interpolateArguments.html\", \"intervalCalculus.html\", \"keyTransformer.html\", \"lag.html\", \"metricPosition.html\", \"pitchFunctions.html\", \"plotRhythm.html\", \"rational.html\", \"readHumdrum.html\", \"regexConstruction.html\", \"rhythmDecompose.html\", \"rhythmFunctions.html\", \"rhythmInterval.html\", \"rhythmOffset.html\", \"romanNumerals.html\", \"struct.html\", \"tertianSet.html\", \"time.html\", \"tonalInterval.html\", \"tonalTransformations.html\", \"transpose.html\", \"withinHumdrum.html\", \"writeHumdrum.html\" ), alias = list(LO5th.Rd = \"LO5th\", REparser.Rd = c(\"REparser\", \"REparse\"), RegexFind.Rd = c(\"RegexFind\", \"%~l%\", \"%~i%\", \"%~n%\", \"%~m%\", \"%~%\"), chordTransformer.Rd = c(\"chordTransformer\", \"figuredBass\"), decimal.Rd = c(\"decimal\", \"as.decimal\"), diatonicSet.Rd = c(\"diatonicSet\", \"dset\", \"as.character,diatonicSet-method\", \"is.diatonicSet\", \"order.diatonicSet\", \"==,diatonicSet,diatonicSet-method\", \"Compare,diatonicSet,diatonicSet-method\", \"diatonicSet.diatonicSet\", \"diatonicSet.logical\", \"diatonicSet.numeric\", \"diatonicSet.integer\", \"diatonicSet.character\"), fillThru.Rd = c(\"fillThru\", \"fillForward\", \"fillBackwards\"), filterHumdrum.Rd = c(\"filterHumdrum\", \"removeEmptyFiles\", \"removeEmptySpines\", \"removeEmptyRecords\", \"[,humdrumR,missing,ANY-method\", \"[,humdrumR,numeric,ANY-method\", \"[,humdrumR,character,ANY-method\", \"[,humdrumR,formula,ANY-method\", \"[[,humdrumR,numeric,missing-method\", \"[[,humdrumR,missing,numeric-method\", \"[[,humdrumR,character,missing-method\", \"[[,humdrumR,ANY,ANY-method\" ), getFields.Rd = \"getFields\", getTandem.Rd = \"getTandem\", humActive.Rd = c(\"humActive\", \"evalActive\", \"getActive\", \"setActive\", \"setActiveFields\"), humAssignment.Rd = \"humAssignment\", humCensus.Rd = c(\"humCensus\", \"census\", \"[.humCensus\", \"print.humCensus\"), humCoercion.Rd = c(\"humCoercion\", \"as.lines\", \"as.matrix.humdrumR\", \"as.matrices\", \"as.data.frames\" ), humColumns.Rd = \"humColumns\", humFormulae.Rd = c(\"humFormulae\", \"ditto\"), humInterpretations.Rd = c(\"humInterpretations\", \"interpretations\", \"print.humInterpretations\"), humMerge.Rd = c(\"humMerge\", \"mergeHumdrum\"), humMeter.Rd = \"humMeter\", humPipe.Rd = c(\"humPipe\", \"%hum>%\", \"%hum<%\", \"%humT%\", \"%s>%\", \"%hums>%\", \"%hums<%\", \"%humsT%\", \"%hums[]%\"), humPrint.Rd = c(\"humPrint\", \"print_humtab\" ), humReference.Rd = c(\"humReference\", \"reference\", \"reference.character\", \"reference.humdrumR\", \"[.humReference\", \"print.humReference\" ), humShape.Rd = c(\"humShape\", \"foldHumdrum\", \"foldStops\", \"foldPaths\", \"foldRecords\", \"spinePipe\"), humSize.Rd = c(\"humSize\", \"nrecords\", \"ntokens\", \"npieces\", \"anySubcorpora\", \"namesSubcorpora\", \"nfiles\", \"is.empty\", \"anyPaths\", \"anyStops\"), humSpines.Rd = c(\"humSpines\", \"spines\", \"[.humSpines\", \"print.humSpines\"), humSummary.Rd = \"humSummary\", humTable.Rd = c(\"humTable\", \"getHumtab\"), humValidation.Rd = c(\"humValidation\", \"validateHumdrum\"), humWindows.Rd = c(\"humWindows\", \"windows\", \"hop\", \"nest\"), humdrumDispatch.Rd = c(\"humdrumDispatch\", \"makeDispatchDF\", \"makeHumdrumDispatcher\", \"print.humdrumDispatch\" ), humdrumPitch.Rd = \"humdrumPitch\", humdrumR.Rd = \"humdrumR\", humdrumRclass.Rd = c(\"humdrumRclass\", \"makeHumdrumR\", \"humdrumRS4\", \"is.humdrumR\", \"$,humdrumR-method\", \"fields\", \"$<-,humdrumR,vector-method\", \"$<-,humdrumR,humdrumR-method\", \"[<-,humdrumR,character,ANY,vector-method\", \"[<-,humdrumR,character,ANY,humdrumR-method\", \"[[,humdrumR,missing,character-method\", \"[[,humdrumR,missing,missing-method\", \"[[,humdrumR,formula,missing-method\", \"[[,humdrumR,missing,formula-method\" ), humdrumRroot.Rd = \"humdrumRroot\", interpolateArguments.Rd = \"interpolateArguments\", intervalCalculus.Rd = c(\"intervalCalculus\", \"integrate\", \"sigma\", \"derive\", \"delta\", \"calculus\"), keyTransformer.Rd = c(\"keyTransformer\", \"key\"), lag.Rd = c(\"lag\", \"lead\"), metricPosition.Rd = \"metricPosition\", pitchFunctions.Rd = c(\"pitchFunctions\", \"semit\", \"midi\", \"pitch\", \"kern\", \"lilypond\", \"interval\", \"degree\", \"solfa\" ), plotRhythm.Rd = c(\"plotRhythm\", \"plotRhythm.default\", \"plotRhythm.rhythmInterval\"), rational.Rd = c(\"rational\", \"as.rational\", \"fraction\", \"as.fraction\"), readHumdrum.Rd = c(\"readHumdrum\", \"findHumdrum\"), regexConstruction.Rd = c(\"regexConstruction\", \"captureRE\", \"captureUniq\", \"orRE\"), rhythmDecompose.Rd = \"rhythmDecompose\", rhythmFunctions.Rd = c(\"rhythmFunctions\", \"recip\", \"duration\" ), rhythmInterval.Rd = c(\"rhythmInterval\", \"rint\", \"as.character,rhythmInterval-method\", \"as.double.rhythmInterval\", \"is.rhythmInterval\", \"is.numeric,rhythmInterval-method\", \"order.rhythmInterval\", \"Compare,rhythmInterval,rhythmInterval-method\", \"Summary,rhythmInterval-method\", \"rhythmInterval.logical\", \"rhythmInterval.NULL\", \"rhythmInterval.numeric\", \"rhythmInterval.rational\", \"rhythmInterval.fraction\", \"rhythmInterval.integer\", \"rhythmInterval.character\"), rhythmOffset.Rd = \"rhythmOffset\", romanNumerals.Rd = \"romanNumerals\", struct.Rd = c(\"struct\", \"is.struct\"), tertianSet.Rd = c(\"tertianSet\", \"tset\", \"is.tertianSet\"), time.Rd = c(\"time\", \"bpm2ms\", \"ms2bpm\" ), tonalInterval.Rd = c(\"tonalInterval\", \"tint\", \"is.tonalInterval\", \"tonalInterval.tonalInterval\", \"tonalInterval.logical\", \"tonalInterval.NULL\", \"tonalInterval.numeric\", \"tonalInterval.rational\", \"tonalInterval.fraction\", \"tonalInterval.integer\", \"tonalInterval.character\", \"rhythmInterval.rhythmInterval\"), tonalTransformations.Rd = c(\"tonalTransformations\", \"invert\"), transpose.Rd = \"transpose\", withinHumdrum.Rd = c(\"withinHumdrum\", \"withHumdrum\", \"inHumdrum\", \"humApply\"), writeHumdrum.Rd = \"writeHumdrum\"), funs = list(LO5th.Rd = \"LO5th()\", REparser.Rd = c(\"REparser()\", \"REparse()\"), RegexFind.Rd = c(\"`%~l%`\", \"`%~i%`\", \"`%~n%`\", \"`%~m%`\", \"`%~%`\"), chordTransformer.Rd = \"figuredBass()\", decimal.Rd = c(\"decimal()\", \"as.decimal()\"), diatonicSet.Rd = c(\"dset()\", \"as.character(<i>&lt;diatonicSet&gt;<\/i>)\", \"is.diatonicSet()\", \"order.diatonicSet()\", \"`==`(<i>&lt;diatonicSet&gt;<\/i>,<i>&lt;diatonicSet&gt;<\/i>)\", \"Compare(<i>&lt;diatonicSet&gt;<\/i>,<i>&lt;diatonicSet&gt;<\/i>)\", \"diatonicSet(<i>&lt;diatonicSet&gt;<\/i>)\", \"diatonicSet(<i>&lt;logical&gt;<\/i>)\", \"diatonicSet(<i>&lt;numeric&gt;<\/i>)\", \"diatonicSet(<i>&lt;integer&gt;<\/i>)\", \"diatonicSet(<i>&lt;character&gt;<\/i>)\", \"as.character(<i>&lt;tertianSet&gt;<\/i>)\", \"`==`(<i>&lt;tertianSet&gt;<\/i>,<i>&lt;tertianSet&gt;<\/i>)\" ), fillThru.Rd = c(\"fillThru()\", \"fillForward()\", \"fillBackwards()\"), filterHumdrum.Rd = c(\"filterHumdrum()\", \"removeEmptyFiles()\", \"removeEmptySpines()\", \"removeEmptyRecords()\", \"`[`\", \"`[`\", \"`[`\", \"`[`\", \"`[[`\", \"`[[`\", \"`[[`\", \"`[[`\"), getFields.Rd = \"getFields()\", getTandem.Rd = \"getTandem()\", humActive.Rd = c(\"evalActive()\", \"getActive()\", \"setActive()\", \"setActiveFields()\"), humAssignment.Rd = character(0), humCensus.Rd = c(\"census()\", \"`[`\", \"print(<i>&lt;humCensus&gt;<\/i>)\" ), humCoercion.Rd = c(\"as.vector(<i>&lt;humdrumR&gt;<\/i>)\", \"as.lines()\", \"as.matrix(<i>&lt;humdrumR&gt;<\/i>)\", \"as.data.frame(<i>&lt;humdrumR&gt;<\/i>)\", \"as.matrices()\", \"as.data.frames()\"), humColumns.Rd = character(0), humFormulae.Rd = \"ditto\", humInterpretations.Rd = c(\"interpretations()\", \"print(<i>&lt;humInterpretations&gt;<\/i>)\"), humMerge.Rd = \"mergeHumdrum()\", humMeter.Rd = character(0), humPipe.Rd = c(\"`%hum&gt;%`\", \"`%hum&lt;%`\", \"`%humT%`\", \"`%s&gt;%`\", \"`%hums&gt;%`\", \"`%hums&lt;%`\", \"`%humsT%`\", \"`%hums[]%`\"), humPrint.Rd = c(\"show(<i>&lt;humdrumR&gt;<\/i>)\", \"print_humtab()\"), humReference.Rd = c(\"reference()\", \"reference()\", \"reference()\", \"`[`(<i>&lt;humReference&gt;<\/i>)\" ), humShape.Rd = c(\"foldHumdrum()\", \"foldStops()\", \"foldPaths()\", \"foldRecords()\", \"spinePipe()\"), humSize.Rd = c(\"nrecords()\", \"ntokens()\", \"npieces()\", \"anySubcorpora()\", \"namesSubcorpora()\", \"nfiles()\", \"length(<i>&lt;humdrumR&gt;<\/i>)\", \"nrow(<i>&lt;humdrumR&gt;<\/i>)\", \"is.empty()\", \"anyPaths()\", \"anyStops()\"), humSpines.Rd = c(\"spines()\", \"`[`(<i>&lt;humSpines&gt;<\/i>)\", \"print(<i>&lt;humSpines&gt;<\/i>)\" ), humSummary.Rd = \"summary(<i>&lt;humdrumR&gt;<\/i>)\", humTable.Rd = \"getHumtab()\", humValidation.Rd = \"validateHumdrum()\", humWindows.Rd = c(\"windows()\", \"hop()\", \"nest()\"), humdrumDispatch.Rd = c(\"humdrumDispatch()\", \"makeDispatchDF()\", \"makeHumdrumDispatcher()\", \"print(<i>&lt;humdrumDispatch&gt;<\/i>)\" ), humdrumPitch.Rd = character(0), humdrumR.Rd = character(0), humdrumRclass.Rd = character(0), humdrumRroot.Rd = \"humdrumRroot\", interpolateArguments.Rd = \"interpolateArguments()\", intervalCalculus.Rd = c(\"integrate()\", \"sigma()\", \"derive()\", \"delta()\", \"calculus()\"), keyTransformer.Rd = \"key()\", lag.Rd = c(\"lag()\", \"lead()\"), metricPosition.Rd = \"metricPosition()\", pitchFunctions.Rd = c(\"semit()\", \"midi()\", \"pitch()\", \"kern()\", \"lilypond()\", \"interval()\", \"degree()\", \"solfa()\"), plotRhythm.Rd = \"plotRhythm()\", rational.Rd = c(\"rational()\", \"as.rational()\", \"fraction()\", \"as.fraction()\"), readHumdrum.Rd = c(\"findHumdrum()\", \"readHumdrum()\" ), regexConstruction.Rd = c(\"captureRE()\", \"captureUniq()\", \"orRE()\"), rhythmDecompose.Rd = \"rhythmDecompose()\", rhythmFunctions.Rd = c(\"recip()\", \"duration()\"), rhythmInterval.Rd = character(0), rhythmOffset.Rd = \"rhythmOffset()\", romanNumerals.Rd = character(0), struct.Rd = \"is.struct()\", tertianSet.Rd = c(\"tertianSet()\", \"tset()\", \"is.tertianSet()\" ), time.Rd = c(\"bpm2ms()\", \"ms2bpm()\"), tonalInterval.Rd = character(0), tonalTransformations.Rd = \"invert()\", transpose.Rd = \"transpose()\", withinHumdrum.Rd = c(\"withinHumdrum()\", \"withHumdrum()\", \"inHumdrum()\", \"humApply()\"), writeHumdrum.Rd = \"writeHumdrum()\"), title = c(LO5th.Rd = \"Line of Fifths\", REparser.Rd = \"Parse String Using Regular expressions\", RegexFind.Rd = \"Match strings against regular expression\", chordTransformer.Rd = \"Parsing and deparsing chord information.\", decimal.Rd = \"Decimal numbers\", diatonicSet.Rd = \"Tonal (diatonic) sets\", fillThru.Rd = \"Propogate data points to \\\"fill\\\" null data.\", filterHumdrum.Rd = \"Filter humdrum data\", getFields.Rd = \"-------------------------------------------&gt; NEEDS DOCUMENTATION &lt;-------------------------------------------\\nGet named\", getTandem.Rd = \"Get tandem interpretation information from humdrum data.\", humActive.Rd = \"The \\\"Active expression\\\" of a humdrumR object.\", humAssignment.Rd = \"Assigning new fields\", humCensus.Rd = \"Tabulate records and tokens in a humdrumR corpus\", humCoercion.Rd = \"humdrumR Coercion.\", humColumns.Rd = \"Spines vs Paths vs Columns\", humFormulae.Rd = \"Standard humdrumR formulae.\", humInterpretations.Rd = \"Summarize humdrum corpus interpretations.\", humMerge.Rd = \"Merge two (or more) humdrumR datasets\", humMeter.Rd = \"Tools for analyzing rhythm and meter.\", humPipe.Rd = \"Piping humdrumR data\", humPrint.Rd = \"-------------------------------------------&gt; NEEDS DOCUMENTATION &lt;-------------------------------------------\", humReference.Rd = \"Summarize reference records in a humdrumR corpus\", humShape.Rd = \"HumdrumR data \\\"Shape\\\"\", humSize.Rd = \"humdrumR size and shape\", humSpines.Rd = \"Summarize spines in humdrum dataset\", humSummary.Rd = \"Summarize humdrumR corpora\", humTable.Rd = \"Humdrum Tables\", humValidation.Rd = \"Validate humdrum files\", humWindows.Rd = \"Applying functions across arbitrary windows.\\n----------------------------------------------&gt; NEEDS DOCUMENTATION &lt;----------------------------------------------------\", humdrumDispatch.Rd = \"Regular expression method dispatch and function application\", humdrumPitch.Rd = \"humdrumR and pitch\", humdrumR.Rd = \"humdrumR\", humdrumRclass.Rd = \"HumdrumR class\", humdrumRroot.Rd = \"<code>humdrumR<\/code>'s root directory on your machine.\", interpolateArguments.Rd = \"Change or insert values in an expression\", intervalCalculus.Rd = \"Interval \\\"calculus\\\"\", keyTransformer.Rd = \"Parsing and deparsing key information\", lag.Rd = \"Shift data within a vector/matrix/data.frame\", metricPosition.Rd = \"Calculate metric positions from duration data.\", pitchFunctions.Rd = \"Manipulate pitch data\", plotRhythm.Rd = \"-------------------------------------------&gt; NEEDS DOCUMENTATION &lt;-------------------------------------------\\nPlotting rhythmic symbols in R base graphics\", rational.Rd = \"Rational numbers\", readHumdrum.Rd = \"Find and read humdrum files into R\", regexConstruction.Rd = \"Making Regular Expressions\", rhythmDecompose.Rd = \"Decompose durations in terms of other durations\", rhythmFunctions.Rd = \"Manipulate pitch data\", rhythmInterval.Rd = \"Representation of rhythmic information\", rhythmOffset.Rd = \"Calculate rhythmic \\\"offset\\\"\", romanNumerals.Rd = \"Roman Numeral\", struct.Rd = \"struct\", tertianSet.Rd = \"Tertian set\", time.Rd = \"Time transformations\", tonalInterval.Rd = \"Representation of tonal pitch information\", tonalTransformations.Rd = \"Invert or transpose tonal intervals.\", transpose.Rd = \"Transpose pitches and keys\", withinHumdrum.Rd = \"with(in)Humdrum\", writeHumdrum.Rd = \"Write <code>humdrumR<\/code> data to humdrum files.\" ), rd = list(LO5th.Rd = structure(list(structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/tonalInterval.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"LO5th\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"LO5th\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"Line of Fifths\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"LO5th(x, generic = FALSE, ...)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Returns an integer vector or array, matching the input.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_value\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The function \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"LO5th\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is a S3-generic function with methods to extract\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the \\\"line-of-fifths\\\" value from various pitch objects and representations.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"The Line of Fifths\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Every interval in Western music is associated with a integer on the line of fifths:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\" )), structure(\" Bb = m7 = -2\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" F = P4 = -1\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(), class = c(\"tag_item\", \"tag\" )), structure(\" C = P1 = 0\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" G = P5 = 1\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" D = M2 = 2\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" A = M6 = 3\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" E = M3 = 4\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" B = M7 = 5\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" F# = A4 = 6\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" etc.\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The natural notes of (C) major scale---which we also call the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"generic intervals\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\"---fall in the range \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"-1:5\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In fact, any diatonic key is a block of seven consecutive numbers of the line-of-fifths: for example, Eb major is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"-4:2\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\\"Sharps\\\" and \\\"flats\\\" represent \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"+7\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"-7\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" on the line-of-fifths respectively.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"tint()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=tint\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Other \", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"core pitch representation\", class = c(\"TEXT\", \"tag\"))), class = c(\"LIST\", \"tag\")), structure(\": \\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"tonalInterval\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"core pitch representation\", class = c(\"TEXT\", \"tag\"))), class = c(\"LIST\", \"tag\"))), class = c(\"tag_concept\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), REparser.Rd = structure(list(structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Regex.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"REparser\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"REparser\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"REparse\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"Parse String Using Regular expressions\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"REparser(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" res,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" parse.strict = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parse.exhaust = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parse.lead = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parse.rest = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" toEnv = FALSE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"REparse(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" str,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" res,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parse.strict = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parse.exhaust = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parse.lead = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parse.rest = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" reverse = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" sep = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" toEnv = FALSE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Takes an input string and parses it into a sequence of regular expressions.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"exhaustive\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is TRUE, the string must be exhaustively broken up by the matching regular expressions.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Superfluous (non-match) characters at the begginning, end, or in bettween matches, will result in\\n\", class = c(\"TEXT\", \"tag\")), structure(\"all \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"NA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" being returned.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), RegexFind.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Regex.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"RegexFind\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"RegexFind\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%~l%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%~i%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%~n%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%~m%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%~%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Match strings against regular expression\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"x %~l% pattern\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"x %~i% pattern\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"x %~n% pattern\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"x %~m% pattern\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"x %~% pattern\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"These infix functions are simply syntactic sugar for\\n\", class = c(\"TEXT\", \"tag\")), structure(\"existing \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"R\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" regular expression matching functions.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If the a vector of regexes is given as the right argument, matches to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"any\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" of the regexes are returned.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%~l%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\": Matches \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pattern\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"x\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and returns \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"logical\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". Shorthand for \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"base::grepl()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:grep\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"%~%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\": The \\\"default\\\"---same as \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%~l%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"%~i%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\": Matches \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pattern\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"x\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and returns \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" indices. Shorthand for \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"base::grep()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:grep\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"%~n%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\": Matches \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pattern\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"x\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and returns \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" counts (can be greater than one if more\\n\", class = c(\"TEXT\", \"tag\")), structure(\"than one match occurs in the same token). Shorthand for \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"stringi::stri_count_regex()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"stringi:stri_count\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"%~m%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\": Matches \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pattern\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"x\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and returns matching strings (or NA if no match). Shorthand for \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"stringi::stri_extract_first_regex()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"stringi:stri_extract\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), chordTransformer.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/tertianSet.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"chordTransformer\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"chordTransformer\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"figuredBass\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Parsing and deparsing chord information.\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"figuredBass(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" Key = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" Exclusive = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parseArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" transposeArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" figurationArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" inPlace = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" memoize = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" deparse = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"These functions are used to work with chord information.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"xxx\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Tertian sets can be read/wrote in various ways.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), decimal.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/tools.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"decimal\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"decimal\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.decimal\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Decimal numbers\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"decimal(x)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"as.decimal(x, ...)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"These functions create decimal numbers that are identical to base R\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"numeric\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (real) numbers.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, these numbers are understood by the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rational numbers\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=rational\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"rational()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=rational\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Other \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR numeric functions\", class = c(\"TEXT\", \"tag\"))), class = c(\"LIST\", \"tag\")), structure(\": \\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"rational\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"()\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"humdrumR numeric functions\", class = c(\"TEXT\", \"tag\"))), class = c(\"LIST\", \"tag\"))), class = c(\"tag_concept\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), diatonicSet.Rd = structure(list(structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/diatonicSet.R, R/tertianSet.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"diatonicSet\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"diatonicSet\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"dset\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"as.character,diatonicSet-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"is.diatonicSet\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"order.diatonicSet\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"==,diatonicSet,diatonicSet-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Compare,diatonicSet,diatonicSet-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet.diatonicSet\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet.logical\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet.numeric\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet.integer\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet.character\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Tonal (diatonic) sets\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"dset(root = 0L, signature = root, alterations = 0L)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list(structure(list(structure(\"as.character\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"diatonicSet\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(x)\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"is.diatonicSet(x)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"order.diatonicSet(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" parallel = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" na.last = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" decreasing = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" method = c(\\\"auto\\\", \\\"shell\\\", \\\"radix\\\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list( structure(list(structure(\"==\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"diatonicSet,diatonicSet\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(e1, e2)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"Compare\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"diatonicSet,diatonicSet\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(e1, e2)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"diatonicSet\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"diatonicSet\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"diatonicSet\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"logical\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"diatonicSet\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"numeric\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x)\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list( structure(list(structure(\"diatonicSet\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"integer\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x)\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list( structure(list(structure(\"diatonicSet\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"character\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(str, Exclusive = NULL, Key = NULL, ..., multiDispatch = FALSE)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"as.character\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"tertianSet\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(x)\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list( structure(list(structure(\"==\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"tertianSet,tertianSet\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(e1, e2)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is one of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"'s\\n\", class = c(\"TEXT\", \"tag\")), structure(\"types of tonal data, representing Western diatonic keys.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For the most part, users should not need to interact with diatonicSets directly---rather, diatonicSets work behind the scene in numerous \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" pitch functions.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"See the \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"keyRepresentations\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"keyTransformations\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" documentation for details of usage and functionality or the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Tonality in humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" vignette for\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a detailed explanation of the theory and specifics of diatonicSets.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://adv-r.had.co.nz/S4.html\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"S4\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\" )), structure(\" subclass of \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"'s virtual class \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(\"from which it inherits a lot of useful \\\"vector-like\\\" behaviors/functionality.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The constructor function \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"dset\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" can be used to create \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSets\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" directly.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The three arguments corespond to the three slots: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"root\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"mode\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"alteration\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"All inputs will be coerced to match in length.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"root\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument will attempt to coerce character strings to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalIntervals\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=tonalInterval\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\", and use their \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"LO5th\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" value as the root.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"By default, the \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"as.character\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:character\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" method, and thus (via \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\") the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"show\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"methods:show\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" method,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"for diatonicSets call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"key()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=diatonicRepresentations\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Thus, if you return a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" on the command line (or call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"print\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:print\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" one one),\\n\", class = c(\"TEXT\", \"tag\")), structure(\"you'll see the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"key interpretation\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=diatonicRepresentations\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" representation printed.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Slots\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(list(structure(\"Root\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"integers representing the root of the key on the line-of-fifths\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(list(structure(\"Signature\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"integers representing the signature (number of accidentals) of the key.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(list(structure(\"Alteration\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"integers representing alterations of the diatonic set\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"A key is represented by two integers, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Root\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Signature\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Root is simply the tonic note of the key on the circle of fifths.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Signature is a value on the circle of fifths, indicating the diatonic mode.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"You can think of the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Signature\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" value as indicating the number of accidentals, with negative numbers\\n\", class = c(\"TEXT\", \"tag\")), structure(\"for flats and positive numbers for sharps.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"You can also think of the signature as indicating how much the \\\"natural key\\\" (C major) is\\n\", class = c(\"TEXT\", \"tag\")), structure(\"slid up and down the line-of-fifths.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Mode_(music)\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"traditional diatonic modes\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" of Western music occur wherever \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Signature - Tonic\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is in the range \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"-5:1\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\":\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"Signature - Tonic = +1 \\\\rightarrow\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\" Lydian\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"Signature - Tonic = +0 \\\\rightarrow\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\" Major (Ionian)\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"Signature - Tonic = -1 \\\\rightarrow\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\" Mixolydian\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"Signature - Tonic = -2 \\\\rightarrow\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\" Dorian\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"Signature - Tonic = -3 \\\\rightarrow\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\" Minor (Aeolian)\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"Signature - Tonic = -5 \\\\rightarrow\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\" Locrian\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"Signature - Tonic = -4 \\\\rightarrow\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\" Phyrgian\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Note that you can make diatonicSets where the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Root\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is outside the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Key\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". This is unusual, and may result in sets you wouldn't predict.\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_describe\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Alterations\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Alteration\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" slots (also integer) can be used to represent various\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\\"altered\\\" scales.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The integer values are interpreted as a seven-trit \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Balanced_ternary\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"balanced ternary\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" string.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(\\\"trits\\\" are the ternary equivalent of binary \\\"bits.\\\")\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Balanced ternary allows for three digits, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"0\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (unaltered degree), \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"1\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (sharpened degree), and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"-1\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (flattened degree).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The seven trits correspond to the seven scale degrees on the line-of-fifth indicated by the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"signature\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\"---i.e., ordered from\\n\", class = c(\"TEXT\", \"tag\")), structure(\"lowest to hightest on the line-of-fifths, not relative to the root.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(For instance, when \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Signature == 0\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the degrees are \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"c(-1, 0, 1, 2, 3, 4, 5)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The ternary arrangement maps powers of three to each scale degree, as so that in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Alteration\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" integer:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"\\\\pm 1\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\": raise or flatten the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"7th\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" scale degree.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"\\\\pm 3\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\": raise or flatten the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"3rd\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" scale degree.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"\\\\pm 9\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\": raise or flatten the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"6th\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" scale degree.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"\\\\pm 27\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\": raise or flatten the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"2nd\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" scale degree.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"\\\\pm 81\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\": raise or flatten the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"5th\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" scale degree.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"\\\\pm 243\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\": raise or flatten the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"1st\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" scale degree.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"\\\\pm 749\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\": raise or flatten the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"4th\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" scale degree.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For example, consider \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Alteration == 26\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\":\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In a balanced ternary representation, the decimal integer 26 is represented as \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"1 0 0 1 0 -1 0\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(In other words 1 in the \\\"27s place\\\" and -1 in the \\\"ones place\\\"---i.e., 27 - 1).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This represents a raised 2nd (the 27) and a lowered 7th (the -1).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"Alteration\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\")), structure(\" integer allows us to concisely represent all the 2,187 possible combinations of raised and lowered diatonic scale degrees!\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, combined with the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Signature\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" slot, there is some redundancy in scale representation.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For example, a melodic minor scale can be represented as a major scale (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Signature - Root == 0\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") with a lowered third degree (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Alteration == -3\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"or\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" as\\n\", class = c(\"TEXT\", \"tag\")), structure(\"minor scale (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Signature - Root == -3\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") with raised 6ths and 7ths (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Alteration == 10\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, though these two representations result in the same set on the line-of-fifths, some might consider them to be\\n\", class = c(\"TEXT\", \"tag\")), structure(\"conceptually different in some contexts, so we consider the redundancy acceptable.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Another case of encoding redundancy \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"is\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" that \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Alteration - 1\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (flatten the 7th) is exactly equivalent to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Signature - 1\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Similarly, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Alteration + 749\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (raise the 4th) is exactly equivalent to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Signature + 1\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Double-flat and double-sharp degrees are \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"not\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" encodable in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, in combination with the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Signature\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" slot, sets with double-flat/sharps (like doubly-diminished 7ths) can be encoded.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Arithmatic\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Arithmetic between diatonicSets is not defined.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, a number of useful arithmetic operations between diatonicSets and other data types \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"are\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" defined:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"XXXX Elaborate\\n\", class = c(\"TEXT\", \"tag\")), structure(\"XXXX Need to implement special logic for adding Alterations! (Taking into account Signature addition.)\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Relational Operators\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"diatonicSets can be compared using the standard \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"relational operations\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:Comparison\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"==\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"!=\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Two diatonicSets are equal (according to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"==\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") only if all their slots (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Root\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Signature\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Alteration\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\")\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are exactly identical.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Ordinal comparisons (e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\">\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"<=\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") between diatonicSets are on their \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Signature\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" only.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Coercion\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" knows how to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Type_conversion\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"coerce\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\" )), structure(\" several \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"base-R atomic types\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:vector\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" into diatonicSets.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This can be done using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"methods:as\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" function---e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as(3, \\\"diatonicSet\\\")\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"---or more intuitively using the function \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet()\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Coercision methods are defined for\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:integer\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\": interpreted as root of major key\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"numeric\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:numeric\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\": rounded to nearest integer and intepreted as root of major key\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"character\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:character\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\": interpreted using \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"regular expression dispatch system\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=regexDispatch\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\", as\\n\", class = c(\"TEXT\", \"tag\")), structure(\"explained fully \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"here\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=diatonicRepresentations\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), fillThru.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/tools.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"fillThru\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"fillThru\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"fillForward\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"fillBackwards\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Propogate data points to \\\"fill\\\" null data.\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"fillThru(x, nonnull = function(x) !is.na(x) & x != \\\".\\\", reverse = FALSE)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"fillForward(...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"fillBackwards(...)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"fillThru\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is a function that allow you to \\\"fill\\\" null values in a vector\\n\", class = c(\"TEXT\", \"tag\")), structure(\"with non-null values from earlier/later in the same vector.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The default, \\\"foward,\\\" behavior fills each null value with the previous (lower index) non-null value, if there are any.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"reverse\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument can be used to cause \\\"backeward\\\" filling, where the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"next\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" (higher index) non-null value is used.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Which values are considered \\\"non-null\\\" can be controlled using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"nonnull\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"nonnull\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument can either be a logical vector which is the same length as the input (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"x\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") argument, a numeric\\n\", class = c(\"TEXT\", \"tag\")), structure(\"vector of positive indices, or a function which, when applied to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"x\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" returns an appropriate logical/numeric vector.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), filterHumdrum.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Filter.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"filterHumdrum\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"filterHumdrum\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"removeEmptyFiles\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"removeEmptySpines\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"removeEmptyRecords\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[,humdrumR,missing,ANY-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[,humdrumR,numeric,ANY-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[,humdrumR,character,ANY-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[,humdrumR,formula,ANY-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[,humdrumR,numeric,missing-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[,humdrumR,missing,numeric-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[,humdrumR,character,missing-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[,humdrumR,ANY,ANY-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Filter humdrum data\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"filterHumdrum(humdrumR, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"removeEmptyFiles(humdrumR)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"removeEmptySpines(humdrumR)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"removeEmptyRecords(humdrumR)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdata[] # returns unchanged\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdata[x:y]\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdata['regex']\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdata[~expression]\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdata[[x:y]]\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdata[[ , x:y]]\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdata[['regex']]\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdata[[x:y, l:m]]\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"filterHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is a command used to filter a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR corpus\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Indexing a humdrumR corpus (using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[]]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" operators)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"uses calls to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"filterHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"!\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"filterHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is used in a similar manner as \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(\"taking any number of \\\"do expressions\\\" (or functions) as arguments.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(In fact, do expressions/function arguments are passed directly to an internal call to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The only difference is that the expressions/functions fed to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"filterHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"must\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" be \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"predicate\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" expressions\\n\", class = c(\"TEXT\", \"tag\")), structure(\"which return a logical (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"/\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") vector.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The returned vector must also be the same length as the input data (the number\\n\", class = c(\"TEXT\", \"tag\")), structure(\"of rows in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum table\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(You can use a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"dofill~\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" expression if you want to \\\"expand\\\" shorter outputs for filtering pusposes.)\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"filterHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" updates the humdrum table's \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Filter\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field using an logical OR (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"|\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") between the existing \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Filter\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field and the negation of your predicate: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Filter | !Predicate\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"HumdrumR functions (mostly) ignore all data points where \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Filter == TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\": when you print a filtered \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" you'll see all the filtered data points turned to null data (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\".\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"), and\\n\", class = c(\"TEXT\", \"tag\")), structure(\"any calls to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=with(in)Humdrum\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" will ignore the filtered data.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"By default, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"filterHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" completely removes any files in the corpus where \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"all\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" the data records are filtered out.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, you can stop this by specifying the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"removeEmptyFiles\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argumet as \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If you \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"want\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" to remove empty files, spines, or records, you should call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"removeEmptyFiles\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"removeEmptySpines\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"removeEmptyRecords\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Indexing\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In R, the basic \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"indexing operators\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:Extract\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"[]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[]]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are used to select subsets of data.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For many R data types (for instance, base R \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"lists\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:list\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\")\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"the \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"single brackets\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" are used for \\\"shallower\\\" extraction while the\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"[[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"double brackets\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" are used for \\\"deeper\\\" extraction.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"HumdrumR corpus\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" indexing follows this same basic pattern:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"single brackets\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" are used to index \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" objects\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by piece\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" while \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"[[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"double brackets\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" are used to index\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"within pieces\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\". (Accidentally writing \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" when you need\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[]]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" is a very common error, so watch out!)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Whether, indexing by piece or within, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" objects can use\\n\", class = c(\"TEXT\", \"tag\")), structure(\"three types of indexing arguments:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" By \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"numeric\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (ordinal integers)\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" By \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" string (regular expressions)\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" By \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"formula\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (arbitrary expressions)\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"The last option (by \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"formula\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") is the most powerful option,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"and indeed, the first two options (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"numeric\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" indexing)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are just convenient shorthands for indexing that can be accomplished using\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"formula\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" method.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Numeric indexing:\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Indexing \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" corpora with\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"single brackets\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" will accept\\n\", class = c(\"TEXT\", \"tag\")), structure(\"one numeric argument.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This argument will be used to pick pieces within the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object ordinally.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[1:10]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will select the first ten pieces in the data while \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[42]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"will select only the 42nd piece.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Indexing \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" objects with\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"[[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"double brackets\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" will accept\\n\", class = c(\"TEXT\", \"tag\")), structure(\"one or two numeric arguments, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", either of which can\\n\", class = c(\"TEXT\", \"tag\")), structure(\"be used in isolation or in combination.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is used in isolation, it must be placed after a comma, as in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[[ , j ]]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".)\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is used to index data records (i.e., based on the humtable \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Record\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field) ordinally.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[[1:20]]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" indexes the first twenty records \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"from each file\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in the corpus, and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[[42]]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" extracts the 42nd record \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"from each file\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is used to index spines (i.e., based on the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Spine\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field) ordinally.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[[ , 3:4]]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" returns the third and fourth spines \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"from each\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"file in the corpus.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"When indexing \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR corpora\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" with numbers,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"all \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"numeric\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (double) inputs are converted to integers.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Note that numeric \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" indexing is entirely \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"ordinal\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\", meaning\\n\", class = c(\"TEXT\", \"tag\")), structure(\"that pieces/data records/spines are not matched based on their value in their\\n\", class = c(\"TEXT\", \"tag\")), structure(\"respective fields, but rather on their order among all existing values.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, for \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"single-bracket\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" indexing the $i_\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"th\", class = c(\"TEXT\", \"tag\"))), class = c(\"LIST\", \"tag\")), structure(\"$ piece in the\\n\", class = c(\"TEXT\", \"tag\")), structure(\"corpus is taken, regardless of that \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"FileN\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field associated\\n\", class = c(\"TEXT\", \"tag\")), structure(\"with that piece.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For example,\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humsubset <- humdata[11:20]\\n\", class = c(\"VERB\", \"tag\")), structure(\"humsubset[2]\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"will return the 12th piece from the original \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"not\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" the second piece.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This is beacuse the first call to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" returns the 11th through 20th pieces, and the second call\\n\", class = c(\"TEXT\", \"tag\")), structure(\"returns the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"second\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" piece that is still present (the 12th).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Similarly,\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humsubset2 <- humdata[[ , 2:4]]\\n\", class = c(\"VERB\", \"tag\")), structure(\"humsubset2[[ , 2]]\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"will return the third spine from the original data.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"As in normal R indexing, negative numbers can be used, causing corresponding elements to be\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"removed\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" instead of retained. Thus, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[-3:-5]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will remove the third, fourth, and fifth pieces from the data\\n\", class = c(\"TEXT\", \"tag\")), structure(\"while \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[[ , -3:-5]]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will remove the third, fourth, and fifth spines from each piece.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Positive and negative indices cannot be mixed in a single argument.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In all cases, indices outside of range (or of value \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"0\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") are ignored.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"E.g., if you have a corpus of twenty files and you call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"corpus[21]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", there is no 21st piece, so \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"21\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is \\\"out of range\\\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If all your input indices are \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"0\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and error will result.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If all your input indices are out of range then\\n\", class = c(\"TEXT\", \"tag\")), structure(\"an empty \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object is returned.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For instance, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[[401:500, ]]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will return an empty\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object if there are no pieces with more than 400\\n\", class = c(\"TEXT\", \"tag\")), structure(\"data records.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Character indexing:\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Indexing \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR objects\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumR:humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" with\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"single brackets\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" will accept one\\n\", class = c(\"TEXT\", \"tag\")), structure(\"vector of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" strings. These strings are\\n\", class = c(\"TEXT\", \"tag\")), structure(\"treated as\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Regular_expression\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"regular expressions\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" (regexes).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"The tokens from the humdrumR object's \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Active\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" fields are searched\\n\", class = c(\"TEXT\", \"tag\")), structure(\"for matches to any of the regular expressions you input. Any piece that contains\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"any\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" match to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"any\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" of the regular expressions is retained---all other pieces\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are filtered out. Note that (because this is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"single-bracket\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" indexing) the entire piece is retained, even if there is only one match.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If no matches occur in any pieces, an empty \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object is returned.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Indexing \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" objects with \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"double brackets\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" will\\n\", class = c(\"TEXT\", \"tag\")), structure(\"accept one or two vectors of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" strings, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(\"either of which can\\n\", class = c(\"TEXT\", \"tag\")), structure(\"be used in isolation or in combination.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is used in isolation, it must be placed after a comma,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"as in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[[ , j]]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"These strings are\\n\", class = c(\"TEXT\", \"tag\")), structure(\"treated as \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Regular_expression\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"regular expressions\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" (regexes).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The tokens from the humdrumR object's \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Active\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" fields are searched\\n\", class = c(\"TEXT\", \"tag\")), structure(\"for matches to any of the regular expressions you input.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Any record which contains at least one token matching any regex in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"will be retained.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Similarly, any spine which contains at least one token matching any\\n\", class = c(\"TEXT\", \"tag\")), structure(\"regex in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is retained.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" are used together,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"matching spines (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") are indexed first, so that\\n\", class = c(\"TEXT\", \"tag\")), structure(\"tokens matching the regular expression(s) in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"must be found in the matching spines.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"A third argument, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"k\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", can also be used, but only if\\n\", class = c(\"TEXT\", \"tag\")), structure(\"both the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" arguments are missing.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In order for this to work, you need to put two commas to mark the \\\"missing\\\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" arguments:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[[ , , '[Ee]-']]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In the case of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"k\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", only matching tokens are retained,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"regardless of their spine or record number(s).\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Formula indexing:\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Indexing \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR objects\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumR:humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" with\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"formulae\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is the most powerful, flexible indexing option.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Either \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"single\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"double\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" brackets will accept\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a (single) formula. The formula are fed directly as arguments to\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"filterHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"---as such, they music evaluate to a logical vector of the same\\n\", class = c(\"TEXT\", \"tag\")), structure(\"length as the input.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"In the case of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"single-bracket\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" indexing, only one \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"formula\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"is accepted, and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"every piece\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" that evalues with at least one\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will be retained.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For instance, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[~Spine > 4]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will return all pieces\\n\", class = c(\"TEXT\", \"tag\")), structure(\"which contain five (or more) spines.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"single-bracket\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" formula indexing is especially useful for indexing\\n\", class = c(\"TEXT\", \"tag\")), structure(\"meta-data properties like reference records:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"for instance, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[~COM == \\\"Paul McCartney\\\"]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will return\\n\", class = c(\"TEXT\", \"tag\")), structure(\"all pieces with a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"!!!COM: Paul McCartney\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" reference record.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"In the case of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"double-bracket\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" indexing, one or two formulas are accepted,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in arguments \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", either of which can\\n\", class = c(\"TEXT\", \"tag\")), structure(\"be used in isolation or in combination.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is used in isolation, it must be placed after a comma,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"as in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[[ , j]]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In the case of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" formulae, any record which evaluates to\\n\", class = c(\"TEXT\", \"tag\")), structure(\"at least one \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" value is retained.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In the case of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", any spine which evaluates to\\n\", class = c(\"TEXT\", \"tag\")), structure(\"at least one \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" value is retained.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Any piece which contains no matches is dropped entirely.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"For \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"[[\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"double-bracket\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"]]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" formula indexing, a third argument, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"k\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"may be used in the absence of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In order for this to work, you need to put two commas to mark the \\\"missing\\\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" arguments:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[[ , , ~formula]]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In the case of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"k\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" all tokens which evaluate to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are retained, regardless of piece/spine/record.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Pieces, spines, or records with no \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" values\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are simply dropped.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"k\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument is exactly the same a \\\"plain\\\" call to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"filterHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), getFields.Rd = structure(list(structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/humdrumR-class.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"getFields\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"getFields\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"-------------------------------------------> NEEDS DOCUMENTATION <-------------------------------------------\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Get named\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"getFields(humdrumR, fieldnames = NULL, dataTypes = \\\"D\\\")\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"-------------------------------------------> NEEDS DOCUMENTATION <-------------------------------------------\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Get named\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), getTandem.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Apply.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"getTandem\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"getTandem\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Get tandem interpretation information from humdrum data.\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"getTandem(tandem, regex)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Every \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" object has a field called\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Tandem\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" which is a vector of strings which accumulates\\n\", class = c(\"TEXT\", \"tag\")), structure(\"tandem interpretations in each Spine. This function (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"getTandem\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\")\\n\", class = c(\"TEXT\", \"tag\")), structure(\"extracts tandem interpretations from this field, based on a matching\\n\", class = c(\"TEXT\", \"tag\")), structure(\"regular expression. The obligatory \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"'*'\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"does not\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" need to\\n\", class = c(\"TEXT\", \"tag\")), structure(\"be included in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"regex\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", as it is added automatically. Thus,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"if you want to find tandem interpretations that match '*clef..', you\\n\", class = c(\"TEXT\", \"tag\")), structure(\"just have to write \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"regex = 'clef..'\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humActive.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/humdrumR-class.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humActive\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humActive\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"evalActive\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"getActive\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"setActive\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"setActiveFields\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"The \\\"Active expression\\\" of a humdrumR object.\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"evalActive(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" humdrumR,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" dataTypes = \\\"D\\\",\\n\", class = c(\"RCODE\", \"tag\")), structure(\" forceVector = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" sep = \\\", \\\",\\n\", class = c(\"RCODE\", \"tag\")), structure(\" nullAs = NA\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"getActive(humdrumR)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"setActive(humdrumR, form)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"setActiveFields(humdrumR, fieldnames)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" data object.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"dataTypes\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Which dataTypes of humdrum records to include. Legal values are \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"'G', 'L', 'I', 'M', 'D', 'd', 'P'\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"or any combination of these in a single string (e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"LIM\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(see the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum table\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" documentation \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Fields\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" section for an explanation.).\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"forceVector\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(list( structure(\"logical\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\")), structure(\". If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the result is forced to be an atomic vector.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"sep\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A length-one \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" string. If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"forceVector == TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" this value is used as a separator\\n\", class = c(\"TEXT\", \"tag\")), structure(\"between tokens that are collapsed.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"nullAsDot\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A single \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"atomic\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" value. Any null tokens are coerced to this value (default is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\".\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_arguments\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This \\\"Active\\\" expression is used as the default value in a lot of humdrumR code.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For one, it is the data which is printed by \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"show\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"methods:show\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" calls,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"i.e., whenever you return a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object in the terminal.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In any expression within a call to\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"with(in)Humdrum\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=withinHumdrum\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\".\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is automatically replaced with the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Active\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The active expression can be changed with the commands\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"setActive or the $ operator\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"This is a handy way to quickly look at different fields in your data.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"The \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Active\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression is often just the name of a\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"field\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\":\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"for instance, the default value is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Token\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, it can actually be any complex expression which evaluates\\n\", class = c(\"TEXT\", \"tag\")), structure(\"within the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum table\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"For instance, the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Active\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression could be:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"paste0(Token, \\\" \\\", Record)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", which would automatically\\n\", class = c(\"TEXT\", \"tag\")), structure(\"print each Token with its record number pasted to it.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Null data\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"HumdrumR identifies \\\"null data\\\" based on the active field.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Anywhere the current active field evaluates to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\".\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is considered Null data, and assigned the type \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"d\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" in the internal\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum table\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"As you work, there will often be data tokens which are null in one field, but not in another field.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For example, if you load \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"**kern\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" data, a token like \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"4r\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (quarter-note rest) token will be \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" if you call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pitch\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", but\\n\", class = c(\"TEXT\", \"tag\")), structure(\"not \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" if you call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"recip\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (rhythm).\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"VERB\", \"tag\")), structure(\"kerndata <- readHumdrum(...)\\n\", class = c(\"VERB\", \"tag\")), structure(\"\\n\", class = c(\"VERB\", \"tag\" )), structure(\"kerndata$Token %hum>% pitch -> kerndata$Pitch\\n\", class = c(\"VERB\", \"tag\")), structure(\"kerndata$Token %hum>% recip -> kerndata$Rhythm\\n\", class = c(\"VERB\", \"tag\")), structure(\"\\n\", class = c(\"VERB\", \"tag\" ))), class = c(\"tag_preformatted\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Now, if you change the active field between \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Pitch\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Rhythm\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" you'll see that there\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are different numbers of (non-null) data tokens: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"ntokens(kerndata$Pitch)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" vs \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"ntokens(kerndata$Rhythm)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will return different numbers!\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(The different would be the number of rest tokens.)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Similarly, if you apply functions/expressions to this data (using \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" for example), the result will depend on\\n\", class = c(\"TEXT\", \"tag\")), structure(\"what the active field is:\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"VERB\", \"tag\")), structure(\"kerndata$Pitch %hum<% ~length(Token)\\n\", class = c(\"VERB\", \"tag\")), structure(\"kerndata$Rhythm %hum<% ~length(Token)\\n\", class = c(\"VERB\", \"tag\")), structure(\"\\n\", class = c(\"VERB\", \"tag\" ))), class = c(\"tag_preformatted\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Once again, we'll get different numbers here! (Assuming there are rests in the data.)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This is the case even though the do-expression isn't actually using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Pitch\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Rhythm\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" fields!\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Pitch\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is the active field the rest tokens are null-data and will be ignored!\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humAssignment.Rd = structure(list(structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/humdrumR-class.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humAssignment\", class = c(\"VERB\", \"tag\" ))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humAssignment\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Assigning new fields\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"R objects often have ways of assigning new values to\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"part\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" of the object using \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"indexing operators\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:Extract\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"HumdrumR objects\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumR:humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" objects are no different, as they allow us to insert\\n\", class = c(\"TEXT\", \"tag\")), structure(\"new fields into them!\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A new field can be inserted into a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object in two ways:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\" )), structure(\" A field can be copied from one humdrumR object to another if their\\n\", class = c(\"TEXT\", \"tag\")), structure(\"internal \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"humdrum tables\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" have the exact same number of data tokens (i.e., rows).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"It might not seem obvious, but this mechanism is very useful because it can be used to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rename\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" existing fields\\n\", class = c(\"TEXT\", \"tag\")), structure(\"within a humdrumR object (explained below).\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\" )), structure(\" A \", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"vector\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:vector\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"list of vectors\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:list\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" can be inserted as\\n\", class = c(\"TEXT\", \"tag\")), structure(\"new fields in a humdrumR object.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_enumerate\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Fields can be assigned using two syntaxes:\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata['fieldname'] <- x\\n\", class = c(\"VERB\", \"tag\")), structure(\"# or\\n\", class = c(\"VERB\", \"tag\")), structure(\"humdata[c('fieldname1', 'fieldname2')] <- x\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"or\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata$fieldname <- x\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"where \\\"fieldname\\\" can be whatever you want it to be, of course!\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(list( structure(\"humdrumR -> humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" assignment:\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Assigning a field from one \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR object\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumR:humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"to another works like this:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(Recall that the two objects must have the exact same numbers of data tokens.)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The name(s) given in the indexing expression on the left side of the assignment (i.e., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata[c('name1', 'name2')]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata$name\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") are used as new field names.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"How fields are extracted from the right side of the assignment is a little trickier:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Any fields in the right-side \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object which are named $PipeN$ (where $N$ is an integer) are copied\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in descending order into the named fields on the left side.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If there are no $PipeN$ fields on the right side, any fields used in the current Active formula (on the right side)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are copied instead.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This system might seem odd at first, but it is very useful in combination with the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" function,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"or its convenient pipe operator \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hum>%\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humPipe\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"When \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" creates new fields, it calls them $Pipe1 \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_ldots\", \"tag\")), structure(\" Pipe2 \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_ldots\", \"tag\")), structure(\" PipeN$.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Since the output of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is always the same as the input except with these new \\\"Pipe\\\" fields,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Byou can use \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR <- humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" assignment to immediately assign these pipe fields more meaningful names in the original object.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This makes the most sense with an example:\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata$Semits <- humdata %hum>% ~semit(Token) \\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In humdrumR, we actually favor the left-to-right \\\"piping\\\" style.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Luckily, R allows you to assign left-to-right, so the proper humdrumR style is actually:\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata %hum>% ~semit(Token) -> humdata$Semits\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Calls to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hum>%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\") keep producing new pipe fields.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If there are more than one pipe fields, you can assign multiple fields at once using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[]<-\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" syntax:\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"VERB\", \"tag\")), structure(\"humdata %hum>% ~semit(Token) %hum>% ~pitch(Token) -> humdata[c('semit', 'pitch')]\\n\", class = c(\"VERB\", \"tag\")), structure(\"\\n\", class = c(\"VERB\", \"tag\" ))), class = c(\"tag_preformatted\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"#' \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"IMPORTANT NOTE!\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\": Any \\\"PipeN\\\" fields in the humdrumR object you assign from\\n\", class = c(\"TEXT\", \"tag\")), structure(\"that you don't assign field names are simply dropped.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This is nice, because often you might proceed through a serious of piped steps, but you only\\n\", class = c(\"TEXT\", \"tag\")), structure(\"want the last one (or two).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If you want to keep all your pipe fields either don't re-assign them at all (i.e., keep the \\\"PipeN\\\" names)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"or assign them all names using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"->[c(\\\"name1\\\", \\\"name2\\\", \\\"name3\\\", ...)]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" syntax.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(list(structure(\"humdrumR -> vector\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" assignment:\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"You can assign vectors or lists of vectors straight into a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR object\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumR:humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"All vectors must be the same length as the number of data tokens\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in the target object.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If you provide multiple vectors to assign (as a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"list\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"data.frame\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" of vectors)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"you must provide the same number of fieldnames using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"->[c('name1', 'name2', ...)]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" syntax.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"You can use the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"ntokens\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" command to determine the right length of vectors you need!\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humCensus.Rd = structure(list(structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Summary.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humCensus\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humCensus\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"census\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"[.humCensus\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"print.humCensus\", class = c(\"VERB\", \"tag\" ))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Tabulate records and tokens in a humdrumR corpus\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"census(humdrumR, dataTypes = \\\"GLIMDd\\\", by = \\\"Filename\\\", removeEmpty = FALSE)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"census(humdata)[i]\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"print\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humCensus\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(censusTable, showEach = TRUE, screenWidth = options(\\\"width\\\")$width - 10L)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A humdrumR object\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"dataTypes\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" string of length 1.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"by\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" string of length 1. Must be a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"field\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" in the humdrumR object.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_arguments\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"census\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is one of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"'s\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"summary functions\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humSummary\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\", used to\\n\", class = c(\"TEXT\", \"tag\")), structure(\"tabulate the raw size of a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" corpus.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"census\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" takes a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" object\\n\", class = c(\"TEXT\", \"tag\")), structure(\"and and returns a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humCensus\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" table.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"dataType\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument controls what types of records to tabulate:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"legal values are \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"'G', 'L', 'I', 'M', 'D', 'd'\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"or any combination of these (e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"LIM\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The default is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"D\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humCensus\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" table has five columns of information:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\" )), structure(\" Records\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" The total number of records.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Tokens\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" The total number of tokens.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" (unique)\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" The number of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"unique\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" tokens\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Characters\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" The total numder of characters. This includes humdrum control characters like \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"*\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"!!\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" (per token)\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" This is simply \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Characters / Tokens\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", indicating the mean length of each token.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_enumerate\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humCensus\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" table has one row for each file in the corpus.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Rows are labeled with each file's corresponding\\n\", class = c(\"TEXT\", \"tag\")), structure(\"number (from the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humTable's\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"File\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" field) and name (the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Filename\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" field).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In addition, when a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humCensus\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object is printed,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the totals across all files are printed as well---(unique) and (per token)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"across all files are calculated across all files as well, not summed.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Indexing\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Rows of a \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"humCensus\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object can be selected with a single argument \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\": e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"censusTable[i]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"numeric\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the corresponding rows are selected ordinally (not by \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"File\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" number).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" string, this string is mached as a regular expression against file names.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is a formula, the right-hand side of the formula is evaluated within the table---if it evaluates to a logical vector,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"files are selected accordingly. For instance,\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"censusTable[~Tokens > 100]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will select all files\\n\", class = c(\"TEXT\", \"tag\")), structure(\"with more than 100 tokens. (The '(unique)' and '(per token)' columns\\n\", class = c(\"TEXT\", \"tag\")), structure(\"must be referred to with their names enclosed in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\\``---for example, \", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"censusTable\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"~\\\\verb\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"(unique)\\\\\", class = c(\"TEXT\", \"tag\"))), class = c(\"LIST\", \"tag\")), structure(\" > 100\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=~\\\\`(unique)\\\\` > 100\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"` will return all files with\\n\", class = c(\"TEXT\", \"tag\")), structure(\"more than 100 unique tokens.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"drop\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument is also available. If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", a plain\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"data.table::data.table()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"data.table:data.table\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is returned.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Other humdrum data summary functions: \\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"humInterpretations\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"humSpines\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"humSummary\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humdrum data summary functions\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_concept\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humCoercion.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/humdrumR-class.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humCoercion\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humCoercion\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.lines\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.matrix.humdrumR\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.matrices\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.data.frames\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR Coercion.\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list(structure(list(structure(\"as.vector\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(x, mode = \\\"any\\\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"as.lines(\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" humdrumR,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" dataTypes = \\\"GLIMDd\\\",\\n\", class = c(\"RCODE\", \"tag\")), structure(\" fieldname = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" alignColumns = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" padPaths = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" padder = \\\"\\\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list( structure(list(structure(\"as.matrix\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" dataTypes = \\\"D\\\",\\n\", class = c(\"RCODE\", \"tag\")), structure(\" fieldnames = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" alignColumns = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" padder = NA,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" path.fold = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"as.data.frame\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" dataTypes = \\\"D\\\",\\n\", class = c(\"RCODE\", \"tag\")), structure(\" fieldname = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" padder = NA,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" fold.path = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"as.matrices(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" humdrumR,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" dataTypes = \\\"D\\\",\\n\", class = c(\"RCODE\", \"tag\")), structure(\" fieldnames = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" padder = NA,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" path.fold = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"as.data.frames(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" humdrumR,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" dataTypes = \\\"D\\\",\\n\", class = c(\"RCODE\", \"tag\")), structure(\" fieldnames = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" padder = NA,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" path.fold = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"mode\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"If the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"mode\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument is not \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"'any'\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", it can be a single \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"string naming an atomic mode---the output will be coerced to this mode (if possible).\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"dataTypes\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Which types of humdrum records to include. Legal values are \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"'G', 'L', 'I', 'M', 'D', 'd'\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"or any combination of these (e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"LIM\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(see the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum table\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" documentation \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Fields\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" section for explanation.).\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"padder\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"An atomic value of length one. If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"par.files\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pad.paths\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" are true, the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"padder\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"argument is used to fill in the desired gaps.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"pad.files\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(list( structure(\"logical\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\")), structure(\" (default \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"). If any pieces in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" corpus have fewer\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humdrumR:humTable][spines/columns]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" than the maximum, should they be padded with the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"padder\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"par.files == TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") or\\n\", class = c(\"TEXT\", \"tag\")), structure(\"should an an error occur (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pad.files == FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\")? Note that these \\\"padded\\\" points are not represented in the original humdrum data.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"pad.paths\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(list( structure(\"logical\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\")), structure(\" If any spine path splits (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"'*^'\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") occur in the humdrumR data, should they be padded\\n\", class = c(\"TEXT\", \"tag\")), structure(\"with the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"padder\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"par.files == TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") or\\n\", class = c(\"TEXT\", \"tag\")), structure(\"should an an error occur (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pad.paths == FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\")?\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Note that these \\\"padded\\\" points are not represented in the original humdrum data.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"field(s)\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"If the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"field\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"not\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", it can instead be a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" string matching\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" object's fields. If so, these fields are extracted instead of the\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Active expression\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humActive\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"For calls to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.vector\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.data.frame\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", only one field can be extracted.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, for calls to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.matrix\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", multiple fields can be extraced---these fields will be\\n\", class = c(\"TEXT\", \"tag\")), structure(\"returned in a third matrix dimension, each field forming one rectangular slice.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_arguments\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Many users may wish to work with humdrum data without\\n\", class = c(\"TEXT\", \"tag\")), structure(\"using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humdrumR:humdrumR][humdrumR]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" API, instead using\\n\", class = c(\"TEXT\", \"tag\")), structure(\"basic \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"R\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data types.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For this purpose, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" data objects can be coerced to\\n\", class = c(\"TEXT\", \"tag\")), structure(\"basic \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"R\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data types.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.vector(humdata)\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:vector\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" evaluates the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" object's\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Active\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" expression, and (attempts) to force the result to a vector of mode. This\\n\", class = c(\"TEXT\", \"tag\")), structure(\"method is essentially a wrapper for \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"evalActive\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.matrix(humdata\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:matrix\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" also evaluates the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" object's\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Active\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" expression, but wraps it into a matrix of dimensions \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"c([humdrumR:humSize][nrow(humdata), ncol(humdata)])\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Note that \\\"\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humdrumR:humTable][Columns]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"\\\" in humdrum data are not necesarily the same as spines.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"as.data.frame(humdata)\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:as.data.frame\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" first calls \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.matrix\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" then converts the matrix to a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"data.frame\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:data.frame\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"as.data.table(humdata)\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"data.table:as.data.table\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" first calls \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.matrix\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" then converts the matrix to a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"data.table::data.table()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"data.table:data.table\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"as.matrices\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.data.frames\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.data.tables\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.matrix\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"/\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.data.frame\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"/\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.data.table\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"on each individual file in a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" corpus, returning a list of matices/data.frames/data.tables.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humColumns.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/humdrumR-class.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humColumns\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humColumns\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Spines vs Paths vs Columns\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In the \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"http://www.humdrum.org/guide/ch05/\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrum syntax\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\", data is placed in \\\"spines,\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"which are not the same as \\\"columns\\\" in a spreadsheet. A \\\"column\\\" refers to a\\n\", class = c(\"TEXT\", \"tag\")), structure(\"tab-delineated group of values.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\\"Spines\\\" can be a single column, or they may (at any time) split into multiple columns,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"which can in turn split again, using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"*^\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" interpretation token. The reverse can happen as well,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"with two or more columns merging into a single column, using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"v\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" token.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This means that, while humdrum data at first glance looks like a simple two-dimensional table,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"it is actually a flexible tree structure. As spines split and merge, the total number of columns\\n\", class = c(\"TEXT\", \"tag\")), structure(\"can change during a piece, creating a \\\"ragged\\\" edge.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Another similar issue is that a corpus of humdrum files may have varying numbers of spines/columns, between pieces.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(\\\"Global\\\" comment/reference records are also a special case, as that are always a single value, even if interspersed with\\n\", class = c(\"TEXT\", \"tag\")), structure(\"multi-column local records.)\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\", spines, columns, and spine paths work like this.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"First of all, we actually assume a slightly more strict version of the humdrum syntax:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"we assume that all the spines which appear at the beginning of a file (headed with exlusive interpretations\\n\", class = c(\"TEXT\", \"tag\")), structure(\"like \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\\"**kern\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") can never merge into each other. Thus, a humdrum file read into \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"must not end with fewer columns than it starts.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Spine merges (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"*v\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") can only happen within spine paths that originally split off the same spine.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This extra-strict specification of spine paths in the humdrum syntax is, fortunately, something that has been\\n\", class = c(\"TEXT\", \"tag\")), structure(\"informally followed in most humdrum datasets.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Our strict spine-path definition makes everything work fairly simply:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Within a piece, the spines which appear at the beginning of the piece are the \\\"true\\\" spines through the rest of the piece, numbered\\n\", class = c(\"TEXT\", \"tag\")), structure(\"from left to right, starting from \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"1L\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For each local token, the value in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Spine\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field is an integer indicating which of these\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\\"true\\\" spines it belongs to---global tokens have a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" value in their \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Spine\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field, because they are considerd to not belong to any spine.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Any spine path splits (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"*^\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" from the main spines form subspines, which we call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Paths\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Every spine's paths are numbered, from right to left, starting from \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"0L\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A spine with no splits will have all \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"0L\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s in its \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Path\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Columns\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"It is very useful to sometimes turn humdrum data into a true two dimensional structure, with no ragged edges.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(This always requires removing global records.)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In order to do this, while maintaining a sensible relationship between spine which have spine paths,\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humRead\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" automatically \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pads\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" humdrum data into a complete, non-ragged 2d table.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For instance, given this file\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"**kern **kern\\n\", class = c(\"VERB\", \"tag\")), structure(\"A E\\n\", class = c(\"VERB\", \"tag\")), structure(\"*^ *\\n\", class = c(\"VERB\", \"tag\")), structure(\"A C E\\n\", class = c(\"VERB\", \"tag\")), structure(\"G B D\\n\", class = c(\"VERB\", \"tag\")), structure(\"*v *v *\\n\", class = c(\"VERB\", \"tag\")), structure(\"A C \\n\", class = c(\"VERB\", \"tag\")), structure(\"*- *-\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humRead\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_link\", \"tag\")), structure(\" pads the file as so:\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"**kern _P **kern\\n\", class = c(\"VERB\", \"tag\")), structure(\"A _P E\\n\", class = c(\"VERB\", \"tag\")), structure(\"*^ _P *\\n\", class = c(\"VERB\", \"tag\")), structure(\"A C E\\n\", class = c(\"VERB\", \"tag\")), structure(\"G B D\\n\", class = c(\"VERB\", \"tag\")), structure(\"*v *v *\\n\", class = c(\"VERB\", \"tag\")), structure(\"A _P C \\n\", class = c(\"VERB\", \"tag\")), structure(\"*- _P *-\\n\", class = c(\"VERB\", \"tag\")), structure(\"\\n\", class = c(\"VERB\", \"tag\" )), structure(\"##########################################\\n\", class = c(\"VERB\", \"tag\")), structure(\"1 1 2 Spine\\n\", class = c(\"VERB\", \"tag\")), structure(\"0 1 0 Path\\n\", class = c(\"VERB\", \"tag\")), structure(\"1 2 3 Column\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(In this example, the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Spine\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Path\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Column\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" values are shown below the data.)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"_P\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" tokens stand for \\\"padded path.\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This appraoch assures that every \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Spine\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" is a contiguous block of tokens, of constant width.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In most humdrumR use cases, these padding tokens (and the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Column\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field) can be safely ignored.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Corpus padding\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humRead\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" automatically pads spine paths \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"within pieces\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, as mentioned above, there is also (sometimes) a need to pad across pieces, in order\\n\", class = c(\"TEXT\", \"tag\")), structure(\"to create a logical, clean 2d structure.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Consider this example, with humdrum data from two pieces:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Piece 1\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\":\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"**kern **kern **kern\\n\", class = c(\"VERB\", \"tag\")), structure(\"E D C\\n\", class = c(\"VERB\", \"tag\")), structure(\"D . .\\n\", class = c(\"VERB\", \"tag\")), structure(\"C C E\\n\", class = c(\"VERB\", \"tag\")), structure(\"*- *- *-\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Piece 2\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\":\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"**kern **kern\\n\", class = c(\"VERB\", \"tag\")), structure(\"A A\\n\", class = c(\"VERB\", \"tag\")), structure(\". B\\n\", class = c(\"VERB\", \"tag\")), structure(\"C C\\n\", class = c(\"VERB\", \"tag\")), structure(\"*- *-\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In this example, we have two pieces, one with three spines, the other with two.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"There is no way to squish these two pieces into one regular 2d table.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"But we \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"could\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" pad any missing columns, as so:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Piece 1\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\":\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"**kern **kern **kern\\n\", class = c(\"VERB\", \"tag\")), structure(\"E D C\\n\", class = c(\"VERB\", \"tag\")), structure(\"D . .\\n\", class = c(\"VERB\", \"tag\")), structure(\"C C E\\n\", class = c(\"VERB\", \"tag\")), structure(\"*- *- *-\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Piece 2\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\":\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"**kern **kern _C\\n\", class = c(\"VERB\", \"tag\")), structure(\"A A _C\\n\", class = c(\"VERB\", \"tag\")), structure(\". B _C\\n\", class = c(\"VERB\", \"tag\")), structure(\"C C _C\\n\", class = c(\"VERB\", \"tag\")), structure(\"*- *- _C\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The function \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"alignColumns\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is used to achieve just this effect.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In this example, the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"_C\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" token stands for \\\"padded column.\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The presence of spine paths makes padding columns across pieces a bit more complicated.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"What \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"alignColumns\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will do, is match up all pieces in a corpus so that\\n\", class = c(\"TEXT\", \"tag\")), structure(\"every \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Spine\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\"/\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"Path\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_strong\", \"tag\")), structure(\" field pair allign in the same column.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Here is an example, with its paths already padded:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Piece 1\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\":\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"**kern _P **kern\\n\", class = c(\"VERB\", \"tag\")), structure(\"A _P E\\n\", class = c(\"VERB\", \"tag\")), structure(\"B _P D\\n\", class = c(\"VERB\", \"tag\")), structure(\"*^ _P *\\n\", class = c(\"VERB\", \"tag\")), structure(\"A C E\\n\", class = c(\"VERB\", \"tag\")), structure(\"G# B E\\n\", class = c(\"VERB\", \"tag\")), structure(\"*v *v *\\n\", class = c(\"VERB\", \"tag\")), structure(\"A _P E\\n\", class = c(\"VERB\", \"tag\")), structure(\"*- _P *-\\n\", class = c(\"VERB\", \"tag\")), structure(\"#################################################\\n\", class = c(\"VERB\", \"tag\")), structure(\"1 1 2 Spine\\n\", class = c(\"VERB\", \"tag\")), structure(\"0 1 0 Path\\n\", class = c(\"VERB\", \"tag\")), structure(\"1 2 3 Column\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Piece 2\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\":\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"**kern **kern _P\\n\", class = c(\"VERB\", \"tag\")), structure(\"A E _P\\n\", class = c(\"VERB\", \"tag\")), structure(\"* *^ _P\\n\", class = c(\"VERB\", \"tag\")), structure(\"G# D F\\n\", class = c(\"VERB\", \"tag\")), structure(\"A C E\\n\", class = c(\"VERB\", \"tag\")), structure(\"* *v *v\\n\", class = c(\"VERB\", \"tag\")), structure(\"E D _P\\n\", class = c(\"VERB\", \"tag\")), structure(\"*- *- _P \\n\", class = c(\"VERB\", \"tag\")), structure(\"#################################################\\n\", class = c(\"VERB\", \"tag\")), structure(\"1 2 2 Spine\\n\", class = c(\"VERB\", \"tag\")), structure(\"0 0 1 Path\\n\", class = c(\"VERB\", \"tag\")), structure(\"1 2 3 Column\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"We have two pieces, each with two spines,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"but in the first piece, the first spine splits, while in the second piece, the\\n\", class = c(\"TEXT\", \"tag\")), structure(\"second spine splits. Thus, the padded output will have four columns:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Piece 1\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\":\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"**kern _P **kern _C\\n\", class = c(\"VERB\", \"tag\")), structure(\"A _P E _C\\n\", class = c(\"VERB\", \"tag\")), structure(\"B _P D _C\\n\", class = c(\"VERB\", \"tag\")), structure(\"*^ _P * _C\\n\", class = c(\"VERB\", \"tag\")), structure(\"A C E _C\\n\", class = c(\"VERB\", \"tag\")), structure(\"G# B E _C\\n\", class = c(\"VERB\", \"tag\")), structure(\"*v *v * _C\\n\", class = c(\"VERB\", \"tag\")), structure(\"A _P E _C\\n\", class = c(\"VERB\", \"tag\")), structure(\"*- _P *- _C \\n\", class = c(\"VERB\", \"tag\")), structure(\"###########################################################\\n\", class = c(\"VERB\", \"tag\")), structure(\"1 1 2 2 Spine\\n\", class = c(\"VERB\", \"tag\")), structure(\"0 1 0 1 Path\\n\", class = c(\"VERB\", \"tag\")), structure(\"1 2 3 4 Column\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Piece 2\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\":\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"**kern _C **kern _P\\n\", class = c(\"VERB\", \"tag\")), structure(\"A _C E _P\\n\", class = c(\"VERB\", \"tag\")), structure(\"* _C *^ _P\\n\", class = c(\"VERB\", \"tag\")), structure(\"G# _C D F\\n\", class = c(\"VERB\", \"tag\")), structure(\"A _C C E\\n\", class = c(\"VERB\", \"tag\")), structure(\"* _C *v *v\\n\", class = c(\"VERB\", \"tag\")), structure(\"E _C D _P\\n\", class = c(\"VERB\", \"tag\")), structure(\"*- _C *- _P \\n\", class = c(\"VERB\", \"tag\")), structure(\"######################################################### \\n\", class = c(\"VERB\", \"tag\")), structure(\"1 1 2 2 Spine\\n\", class = c(\"VERB\", \"tag\")), structure(\"0 1 0 1 Path\\n\", class = c(\"VERB\", \"tag\")), structure(\"1 2 3 4 Column\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Note that \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"alignColumns\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" actually adds rows to the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" object's\\n\", class = c(\"TEXT\", \"tag\")), structure(\"internal \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum tables\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humFormulae.Rd = structure(list(structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Formulae.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"data\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_docType\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humFormulae\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humFormulae\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"ditto\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"Standard humdrumR formulae.\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"An object of class \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"list\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" of length 3.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_format\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"ditto\\n\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" predefines a few \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"with(in)humdrum\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=withinHumdrum\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" command combinations, as R formulae or lists of formulae.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\" )), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"ditto\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" calls \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"fillThru()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=fillThru\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" across pieces/spines/paths, replicating the classic humdrum toolkit ditto command.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"datasets\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_keyword\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humInterpretations.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Summary.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humInterpretations\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humInterpretations\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"interpretations\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"print.humInterpretations\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Summarize humdrum corpus interpretations.\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"interpretations(humdrumR)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"print\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humInterpretations\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(interps, showEach = TRUE, screenWidth = options(\\\"width\\\")$width - 10L)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This function provides a summary of the interpretations in the pieces of a humdrumR corpus.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Other humdrum data summary functions: \\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"humCensus\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"humSpines\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"humSummary\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum data summary functions\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_concept\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humMerge.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/humdrumR-class.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humMerge\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humMerge\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"mergeHumdrum\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Merge two (or more) humdrumR datasets\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"mergeHumdrum(...)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"-------------------------------------------> NEEDS DOCUMENTATION <-------------------------------------------\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humMeter.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/rhythmInterval.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humMeter\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humMeter\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Tools for analyzing rhythm and meter.\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" includes a number of useful\\n\", class = c(\"TEXT\", \"tag\")), structure(\"functions for working with rhythms and meter.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"rhythmDecompose()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=rhythmDecompose\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" decomposes a series of rhythms in terms of desired pulses.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"rhythmOffset()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=rhythmOffset\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" Calculates the cummulative offset of durations from a starting point.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humPipe.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Piping.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humPipe\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humPipe\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hum>%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hum<%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%humT%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%s>%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hums>%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hums<%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%humsT%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hums[]%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Piping humdrumR data\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"humdrumR %hum>% formula\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdrumR %hum<% formula\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdrumR %humT% formula\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"e1 %s>% e2\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"list %hums>% formula\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"list %hums<% formula\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"list %humsT% formula\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"list %hums[]% formula\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"These infix operators make it possible to use\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"[humdrumR:with-in-Humdrum][with(in)Humdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"functions in a piping style, similar to the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"|\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (pipe)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in unix-style terminals, or the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"|>\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" pipe operator.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"from the R package \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://cran.r-project.org/web/packages/magrittr/index.html\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"magrittr\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The key is that the function \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[withinHumdrum][withinHumdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" always returns a new\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humdrumR][humdrumR]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" data object. Thus, you can always send the output\\n\", class = c(\"TEXT\", \"tag\")), structure(\"of \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"[withinHumdrum][withinHumdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" back in to a new call of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[withinHumdrum][withinHumdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This is exactly what the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hum>%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" is for: on the left-hand side,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"input a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humdrumR][humdrumR]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" object, on the right-hand side suitable\\n\", class = c(\"TEXT\", \"tag\")), structure(\"arguments to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[withinHumdrum][withinHumdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" (i.e., a formula, a function, or list of formulae,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"functions, and named arguments). You can then chain this call with another call to\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hum>%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" and more \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[withinHumdrum][withinHumdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" arguments.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hum<%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" acts the same way as \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hum>%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" except it calls \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[withHumdrum][withinHumdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Since \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[withHumdrum][withinHumdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" does \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"not\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" return a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humdrumR][humdrumR]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the output can't be piped any further (using \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hum>%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hum<%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\\%hum<\\\\%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" should only be used as the last step in a pipe---you would do this\\n\", class = c(\"TEXT\", \"tag\")), structure(\"if you want to extract the last step in your pipe from the data's \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humdrumR:humtable][Humdrum Table]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" into\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a normal vector or list of R data.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"' \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\\%humT\\\\%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" creates a \\\"T\\\" in the pipe, applying the desired expression but not keeping the result---the unaltered\\n\", class = c(\"TEXT\", \"tag\")), structure(\"humdrumR input object is returned. This works simply by replacing all \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do~\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" with \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"doplot~\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" in a call to\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[withinHumdrum][withinHumdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\". The purpose of this option, is if you want to apply expressions for their\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Side_effect_(computer_science)\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"side effects\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"for instance, for plotting.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"%hum[]%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" is similar to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hum>%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" except it apply the formulae on its right-hand\\n\", class = c(\"TEXT\", \"tag\")), structure(\"side using \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humdrumR][filterHumdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\". Thus, it can be used to filter/index\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"[humdrumR][humdrumR]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" data object on the fly.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Plural pipes\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In R we often apply the same function to a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"list\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" of data.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\\"Plural pipes\\\" expand this idea to piping: take a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"list\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" of data\\n\", class = c(\"TEXT\", \"tag\")), structure(\"and pipe each element in the list to an expression/function.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"There are plural pipe versions of each singular pipe operator.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Just add an \\\"s\\\" to make them plural:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"|>\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" (singular) : \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%s>%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" (plural);\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"%hum>%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" (singular) : \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hums>%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" (plural);\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"%hum<%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" (singular) : \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hums<%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" (plural);\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"%humT%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" (singular) : \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%humsT%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" (plural);\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"%hum[]%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" (singular) : \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hums[]%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" (plural);\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Note: \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"%s>%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" is an expansion of the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\\>\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" pipe operator, which\\n\", class = c(\"TEXT\", \"tag\")), structure(\"makes use of some clever meta-programming---we can't guarantee it will\\n\", class = c(\"TEXT\", \"tag\")), structure(\"always behave the way we might like!\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"humdata <- readHumdrum('path*.krn')\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdata %hum>% ~table(.)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdata %hum>%\\n\", class = c(\"RCODE\", \"tag\")), structure(\" c(by~Spine, do ~ table(.)) %hum>%\\n\", class = c(\"RCODE\", \"tag\")), structure(\" c(mfcol ~ c(2,2), doplot~barplot(.))\\n\", class = c(\"RCODE\", \"tag\")), structure(\" \\n\", class = c(\"RCODE\", \"tag\")), structure(\"humdata %hum>%\\n\", class = c(\"RCODE\", \"tag\")), structure(\" c(by ~ Spine, do ~ table(.)) %hum<%\\n\", class = c(\"RCODE\", \"tag\")), structure(\" (do ~ sort(.)) \\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_examples\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humPrint.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/humdrumR-class.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humPrint\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humPrint\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"print_humtab\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"-------------------------------------------> NEEDS DOCUMENTATION <-------------------------------------------\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list(structure(list(structure(\"show\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(object)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"print_humtab(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" humdrumR,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" dataTypes = \\\"GLIMDd\\\",\\n\", class = c(\"RCODE\", \"tag\")), structure(\" firstAndLast = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" max.records.file = 40L,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" max.token.length = 30L,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" collapseNull = 10L\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"-------------------------------------------> NEEDS DOCUMENTATION <-------------------------------------------\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Show a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" object in the terminal.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humReference.Rd = structure(list(structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Summary.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humReference\", class = c(\"VERB\", \"tag\" ))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humReference\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"reference\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"reference.character\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"reference.humdrumR\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[.humReference\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"print.humReference\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Summarize reference records in a humdrumR corpus\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"reference(x)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"reference('OTL')\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"reference(humdata)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"[\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humReference\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(refTable, i, j, drop = FALSE)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"reference\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is one of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"'s\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"summary functions\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humSummary\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\", used to\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"tabulate the reference records\\n\", class = c(\"TEXT\", \"tag\")), structure(\"present in a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" corpus.\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"reference\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" takes a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" object\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"and and returns a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humReference\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" table.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Alternatively, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"reference\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" can take a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" string,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"which it will check against known reference codes and print a\\n\", class = c(\"TEXT\", \"tag\")), structure(\"information about matching codes. For instance, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"reference('OTL')\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"returns a description of the standard humdrum \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"!!!OTL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" reference record\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(original title metadata).\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humReference\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\")), structure(\" table has one column for\\n\", class = c(\"TEXT\", \"tag\")), structure(\"each reference code that appears in a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" corpus.\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Since reference records can be long (too much to print on one screen),\\n\", class = c(\"TEXT\", \"tag\")), structure(\"and humdrum files can have multiple of the same type of reference code\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(for instance multiple composers annotated with \\\"!!!COM\\\"),\\n\", class = c(\"TEXT\", \"tag\")), structure(\"by default, a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humReference\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" only prints the number of each type of\\n\", class = c(\"TEXT\", \"tag\")), structure(\"reference record to appear in each file.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, if only one type of reference code is present in a\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humReference\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" table, the complete reference records for that code\\n\", class = c(\"TEXT\", \"tag\")), structure(\"will be printed for each file. Likewise, if only one file is present\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in the table, all of that file's complete reference records are printed.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, if you want to see actualy reference records, try indexing the\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humReference\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" table down to one column or row (see below).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humReference\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" table has one row for each file in the corpus.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Rows are labeled with each file's corresponding\\n\", class = c(\"TEXT\", \"tag\")), structure(\"number (from the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humTable\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"'s \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"File\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" field) and name (the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Filename\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" field).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In addition, when a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humReference\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object is printed,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"three different summary totals are printed for each reference code:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Any\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" indicates how many files in the corpus have at least\\n\", class = c(\"TEXT\", \"tag\")), structure(\"one example of each code in them.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Sum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" indicates the total number of each reference code to appear\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in the corpus, including multiple appearances in one file (like multiple \\\"!!!COM\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"records).\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Finally, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Unique\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" tabulates the number of unique tokens in each reference\\n\", class = c(\"TEXT\", \"tag\")), structure(\"code---if your corpus only hase two unique composers (encoded in \\\"!!!COM\\\"),\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Unique\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" total will be \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"2\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Indexing\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humReference\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" tables can be indexed much like base \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"R\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[data.frames][base::data.frame()], with two arguments: \", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"i\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"(rows) and\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"j\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"(columns). If\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"i\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"or\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"j\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"are\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"numeric\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\", they select rows or columns respectively, ordinally. If \", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"i\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"is a\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"character\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\", it is matched as a regular expression against filenames in the corpus. If \", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"j\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"is a\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"character`, it is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"partially matched\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:pmatch\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"against column names.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"drop\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument is also available. If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", a plain\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[data.table][data.table::data.table()]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" is returned.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humShape.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/humdrumR-class.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humShape\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humShape\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"foldHumdrum\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"foldStops\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"foldPaths\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"foldRecords\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"spinePipe\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"HumdrumR data \\\"Shape\\\"\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"foldHumdrum(humdrumR, byfields, foldAtomic = TRUE, sep = \\\" \\\", padPaths = FALSE)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"foldStops(humdrumR, foldAtomic = TRUE, sep = \\\" \\\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"foldPaths(humdrumR, foldAtomic = TRUE, sep = \\\" \\\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"foldRecords(humdrumR, foldAtomic = TRUE, sep = \\\" \\\", padPaths = FALSE)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"spinePipe(humdrumR, targetSpines, destinationSpines)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" data object.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(see the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum table\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" documentation \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Fields\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" section for explanation.).\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"foldAtomic\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(list( structure(\"logical\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\")), structure(\". If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"foldAtomic == TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", each stop is collapsed to a single string\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"foldAtomic == FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", each stop is collapsed to a list of tokens.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"sep\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(list( structure(\"character\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\")), structure(\". If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"foldAtomic == TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", collapsed tokens are separated by this string.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"pad\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(list( structure(\"logical\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\")), structure(\". Should \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"path/column padding tokens\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humColumns\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" be included?\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_arguments\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"These functions are used to change the \\\"shape\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"of data stored in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum tables\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(held within \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" objects of course).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"-------------------------------------------> NEEDS DOCUMENTATION <-------------------------------------------\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"foldXXX\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" family allows you collapse all\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"user fields\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"across groups in another field.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humSize.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/humdrumR-class.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humSize\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humSize\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"nrecords\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"ntokens\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"npieces\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"anySubcorpora\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"namesSubcorpora\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"nfiles\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"is.empty\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"anyPaths\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"anyStops\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR size and shape\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"nrecords(humdrumR, dataTypes = \\\"D\\\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"ntokens(humdrumR, dataTypes = \\\"D\\\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"npieces(humdrumR)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"anySubcorpora(humdrumR)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"namesSubcorpora(humdrumR)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"nfiles(humdrumR)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"length\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(x)\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list( structure(list(structure(\"nrow\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(x)\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"is.empty(humdrumR)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"anyPaths(humdrumR)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"anyStops(humdrumR)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"These functions can be used to quickly\\n\", class = c(\"TEXT\", \"tag\")), structure(\"get basic information about the size and \\\"shape\\\" of\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" corpus.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For more details, use the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"census\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humSummary\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" function.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"HumdrumR\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" objects can be divided into \\\"subcorpora.\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"anySubcorpora\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"namesSubcorpora\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" functions tell us if there are any subcorpora and, if so, what they are called.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A few common base \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"R\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" methods are defined\\n\", class = c(\"TEXT\", \"tag\")), structure(\"as synonyms for the humdrumR-specific sizing functions:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"length(humdata)\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:length\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" is equivalent to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"npieces(humdata)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\";\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"nrow(humdata)\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:nrow\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" is shortand for \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"nrecords(., dataTypes = 'LIMDd')\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (i.e., local records only).\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"ncol(humdata)\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:nrow\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" returns the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"maximum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" value of the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Column\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" field---the maximum number of\\n\", class = c(\"TEXT\", \"tag\")), structure(\"tab-delineated columns in the humdrum files (irrespective of Spines/Paths).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The results of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"nrow\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"ncol\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will match\\n\", class = c(\"TEXT\", \"tag\")), structure(\"up with the dimensions of matrices/data.frames produced by calls to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.matrix/as.data.frame\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=as.matrix\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"dim(humdata)\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:dim\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" returns \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"c(nrow(humdata), ncol(humdata))\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", as usual.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"is.empty(humdata)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" asks if \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"ntokens(humdata, dataTypes = 'D') == 0L\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humSpines.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Summary.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humSpines\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humSpines\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"spines\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[.humSpines\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"print.humSpines\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Summarize spines in humdrum dataset\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"spines(humdrumR)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"[\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humSpines\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(spines, i, j)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"print\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humSpines\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(spineTable, showEach = TRUE)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This function provides summary of the spines and spine paths in the pieces of a humdrumR corpus.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Other humdrum data summary functions: \\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"humCensus\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"humInterpretations\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"humSummary\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum data summary functions\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_concept\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humSummary.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Summary.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humSummary\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humSummary\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Summarize humdrumR corpora\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list(structure(list(structure(\"summary\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(object, ...)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" includes a number of built in functions for creating quick summaries of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"corpora:\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"census\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humCensus\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Tabulates the raw size of the humdrumR corpus.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"reference\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humReference\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Tabulates reference records (metadata) for each file.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"spines\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humSpines\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Tabulates the number of spines and spine paths in files in the corpus.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"interpretations\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humInterpretations\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Tabulates the types of exclusive and tandem interpretations in the corpus.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"sections\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humSections\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Tabulates any formal data (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"*>\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\") in the corpus.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_enumerate\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Each function takes a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" object and returns a\\n\", class = c(\"TEXT\", \"tag\")), structure(\"special class of data.table.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"summary\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" method for \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR objects\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" calls all of the above functions and prints a condensed version of each.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Other humdrum data summary functions: \\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"humCensus\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"humInterpretations\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"humSpines\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum data summary functions\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_concept\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humTable.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/humdrumR-class.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humTable\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humTable\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"getHumtab\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Humdrum Tables\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"getHumtab(humdrumR, dataTypes = c(\\\"G\\\", \\\"L\\\", \\\"I\\\", \\\"M\\\", \\\"D\\\", \\\"d\\\"))\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"dataTypes\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" vector. Specifies which types of data tokens/records to extract.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"See the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humTable\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" documentation and/or the humdrum syntax vignette for clarification!\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"dataTypes\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", values can be:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\\"G\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\": global comments\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\\"L\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\": local comments\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\\"I\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\": interpretations\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\\"M\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\": barlines\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\\"D\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\": non-null data\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\\"d\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\": null data\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Multiple types can be specified as a vector, or smooshed into a single string: e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"GLIMD\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_arguments\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In the \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" package, the fundamental data structure is called a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Humdrum Table\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A humdrum table encodes all the information in a collection of one or more humdrum-syntax files\\n\", class = c(\"TEXT\", \"tag\")), structure(\"as a single \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"data.table\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"data.table:data.table\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(A \", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"data.table\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is an \\\"enhanced\\\" version of R's standard \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"data.frame\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Humdrum tables are stored \\\"inside\\\" every \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" object that you will work with, and various \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"functions allow you to study or manipulate the them.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If you want to directly access the humdrum table within a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" object, use the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"getHumtab\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" function.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"getHumtab\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" extracts a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum table\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" from a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" object.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In a humdrum table, each row represents a single \\\"token\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in the original humdrum data. Even multistops---tokens separated by spaces---are broken onto\\n\", class = c(\"TEXT\", \"tag\")), structure(\"their own rows. Meanwhile, each column in the humdrum table represents a single\\n\", class = c(\"TEXT\", \"tag\")), structure(\"piece of information associated with each token, which we call a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"field\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Throughout this documentation, you should keep in mind that a \\\"token\\\" refers\\n\", class = c(\"TEXT\", \"tag\")), structure(\"to a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"row\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" in the humdrum table while a \\\"field\\\" refers to a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"column\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\":\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"Token = Row\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(), class = c(\"tag_item\", \"tag\" )), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Field = Column\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Fields:\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"There are five types of fields in a humdrum table:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Data fields\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Structure fields\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Interpretation fields\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Formal fields\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Reference fields\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_enumerate\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"When first created by a call to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" every\\n\", class = c(\"TEXT\", \"tag\")), structure(\"humdrum table has at least nineteen fields: one data field (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Token\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"), two interpretation\\n\", class = c(\"TEXT\", \"tag\")), structure(\"fields (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Tandem\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Exclusive\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"), three formal fields, and fifteen structure fields. Additional\\n\", class = c(\"TEXT\", \"tag\")), structure(\"interpretation or reference fields\\n\", class = c(\"TEXT\", \"tag\")), structure(\"may be present depending on the content of the humdrum file(s), and users can create additional data fields\\n\", class = c(\"TEXT\", \"tag\")), structure(\"by \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"assigning to the object\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humAssignment\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"Data fields:\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Data fields are used to describe individual data points\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in humdrum data (as opposed to groups of points).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Every humdrum table starts with a data\\n\", class = c(\"TEXT\", \"tag\")), structure(\"field called \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Token\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\", which\\n\", class = c(\"TEXT\", \"tag\")), structure(\"contains character strings representing the original strings read from the humdrum files.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Users can create as many additional data fields as they like. Every call to\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"---which can also be called using the\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR:humPipe\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=\\\\%hum>\\\\%\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" piping\\n\", class = c(\"TEXT\", \"tag\")), structure(\"operator---generates one or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"N\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\" new data fields named \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"{Pipe1, Pipe2, ..., PipeN}\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"These fields can be renamed using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"$<-\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" operator.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Structure fields:\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Every humdrum table starts with fifteen Structure fields,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"which describe where each data token was \\\"located\\\" in the original humdrum data: which file, which spine, which record, etc.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"See the vignette on humdrum syntax to fully understand the terms here.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"File info\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\":\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Filename\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" The unique name of the humdrum file. This may include an appended path\\n\", class = c(\"TEXT\", \"tag\")), structure(\"if more than one file with the same name were read from different directories (see the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" docs).\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Filepath\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" The full file name (always includes its full path).\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Label\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" A label specified during the call to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\", associated with a particular\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" \\\"REpath-pattern.\\\" If no label was specified, patterns are just labeled \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"_n\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", where \\\"\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\\" is the\\n\", class = c(\"TEXT\", \"tag\")), structure(\"number of the pattern. (Labels can also be created when \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"merging two humdrumR objects\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humMerge\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".)\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"File\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" A unique number associated with each file (ordered alphabetically, starting from \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"1\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Piece\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" A number specifying the number of the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"piece\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" in the corpus.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This is identical to the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"File\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field except when\\n\", class = c(\"TEXT\", \"tag\")), structure(\"more than one piece were read from the same file.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Location info\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\":\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Spine\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" The spine, numbered (from left-to-right) starting from \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"1\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" This field is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" wherever \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Global == TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Path\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" The \\\"spine path.\\\" Any time a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"*^\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" spine path split occurs in\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the humdrum data, the right side of the split becomes a new \\\"path.\\\" The original path\\n\", class = c(\"TEXT\", \"tag\")), structure(\"is numbered \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"0\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" with additional paths numbered with integers to the right.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(If there are no spine path splits, the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Path\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field is all zeros.)\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" This field is always \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" when \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Global == TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Read the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum columns documentation\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humColumns\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" for a more thorough explanation\\n\", class = c(\"TEXT\", \"tag\")), structure(\"of spine paths.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Column\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" The tab-delineated column in the humdrum file---irrespective of Spine/Paths---, numbered starting from \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"1\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" This field is always \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" when \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Global == TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" See this \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"explanation of columns in humdrumR\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humColumns\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Record\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" The record (i.e., line) number in the original file.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"NData\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"data\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" record enumeration in the file, starting from \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"1\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Stop\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Which token in a multistop token, numbered starting from \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"1\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" In files with no multistops, the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Stop\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field is all \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"1\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" This field is always \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" when \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Global == TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Global\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"logical\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Did the token come from a global record (as opposed to a local record)?\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" When \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Global == TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Spine\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Column\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Stop\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" fields are always \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Token info\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\":\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Type\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" What type of record is it?\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\\"D\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" = non-null data\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\\"d\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" = null data\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\\"I\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" = interpretation\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\\"M\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" = measure/barline\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\\"L\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" = local comment\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\\"G\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" = global comment.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\\"P\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" = null \\\"non-tokens\\\" (see the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR columns\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humColumns\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" documentation for an explanation.)\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Null\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"logical\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Is the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"active\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumR\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" data field null?\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" See the detailed discussion below, in the section of this documentation called \\\"Null Data.\\\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Filter\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"logical\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Has this record/token been \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"filtered out\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=filterHumdrum\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"?\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Interpretation fields:\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Interpretation fields describe interpretation metadata in the humdrum file(s).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Humdrum interpretations are tokens that \\\"carry forward\\\" to data points after them, unless cancelled out by a\\n\", class = c(\"TEXT\", \"tag\")), structure(\"subsequent interpretation. (See the humdrum syntax vignette for a detailed explanation.)\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"All\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" humdrum data must have an \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"exclusive\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" interpretation\\n\", class = c(\"TEXT\", \"tag\")), structure(\"so humdrum tables always have an \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Exclusive\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (:: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") field indicating the\\n\", class = c(\"TEXT\", \"tag\")), structure(\"exclusive interpretation associated with each token/row of the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"active\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumR\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" field.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Humdrum data may, or may not, include additional \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tandem\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" interpretations. A universal rule for parsing\\n\", class = c(\"TEXT\", \"tag\")), structure(\"tandem intepretations is impossible, because A) tandem interpretations can \\\"overwrite\\\" each other and B)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"users can create their own tandem interpretations. The best we can do in all cases is\\n\", class = c(\"TEXT\", \"tag\")), structure(\"identify \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"all\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" tandem interpretations that have appeared previously in the spine\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(counting most recent first). All these previous interpretations are encoded in a single\\n\", class = c(\"TEXT\", \"tag\")), structure(\"character string in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Tandem\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If working with non-standard intrepretations, users can parse the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Tandem\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field using the\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"getTandem\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" function.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If no tandem interpretations occur in a file, the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Tandem\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field is full of empty strings (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Fortunately, many tandem interpretations are widely used and standardized, and these\\n\", class = c(\"TEXT\", \"tag\")), structure(\"interpretations are known by \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". Recognized interpretations (such as \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"*clefG4\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"*k[b-]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\")\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are automatically parsed into their own fields by a call to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"See the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" documentation for more details.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Formal fields:\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Formal fields indicate musical sections, or time windows within\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a piece, including formal designations (\\\"verse\\\", \\\"chorus\\\", etc.) and measures/bars.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Humdrum data may or may not include formal metadata fields, indicated by the token \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"*>\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Classified formal marks are put into fields matching their name.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Unclassified formal marks are placed in a field called \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Formal\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" as a default.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Nested formal categories are appended with an underscore and a number for each level of descent:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Formal_1, Formal_2, ..., Formal_N\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If part of a section is not given a name in a lower hierarchical level, the field is simply\\n\", class = c(\"TEXT\", \"tag\")), structure(\"empty (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") at that point.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Humdrum data may, or may not, also include barlines (tokens beginning \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"=\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Humdrum tables \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"always\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" include three formal fields related to barlines:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Bar\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" How many barline records (single or double) have passed before this token?\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" If no \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"=\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" tokens occur in a file, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Bar\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is all zeros.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Note that this field is independent of whether the barlines are labeled with numbers in the humdrum file!\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"DoubleBar\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" How many \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"double\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\"-barline records have passed before this token?\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" If no \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"==\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" tokens occur in a file, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"DoubleBar\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is all zeros.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"BarLabel\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" :: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Any characters that occur in a barline-token \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"after\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" an initial \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"=\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"==\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"These include the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"-\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" in the common \\\"implied barline token \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"=-\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(\"repeat tokens (like \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"=:||\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"), and also any \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"explicit\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" bar numbers.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Note that the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Bar\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field always enumerate \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"every\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" bar record, while\\n\", class = c(\"TEXT\", \"tag\")), structure(\"measure-number labels in humdrum data (which appear in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"BarLabel\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field) may\\n\", class = c(\"TEXT\", \"tag\")), structure(\"do weird things like skipping numbers, repeating numbers, or having suffixes (e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"19a\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If no barline tokens appear in the file, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"BarLabel\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is all empty strings (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Reference fields:\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Reference fields describe any \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Reference Records\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in the humdrum data. Every reference record (records beginning \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"!!!\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") in any\\n\", class = c(\"TEXT\", \"tag\")), structure(\"humdrum file in a corpus read by \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" is parsed into a field named\\n\", class = c(\"TEXT\", \"tag\")), structure(\"by the reference code: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"XXX\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"!!!XXX\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Reference tokens are all identical throughout\\n\", class = c(\"TEXT\", \"tag\")), structure(\"any humdrum piece. If a reference code appears in one file but not another, the field is\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" in the file which does not have the code. If no reference records appear in any\\n\", class = c(\"TEXT\", \"tag\")), structure(\"files read by \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\", no reference fields are created.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Examples of common reference records are \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"!!!COM:\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (composer) and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"!!!OTL:\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (original title).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Any humdrum data with these records will end up having \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"COM\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"OTL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" fields in its humdrum table.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Null Data:\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In humdrum syntax, there is no requirement that every spine-path contains data\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in every record. Rather, spines are often padded with \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"null tokens\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In some cases, entire records may be padded with null tokens.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Each type of humdrum record uses a different null token:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Intepretation\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\": \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"*\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Comment\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\": \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"!\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Barline\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\": \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"=\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Data\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\": \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\".\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Null tokens in a humdrum table are identified in the logical \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Null\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Null\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field is set when a humdrum table is created (by \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\") and is updated everytime\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a new \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"active\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumR\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" field is set.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Null\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is set to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" wherever, either\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" the active field is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data and the token is a single \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\".\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"!\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"=\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"*\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\";\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" the active field is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (including \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NA_character_\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"In parallel to the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Null\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field, null \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"data\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" tokens (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\".\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") are identified as their own record type: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"d\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"All updates/changes to the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Null\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field are also propogated to the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Type\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field---i.e., setting \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Type == d\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" wherever\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a data record is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Null\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This is important/useful because \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" routines are, by default, only applied to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"D\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data, ignoring \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"d\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Whenever you \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"print\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humPrint\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"export\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=writeHumdrum\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" a \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" object, null data in the active field\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(i.e., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Null == TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") print as \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\".\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, if you are working with numeric data, with \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" values, these \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" values will print as \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\".\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Reshaping:\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Breaking the complex syntax of humdrum data into the \\\"flat\\\" structure of a humdrum table, with every single token on one line\\n\", class = c(\"TEXT\", \"tag\")), structure(\"of a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"data.table\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", makes humdrum data easier to analyze.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Of course, thanks to the structure fields, we can easily\\n\", class = c(\"TEXT\", \"tag\")), structure(\"regroup and reform the original humdrum data or use the structure of the data (like spines) in our analyses.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, in some cases, you might want to work with humdrum data in a different structure or \\\"shape.\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"HumdrumR has several options for \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"folding\\\"\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humShape\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" tokens within humdrum tables,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"or otherwise \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"reshaping humdrum data\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humCoercion\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" into data formats/structures you might prefer.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humValidation.Rd = structure(list(structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Validation.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humValidation\", class = c(\"VERB\", \"tag\" ))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humValidation\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"validateHumdrum\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Validate humdrum files\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"validateHumdrum(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" contains = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" recursive = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" errorReport.path = NULL\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"recursive\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(list( structure(\"logical\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\")), structure(\". If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the final part of the search pattern (i.e., the file search)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"is searched for recursively through all sub directories.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"errorReport.path\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(list( structure(\"character\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\")), structure(\". A directory path which, if not \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", an error report is written\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in the file \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"'humdrumR_syntaxErrorReport_date.txt'\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". In addition, all files with errors\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are written to this directory (with \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"'errorMarkup'\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" appended to their names), with\\n\", class = c(\"TEXT\", \"tag\")), structure(\"errors annotated inline.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"patterns\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(list( structure(\"character\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\")), structure(\" vector. Search pattern(s) for identifying files\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(see \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[readHumdrum][readHumdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\").\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"files\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A list of character strings, each representing a record in a file.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_arguments\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This function checks files for violations of the\\n\", class = c(\"TEXT\", \"tag\")), structure(\"humdrum syntax.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humWindows.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Windows.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humWindows\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humWindows\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"windows\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"hop\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"nest\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Applying functions across arbitrary windows.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"----------------------------------------------> NEEDS DOCUMENTATION <----------------------------------------------------\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"windows(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" df,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" form,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" with = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" start = 1L,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" end = nrow(df),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" bounds = \\\"exclude\\\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"hop(vec, pattern, start = 1L, end = length(vec))\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"nest(vec, open, close, depth = 1)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Applying functions across arbitrary windows.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"----------------------------------------------> NEEDS DOCUMENTATION <----------------------------------------------------\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humdrumDispatch.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Compose.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumDispatch\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumDispatch\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"makeDispatchDF\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"makeHumdrumDispatcher\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"print.humdrumDispatch\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Regular expression method dispatch and function application\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"humdrumDispatch(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" str,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" dispatchDF,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" Exclusive = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" multiDispatch = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" outputClass = \\\"character\\\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"makeDispatchDF(...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"makeHumdrumDispatcher(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" funcName = \\\"humdrum-dispatch\\\",\\n\", class = c(\"RCODE\", \"tag\")), structure(\" outputClass = \\\"character\\\",\\n\", class = c(\"RCODE\", \"tag\")), structure(\" args = alist()\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list( structure(list(structure(\"print\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrumDispatch\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x)\\n\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"str\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"The input \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" string, on which dispatch is called.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"dispatchDF\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A data.frame which describes what function should be called for\\n\", class = c(\"TEXT\", \"tag\")), structure(\"which regex input. (See details).\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Exclusive\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Defaults to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", only the regexes are used for dispatch.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"multiDispatch\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(list( structure(\"logical\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\")), structure(\", length 1. If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (the default) the \\\"best\\\" regex/exclusive match\\n\", class = c(\"TEXT\", \"tag\")), structure(\"is dispatched for each Exclusive segment. If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", differenet functions can be dispatched\\n\", class = c(\"TEXT\", \"tag\")), structure(\"within the same input vector.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"...\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Arguments to pass to dispatch functions.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"outputClass\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Character string: the default output class which the function should return.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Generally, to make sense, all dispatched functions should return the same type, which you should explicitly\\n\", class = c(\"TEXT\", \"tag\")), structure(\"indicate with the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"outputClass\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Dispatch functions should also be \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"vectorized\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:Vectorize\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\", class = c(\"TEXT\", \"tag\" ))), class = \"tag\")), class = c(\"tag_item\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_arguments\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"regular-expression method dispatch system\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"is a simple system for making new functions which can by smartly\\n\", class = c(\"TEXT\", \"tag\")), structure(\"applied to a variety of character strings.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Humdrum dispatch works like normal R method dispatch, but instead of dispatching specific methods\\n\", class = c(\"TEXT\", \"tag\")), structure(\"based on their class (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", etc.) it dispatches based on regular expressions.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In addition, exclusive interpretations can be used to guide dispatch.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Many \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" functions are in fact, humdrum-dispatch functions: for example, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"tonalInterval.character()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=tonalInterval.character\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If you call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval('ee-')\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the function will recognize that the input string is a token in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"**kern\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"representation, and call the appropriate parser.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If you instead call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval('me')\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the function will recognize that the input string is a token in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"**solfa\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"representation, and call the appropriate parser for that.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"dispatchDF\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"dispatchDF\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" must be a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"data.table::data.table()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"data.table:data.table\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" created using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"makeDispatchDF\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" function.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"makeDispatchDF\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" takes one or more arguments, each a list with three components (ordered, not nameed):\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" A character vector of exclusive interpretations. (Specify \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"any\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" if you don't want exclusive dispatch).\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" A regular expression (character string) or a function which can generate a regular expression, which accepts \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"...\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"arguments at the time of dispatch.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" A function to dispatch.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_enumerate\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"makeHumdrumDispatcher\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"makeHumdrumDispatcher\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is a function which creates a new function which automatically performs humdrum-dispatch.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A number of important \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" functions are created with \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"makeHumdrumDispatcher\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\":\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"tonalInterval.character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"diatonicSet.character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"tertianSet.character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"rhythmInterval.character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"u <- c('A', 'B', 'CD', 'E', 'F', 'gh', 'L', 'KX')\\n\", class = c(\"RCODE\", \"tag\")), structure(\"l <- c('a', 'b', 'cd', 'e', 'f', 'gh', 'l', 'kx')\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"lowercasefunc <- \\\\(x) 5L - nchar(x)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdrumDispatch(l, outputClass = 'integer',\\n\", class = c(\"RCODE\", \"tag\")), structure(\" makeDispatchDF(list('any', '[a-z]+', lowercasefunc),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" list('any', '[A-Z]+', nchar)))\\n\", class = c(\"RCODE\", \"tag\")), structure(\" # lowercasefunc will be called on l, nchar on u\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_examples\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humdrumPitch.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/humdrumR-package.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumPitch\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumPitch\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR and pitch\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumR\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" includes a number of intertwined data structures, and associated functions, for representing and manipulating musical pitch information.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Tonality\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"There are four data types extensively used in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" to encode/process \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Tonality\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"tonal\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" musical information:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"integers\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:integer\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" --- used to encode \\\"\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"line-of-fifths\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"\\\" tonal information\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"tonalInterval\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" --- embeds line-of-fifth tonal integers alongside \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Octave\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"octave\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"\\\"https://en.wikipedia.org/wiki/Cent_(music)\\\"\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"cent\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" information to encode most tonal pitch representations (solfege, intervals, letternames, etc.)\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"diatonicSet\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" --- combines line-of-fifth tonal integer representations to represent diatonic tonality, including alterations of basic diatonic scale(s).\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"tertianSet\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" --- an extension of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" used to encode \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Tertian\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"tertian\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" diatonic harmonies.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"For a detailed explanation of the theory and specifics of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"'s treatment of tonality, see the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Tonality in humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" vignette.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Atonality\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"THIS SECTION IS INCOMPLETE\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In addition, there are xxx data types used to encode non-tonal (or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Atonality\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"atonal\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\") pitch information.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"integers\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:integer\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" --- used to encode \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Semitone\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"semitones\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" (as well as \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/MIDI\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"MIDI\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" numbers).\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"xxx\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" --- sets?\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"xxx\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" --- 12-tone rows?\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humdrumR.Rd = structure(list(structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/humdrumR-package.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"package\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_docType\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humdrumR\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humdrumR\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humdrumR\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\")), structure(\" is a toolkit for the analysis of data encoded in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"http://www.humdrum.org/guide/ch05/\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrum syntax\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"The humdrum syntax is an incredibly flexible, and powerful, scheme for encoding musical data.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Tens of thousands of musical scores (and other musical data) have been encoded in the humdrum syntax, many available online through repositories such as\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"http://kern.ccarh.org/\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"KernScores\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is intended as a modernized replacement for the original \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"http://www.humdrum.org/\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrum toolkit\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\" )), structure(\", levaraging\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"the power of R to give us enprecedented power to manipulate and analyze humdrum data using concise, expressive syntax.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Package design\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The package \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" has XXX main components:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\" )), structure(\" To represent humdrum data in R, we have the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"http://adv-r.had.co.nz/S4.html\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"S4 class\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\", and it's core component\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum table\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(), class = c(\"tag_item\", \"tag\" )), structure(\" To create \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data, a sophisticated humdrum data parser: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data can also be written back to humdrum-syntax text files using \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"writeHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" To filter and \\\"index\\\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data, we have the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"filterHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" function, which can also be called in a variety of\\n\", class = c(\"TEXT\", \"tag\")), structure(\"short hands using R's standard \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"indexing operators\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:Extract\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\": \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[]]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" To manipulate and modify \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data, we have the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"with(in)Humdrum\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=with-in-Humdrum\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"humApply\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" functions.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" A set of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"pipe\\\" operators\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humPipe\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hum>%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%hum<%\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\", etc.), so that \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data can be manipulated and filtered in concise,\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Vertical_bar#Pipe\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"bash-style pipes\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(), class = c(\"tag_item\", \"tag\" )), structure(\" To facilate the development of functions to work with humdrum tokens---which are simple character strings packed with information---,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a useful API we call our \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"regular-expression dispatch system\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumDispatch\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(), class = c(\"tag_item\", \"tag\" )), structure(\" Several \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"modules\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumPitch\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" for representing and manipulating musical pitch information,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"including our core \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" class to represent tonal pitch.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" A \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"module\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humRhythm\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" for representing and manipulating musical rhythm information,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"with a core \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" class to represent rhythms.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"internal\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_keyword\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humdrumRclass.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/humdrumR-class.R, R/Filter.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"class\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_docType\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"makeHumdrumR\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRS4\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"is.humdrumR\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"$,humdrumR-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"fields\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"$<-,humdrumR,vector-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"$<-,humdrumR,humdrumR-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[<-,humdrumR,character,ANY,vector-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[<-,humdrumR,character,ANY,humdrumR-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[,humdrumR,missing,character-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[,humdrumR,missing,missing-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[,humdrumR,formula,missing-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[,humdrumR,missing,formula-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"HumdrumR class\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"is.humdrumR(x)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"$\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(x, name)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"fields(\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" humdrumR,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" fieldTypes = c(\\\"Data\\\", \\\"Structure\\\", \\\"Interpretation\\\", \\\"Formal\\\", \\\"Reference\\\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list( structure(list(structure(\"$\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrumR,vector\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(x, name) <- value\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"$\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrumR,humdrumR\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(x, name) <- value\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"[\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrumR,character,ANY,vector\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(x, i, j) <- value\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"[\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"humdrumR,character,ANY,humdrumR\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(x, i, j) <- value\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdata[[ , 'regex']]\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdata[[ , , ~expression]] or humdata [[ , , 'regex']] or humdata[[z = ~expression]] or humdata[[z = 'regex']]\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdata[[~expression]]\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humdata[[ , ~expression]]\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"S4\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" class is the basic unit of the\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" package.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Each \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object represents data \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"read\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=readHumdrum\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" from one or\\n\", class = c(\"TEXT\", \"tag\")), structure(\"more humdrum files.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In the documentation we refer to the collection of files within a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" object\\n\", class = c(\"TEXT\", \"tag\")), structure(\"as a \\\"\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"corpus\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\",\\\" and each file as a \\\"\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"piece\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\".\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, though humdrum data is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"usually\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" encoded as one \\\"piece\\\" per file, this is not necessarily the case:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"files might represent movements within a piece, or even just a part of a score. Still, we tend to refer\\n\", class = c(\"TEXT\", \"tag\")), structure(\"to them as \\\"pieces.\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In coding examples, we name humdrumR objects \\\"\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The most imporant part of a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object is the\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum tables\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" it holds within it.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In essence, an \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object is simply a wrapper around these\\n\", class = c(\"TEXT\", \"tag\")), structure(\"humdrum tables, which helps users to\\n\", class = c(\"TEXT\", \"tag\")), structure(\"to visualize, index, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"summarize\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humSummary\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\", and \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"manipulate\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=withinHumdrum\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the table in a variety of ways.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Basic information about the size and shape of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data can be\\n\", class = c(\"TEXT\", \"tag\")), structure(\"obtained with calls to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"nrecords, npieces, length, ncol, etc.\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humSize\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"More detailed summary information can be obtained with the humdrumR \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"corpus summary functions\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humSummary\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"HumdrumR data can also be coerced to more basic R data types using \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.matrix, as.data.frame, etc.\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humCoercion\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"A number of helpful functions are also defined to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"reshape\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humShape\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" humdrumR data.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"The most powerful features of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" are the tools it gives you to\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Filter humdrum data, using \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"filterHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" and the standard R \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"indexing operators\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:Extract\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\": \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"[]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[[]]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Apply functions and arbitrary commands to humdrum data using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"with(in)Humdrum\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=withinHumdrum\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" routines,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"and their associated \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"piping operators\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humPipe\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_enumerate\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Slots\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(list( structure(\"Humtable\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A list of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum tables\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\", each having the same fields\\n\", class = c(\"TEXT\", \"tag\")), structure(\"but containing data from different types of records (e.g., interpretations, data, barlines, comments).\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(list( structure(\"Files\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A list of two elements. The first, \\\"Search\\\", contains a single character representing\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pattern\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" used in the call to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" which created this humdrumR object.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The second, \\\"Names\\\", is a vector of strings representing all the files which matched the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pattern\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"and were read into the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(list( structure(\"Fields\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A list containing strings corresponding to the existing fields in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The fields are divided into five categories: \\\"Data\\\", \\\"Structure\\\", \\\"Interpretation\\\", \\\"Formal\\\", and \\\"Reference\\\"---see\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum table\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" documentation.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(list( structure(\"Active\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A quosure expression which\\n\", class = c(\"TEXT\", \"tag\")), structure(\"extracts data from field(s) in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum table\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\": the \\\"active expression.\\\"\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(list( structure(\"LoadTime\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"POSIXct\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:DateTimeClasses\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" value, indicating the time at which \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" was\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"called to create this \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(list( structure(\"Patterns\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A character vector of the original search patterns used to match files in the system.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_describe\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Active field\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Active\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" slot of a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" object contains an \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"expression\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"rlang:quosure\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"which refers to fields in the internal \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrum table\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humTable\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Go to the dedicated \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"active field\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humActive\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" documentation to learn more about this important slot!\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), humdrumRroot.Rd = structure(list(structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/humdrumR-package.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"data\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_docType\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humdrumRroot\", class = c(\"VERB\", \"tag\" ))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRroot\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"'s root directory on your machine.\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"An object of class \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" of length 1.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_format\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"humdrumRroot\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRroot\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is the path to where the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" package is install on your machine.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A few simple humdrum files are stored here.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"datasets\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_keyword\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), interpolateArguments.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Apply.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"interpolateArguments\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"interpolateArguments\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Change or insert values in an expression\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"interpolateArguments(quo, namedArgs)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"namedArgs\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A list of named arguments. Unnamed arguments are simply ignored.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"expr\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A unevaluated expression object.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_arguments\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This function can be used to modify arguments to a functions\\n\", class = c(\"TEXT\", \"tag\")), structure(\"within an existing expression (or quosure/formula).\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"interpolateArguments\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" inteprets named value in its \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"namedArgs\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"argument in one of two ways: If the named value is a list, it interprets\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the name of the list as a function call, and inserts/swaps any arguments\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in that list into any instances of that function call within the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"expr\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Named arguments are inserted or substituted if already present in expression.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Unnamed argmuments are simply added to the call.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Examples:\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"myexpr <- quote(dnorm(x, mean = 5))\\n\", class = c(\"VERB\", \"tag\")), structure(\"interpolateArguments(myexpr, list(dnorm = list(mean = 2, sd = 5, TRUE)))\\n\", class = c(\"VERB\", \"tag\")), structure(\"\\n\", class = c(\"VERB\", \"tag\")), structure(\"# result is new expresson: dnorm(x, mean = 2, sd = 5, TRUE)\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If a named valued in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"namedArgs\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument is not a list,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"that name/value pair is substituted anywhere it is present in the expression.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This approach is often more conscise, but arguments cannot be added to an\\n\", class = c(\"TEXT\", \"tag\")), structure(\"expression this way, only substituted if already present.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Examples:\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"myexpr <- quote(dnorm(x, mean = 5))\\n\", class = c(\"VERB\", \"tag\")), structure(\"interpolateArguments(myexpr, mean = 2)\\n\", class = c(\"VERB\", \"tag\")), structure(\"\\n\", class = c(\"VERB\", \"tag\")), structure(\"# result is new expression: dnorm(x, mean = 2)\\n\", class = c(\"VERB\", \"tag\")), structure(\"}\\n\", class = c(\"VERB\", \"tag\" ))), class = c(\"tag_preformatted\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"myexpr2 <- quote(A + b*x + rnorm(length(a), mean(Z), sd = 2))\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"interpolateArguments(myexpr2,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" list(sd = 10, mean = list(na.rm = TRUE)))\\n\", class = c(\"RCODE\", \"tag\")), structure(\" \\n\", class = c(\"RCODE\", \"tag\")), structure(\"# result is new expression: \\n\", class = c(\"RCODE\", \"tag\")), structure(\"# a + b*x + rnorm(length(a), mean(Z, na.rm = TRUE), sd = 10)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_examples\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), intervalCalculus.Rd = structure(list(structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/tools.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"intervalCalculus\", class = c(\"VERB\", \"tag\" ))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"intervalCalculus\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integrate\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"sigma\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"derive\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"delta\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"calculus\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Interval \\\"calculus\\\"\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"integrate(intervals, skip = list(is.na))\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"sigma(intervals, skip = list(is.na))\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"derive(intervals, skip = list(is.na))\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"delta(intervals, skip = list(is.na))\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"calculus(x, n, skip = list(na))\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Interval \\\"calculus\\\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), keyTransformer.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/diatonicSet.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"keyTransformer\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"keyTransformer\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"key\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Parsing and deparsing key information\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"key(x, ..., Key = NULL, parseArgs = list(), memoize = TRUE, deparse = TRUE)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"XXX\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), lag.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/tools.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"lag\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"lag\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"lead\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Shift data within a vector/matrix/data.frame\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"lag(x, n = 1, fill = NA, wrap = FALSE, windows = NULL, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"lead(x, n, ...)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"x\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"The input argument. Should be vector (including lists), array, or data.frame\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"The amount to lag/lead the data.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"fill\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"wrap = FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and/or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"windows = NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", parts of the output are padded with the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"fill\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument. Defaults to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"wrap\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"wrap = TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", data from the end (head or tail) is copied to the other end of the output, \\\"wrapping\\\" the data\\n\", class = c(\"TEXT\", \"tag\")), structure(\"within the data structure.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"windows\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A vector or list of vectors, all of th same length as \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"x\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". Lags crossing the boundaries indicated in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"windows\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are filled.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"margin\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Arrays and data.frames can be lagged lead in multiple dimensions using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"margin\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_arguments\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"lag\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"lead\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" functions take input vectors, matrices, or data.frames and shifts their data\\n\", class = c(\"TEXT\", \"tag\")), structure(\"by \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" indices.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"They are similiar to the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"data.table::shift\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"data.table:shift\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" function, but with a few additional options:\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"data.table::shift()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"data.table:shift\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), metricPosition.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/rhythmInterval.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"metricPosition\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"metricPosition\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Calculate metric positions from duration data.\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"metricPosition(rints, bars = NULL, beats = rint(c(2, 4, 8, 16, 32)))\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Calculate metric positions from duration data.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Other rhythm analysis tools: \\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"rhythmDecompose\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"()\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"rhythmOffset\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"()\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythm analysis tools\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_concept\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), pitchFunctions.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/tonalInterval.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pitchFunctions\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pitchFunctions\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"semit\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"midi\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pitch\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"kern\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"lilypond\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"interval\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"degree\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"solfa\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Manipulate pitch data\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"semit(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" Key = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" Exclusive = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parseArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" transposeArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" inPlace = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" memoize = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" deparse = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"midi(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" Key = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" Exclusive = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parseArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" transposeArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" inPlace = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" memoize = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" deparse = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"pitch(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" Key = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" Exclusive = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parseArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" transposeArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" inPlace = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" memoize = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" deparse = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"kern(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" Key = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" Exclusive = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parseArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" transposeArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" inPlace = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" memoize = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" deparse = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"lilypond(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" Key = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" Exclusive = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parseArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" transposeArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" inPlace = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" memoize = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" deparse = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"interval(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" Key = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" Exclusive = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parseArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" transposeArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" inPlace = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" memoize = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" deparse = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"degree(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" Key = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" Exclusive = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parseArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" transposeArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" inPlace = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" memoize = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" deparse = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"solfa(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" Key = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" Exclusive = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parseArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" transposeArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" inPlace = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" memoize = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" deparse = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Manipulate pitch data\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"tonalInterval\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), plotRhythm.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Graphics.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"plotRhythm\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"plotRhythm\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"plotRhythm.default\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"plotRhythm.rhythmInterval\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"-------------------------------------------> NEEDS DOCUMENTATION <-------------------------------------------\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Plotting rhythmic symbols in R base graphics\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"plotRhythm(x, y, notes, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"plotRhythm\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"default\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x, y, notes, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"plotRhythm\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x, y, notes, ...)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"-------------------------------------------> NEEDS DOCUMENTATION <-------------------------------------------\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Plotting rhythmic symbols in R base graphics\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), rational.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/tools.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rational\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rational\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.rational\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"fraction\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.fraction\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Rational numbers\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"rational(numerator, denominator = 1)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"as.rational(x, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"fraction(numerator, denominator, sep = \\\"/\\\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"as.fraction(x, sep, ...)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"R has no built in rational number representation; \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" defines one.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"as.decimal()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=as.decimal\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"as.numeric()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=as.numeric\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Other \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR numeric functions\", class = c(\"TEXT\", \"tag\"))), class = c(\"LIST\", \"tag\")), structure(\": \\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"decimal\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"()\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"humdrumR numeric functions\", class = c(\"TEXT\", \"tag\"))), class = c(\"LIST\", \"tag\"))), class = c(\"tag_concept\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), readHumdrum.Rd = structure(list(structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Read.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"readHumdrum\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"readHumdrum\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"findHumdrum\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"Find and read humdrum files into R\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"findHumdrum(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" contains = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" recursive = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" allowDuplicates = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" verbose = FALSE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"readHumdrum(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" recursive = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" contains = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" allowDuplicates = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" verbose = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" tandems = \\\"known\\\",\\n\", class = c(\"RCODE\", \"tag\")), structure(\" reference = \\\"all\\\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"...\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"character: One or more patterns used to identify files to read.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For details: see the \\\"REpath-patterns\\\" section below.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"contains\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(list( structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"!is.null(contains)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"contains\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument is\\n\", class = c(\"TEXT\", \"tag\")), structure(\"is treated as regular expressions: only files which contain matches to\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"all\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" of these regular expressions are read.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"readHumdrum('.*krn$', contains = \\\"EEE\\\")\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will only read kern files which contain matches\\n\", class = c(\"TEXT\", \"tag\")), structure(\"to \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"\\\"EE\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"---which is kern for the E two octaves below middle C (or lower).\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"recursive\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"logical: If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the final part of the search pattern (i.e., the file search) is searched for\\n\", class = c(\"TEXT\", \"tag\")), structure(\"recursively through all sub directories.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"allowDuplicates\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(list( structure(\"logical\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" of length one, indicating what should happen if multiple search patterns match the same files.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"allowDuplicates = TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(\"any such files are read multiple times, grouped into their respective corpora by the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Label\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"allowDuplicates = FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", any redundant files are only read into the corpus of the first pattern they\\n\", class = c(\"TEXT\", \"tag\")), structure(\"match.\", class = c(\"TEXT\", \"tag\" ))), class = \"tag\")), class = c(\"tag_item\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"verbose\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"logical: If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the names of matching files are printed before parsing begins. This is very\\n\", class = c(\"TEXT\", \"tag\")), structure(\"useful as a check to make sure you aren't reading the wrong files!\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"tandems\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(list( structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". This argument controls which, if any, tandem interpretations\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are parsed into their own fields. The default value is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"known\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"reference\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(list( structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". This argument controls which, if any, reference records\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are parsed into their own fields. The default value is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"all\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_arguments\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"These functions find valid humdrum files on your local machine and read them into \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"findHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" does the work of finding and reading the text files into R.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" utilizes \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"findHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" to read files, then parses them to\\n\", class = c(\"TEXT\", \"tag\")), structure(\"create a \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"humTable\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" and build\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a \", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumRclass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" data object around the table.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"REpath-patterns\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\\"REpath-patterns\\\" are specified using \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"...\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" arguments.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In combination, all the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"...\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" arguments are used to search for file paths.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Each part of the search path you specify (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"dirpart/dirpart/filepart\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", etc) are matched as regular expressions\\n\", class = c(\"TEXT\", \"tag\")), structure(\"against directories/files on your disc.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, we can say things like \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"findHumdrum(\\\"../^A.*/.*krn$\\\")\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", which would\\n\", class = c(\"TEXT\", \"tag\")), structure(\"match any kern files in any directory beginning with a capital \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"A\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" in the\\n\", class = c(\"TEXT\", \"tag\")), structure(\"directory above the current working directory.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For conveniance, you can break the path across multiple arguments instead of using delimited strings: For example, the code\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"findHumdrum(\\\"..\\\", \\\"^A.*\\\", \\\".*krn$\\\")\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will give an identical result as the previous example\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"findHumdrum(\\\"../^A.*/,*krn$\\\")\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This is useful when searching for more than one pattern (see next paragraph) in the same directory.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If you want to search for \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"more than one\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" pattern, you can input them as a character vector:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For instance, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum(c(\\\"mozart\\\", \\\"beethoven\\\")\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"---this command will search for\\n\", class = c(\"TEXT\", \"tag\")), structure(\"filenames containing \\\"mozart\\\" OR \\\"beethoven.\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This works for directories too: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum(c(\\\"Mozart\\\", \\\"Beethoven\\\"), \\\".*krn$\\\")\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will\\n\", class = c(\"TEXT\", \"tag\")), structure(\"look for any kern files in directories containing \\\"Mozart\\\" OR \\\"Beethoven.\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If patterns are named, these names will show up as identifying patterns in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humdrumR][humdrumR]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" object's\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Label\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field. Unnamed patterns are simply labeled with numbers.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Normal (system appropriate) conventions (i.e., directories separated by \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"/\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"'~'\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" at beginning to indicate home, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"..\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" to indicate directory above working directory, etc.)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are followed.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If a pattern contains a solo dot followed by a file sep---e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"./\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"x/./y\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"---this is\\n\", class = c(\"TEXT\", \"tag\")), structure(\"treated as the current directory, not a regular expression.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If a pattern contains two dots---e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"../\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"---this is treated as the directory above, not a regular expression.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If you want to create a regular expression to match any directory, use \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\".*/\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The regex pattern \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" matches any file (it is changed to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\".*\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"). If you don't specifiy any \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"...\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument,\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"findHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") will default to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\".*\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" as well.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum()\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will read any humdrum files in the working directory.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(If two or more files in different directories share the same name, a unique name is created for\\n\", class = c(\"TEXT\", \"tag\")), structure(\"each file by appending the names of the directories they occupy, recursively\\n\", class = c(\"TEXT\", \"tag\")), structure(\"until the names are unique.)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If a single humdrum file has multiple pieces in it---meaning that all spine paths close with \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"*-\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\", then\\n\", class = c(\"TEXT\", \"tag\")), structure(\"open again with \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"**\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"---then they are parsed separetely.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"They are distinguished in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Piece\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If there are no multi-piece files, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Piece\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"File\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will be identical.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Validity\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"findHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" automatically ignore non-text files.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Whatsmore, any files which contain humdrum syntax errors (checked by \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[validateHumdrum][validateHumdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\") are automatically\\n\", class = c(\"TEXT\", \"tag\")), structure(\"skipped. If you want to see specifically what errors occured, call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[validateHumdrum][validateHumdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"directly and its \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"errorReport.path\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Tandem Interpretations\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tandems\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument controls which tandem interpretations\\n\", class = c(\"TEXT\", \"tag\")), structure(\"parsed into their own fields. This can be helpful to either save processing time and memory\\n\", class = c(\"TEXT\", \"tag\")), structure(\"by \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"not\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" parsing interpretations you won't need, or to parse interpretations that\\n\", class = c(\"TEXT\", \"tag\")), structure(\"humdrumR doesn't recognize.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \\\"known\\\" tandem interpretations that humdrumR recognizes are encoded in a build humdrumR\\n\", class = c(\"TEXT\", \"tag\")), structure(\"table called \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"knownInterpretations\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Each interpretation has a humdrumR name (\\\"Clef\\\", \\\"TimeSignature\\\", etc.) as well as a regular expression\\n\", class = c(\"TEXT\", \"tag\")), structure(\"associated with it.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The default value for the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tandems\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"known\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". If the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tandems\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument\\n\", class = c(\"TEXT\", \"tag\")), structure(\"contains \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"known\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"all\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" tandem interpretations in the built-in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"knownInterpretations\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"table are parsed.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Users may specify different interpretations to parse in two ways:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" character strings\\n\", class = c(\"TEXT\", \"tag\")), structure(\"matching one of the name values from the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Name\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" column of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"knownInterpretations\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For instance, if you specify \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tandems = c('Clef', 'TimeSignature')\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", only clef (e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"*clefG2\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"),\\n\", class = c(\"TEXT\", \"tag\")), structure(\"and time signature (e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"*M3/4\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") intepretations will be parsed.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" if the chracter string(s) in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tandem\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" do not exactly match one of the names in\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"knownInterpretations$Name\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", they are treated as regular expressions and used to match\\n\", class = c(\"TEXT\", \"tag\")), structure(\"tandem interpretations in the data. This allows users to parse non-standard tandem interpretations\\n\", class = c(\"TEXT\", \"tag\")), structure(\"that humdrumR doesn't already know about.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_enumerate\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If any values in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tandems\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" are named, these names will be used for resulting fields.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If no matches to an given interpretation are found, no field is created for that interpretation.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"tandems = NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", then no tandem interpretations are parsed.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Reference Records\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"By default (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"reference = \\\"all\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"), humdrumR reads all reference records in the data.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The reference code for each record (e.g, the \\\"OTL\\\", in \\\"!!!OTL: xxx\\\") is used as the name of\\n\", class = c(\"TEXT\", \"tag\")), structure(\"an associated field.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(If a reference record has no reference code (i.e., it lacks a colon), the field is called \\\"Unkeyed.\\\")\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In large datasets with many reference records, the reference data can actually make up a large portion\\n\", class = c(\"TEXT\", \"tag\")), structure(\"of the humdrum table, and eat up a lot of memory. In these cases, we might not want to read\\n\", class = c(\"TEXT\", \"tag\")), structure(\"all (or any) reference records---we can instead read only the reference records that we are planning to use\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in our analyses (if any).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"reference = NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", no reference records are parsed.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Otherwise, the character values of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"reference\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" are treated as reference codes and only\\n\", class = c(\"TEXT\", \"tag\")), structure(\"matching reference records are parsed.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For instance, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"readHumdrum(_, reference = \\\"OTL\\\")\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" will \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"only\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" parse OTL reference records.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If the values of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"reference\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" are named, these names are used to name associated fields.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, by specifing \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"reference = c(Title = 'OTL')\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", you can use \\\"OTL\\\" reference records to populate\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a field called \\\"Title\\\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If there are more than one reference records with the same reference code,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"either explicitely numbered (e.g., \\\"!!!COM1:\\\", \\\"!!!COM2:\\\") all are read and rather than making two\\n\", class = c(\"TEXT\", \"tag\")), structure(\"or more fields, a single field is created (\\\"COM\\\" in this) with the multiple values separated by \\\";\\\".\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Result\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"findHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" returns a \\\"fileFrame\\\" (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"data.table\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"), listing all file names,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the patterns they match, the directories they were found in, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"and\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" the raw text content of these files.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"readHumdrum\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\")), structure(\" returns a fully parsed \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"readHumdrum() # loads all valid humdrum files in the current directory.\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"readHumdrum(\\\".*krn$\\\") # loads all files ending with \\\"krn\\\" in the currect directory\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"readHumdrum(\\\"^Composers$/^Be|^Mo/.*/^Joined$/.*krn$\\\") \\n\", class = c(\"RCODE\", \"tag\")), structure(\"# Goes inside the directory \\\"Composers\\\".\\n\", class = c(\"RCODE\", \"tag\")), structure(\"# Inside \\\"Composers\\\" looks for directories that start with \\\"Be\\\" or \\\"Mo\\\".\\n\", class = c(\"RCODE\", \"tag\")), structure(\"# If there are any \\\"Be|Mo\\\" matching directories within \\\"Composers\\\", matches all directories within them.\\n\", class = c(\"RCODE\", \"tag\")), structure(\"# Within these directories, looks for directories called \\\"Joined\\\".\\n\", class = c(\"RCODE\", \"tag\")), structure(\"# If there are any directories called \\\"Joined\\\", loads all files (if any) that end with \\\"krn\\\".\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"readHumdrum(\\\"^Composers$\\\", \\\"^Be|^Mo\\\", \\\".*\\\", \\\"^Joined$\\\", \\\".*krn$\\\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\"# exactly the same as the previous!\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"readHumdrum(\\\"^Composers$\\\", c(Beethoven = \\\"^Be\\\", Mozart = \\\"^Mo\\\"), \\\".*\\\", \\\"^Joined$\\\", \\\".*krn$\\\") \\n\", class = c(\"RCODE\", \"tag\")), structure(\"# exactly the same as the previous, except now the two matching patterns (\\\"^Be\\\", or \\\"^Mo\\\") will be grouped\\n\", class = c(\"RCODE\", \"tag\")), structure(\"# in the Label field as \\\"Beethoven\\\" and \\\"Mozart\\\" respectively.\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_examples\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), regexConstruction.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Regex.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"regexConstruction\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"regexConstruction\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"captureRE\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"captureUniq\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"orRE\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Making Regular Expressions\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"captureRE(strs, n = \\\"\\\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"captureUniq(strs, zero = TRUE)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"orRE(...)\\n\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" includes some helpful functions for creating new regular expressions which work with the\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"stringr\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" package.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"captureRE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will take a character vector and collapse it to a \\\"capture group.\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument can be used to append a number tag, for instance \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"'*'\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (zero or more) to the group.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"I.e., \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"captureRE(c(\\\"a\\\", \\\"b\\\", \\\"c\\\"), '*')\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will output \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"[abc]*\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"captureUniq\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will make a similar capture group to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"captureRE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", but with an expression\\n\", class = c(\"TEXT\", \"tag\")), structure(\"that makes sure that only 1 or more \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"of the same character\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" repeats.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For instance, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"captureUniq(c('a', 'b','c'))\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will return \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"([abc])\\\\\\\\1*\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"---this expression will match\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"aaa\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"bb\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" but not \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"aabb\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), rhythmDecompose.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/rhythmInterval.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmDecompose\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmDecompose\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Decompose durations in terms of other durations\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"rhythmDecompose(rhythmInterval, into = rint(c(1, 2, 4, 8, 16, 32)))\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Decompose durations in terms of other durations\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Other rhythm analysis tools: \\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"metricPosition\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"()\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"rhythmOffset\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"()\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythm analysis tools\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_concept\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), rhythmFunctions.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/rhythmInterval.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmFunctions\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmFunctions\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"recip\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"duration\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Manipulate pitch data\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"recip(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" Exclusive = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parseArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" timeArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" inPlace = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" memoize = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" deparse = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"duration(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" Exclusive = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" parseArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" timeArgs = list(),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" inPlace = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" memoize = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" deparse = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Manipulate pitch data\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"rhythmInterval\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), rhythmInterval.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/rhythmInterval.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rint\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.character,rhythmInterval-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.double.rhythmInterval\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"is.rhythmInterval\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"is.numeric,rhythmInterval-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"order.rhythmInterval\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Compare,rhythmInterval,rhythmInterval-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Summary,rhythmInterval-method\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval.logical\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval.NULL\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval.numeric\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval.rational\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval.fraction\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval.integer\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval.character\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Representation of rhythmic information\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"rhythmInterval(x, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"rint(denominator, numerator = 1L)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"as.character\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(x)\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list( structure(list(structure(\"as.double\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x)\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"is.rhythmInterval(x)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"is.numeric\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(x)\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"order.rhythmInterval(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" ...,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" na.last = TRUE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" decreasing = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" method = c(\\\"auto\\\", \\\"shell\\\", \\\"radix\\\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list( structure(list(structure(\"Compare\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"rhythmInterval,rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(e1, e2)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"Summary\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_S4method\", \"tag\")), structure(\"(x)\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"rhythmInterval(x, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"logical\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"`NULL`\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"numeric\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(n)\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list( structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"rational\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x)\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list( structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"fraction\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x)\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list( structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"integer\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x)\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(list( structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"character\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(str, Exclusive = NULL, ..., multiDispatch = FALSE)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"S4\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" class is the core rhythm representation in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" package.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The object is used to represent rhythmic durations\\n\", class = c(\"TEXT\", \"tag\")), structure(\"and metric positions.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Each duration is represented in\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Whole_note\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"whole note\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" units.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Numerically, these whole note units are represented as a ratio\\n\", class = c(\"TEXT\", \"tag\")), structure(\"between integers, held in the slots \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"@Numerator\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"@Denominator\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This allows use to represent any rational number with no loss of precision\\n\", class = c(\"TEXT\", \"tag\")), structure(\"due to rounding errors and weak decimal expansions (like \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"0.333333\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Rhythm intervals are similar to standard musical\\n\", class = c(\"TEXT\", \"tag\")), structure(\"termoniology (i.e, \\\"three eighth-notes\\\" is the ratio (3/8).\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Slots\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(list( structure(\"Numerator\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Integers\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(list( structure(\"Octave\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Integers\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_describe\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Vectorization\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" inherits from the virtual class\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This means you can apply normal vectorized commands to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"and even put them in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"base::data.frame()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:data.frame\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Arithmetic\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" objects have arithmetic operations defined.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Addition and subtraction are straightword and intuitive (i.e., (1/8) + (3/8) = (1/2)).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Multiplication and division are slightly more complicated:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Scalar_multiplication\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"scalar multiplication\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"is defined \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"for rational numbers\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\": (3/8) * 2 = (3/4)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(the result is always a new \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, note that a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" cannot be multiplied by another\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"---afterall, what would a quarter-note times a quarter-note be?\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" can be divided by another \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" to produce\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a real number: (1/2) / (1/4) = 2.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Like other rational values in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"R\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" we can also do either\\n\", class = c(\"TEXT\", \"tag\")), structure(\"``true'' (rational) division (using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"/\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:Arithmetic\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" operator)\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"or\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Euclidean_division\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Euclidean\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"division (using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%%\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:Arithmetic\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" operator).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Rational division (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"/\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") of a `rhythmInterval` by another `rhythmInterval`\\n\", class = c(\"TEXT\", \"tag\")), structure(\"results in a rational number. For instance, $(1/2) / (1/4) = 2$.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Rational division of a `rhythmInterval` by a rational number results in a\\n\", class = c(\"TEXT\", \"tag\")), structure(\"new `rhythmInterval`: $(1/2) / 2 = (1/4)$.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Eucliean (a.k.a., integer) division can only be applied between `rhythmInterval`s\\n\", class = c(\"TEXT\", \"tag\")), structure(\"resulting in an integer quotient---the remainder, which is a `rhythmInterval`,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"can be calculated with the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%%\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:Arithmetic\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" operator.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The remainder (a.k.a., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"modulo\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\") operator (`%%`) is especially\\n\", class = c(\"TEXT\", \"tag\")), structure(\"useful, for instance in calculating metric positions.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Relational Operators\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s can be compared using the standard\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"relational operators\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:Comparison\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"---\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"==\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"!=\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\">\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\">=\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", etc.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"core rhythm representation\", class = c(\"TEXT\", \"tag\"))), class = c(\"LIST\", \"tag\"))), class = c(\"tag_concept\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), rhythmOffset.Rd = structure(list(structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/rhythmInterval.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"rhythmOffset\", class = c(\"VERB\", \"tag\" ))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmOffset\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Calculate rhythmic \\\"offset\\\"\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"rhythmOffset(durations, start = 0, bars = NULL, tatum = 1, as = as.decimal)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"durations\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A vector of numeric values representing durations.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"start\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A duration value (coerced to same class as \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"durations\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"), from which the\\n\", class = c(\"TEXT\", \"tag\")), structure(\"offset begins.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"groups\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A vector of equal length as \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"durations\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" representing a grouping factor,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"usable by \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"[base][tapply]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\". If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"!is.null(groups)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", offsets are calculated\\n\", class = c(\"TEXT\", \"tag\")), structure(\"for duration values within each group. The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"start\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument is recycle to match\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the length of the number of groups, so a different start value can be applied to each group.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"is.null(groups)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", offsets are calculated for the whole \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"durations\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" vector, from the\\n\", class = c(\"TEXT\", \"tag\")), structure(\"first \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"start\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" value.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_arguments\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Borrowing the term from \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"music21\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", rhythmic \\\"offset\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"refers to a duration of time since a starting point (usually, the beginning\\n\", class = c(\"TEXT\", \"tag\")), structure(\"of a piece).\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmOffset\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" takes a vector of numbers representing durations\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(maybe \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"[rhythmInterval][rhythmInterval]s\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\", maybe other\\n\", class = c(\"TEXT\", \"tag\")), structure(\"numeric values) and cummulatively sums them from a starting value.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The output is a vector of durations of the same type as the input\\n\", class = c(\"TEXT\", \"tag\")), structure(\"where each output value corresponds to the duration of time elapsed\\n\", class = c(\"TEXT\", \"tag\")), structure(\"at that point.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Other rhythm analysis tools: \\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"metricPosition\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"()\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"rhythmDecompose\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"()\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythm analysis tools\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_concept\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), romanNumerals.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/diatonicSet.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"romanNumerals\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"romanNumerals\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Roman Numeral\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Roman numerals can be calculated for diatonicSets (keys) and\\n\", class = c(\"TEXT\", \"tag\")), structure(\"for tertian sets (chords).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The later case is the standard meaning of \\\"roman numeral.\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, the former case is used as well, for instance\\n\", class = c(\"TEXT\", \"tag\")), structure(\"to represent modulation schemes in\\n\", class = c(\"TEXT\", \"tag\")), structure(\"analyses of classical music. For instance, modulate from I-V,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the to vi/V.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"More importantly, many \\\"roman numerals\\\" in harmonic analyses\\n\", class = c(\"TEXT\", \"tag\")), structure(\"implicitely combine tertian and diatonic roman numerals:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in \\\"applied\\\" roman numerals.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Given a roman numeral like \\\"V65/V\\\", the \\\"V65\\\" represents a\\n\", class = c(\"TEXT\", \"tag\")), structure(\"chord while the \\\"/V\\\" represents a key.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), struct.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Vector.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"is.struct\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"is.struct(x)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Virtual class to help create atomic-vector-like composite data objects.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" defines a number of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"http://adv-r.had.co.nz/S4.html\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"S4 classes\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" which are, underneath the surface, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Composite_data_type\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"composite data types\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"made up of collections of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"base-R atomic vectors\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:vector\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\", stuck together.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \\\"vectorized\\\" nature of R's atomic types is one of R's key strengths, so in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" we try to A) mostly use the standard atomic types B)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"make all the new types we \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" define act as much like atomic vectors as possible.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"virtual\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" S4 class which serves this purpose: creating composite atomic vectors which act (mostly) like base-R atomic vectors.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"As a \\\"virtual class\\\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s themselves don't really exist as independent objects, but the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" class defines (abstractly) all the necessarry methods to treat a collection of\\n\", class = c(\"TEXT\", \"tag\")), structure(\"atomic vectors as a single vector/matrix-like object---simply make your new subclass \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"inherit\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"and it is all taken care of. (To do this, specify \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"contains = \\\"struct\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" in your call to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"setClass\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"methods:setClass\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Important \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" classes which inherit from \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" include:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"tonalInterval\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"diatonicSet\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"tertianSet\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Be warned, R's S4 object-system is limited in this regard: you can't really define S4 classes that act \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"fully\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" like R atomics, as\\n\", class = c(\"TEXT\", \"tag\")), structure(\"many of their features are hard-coded into R itself and can't be replicated.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The most important limitation of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" that you may encounter is that, though \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" classes work (ok) in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"data.frames\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:data.frame\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"data.tables\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"data.table:data.table\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tibbles\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"tibble:tibble\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" will either not work or give strange behaviors if you put \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s into them.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Slots\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(list( structure(\"dim\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Either \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or a non-negative \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer-vector\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:integer\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"length == 2L\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", representing the number of rows and columns respectively. Dimensions \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"can\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" be zero.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(list( structure(\"rownames\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Either \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or a \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"integer\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:integer\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"/\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:character\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"-vector which is the same length as either\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A) if \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"dim == NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the length of the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" B) if \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"dim != NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the number of rows in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(list( structure(\"colnames\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Either \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (it \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"must\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" be \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" if \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"dim == NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") or a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"integer\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:integer\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"/\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:character\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"-vector of length equal to the number of columns in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_describe\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Behavior\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" subclasses (i.e., classes which inherit from \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") behave very similarly to normal \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"R atomic vectors/matrices\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:vector\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, they do differ in a few respects, mostly in ways that are intended to avoid some of the quirky behaviors of R matrices:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In general, the distinction between dimensionless vectors and dimensioned vectors (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"matrices\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:matrix\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\") is slightly weaker in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"structs\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" than with normal R atomic vectors/matrices.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Most importantly, dimensioned \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s won't drop their dimensions under various common operations (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"c\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:c\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\", etc.), the way base-R matrices do.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In general, it is easier to interact with a multi-column (matrix-)\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" in the same way as a dimensionless (vector-)\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For example, if the struct has dimensions then \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"length(struct) == nrow(struct)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", instead of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"length(matrix) == nrow(matrix) * ncol(matrix)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"---i.e., the \\\"height\\\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"of the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (the number of rows) is its length.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Another big difference is in the behaviors of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"c\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:c\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\": \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"c\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" doesn't always cause \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s to lose their dimensions and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"c\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" can be used to concatinated multi-column \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"or even mixes of dimensionless and dimensioned \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If any \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" arguments to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"c\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" have dimensions, the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s are concatinated via a call to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rbind\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:cbind\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\", with any dimensionless vectors coerced to\\n\", class = c(\"TEXT\", \"tag\")), structure(\"1-column matrices.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Of course, the (resulting) number of columns must all be the same or an error will occur!\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Other differences:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s can have either no dimensions (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"dim(struct) == NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") or two dimensions. Higher dimensional \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s are not supported (yet).\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"rowSums\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"colSums\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will coerce a dimensionless struct to a column matrix.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s always throw an error if you try to index them with a index value that is greater than the length/nrow of the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This is different than atomic vectors, which will pad the vector up to the length of the index you give---a sometimes useful but quirky behavior.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s with two dimensions have a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"cartesian\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" indexing argument.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"cartesian = TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"i\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"j\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" arguments are treated as cartesian coordinates.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(This behavior can be achieved with base R matrices (or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s) by inputing a matrix with two columns.)\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Requirements\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"To work, \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" makes a few assumptions about your class.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Your class must have one or more slots which are vectors, all of which are the same length.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"'s indexing method will cause all of these vectors to be indexed as one.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"When you define a new subclass of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", it will inherit a\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"validObject\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"methods:validObject\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" method which assures that all elements are the same dimension.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, if you are writing your own \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"validObject\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" method (using \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"setValidity\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"methods:validObject\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\")\\n\", class = c(\"TEXT\", \"tag\")), structure(\"you just have to worry specifically about the validity of the information in your slots,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"not that the slots are all the same length.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Initialize\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"An initialize method which automatically makes all slots the same length is predefined\\n\", class = c(\"TEXT\", \"tag\")), structure(\"for \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"structs\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". If you want to make a more specialized \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"initialize\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"methods:new\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" method,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"you can still take advantage of the inherited method by using \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"callNextMethod\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"methods:NextMethod\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" at the\\n\", class = c(\"TEXT\", \"tag\")), structure(\"beginning of your method.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Predefined methods\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The main purpose of the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" virtual class is that it defines many of the basic methods you need to manipulate subclass objects.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Most importantly, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"indexing\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:Extract\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" methods are fully defined (that mimic base-R atomic vector/matrix indexing), as well as\\n\", class = c(\"TEXT\", \"tag\")), structure(\"basic \\\"structural\\\" methods like \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"(col/row)names\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:colnames\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"dim\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:dim\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"length\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:length\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"ncol, nrow\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:nrow\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\", etc.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In addition:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" If you define \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"> and >=\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:Comparison\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"<\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"<=\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will be automatically defined.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" If you define \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.character\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:character\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" for your subclass, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"show\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"methods:show\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"format\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:format\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" methods are automatically defined.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"What's more, default arithmetic methods for addition, subtraction, (scalar-integer) multiplication, and negation (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"-x\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") are defined.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The default addition behavior is that each numeric (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"base::integer\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:integer\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"base::numeric\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:numeric\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\") slot from your subclasses will be added together.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct1 + struct2\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will extract each numeric/integer slot from each \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", add them together and create a new \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" from the result.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"-struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will negate all numeric fields, and subtraction is simply defined as adding the negation.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Since \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"scalar\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" multiplication is defined, two \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s cannot be multiplied, but a struct can be multiplied by an integer (all numeric fields are multiplied by the integer(s)).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If these definitions don't work for your subclass, you'll need to create your own, more specific, method!\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"setClass('mynewsubclass', contains = 'struct', slots = c(X= 'numeric', Y = 'numeric'))\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"test <- new('mynewsubclass', X = 1:10, Y = 10:1)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"# all of these should work:\\n\", class = c(\"RCODE\", \"tag\")), structure(\"test[1:5]\\n\", class = c(\"RCODE\", \"tag\")), structure(\"rev(test) == test\\n\", class = c(\"RCODE\", \"tag\")), structure(\"cbind(test, test)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"c(test, test)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"test * 3\\n\", class = c(\"RCODE\", \"tag\")), structure(\"test - test\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_examples\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Examples of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" subclasses: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tertianSet\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), tertianSet.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/tertianSet.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tertianSet\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tertianSet\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tset\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"is.tertianSet\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Tertian set\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"tertianSet(...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"tset(\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" root = 0L,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" signature = 0L,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" alterations = 0L,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" cardinality = 3L,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" extension = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" inversion = 0L\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"is.tertianSet(x)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tertianSet\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is one of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR's\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumR\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"types of tonal data, representing Western tertian harmonies.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tertianSet\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is a subclass of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (and thence, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The only structural addition, compared to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", is the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Extensions\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" slot.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This slot indicates which tertian chord members are active in the chord.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"There are seven possible chord members:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the root, third, fifth, seventh, ninth, eleventh, and thirteenth.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Every possible combination of these seven degrees is represented by a single integer, corresponding\\n\", class = c(\"TEXT\", \"tag\")), structure(\"to the 7-bit representation of on/offs on the seven degrees in reverse order (13, 11, 9, 7, 5, 3, 1).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For example, the integer \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"15\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" corresponds to a seventh chord: in binary, 15 is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"0001111\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The initial three zeros indicate that the 13th, 11th, and 9th are \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"not\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" part of the harmony, while the four ones\\n\", class = c(\"TEXT\", \"tag\")), structure(\"indicate that the root, third, fifth, and seventh \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"are\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" part of the harmony.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Ultimately, adding or removing a chord degree from a harmony can be achieved by adding the power of\\n\", class = c(\"TEXT\", \"tag\")), structure(\"two associated with that degree:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Root\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\": \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"\\\\pm 1\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(), class = c(\"tag_item\", \"tag\" )), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Third\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\": \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"\\\\pm 2\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Fifth\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\": \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"\\\\pm 4\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Seventh\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\": \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"\\\\pm 8\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Ninth\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\": \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"\\\\pm 16\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Eleventh\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\": \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"\\\\pm 32\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Thirteenth\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\": \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"\\\\pm 64\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tertianSet\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" has many specific methods defined for reading/writing harmonic information.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"diatonicSet humTonality\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), time.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/rhythmInterval.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"time\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"time\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"bpm2ms\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"ms2bpm\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Time transformations\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"bpm2ms(bpm)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"ms2bpm(ms)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Time transformations\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), tonalInterval.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/tonalInterval.R, R/rhythmInterval.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tint\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"is.tonalInterval\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval.tonalInterval\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval.logical\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval.NULL\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval.numeric\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval.rational\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval.fraction\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval.integer\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval.character\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"rhythmInterval.rhythmInterval\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Representation of tonal pitch information\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"tonalInterval(...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"tint(\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" octave,\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" LO5th = 0L,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" cent = numeric(length(octave)),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" partition = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" Key = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" roundContour = floor\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"is.tonalInterval(x)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"tonalInterval(...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"tonalInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"tonalInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"tonalInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"logical\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"tonalInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"`NULL`\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"tonalInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"numeric\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(\\n\", class = c(\"RCODE\", \"tag\" )), structure(\" x,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" tonalHarmonic = 3,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" centMargin = 10,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" accidental.melodic = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" ...\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"tonalInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"rational\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x, tonalHarmonic = 3, accidental.melodic = FALSE, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"tonalInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"fraction\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x, tonalHarmonic = 3)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"tonalInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"integer\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(n, accidental.melodic = FALSE, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"tonalInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"character\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(str, Exclusive = NULL, ..., multiDispatch = FALSE)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(list(structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"rhythmInterval\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_method\", \"tag\")), structure(\"(x, ...)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is the core tonal pitch representation in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrumR\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is an abstract representation of tonal pitch, which can be translated to/from all standard \\\"concrete\\\" pitch representations:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"solfege, scientific pitch, semitones, frequencies, scale degrees, intervals, etc.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For the most part, users should not need to interact with \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s directly---rather, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s work behind the scene in numerous \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" pitch functions.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"See the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pitchRepresentations\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalTransformations\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" documentation for details of usage and functionality or the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Tonality in humdrumR\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" vignette for\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a detailed explanation of the theory and specifics of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"http://adv-r.had.co.nz/S4.html\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"S4\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" subclass of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"'s virtual class \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\", from which it inherits a lot of useful \\\"vector-like\\\" behaviors/functionality.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The constructor function \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tint\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" can be used to create \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalIntervals\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" directly.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The three arguments corespond to the three slots: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"octave\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"LO5th\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (Fifth), and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"cent\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"All inputs will be coerced to match in length.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"What's more, the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"octave\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument can be left blank, in which case the appropriate octave will automatically be computed\\n\", class = c(\"TEXT\", \"tag\")), structure(\"to place the interval in the octave above middle-C.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"By default, the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as.character\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:character\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" method, and thus (via \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"struct\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\") the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"show\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"methods:show\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" method, for \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"kern()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=pitchRepresentations\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Thus, if you return a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" on the command line (or call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"print\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:print\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" one one) you'll see the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"kern pitch\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=pitchRepresentations\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" representation printed.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Slots\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(list( structure(\"Octave\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"integers representing the octave offset.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(list( structure(\"Fifth\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"integers representing the \\\"line-of-fifths\\\" value.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(list( structure(\"Cent\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"numeric values representing cents (1200th of an octave).\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_describe\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Arithmetic\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Technically, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s are examples of algebraic \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Module_(mathematics)\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"modules over integers\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This means that certain arithmetic operations are defined for \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalIntervals\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and can be called using standard arithmetic operators (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"+\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"-\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", etc.):\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Addition: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalIntervals\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" can be added together, acting exactly as you'd expect (i.e., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"M3 + m3 = P5\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Subtraction: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalIntervals\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" can be subtracted just as they are added. Also, they can be negated with a single \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"-\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"operator (like \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"-M3\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Multiplication: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s can \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"not\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" be multiplied together.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Scalar_multiplication\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"scalar (integer) multiplication\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" is defined:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"thus, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalIntervals\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" can be multiplied by integers to create new \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s: e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"M2 * 3L = A4\", class = c(\"VERB\", \"tag\"))), class = \"tag\")), class = c(\"tag_eqn\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Division: as the natural inverse of scale multiplication, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Euclidean_division\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Euclidean division\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"is defined for \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalIntervals\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"---i.e., division by/into whole (integer) pieces, often with leftover \\\"remainders\\\" (modulo).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In R, Euclidean division is achieved with the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%/%\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:Arithmetic\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" operator---\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"not\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"/\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"---, with the associated \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"%%\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:Arithmetic\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" used for the remainder/modulo.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Two \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s can be divided to produced an integer; Conversely, a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" can be divided by an integer to produce a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Take note that the way \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" defines Euclidean division is based in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonal space\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\"---i.e., the line-of-fifths---not frequency or atonal-semitone space.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For example, an augmented-fourth divided by a major-second \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"is\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"3L\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", but a diminished-fifth divided by a major-second is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"not\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" 3L---\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"d5 %/% M2\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" equals \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"-3L\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" with a remainder of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"P8\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (plus an octave)!\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The division algorithm works by applying standard Euclidean division to the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"@Fifth\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" slot (line-of-fifths tonal space), and shifting the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"@Octave\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" value in\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the remainder to the match the appropriate octave.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This definition has the useful properties that \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"specificinterval %% A1 = genericinterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"interval %% d2 = enharmonicinterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Since basic data types can be parsed into \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (see below), \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will attempt to automatically \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Type_conversion\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"coerce\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"data to tonalIntervals when asked to perform arithmetic.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This means that arithmetic can be applied when one of the two arguments is a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and the other is a coercable atomic.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For instance, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"M3 + 2L\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will interpret \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"2L\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" as two semitones and add a major-second to the major-third!\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The clever \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"dispatch system\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=regexDispatch\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" will even ignore character strings that are not recognized (see examples)!\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This is useful when combined with the \\\"Predifined Intervals\\\" (like \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"M3\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"), described below.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Relational Operators\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s can be compared using the standard \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"relational operations\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:Comparison\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"---\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"==\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"!=\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\">\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\">=\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", etc.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Two \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s are equal (according to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"==\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") only if all their slots (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Octave\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Fifth\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Cent\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\")\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are exactly identical.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, enharmonic notes (like C# and Db) are \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"not\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" equal.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In contrast, ordinal comparisons (e.g., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\">\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"<=\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") between \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s are based on their semitone (equal temperament) size, so enharmonicity is irrelevant.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"m3 >= A2\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"A2 >= m3\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" are both \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", even though \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"m3 == A2\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is not.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Predefined Intervals:\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" automatically exports a bunch of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s, named by their musical interval representation.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Every generic interval from 1 to 15 is combined with every interval quality \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"dd\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (doubly diminished), \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"d\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (diminished), \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"m\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (minor), \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"M\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (major), \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"A\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (augumented)\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"AA\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (doubly augmented).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, after loading \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", you can type things like \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"M3 + M3\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and get \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"A5\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In addition, the variables \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"unison\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"= P1 = tint(0, 0)\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"), \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pythagorean.comma\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"= d2 = tint(-19,12)\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"), and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"octave\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tint(1, 0)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") are exported as well.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Parsing\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" includes a easy-to-use but powerful system for parsing pitch information into the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" representation.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Basic methods are defined for numeric values representing atonal pitch information:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"integer\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:integer\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" values are interpreted as semitones. Watch out! In R, you need to append an \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"L\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" to a number to make it an explicit integer:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For example, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval(3L)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"numeric\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"base:numeric\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"/\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(list(structure(\"decimal()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=decimal\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"rational()\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=rational\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" values are interpreted as frequency ratios, assuming a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Pythagorean_tuning\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Pythagorean tuning\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For example, the value \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"2.0\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will be interpreted as an octave (two to one ratio.)\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, the most useful tool for humdrum data is parsing pitch representations encoded in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" tokens.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" regex/exclusive parsing system is used to interpret character strings as tonalIntervals.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This includes character tokens with pitch information embedded alongside other information, like \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"4.ee\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" in a kern token.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"There are six regex-patterns that \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" known how to parse automatically:\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"lcr\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\" Representation \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_tab\", \"tag\")), structure(\" Exclusive \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_tab\", \"tag\")), structure(\" Example \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_cr\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\" Kern \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_tab\", \"tag\")), structure(\" **kern \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_tab\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"ee-\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_cr\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Scientific_pitch\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Scientific Pitch\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(), class = c(\"tag_tab\", \"tag\")), structure(\" **pitch \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_tab\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Eb5\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_cr\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\" Interval \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_tab\", \"tag\")), structure(\" **hint/**mint/**int \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_tab\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"+m3\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_cr\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\" Scale degree \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_tab\", \"tag\")), structure(\" **deg \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_tab\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"b3\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_cr\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\" Solfege \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_tab\", \"tag\")), structure(\" **solfa \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_tab\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"me\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_cr\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://lilypond.org/doc/v2.22/Documentation/notation/pitches\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Lilypond pitch\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(), class = c(\"tag_tab\", \"tag\")), structure(\" none \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_tab\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"ees'\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_cr\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_tabular\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If you call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"any function that uses tonalInterval as a parser\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=pitch\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\") on a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"character\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" string,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the regex-system will automatically (attempt) to interpret the tokens as on the pitch types above---if there is a conflict\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the representations are favored in the order they are presented in the table above.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If a matching exclusive interpretation (see table above) is provided using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Exclusive\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"this choice overrides the regex-dispatch.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If there is no match, an NA \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is returned.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Parsing with Options\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The six tonal representations listed above function through a common parsing interface.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"M3 <- tint( , 4L)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"M2 <- tint( , 2L)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"M9 <- tint(-1L, 2L)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"M9 - M2 \\n\", class = c(\"RCODE\", \"tag\")), structure(\"# = octave\\n\", class = c(\"RCODE\", \"tag\")), structure(\"M9 - 2L\\n\", class = c(\"RCODE\", \"tag\")), structure(\"# = octave\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"M3 %/% M2 \\n\", class = c(\"RCODE\", \"tag\")), structure(\"# = 2\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"###\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"cMajor <- sort(tint( , -1:5))\\n\", class = c(\"RCODE\", \"tag\")), structure(\"eMajor <- cMajor + M3\\n\", class = c(\"RCODE\", \"tag\")), structure(\"eMajor + 2L \\n\", class = c(\"RCODE\", \"tag\")), structure(\"# f# g# a# b cc# dd# ee#\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"eMajor[4:5] - octave \\n\", class = c(\"RCODE\", \"tag\")), structure(\"# = A B\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\\"4.ee\\\" + P5 \\n\", class = c(\"RCODE\", \"tag\")), structure(\"# = \\\"4.bb\\\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_examples\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Other \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"core pitch representation\", class = c(\"TEXT\", \"tag\"))), class = c(\"LIST\", \"tag\")), structure(\": \\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"LO5th\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"()\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"core pitch representation\", class = c(\"TEXT\", \"tag\"))), class = c(\"LIST\", \"tag\"))), class = c(\"tag_concept\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), tonalTransformations.Rd = structure(list(structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/tonalInterval.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"tonalTransformations\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalTransformations\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"invert\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Invert or transpose tonal intervals.\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"invert(tint, around, Key, ...)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Invert or transpose tonal intervals.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), transpose.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/tonalInterval.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"transpose\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"transpose\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Transpose pitches and keys\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"transpose(x, by, Key, to, real, relative, ...)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"x\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"The input pitch(es) to transpose. A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or something intepretable as a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"by\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or something intepretable as a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The input \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"x\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is transposed by this interval.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Key\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or something intepretable as a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". For tonal and/or to transpositions,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"this is the \\\"from\\\" key. If this value is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", it defaults to C major.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"to\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or something intepretable as a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". The input \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"x\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is transposed\\n\", class = c(\"TEXT\", \"tag\")), structure(\"to this key.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"real\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A logical. If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (the default), transposition is real. If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", transposition is tonal.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"relative\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A logical. If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" transposition is relative. If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (the default), transposition is parallel.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_arguments\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This function \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"transposes\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=https://en.wikipedia.org/wiki/Transposition_(music)\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" pitches or keys\\n\", class = c(\"TEXT\", \"tag\")), structure(\"by various intervals or to target keys.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Inside the box, inputs and transpositions take place as \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"diatonicSet\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"s,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"but any numeric or character string representation of pitches can be transposed as well.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This function is incorporated directly into \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalTransform\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\", and thence, all \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pitch translation\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=pitchRepresentations\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"functions, so you probably won't call it directly very often.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"There are two distinct types of transposition (real and tonal).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"There are also two different approaches to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"specifying\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" transpositions: \\\"to\\\" and \\\"by\\\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\\"To\\\" transpositions can also be either \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"parallel\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"relative\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_details\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Types of Transposition\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"There are two different types of transposition: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"real\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" transposition and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonal\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\" transposition.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"real\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" transposition, all inputs are transposed by the same \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"specific\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" interval.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For example, the pitches \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{C D E F G}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" could be transposed up a major second to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{C D E F# G}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"tonal\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" transposition, inputs are transposed by \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"generic\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" intervals, within a key.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For example, the sequence \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{C D E F G}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\", in the key of C major, could be translated up a generic second\\n\", class = c(\"TEXT\", \"tag\")), structure(\"to \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"{D E F G A}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"To choose between real and tonal transposition, use the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"real\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"real = TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" for real transposition, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"real = FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" for tonal transposition.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Alterations\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Tonal transposition is complicated by the presence of any alterations in the input pitches.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For instance, if we are given the pitches \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{C F# G D# E}`` in the key of C major, how should they by tonally transposed up a second, within C major? There is not one obvious, correct answer answer, which can be easily identified. The algorithm implemented by \", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"humdrumR` is as follows:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Alterations/accidentals in the input are identified. (In this case, F# and D#).\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" The generic pitches are transposed within the key, resulting in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{D G A E F}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Alterations in the input are added to the output \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"unless\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" the resulting pitches are interpreted as a comma\\n\", class = c(\"TEXT\", \"tag\")), structure(\"by a call to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tintPartion\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\", with a given enharmonic wrap value (the default is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"12\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In this example, adding the first accidental results in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{G#}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" which is not a comma.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, the second accidental results in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{E#}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" which \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"is\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" a comma away from the natural \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{F}\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, this accidental is not added to the output, resulting in \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{E}\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", not \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{E#}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The resulting output is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{D G# A E F}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_enumerate\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The size of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"enharmonicWrap\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" effectively determines how extreme accidentals are allowed.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The default value, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"12\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", assures that no output notes are enharmonically equivalent to notes in the key.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"To further illustrate, here is the sequence \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{C F# G D# E, B- A A- G C# D, B D- C}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" transposed\\n\", class = c(\"TEXT\", \"tag\")), structure(\"tonally within C major by all seven possible generic intervals, with \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"enharmonicWrap = 12\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\":\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Specifying Transpositions\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"There are two approaches to specifying transpositions, the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" arguments.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument must be an interval, and the input is translated by that interval.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" interval is specific but \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"real = FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the input is treated as a generic interval,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"and tranposition takes place within the key indicated by the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Key\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"The \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"to\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument translates an input \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" a desired key.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For example, if the input is in the key of E major but we want it transposed to G major, we could say \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to = '*E:'\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"real = TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", input is simply translated to the root of the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" key, with all the exact same intervals.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"real = FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the input is translated to the root of the new key, with its intervals changed to match the new key as well.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In either case, the result depends on what the input's key is, which is indicated by the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"standard\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=tonalTransform\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Key\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Key\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" arguments is like the \\\"from\\\" key.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"Key = NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the input key is interpreted as C major.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Consider the input notes \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{D B C A# B, D C# D E D}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" in the key of the G major.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If we specify \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to = e:, real = TRUE\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\", the output will be \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{B G# A F## G#, B A# B C# B}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(Notice that even though the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" key is minor, the output is still clearly in E major).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If we specify \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to = e:, real = FALSE\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\", the output will instead be \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{B G A F# G, B A# B C B}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Building off the previous example, consider how the input \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"key\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" matters as well.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If we use the same input notes (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{D B C A# B, D C# D E D}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\") but the input \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Key\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is C major, then:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If we specify \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to = e:, real = TRUE\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\", the output will be \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{F# D# E C## D#, F# E# F# G# F#}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If we specify \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to = e:, real = FALSE\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\", the output will instead be \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"{F# D E C# D, F# E F# G F#}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"both\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" are specified, the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" transposition is applied first, followed by the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" transposition.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"real = FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" transposition happens within the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" key, not the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Key\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" key.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Relative vs Parallel\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"When transposing to, we have diferent approaches about to determining the relationship between the\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\\"from\\\" key (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Key\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument) and the \\\"to\\\" key (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If we think of \\\"parallel\\\" relationships between keys, we match the roots of the keys regardless of modes.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For instance, C major and C minor are parallel keys.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If we instead think of \\\"relative\\\" relationships between keys, we match the modes of the keys, not the roots.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For instance, C major and A minor are relative keys.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This is similar to the distinction between \\\"la-based minor\\\" solfege (relative) vs \\\"fixed-do\\\" solfege (parallel).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"When transposing using a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument, if \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"relative = FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" the input key (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Key\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument) is transposed to match the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"root\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"of the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For example, if the input key is G minor and the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"to`` key is C major, the output is transposed to G minor. However, if \", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"relative = TRUE\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"the input key is transposed to match the mode of the\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"to\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"key: A G minor input with a C major\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"to\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"would be translated to A minor, the parallel minor of the\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"to\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"key. If the\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"Key\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"(from key) and\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"to` (to key) arguments have the same mode, the parallel and relative transpositions\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are the same.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_subsection\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Special Operators +-\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"As a note, real transposition \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and interval can be achieved more concisely using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"+\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"-\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" operators,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"as long as at least one side of the operators is an actual \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"tonalInterval\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" preassigns all common tonalIntervals to objects in your global environment.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus, you can type commands like \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"c#\\\" + M2\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" to get \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"d#\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"c(\\\"C4\\\", \\\"E4\\\", \\\"C5\\\") - m6\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" to get \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"E3\\\" \\\"G#3\\\" \\\"E4\\\"\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"tonalTransformations\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_seealso\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), withinHumdrum.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Apply.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withHumdrum\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"inHumdrum\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humApply\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"with(in)Humdrum\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"withinHumdrum(humdrumR, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"withHumdrum(humdrumR, ..., drop = TRUE)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"inHumdrum(humdrumR, ...)\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"humApply(humdrumR, FUN, ..., within = TRUE, doplot = FALSE)\\n\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"humdrumR\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumRclass\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\" data object.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"...\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Any arguments which can be fed to\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humdrumR:with-in-Humdrum][with(in)Humdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" as formulae (except for\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expressions, which are replaced by the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"FUN\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument!).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, rather that writinging formula in the format \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Keyword ~ Expression\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humApply\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" arguments should be written as normal \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"R\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" arguments:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Keyword = Expression\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Unnamed arguments are ignored.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"#' @param within A logical. If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (the default),\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humdrumR:with-in-Humdrum][withinHumdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" is used to apply the\\n\", class = c(\"TEXT\", \"tag\")), structure(\"function---meaning that the output is reconstituted into a new field in the\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" object. If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"within == FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humdrumR:with-in-Humdrum][withHumdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" is used instead,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"which results in the function's output being returned inprocessed.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"drop\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"This argument is concetually similar to the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"drop\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument in R matrices and data.frames.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"drop = TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the output of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is simplified as much as possible (trying to return\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the \\\"raw\\\" vector, list, table, etc. within it). If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"drop = FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the result is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"always\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"data.table\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". The default value (\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"drop = TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") is usually what we want because it is more\\n\", class = c(\"TEXT\", \"tag\")), structure(\"intuitive, but in more complex code, it can be helpful to set \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"drop = FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" so that\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the output is consistent.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"FUN\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"A function to apply to the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR:humdrumR\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=Active\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(list(structure(\"field(s) in the\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"humdrumR` object.\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"doplot\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"Boolean. If \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"FUN\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument is treated\\n\", class = c(\"TEXT\", \"tag\")), structure(\"as a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"doplot\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression by \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humdrumR:with-in-Humdrum][with(in)Humdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(\"so the result is ignored (for plotting or side-effects purposes).\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_item\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = c(\"tag_arguments\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"From \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"inHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", a new humdrumR data object.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"From \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"withHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", whatever value is returned by expression.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_value\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Apply arbitrary expressions to fields within \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[S4class][humdrumRclass]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" data.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"Overview\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"These functions are the primary means of working with\\n\", class = c(\"TEXT\", \"tag\")), structure(\"humdrumR data. (They are analogous to the base functions\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[base][with]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[base][within]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"as applied to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[base:data.frame][data.frames]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Specifically they allow you to evaluate arbitrary\\n\", class = c(\"TEXT\", \"tag\")), structure(\"expressions involving fields in a humdrumR data object.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"They also includes a number of special evaluation options:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Evaluate an expression in only matching parts of the data.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Evaluate an expression separately in subsets of the data.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Evaluate an expression across windows in the data (e.g., ngrams, rolling windows).\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" Evaluate an expression which produces a plot, with particular plotting parameters set using \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[graphics][par]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_itemize\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"The difference between \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is\\n\", class = c(\"TEXT\", \"tag\")), structure(\"analogous to the difference between \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[base][with]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[base][within]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" evaluates your expression(s) and then simply returns the result of\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the evaluation. \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" evaluates your expression(s) and then\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(attempts) to insert the results back into the humdrumR object, generating new\\n\", class = c(\"TEXT\", \"tag\")), structure(\"fields called \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"PipeX\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (see details).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"inHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is simply a short hand for \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(list(structure(\"Formulae\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Every formula in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"formulae\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument\\n\", class = c(\"TEXT\", \"tag\")), structure(\"is treated as a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Keyword ~ Expression(s)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"pairing. Multiple expressions can be input using multiple \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"~\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" operators:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Keyword ~ Expression1 [~ Expression2 ~ ... ~ ExpressionN]\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(the leftmost expression is treated as the keyword.)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If there is no leftmost expression (i.e., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"~ Expression\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"), the Keyword\\n\", class = c(\"TEXT\", \"tag\")), structure(\"defaults to \\\"\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\\" The keyword expression must be a single, simple name/symbol, following\\n\", class = c(\"TEXT\", \"tag\")), structure(\"standard R rules (i.e., \\\"\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\".foobar\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\\" is acceptable but \\\"\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"3 + foobar\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\\" is not).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"Legal keywords, and their meanings are:\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" An expression to be evaluated within the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data object (see \\\"Expression evaluation\\\").\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"doplot\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" An expression to be evaluated within the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data object while ignoring the result of the expression (see \\\"Expression evaluation\\\" and \\\"Plotting\\\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" An expression used to break the data into groups, with the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression(s) evaluated\\n\", class = c(\"TEXT\", \"tag\")), structure(\"separately in each group (see \\\"Partitioning\\\").\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"where\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" An expression indicating a subset of the data in which to evaluate the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression (see \\\"Partitioning\\\").\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"ngrams\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" A positive number \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\". The expression is evaluated across overlapping length-\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" windows.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"recordtypes\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" A string or vector of characters drawn from \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"c(\\\"D\\\", \\\"d\\\", \\\"I\\\", \\\"L\\\", \\\"M\\\",\\\"G\\\")\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". These characters\\n\", class = c(\"TEXT\", \"tag\")), structure(\"correspond to types of humdrum records: \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"D\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\"ata, null \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"d\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\"ata, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"I\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\"nterpretations,\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"M\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\"easures, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"L\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\"ocal comments, and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"G\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_strong\", \"tag\")), structure(\"lobal comments respectively. The expression\\n\", class = c(\"TEXT\", \"tag\")), structure(\"is only evaluated on data drawn from the specified record types (defaults to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\\"D\\\"\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\").\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"pre\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" An expression to evaluate once before evaluating the do expression(s). Useful, for instance, for taking logs\\n\", class = c(\"TEXT\", \"tag\")), structure(\"or opening a graphing window. The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"pre\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression is evaluated in the global environment.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(), class = c(\"tag_item\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"post\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" An expression evaluate once after evaluating the do expression(s). Always evaluated in the global environment.\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_enumerate\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Expression evaluation\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The right-hand side of any formula in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"formulae\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument with the keyword \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"doplot\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(or with no keyword specified) is evaluated within the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data object.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The expression can, thus, refer to any field in the humdrumR object (Record, Token, File, etc.).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"You can also include a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\".\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" anywhere in the expression, which will be\\n\", class = c(\"TEXT\", \"tag\")), structure(\"interpreted as the humdrumR object's current \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[dest=humdrumR][Active]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"expression.\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdata <- readHumdrum('directorywithdata/*.krn') # read some data\\n\", class = c(\"VERB\", \"tag\")), structure(\"\\n\", class = c(\"VERB\", \"tag\")), structure(\"withinHumdrum(humdata, ~getPitch(Token)) # The most basic pattern\\n\", class = c(\"VERB\", \"tag\")), structure(\"withinHumdrum(humdata, ~getPitch(.)) # Same as previous (unless `Active` field has been changed))\\n\", class = c(\"VERB\", \"tag\")), structure(\"\\n\", class = c(\"VERB\", \"tag\")), structure(\"withinHumdrum(humdata, ~solfa(getPitch(Token), key = Key)) \\n\", class = c(\"VERB\", \"tag\")), structure(\"# Assumes that the Key field was parsed during the call to `[readHumdrum][readHumdrum]`\\n\", class = c(\"VERB\", \"tag\")), structure(\"\\n\", class = c(\"VERB\", \"tag\")), structure(\"withinHumdrum(humdata, ~getSemits(Token) - mean(getSemits(Token))) \\n\", class = c(\"VERB\", \"tag\")), structure(\"\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"If multiple \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expressions are provided, they are each evaluated one at a time,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"with the result of each piped into the next. Other, non-\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", formulae (like \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by~\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" or\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"ngrams~\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\") are reused for each expression evaluated.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Partitioning\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression is used to break the data into subsets, with the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression(s) evaluated\\n\", class = c(\"TEXT\", \"tag\")), structure(\"separately within each subset. This works the similarly to the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument in\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[data.table][data.table]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"s, the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"INDEX\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"argument of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[base][tapply]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\", or the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"INDICES\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[base][by]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Each \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression must evaluate, within the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data object, to a vector (or a list of vectors\\n\", class = c(\"TEXT\", \"tag\")), structure(\"of equal length) of categories to group the data by.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Most commonly, the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression(s) are simply field(s) in the data:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"for instance,\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum(humdata,\\n\", class = c(\"VERB\", \"tag\")), structure(\" do ~ table(Token),\\n\", class = c(\"VERB\", \"tag\")), structure(\" by ~ File)\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"will apply the function \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[base][table]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" to the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Token\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"separately\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" for each file in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"However, we can also use more complex expressions like\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum(humdata,\\n\", class = c(\"VERB\", \"tag\")), structure(\" do ~ table(Token), \\n\", class = c(\"VERB\", \"tag\")), structure(\" by ~ Spine > 3 | Record \\\\%\\\\% 2 == 0)\\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"which will evaluate the do expression in two groups, one where either the spine number is\\n\", class = c(\"TEXT\", \"tag\")), structure(\"three or less \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"or\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" the record number is even, and another group where the opposite is true.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression evaluates to a list of grouping vectors,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expressions are evaulated across every combination of categories in all the vectors.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"withinHumdrum(humdata,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"do ~ table(Token),\\n\", class = c(\"TEXT\", \"tag\")), structure(\"by ~ list(File, Spine))\\n\", class = c(\"TEXT\", \"tag\")), structure(\"will apply \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"table\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Token\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" across each spine \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"in\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" each file.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"As some \", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Syntactic_sugarsyntactic\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"syntactic sugar\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\", if the\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression has more than two parts, all parts except\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the (leftmost) keyword part are combined in a list (i.e., \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by ~ File ~ Spine\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"becomes \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by ~ list(File, Spine)}\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Thus the previous example can also be written:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"withinHumdrum(humdata,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"do ~ table(Token),\\n\", class = c(\"TEXT\", \"tag\")), structure(\"by ~ File ~ Spine)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"A \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"where\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression is used to identify a subset of the data and evaluate\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression(s) \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"only\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" in that subset.\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"where\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expressions must evaluated, within the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data object, to\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a single logical vector. The \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression(s) are only evaluated where this logical\\n\", class = c(\"TEXT\", \"tag\")), structure(\"vector is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"TRUE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Wherever the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"where\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression evaluates to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"FALSE\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the original \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data is\\n\", class = c(\"TEXT\", \"tag\")), structure(\"kept unchanged.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If multiple partitioning formulae (i.e, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"where\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\") expressions\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are evaluated recursively, in order from left to right. Thus if you specify\\n\", class = c(\"TEXT\", \"tag\")), structure(\"withinHumdrum(humdata,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"do ~ sd(semits),\\n\", class = c(\"TEXT\", \"tag\")), structure(\"by ~ File,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"where ~ semits > mean(semits))\\n\", class = c(\"TEXT\", \"tag\")), structure(\"a the standard deviation of the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"semits\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field will be calculated only in each file,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"but only where the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"semits\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field is greater than the mean \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"semits\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" value\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"within that file\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\". Contrast this with this call:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"withinHumdrum(humdata,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"do ~ sd(semits)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"where ~ semits > mean(semits),\\n\", class = c(\"TEXT\", \"tag\")), structure(\"by ~ File)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"wherein the standard deviation of \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"semits\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is, again, calculated for each file,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"but this time wherever the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"semits\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field is greater than the mean value \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"across all the data\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Plotting\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"The \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"doplot\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" keyword behaves exactly like the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" keyword, except that the result of the\\n\", class = c(\"TEXT\", \"tag\")), structure(\"evaluation is ignored. This is useful for plotting \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"as well as\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" other side-effects (like writing to a file).\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"doplot\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is used with \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the function simply returns \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"NULL\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (after executing the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"doplot\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"expression\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"doplot\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is used with \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (or \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"inHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"), the function simply returns the unaltered\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" also allows you to specify plotting options in line, without having to make a separate call\\n\", class = c(\"TEXT\", \"tag\")), structure(\"to \", class = c(\"TEXT\", \"tag\" )), structure(list(structure(\"[graphics][par]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\". Any \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[graphics][par]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" argument can be specified as a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Keyword ~ Expression\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" pair\\n\", class = c(\"TEXT\", \"tag\")), structure(\"in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"formulae\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" argument. For instance, if you call a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"doplot\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression with a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"by\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression\\n\", class = c(\"TEXT\", \"tag\")), structure(\"that creates four groups, R will create four plots---but you will only see the last one! Normally, you would need to\\n\", class = c(\"TEXT\", \"tag\")), structure(\"call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"par(mfcol = c(2,2))\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"before\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_emph\", \"tag\")), structure(\" calling your plotting function. However, with \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" you can\\n\", class = c(\"TEXT\", \"tag\")), structure(\"soecific \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"mfcol = c(2,2)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" right in a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"formulae\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" formula:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"withinHumdrum(humdata,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"doplot ~ fooplot(.),\\n\", class = c(\"TEXT\", \"tag\")), structure(\"by ~ list(Two, byTwo),\\n\", class = c(\"TEXT\", \"tag\")), structure(\"mfcol ~ c(2, 2))\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The best part is \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will reset \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"par\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" to it's previous state after \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" is done.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Tandem interpretations\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"The function \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[readHumdrum][readHumdrum]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" automatically parses\\n\", class = c(\"TEXT\", \"tag\")), structure(\"tandem interpretations (that it recognizes) into\\n\", class = c(\"TEXT\", \"tag\")), structure(\"their own fields in the resulting \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humdrumR][humdrumRclass]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" data.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For instance, data with a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"'*clefF4'\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will show\\n\", class = c(\"TEXT\", \"tag\")), structure(\"up as a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Clef\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field. However, users might read humdrum data with their\\n\", class = c(\"TEXT\", \"tag\")), structure(\"own custom tandem interpretations that are not built into \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" includes the function \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[getTandem][getTandem]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" to help us\\n\", class = c(\"TEXT\", \"tag\")), structure(\"extract arbitrary tandem intrpretation data.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Luckily, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" knows some\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Syntactic_sugarsyntactic\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"syntactic sugar\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"which makes it easy to do this anywhere in our expressions, simply by putting a\\n\", class = c(\"TEXT\", \"tag\")), structure(\"named object beginning with the symbol \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"*\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\". Of course, R doesn't normally\\n\", class = c(\"TEXT\", \"tag\")), structure(\"allow names to begin with symbols like \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"*\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", but you can force it by\\n\", class = c(\"TEXT\", \"tag\")), structure(\"placing grave symbols around the name \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"*name\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\". If you do this in a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"expression, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will treat this name as a\\n\", class = c(\"TEXT\", \"tag\")), structure(\"regular expression and substitute a call \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"getTandem(Tandem, 'regular expression')\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" in the expression.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"This means you can could do something like\\n\", class = c(\"TEXT\", \"tag\")), structure(\"withinHumdrum(humdata,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"do ~ myFunction(Token, \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"*mytandempattern\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\"))\\n\", class = c(\"TEXT\", \"tag\")), structure(\"and \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"myFunction\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will be called with the first argument being the\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Token\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field, and the second argument being tandem interpretations\\n\", class = c(\"TEXT\", \"tag\")), structure(\"which match \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"'mytandempattern'\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" (extracted from the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Tandem\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" field).\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Splatting\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"(\\\"Splatting\\\" refers to feeding a function a list/vector of arguments.)\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Sometimes we want to divide our data into pieces (a l\\\\'a \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"partition\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" option), but\\n\", class = c(\"TEXT\", \"tag\")), structure(\"rather than applying the same expression to each piece, we want to feed\\n\", class = c(\"TEXT\", \"tag\")), structure(\"the separate pieces as separate arguments to the same function.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"In \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" you can use some\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(list(structure(\"https://en.wikipedia.org/wiki/Syntactic_sugarsyntactic\", class = c(\"VERB\", \"tag\"))), class = \"tag\"), structure(list(structure(\"syntactic sugar\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_href\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"to do just this, using the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"@\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" symbol in the format \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"myFunction(TargetExpr@GroupingExpr)\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\".\\n\", class = c(\"TEXT\", \"tag\")), structure(\"If we make this call\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"withinHumdrum(humdata,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"do ~ myFunction(Token@Spine))\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"and there are four spines\\n\", class = c(\"TEXT\", \"tag\")), structure(\"this is how \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" will intepret the expression:\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"withinHumdrum(humData,\\n\", class = c(\"TEXT\", \"tag\")), structure(\"do ~ myFunction(Token\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Spine == 1\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\", # first argument when Spine == 1\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Token\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Spine == 2\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\", # second argument when Spine == 2\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Token\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Spine == 3\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\", # etc.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Token\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Spine == 4\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_link\", \"tag\")), structure(\"))\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Argument interpolation\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Any named arguments to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" are \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humdrumR:interpolateArguments][interpolated]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\" into the\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expressions. This is useful if you've already created a list of formulas that you like, but would like\\n\", class = c(\"TEXT\", \"tag\")), structure(\"to make small changes to a function call within the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expressions, without starting from scratch.\\n\", class = c(\"TEXT\", \"tag\")), structure(\"Examples:\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"mycommand <- c(do ~ mean(., na.rm = TRUE), by ~ Spine ~ File)\\n\", class = c(\"VERB\", \"tag\")), structure(\"withinHumdrum(humdata,\\n\", class = c(\"VERB\", \"tag\")), structure(\" mycommand,\\n\", class = c(\"VERB\", \"tag\")), structure(\" na.rm = FALSE)\\n\", class = c(\"VERB\", \"tag\")), structure(\"# mycommand is executed with na.rm changed to FALSE \\n\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_preformatted\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\" ))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(list(structure(\"Piping\", class = c(\"TEXT\", \"tag\"))), class = \"tag\"), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\" )), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"For calls to \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"withinHumdrum\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the result of each \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"do\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" expression\\n\", class = c(\"TEXT\", \"tag\")), structure(\"is insterted back into the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"[humtable][humdrum table]\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_verb\", \"tag\")), structure(\". The results\\n\", class = c(\"TEXT\", \"tag\")), structure(\"are put into new field(s) labeled Pipe1, PipeX, ..., PipeN. If the results\\n\", class = c(\"TEXT\", \"tag\")), structure(\"of the expression are shorter than the rows in the \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humtable\", class = c(\"TEXT\", \"tag\"))), Rd_option = structure(\"=humdrum table\", Rd_tag = \"TEXT\"), class = c(\"tag_link\", \"tag\")), structure(\",\\n\", class = c(\"TEXT\", \"tag\")), structure(\"or an \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"object\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\", the humdrum table is shrunk to fit them.\\n\", class = c(\"TEXT\", \"tag\"))), class = \"tag\")), class = c(\"tag_section\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list( structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"humdata <- readHumdrum('directorywithdata/*.krn')\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" )), structure(\"withinHumdrum(humdata, ~nchar(.)) # counts characters in each data token.\\n\", class = c(\"RCODE\", \"tag\")), structure(\"withinHumdrum(humdata, ~table(.), by ~ Spine) # Tabulates data tokens in each Spine.\\n\", class = c(\"RCODE\", \"tag\")), structure(\"\\n\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_examples\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\")), writeHumdrum.Rd = structure(list( structure(\"% Generated by roxygen2: do not edit by hand\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"% Please edit documentation in R/Write.R\", class = c(\"COMMENT\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"writeHumdrum\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_name\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"writeHumdrum\", class = c(\"VERB\", \"tag\"))), class = c(\"tag_alias\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"Write \", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"humdrumR\", class = c(\"RCODE\", \"tag\"))), class = c(\"tag_code\", \"tag\")), structure(\" data to humdrum files.\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_title\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"RCODE\", \"tag\")), structure(\"writeHumdrum(\\n\", class = c(\"RCODE\", \"tag\")), structure(\" humdrumR,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" fieldname = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" affix = \\\"_humdrumR\\\",\\n\", class = c(\"RCODE\", \"tag\")), structure(\" prefix = \\\"\\\",\\n\", class = c(\"RCODE\", \"tag\")), structure(\" rename = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" extension = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" directory = NULL,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" EMD = paste0(\\\"Edited in humdrumR \\\", packageVersion(\\\"humdrumR\\\"), \\\" on \\\", Sys.date()),\\n\", class = c(\"RCODE\", \"tag\")), structure(\" overwrite = FALSE,\\n\", class = c(\"RCODE\", \"tag\")), structure(\" verbose = TRUE\\n\", class = c(\"RCODE\", \"tag\")), structure(\")\\n\", class = c(\"RCODE\", \"tag\" ))), class = c(\"tag_usage\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(list(structure(\"\\n\", class = c(\"TEXT\", \"tag\")), structure(\"----------NEEDS DOCUMENTATION------------\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"tag_description\", \"tag\")), structure(\"\\n\", class = c(\"TEXT\", \"tag\"))), class = c(\"Rd\", \"tag\"))), source = list( LO5th.Rd = \"R/tonalInterval.R\", REparser.Rd = \"R/Regex.R\", RegexFind.Rd = \"R/Regex.R\", chordTransformer.Rd = \"R/tertianSet.R\", decimal.Rd = \"R/tools.R\", diatonicSet.Rd = c(\"R/diatonicSet.R\", \"R/tertianSet.R\"), fillThru.Rd = \"R/tools.R\", filterHumdrum.Rd = \"R/Filter.R\", getFields.Rd = \"R/humdrumR-class.R\", getTandem.Rd = \"R/Apply.R\", humActive.Rd = \"R/humdrumR-class.R\", humAssignment.Rd = \"R/humdrumR-class.R\", humCensus.Rd = \"R/Summary.R\", humCoercion.Rd = \"R/humdrumR-class.R\", humColumns.Rd = \"R/humdrumR-class.R\", humFormulae.Rd = \"R/Formulae.R\", humInterpretations.Rd = \"R/Summary.R\", humMerge.Rd = \"R/humdrumR-class.R\", humMeter.Rd = \"R/rhythmInterval.R\", humPipe.Rd = \"R/Piping.R\", humPrint.Rd = \"R/humdrumR-class.R\", humReference.Rd = \"R/Summary.R\", humShape.Rd = \"R/humdrumR-class.R\", humSize.Rd = \"R/humdrumR-class.R\", humSpines.Rd = \"R/Summary.R\", humSummary.Rd = \"R/Summary.R\", humTable.Rd = \"R/humdrumR-class.R\", humValidation.Rd = \"R/Validation.R\", humWindows.Rd = \"R/Windows.R\", humdrumDispatch.Rd = \"R/Compose.R\", humdrumPitch.Rd = \"R/humdrumR-package.R\", humdrumR.Rd = \"R/humdrumR-package.R\", humdrumRclass.Rd = c(\"R/humdrumR-class.R\", \"R/Filter.R\" ), humdrumRroot.Rd = \"R/humdrumR-package.R\", interpolateArguments.Rd = \"R/Apply.R\", intervalCalculus.Rd = \"R/tools.R\", keyTransformer.Rd = \"R/diatonicSet.R\", lag.Rd = \"R/tools.R\", metricPosition.Rd = \"R/rhythmInterval.R\", pitchFunctions.Rd = \"R/tonalInterval.R\", plotRhythm.Rd = \"R/Graphics.R\", rational.Rd = \"R/tools.R\", readHumdrum.Rd = \"R/Read.R\", regexConstruction.Rd = \"R/Regex.R\", rhythmDecompose.Rd = \"R/rhythmInterval.R\", rhythmFunctions.Rd = \"R/rhythmInterval.R\", rhythmInterval.Rd = \"R/rhythmInterval.R\", rhythmOffset.Rd = \"R/rhythmInterval.R\", romanNumerals.Rd = \"R/diatonicSet.R\", struct.Rd = \"R/Vector.R\", tertianSet.Rd = \"R/tertianSet.R\", time.Rd = \"R/rhythmInterval.R\", tonalInterval.Rd = c(\"R/tonalInterval.R\", \"R/rhythmInterval.R\"), tonalTransformations.Rd = \"R/tonalInterval.R\", transpose.Rd = \"R/tonalInterval.R\", withinHumdrum.Rd = \"R/Apply.R\", writeHumdrum.Rd = \"R/Write.R\"), keywords = list(character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), \"datasets\", character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), \"internal\", character(0), \"datasets\", character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0)), concepts = list(\"core pitch representation\", character(0), character(0), character(0), \"humdrumR numeric functions\", character(0), character(0), character(0), character(0), character(0), character(0), character(0), \"humdrum data summary functions\", character(0), character(0), character(0), \"humdrum data summary functions\", character(0), character(0), character(0), character(0), character(0), character(0), character(0), \"humdrum data summary functions\", \"humdrum data summary functions\", character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), \"rhythm analysis tools\", character(0), character(0), \"humdrumR numeric functions\", character(0), character(0), \"rhythm analysis tools\", character(0), \"core rhythm representation\", \"rhythm analysis tools\", character(0), character(0), character(0), character(0), \"core pitch representation\", character(0), character(0), character(0), character(0)), internal = c(FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE )), class = c(\"tbl_df\", \"tbl\", \"data.frame\"), row.names = c(NA, -57L)), tutorials = structure(list(name = character(0), file_out = character(0), title = character(0), pagetitle = character(0), url = character(0)), class = c(\"tbl_df\", \"tbl\", \"data.frame\"), row.names = integer(0)), vignettes = structure(list( name = structure(c(\"GettingStarted\", \"HumdrumSyntax\", \"Intervals\", \"IntroForCoders\", \"KeysAndChord\", \"Overview\", \"PitchAndTonality\", \"ReadWrite\", \"RhythmAndMeter\", \"Validation\" ), class = c(\"fs_path\", \"character\")), file_in = structure(c(\"vignettes/GettingStarted.Rmd\", \"vignettes/HumdrumSyntax.Rmd\", \"vignettes/Intervals.Rmd\", \"vignettes/IntroForCoders.Rmd\", \"vignettes/KeysAndChord.Rmd\", \"vignettes/Overview.Rmd\", \"vignettes/PitchAndTonality.Rmd\", \"vignettes/ReadWrite.Rmd\", \"vignettes/RhythmAndMeter.Rmd\", \"vignettes/Validation.Rmd\"), class = c(\"fs_path\", \"character\" )), file_out = structure(c(\"articles/GettingStarted.html\", \"articles/HumdrumSyntax.html\", \"articles/Intervals.html\", \"articles/IntroForCoders.html\", \"articles/KeysAndChord.html\", \"articles/Overview.html\", \"articles/PitchAndTonality.html\", \"articles/ReadWrite.html\", \"articles/RhythmAndMeter.html\", \"articles/Validation.html\"), class = c(\"fs_path\", \"character\" )), title = c(\"Getting started with humdrumR\", \"The Humdrum Syntax\", \"Rhythm and Pitch Intervals\", \"HumdrumR for Coders\", \"Diatonic and Tertian Sets in humdrumR\", \"Overview of humdrumR\", \"Pitch and Tonality in humdrumR\", \"Reading and writing data with humdrumR\", \"Rhythm and Meter in humdrumR\", \"Validating Humdrum Data\" ), description = c(NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, NA_character_), depth = c(1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L)), class = c(\"tbl_df\", \"tbl\", \"data.frame\"), row.names = c(NA, -10L)), bs_version = 5L, prefix = \"\"), class = \"pkgdown\")), examples = base::quote(TRUE), run_dont_run = base::quote(FALSE), seed = base::quote(1014), lazy = base::quote(FALSE), override = base::quote(list()), install = base::quote(FALSE), preview = base::quote(FALSE), new_process = base::quote(FALSE), devel = base::quote(FALSE), crayon_enabled = base::quote(TRUE), crayon_colors = base::quote(256L), pkgdown_internet = base::quote(TRUE)) #> \t      pkgdown::build_site(...) #> \t        build_site_local(pkg = pkg, examples = examples, run_dont_run = run_dont_run, seed = seed, lazy = lazy, override = override, preview = preview, devel = devel) #> \t          build_reference(pkg, lazy = lazy, examples = examples, run_dont_run = run_dont_run, seed = seed, override = override, preview = FALSE, devel = devel) #> \t            purrr::map(topics, build_reference_topic, pkg = pkg, lazy = lazy, examples_env = examples_env, run_dont_run = run_dont_run) #> \t              .f(.x[[i]], ...) #> \t                data_reference_topic(topic, pkg, examples_env = examples_env, run_dont_run = run_dont_run) #> \t                  run_examples(tags$tag_examples[[1]], env = if (is.null(examples_env)) NULL else new.env(parent = examples_env), topic = tools::file_path_sans_ext(topic$file_in), run_dont_run = run_dont_run) #> \t                    highlight_examples(code, topic, env = env) #> \t                      downlit::evaluate_and_highlight(code, fig_save = fig_save_topic, env = child_env(env), output_handler = evaluate::new_output_handler(value = pkgdown_print)) #> \t                        evaluate::evaluate(code, child_env(env), new_device = TRUE, output_handler = output_handler) #> \t                          evaluate_call(expr, parsed$src[[i]], envir = envir, enclos = enclos, debug = debug, last = i == length(out), use_try = stop_on_error != 2L, keep_warning = keep_warning, keep_message = keep_message, output_handler = output_handler, include_timing = include_timing) #> \t                            eval(expr, envir, enclos) #> \t                              withinHumdrum(humdata, ~table(.), by ~ Spine) #> \t                                .withHumdrum(humdrumR, ..., withfunc = \"withinHumdrum\") #> \t                                  checkhumdrumR(humdrumR, withfunc) #> Error: In the call withinHumdrum(humdrumR = _), the argument humdrumR must be a humdrumR object."},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/writeHumdrum.html","id":null,"dir":"Reference","previous_headings":"","what":"Write humdrumR data to humdrum files. — writeHumdrum","title":"Write humdrumR data to humdrum files. — writeHumdrum","text":"----------NEEDS DOCUMENTATION------------","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/writeHumdrum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write humdrumR data to humdrum files. — writeHumdrum","text":"","code":"writeHumdrum(   humdrumR,   fieldname = NULL,   affix = \"_humdrumR\",   prefix = \"\",   rename = NULL,   extension = NULL,   directory = NULL,   EMD = paste0(\"Edited in humdrumR \", packageVersion(\"humdrumR\"), \" on \", Sys.date()),   overwrite = FALSE,   verbose = TRUE )"}]
