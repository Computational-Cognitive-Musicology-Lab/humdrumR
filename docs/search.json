[{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/GettingStarted.html","id":"quick-start","dir":"Articles","previous_headings":"","what":"Quick Start","title":"Getting started with humdrumR","text":"Let’s just dive right ! First, make sure humdrumR installed: install humdrumR. Open R session load humdrumR library using command library(humdrumR)—now ready rock! HumdrumR comes packaged small number humdrum data files just play around . files stored directory computer installed humdrumR, subfolder called “HumdrumData”. can move R session folder using R’s “set working directory command”: setwd(humdrumRroot). ’re humdrumR directory, can use base R dir function see humdrum data available . looks like five folders humdrum data available . Using dir , can look inside one: let’s start ‘BachChorales’ folder. ten files folder, named “chor001.krn”, “chor002.krn”, etc. simple plain humdrum text files, using ’**kern’ interpretation represent ten chorales J.S. Bach. Take minute find files computer’s finder/exporer open simple text editor. One core philosophies humdrumR maintain direct, transparent relationship symbolic data—always take time look data! can also within Rstudio’s “Files” pane—fact, Rstudio make things extra easy can (within Files pane) click “” > “Go Working Directory” quickly find files.","code":"library(humdrumR)  setwd(humdrumRroot)  dir('HumdrumData') [1] \"BachChorales\"        \"BeethovenVariations\" \"MozartVariations\"    [4] \"RapFlow\"             \"RollingStoneCorpus\" dir('HumdrumData/BachChorales')  [1] \"chor001.krn\" \"chor002.krn\" \"chor003.krn\" \"chor004.krn\" \"chor005.krn\"  [6] \"chor006.krn\" \"chor007.krn\" \"chor008.krn\" \"chor009.krn\" \"chor010.krn\""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/GettingStarted.html","id":"reading-humdrum-data","dir":"Articles","previous_headings":"Quick Start","what":"Reading humdrum data","title":"Getting started with humdrumR","text":"Now ’ve found humdrum data look , let’s read humdrumR. can useing humdrumR’s readHumdrum command. Try : command two things: readHumdrum function read “chor001.krn” file R create humdrumR data object . new object saved variable called chor1. (name ‘chor1’ just name chose—welcome give different name want.) ’ve created chor1 object (whatever chose call ), can take quick look just typing name command line pressing enter: (R, enter something command line, R “prints” read.) print-see shows name file, contents file, stuff “Data fields” learn soon. Cool! Still, looking single humdrum file really exciting. whole point using computers working large amounts data. Luckily, humdrumR makes easy. Check next command: Notice ’ve changed instead writing 'chor001.krn', wrote 'chor0'. feed string 'chor0' readHumdrum, won’t just look file called “chor0”; read file folder whose name contains substring “chor0”—case ten files! Try printing new chorales object see different. Wow! ’ve now got “humdrumR corpus ten files”—’s nothing: readHumdrum work just well reading hundreds thousands files! Notice print humdrumR object, humdrumR shows beginning first file end last file, well telling many files total. readHumdrum number cool options can read detail humdrumR read/write tutorial.","code":"readHumdrum('HumdrumData/BachChorales/chor001.krn') -> chor1 Finding and reading files...     REpath-pattern 'HumdrumData/BachChorales/chor001.krn' matches 1 text files in 1 directory. One files read from disk. Validating one files...all valid. Parsing one files...Assembling corpus...Done! chor1 ############################ vvv chor001.krn vvv ############################     1:  !!!COM: Bach, Johann Sebastian     2:  !!!CDT: 1685/02/21/-1750/07/28/     3:  !!!OTL@@DE: Aus meines Herzens Grunde     4:  !!!OTL@EN:      From the Depths of My Heart     5:  !!!SCT: BWV 269     6:  !!!PC#: 1     7:  !!!AGN: chorale     8:          **kern        **kern        **kern        **kern     9:          *ICvox        *ICvox        *ICvox        *ICvox    10:          *Ibass       *Itenor        *Ialto       *Isoprn    11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano    12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B]    13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B]    14:             *>A           *>A           *>A           *>A    15:         *clefF4      *clefGv2       *clefG2       *clefG2    16:          *k[f#]        *k[f#]        *k[f#]        *k[f#]    17:             *G:           *G:           *G:           *G:    18:             *F:             *             *             *    19:           *M3/4         *M3/4         *M3/4         *M3/4    20:          *MM100        *MM100        *MM100        *MM100    21:             4GG            4B            4d            4g    22:              =1            =1            =1            =1    23:              4G            4B            4d            2g    24:              4E           8cL            4e             .    25:               .           8BJ             .             .    26:             4F#            4A            4d           4dd    27:              =2            =2            =2            =2    28:              4G            4G            2d           4.b    29:              4D           4F#             .             .    30:               .             .             .            8a    31:              4E            4G            4B            4g    32:              =3            =3            =3            =3    33:              4C           8cL           8eL           4.g    34:               .           8BJ            8d             .    35:            8BBL            4c            8e             .    36:            8AAJ             .          8f#J            8a    37:             4GG            4d            4g            4b    38:              =4            =4            =4            =4    39:             2D;           2d;          2f#;           2a;    40:             4GG            4d            4g            4b    41:              =5            =5            =5            =5    42:            4FF#            4A            4d           2dd    43:             4GG            4B            4e             .    44:             4AA            4c           4f#           4cc    45:              =6            =6            =6            =6    46:             4BB            4d            2g            4b    47:              4C            4e             .            2a    48:              4D           8dL           4f#             .    49:               .           8cJ             .             .    50:              =7            =7            =7            =7    51:            2GG;           2B;           2d;           2g;    52:            =:|!          =:|!          =:|!          =:|!    53:             *>B           *>B           *>B           *>B    54:             4GG            4d           [4g            4b    55:              =8            =8            =8            =8    56:             4GG            4d          8gL]            4b    57:               .             .          8f#J             .    58:             4AA            4c           8eL           4cc    59:               .             .          8f#J             .    60:             4BB           8BL           [4g           4dd    61:               .           8AJ             .             .    62:              =9            =9            =9            =9    63:            4.BB           8BL          8gL]          4.dd    64:               .           8cJ           8aJ             .    65:               .            4d           8gL             .    66:             8AA             .          8f#J           8cc    67:             4GG            4d            4g            4b    68:             =10           =10           =10           =10    69:             2D;           2d;          2f#;           2a;    70:             [4E            4B            4e            4g    71:             =11           =11           =11           =11    72:             4E]            4G            4e            2b    73:              4D            4B          8f#L             .    74:               .             .           8gJ             .    75:              4C            4e            4a           4cc    76:             =12           =12           =12           =12    77:            4.BB            2d            4a           2dd    78:               .             .           4.g             .    79:              8C             .             .             .    80:              4D            4d             .           4cc    81:               .             .           8f#             .    82:             =13           =13           =13           =13    83:            8GGL           2.d            2g           2.b    84:            8AAJ             .             .             .    85:             4BB             .             .             .    86:             4GG             .            4f             .    87:             =14           =14           =14           =14    88:             2C;           2c;           2e;           2g;    89:             4GG            4d            4g            4b    90:             =15           =15           =15           =15    91:            4FF#           8dL           4.a           2dd    92:               .           8cJ             .             .    93:             4GG            4B             .             .    94:               .             .            8g             .    95:             4AA            4c           4f#           4cc    96:             =16           =16           =16           =16    97:             4BB            2d            2g            2b    98:             4GG             .             .             .    99:              4D           8dL          [4f#            4a   100:               .           8cJ             .             .   101:             =17           =17           =17           =17   102:             8EL            4B         8f#L]           4.g   103:              8D             .           8eJ             .   104:              8C            4c           8eL             .   105:             8BB             .          8f#J            8a   106:             8AA            4d            4g            4b   107:            8GGJ             .             .             .   108:             =18           =18           =18           =18   109:             2D;           2d;          2f#;           2a;   110:             [4G            4d            4g            4b   111:             =19           =19           =19           =19   112:             4G]            2d            2a           2dd   113:             4F#             .             .             .   114:             [4E            4e           8gL           4cc   115:               .             .          8f#J             .   116:             =20           =20           =20           =20   117:            8EL]            2e            2g            4b   118:             8DJ             .             .             .   119:              4C             .             .            2a   120:              4D           8dL           4f#             .   121:               .           8cJ             .             .   122:             =21           =21           =21           =21   123:           2.GG;          2.B;          2.d;          2.g;   124:              ==            ==            ==            ==   125:              *-            *-            *-            *-   126:  !!!hum2abc: -Q ''   127:  !!!title: @{PC#}. @{OTL@@DE}   128:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian ***   129:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&***   130:  !!!YOR3: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371***   131:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.***   132:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10   133:  !!!EED:  Craig Stuart Sapp   134:  !!!EEV:  2009/05/22 ############################ ^^^ chor001.krn ^^^ ############################                      (***four global comments truncated due to screen size***)      Data fields:              *Token :: character readHumdrum('HumdrumData/BachChorales/chor0') -> chorales Finding and reading files...     REpath-pattern 'HumdrumData/BachChorales/chor0' matches 10 text files in 1 directory. Ten files read from disk. Validating ten files...all valid. Parsing ten files...Assembling corpus...Done! chorales ############################# vvv chor001.krn vvv #############################      1:  !!!COM: Bach, Johann Sebastian      2:  !!!CDT: 1685/02/21/-1750/07/28/      3:  !!!OTL@@DE: Aus meines Herzens Grunde      4:  !!!OTL@EN:      From the Depths of My Heart      5:  !!!SCT: BWV 269      6:  !!!PC#: 1      7:  !!!AGN: chorale      8:          **kern        **kern        **kern        **kern      9:          *ICvox        *ICvox        *ICvox        *ICvox     10:          *Ibass       *Itenor        *Ialto       *Isoprn     11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano     12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B]     14:             *>A           *>A           *>A           *>A     15:         *clefF4      *clefGv2       *clefG2       *clefG2     16:          *k[f#]        *k[f#]        *k[f#]        *k[f#]     17:             *G:           *G:           *G:           *G:     18:             *F:             *             *             *     19:           *M3/4         *M3/4         *M3/4         *M3/4     20:          *MM100        *MM100        *MM100        *MM100     21:             4GG            4B            4d            4g     22:              =1            =1            =1            =1     23:              4G            4B            4d            2g     24:              4E           8cL            4e             .     25:               .           8BJ             .             .     26:             4F#            4A            4d           4dd     27:              =2            =2            =2            =2     28:              4G            4G            2d           4.b     29:              4D           4F#             .             .     30:               .             .             .            8a     31:              4E            4G            4B            4g     32:              =3            =3            =3            =3     33:              4C           8cL           8eL           4.g     34:               .           8BJ            8d             .     35:            8BBL            4c            8e             .     36:            8AAJ             .          8f#J            8a     37:             4GG            4d            4g            4b     38:              =4            =4            =4            =4     39:             2D;           2d;          2f#;           2a;     40:             4GG            4d            4g            4b 41-134::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: ############################# ^^^ chor001.krn ^^^ #############################          (8 more files...)  ############################# vvv chor010.krn vvv #############################   1-60:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::     61:            2AA;           2c;           2e;           2a;     62:              2A            2e            2a           2cc     63:              =9            =9            =9            =9     64:              4E            4e            4g            4b     65:             8DL            4e            4g           4cc     66:             8CJ             .             .             .     67:             4BB            4d           8gL           4dd     68:               .             .           8fJ             .     69:              4C            4c            4e            4g     70:             =10           =10           =10           =10     71:              4D           8F#            4d            4b     72:               .            4G             .             .     73:              4D             .            4c            4a     74:               .           8F#             .             .     75:            2GG;           2G;           2B;           2g;     76:             =11           =11           =11           =11     77:              2C            2G            2e            2g     78:             4AA            4A            4e           4cc     79:              4E           4G#           8eL            4b     80:               .             .           8dJ             .     81:             =12           =12           =12           =12     82:              4F            4A            4c            4a     83:              4C            4G            4c            4e     84:            4BB-            4G           [2d            4g     85:             4AA            4A             .            4f     86:             =13           =13           =13           =13     87:            4GG#            4B           4d]           1e;     88:             4AA            4A            4c             .     89:            2EE;         2G#X;           2B;             .     90:              ==            ==            ==            ==     91:              *-            *-            *-            *-     92:  !!!hum2abc: -Q ''     93:  !!!title: @{PC#}. @{OTL@@DE}     94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B***     95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a***     96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 ***     97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1***     98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10     99:  !!!EED:  Craig Stuart Sapp    100:  !!!EEV:  2009/05/22 ############################# ^^^ chor010.krn ^^^ #############################                        (***four global comments truncated due to screen size***)      humdrumR corpus of ten files.      Data fields:              *Token :: character"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/GettingStarted.html","id":"the-data-model","dir":"Articles","previous_headings":"","what":"The Data Model","title":"Getting started with humdrumR","text":"really make use humdrumR, need understand bit humdrum data represented humdrumR package: humdrumR “data model.” essential thing understand maps humdrum data syntax R data.table.  fully understand , start least basic understanding humdrum syntax! Read syntax humdrum.org check [vignette]{HumdrumSyntax.html “Humdrum Syntax”} topic.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/GettingStarted.html","id":"data-frames","dir":"Articles","previous_headings":"The Data Model","what":"data.frames","title":"Getting started with humdrumR","text":"Data.frames essential R. data.frame simply two-dimensional table named columns. column either vector list values, length. HumdrumR makes use popular extension base-R data.frames, data.table. humdrumR, every single, individual token collection humdrum-syntax text files given row data.frame. example, consider simple, humdrum-syntax file: file contains nineteen individual tokens. illustrate, ’ll print file, token bracketed < >: happens humdrumR reads file? (file bundled humdrumR \"humdrumRroot/examples\" directory.) see thing saw earlier, reading real humdrum data \"HumdrumData\" folder. ’s hood? see , can use getHumtab function extract underlying humdrum table: Look , data.table nineteen rows! case, humdrum data table (“humtable”) twenty-four columns! columns : humdrumR, refer columns fields. learn fields humdrumR object, better call fields command directly original humdrumR object: see twenty-four fields (humtable columns), divided five types fields: Data fields Structure fields Interpretation fields Form fields Reference fields (good place read details columns means humTable documentation can get calling ?humTable.) Let’s go back Bach chorales dataset loaded earlier (saved chorales): chorales corpus 44 fields!—fields example1, additional ones. additional fields interpretation reference records didn’t appear toy example1.","code":"!!!OTL: Example 1  **kern                        **kern                          *M4/4                         *M4/4                           *C:                           *C:                             =                             =                               2G                            4g                              .                             4f                              2C                            2e                              ==                            ==                              *-                            *-                             NULL <!!!OTL: Example 1> <**kern>                      <**kern>                       <*M4/4>                       <*M4/4>                        <*C:>                         <*C:>                          <=>                           <=>                            <2G>                          <4g>                           <.>                           <4f>                           <2C>                          <2e>                           <==>                          <==>                           <*->                          <*-> example1 <- readHumdrum('examples/BasicExample.krn') Finding and reading files...     REpath-pattern 'examples/BasicExample.krn' matches 1 text files in 1 directory. One files read from disk. Validating one files...all valid. Parsing one files...Assembling corpus...Done!  example1  vvv BasicExample.krn vvv     1:  !!!OTL: Example 1    2:    **kern  **kern    3:     *M4/4   *M4/4    4:       *C:     *C:    5:         =       =    6:        2G      4g    7:         .      4f    8:        2C      2e    9:        ==      ==   10:        *-      *-  ^^^ BasicExample.krn ^^^       Data fields:              *Token :: character humtab <- getHumtab(example1)  humtab                 Token Record Type Column Spine Path Stop Exclusive  Tandem Bar  1: !!!OTL: Example 1      1    G     NA    NA   NA   NA      <NA>    <NA>  NA  2:            **kern      2    I      1     1    0    1      kern           0  3:             *M4/4      3    I      1     1    0    1      kern    M4/4   0  4:               *C:      4    I      1     1    0    1      kern C:,M4/4   0  5:                 =      5    M      1     1    0    1      kern C:,M4/4   1  6:                2G      6    D      1     1    0    1      kern C:,M4/4   1  7:                 .      7    d      1     1    0    1      kern C:,M4/4   1  8:                2C      8    D      1     1    0    1      kern C:,M4/4   1  9:                ==      9    M      1     1    0    1      kern C:,M4/4   2 10:                *-     10    I      1     1    0    1      kern C:,M4/4   2 11:            **kern      2    I      2     2    0    1      kern           0 12:             *M4/4      3    I      2     2    0    1      kern    M4/4   0 13:               *C:      4    I      2     2    0    1      kern C:,M4/4   0 14:                 =      5    M      2     2    0    1      kern C:,M4/4   1 15:                4g      6    D      2     2    0    1      kern C:,M4/4   1 16:                4f      7    D      2     2    0    1      kern C:,M4/4   1 17:                2e      8    D      2     2    0    1      kern C:,M4/4   1 18:                ==      9    M      2     2    0    1      kern C:,M4/4   2 19:                *-     10    I      2     2    0    1      kern C:,M4/4   2     DoubleBar BarLabel NData       OTL Piece                  Filepath File  1:        NA     <NA>    NA Example 1     1 examples/BasicExample.krn    1  2:         0     <NA>    NA Example 1     1 examples/BasicExample.krn    1  3:         0     <NA>    NA Example 1     1 examples/BasicExample.krn    1  4:         0     <NA>    NA Example 1     1 examples/BasicExample.krn    1  5:         0             NA Example 1     1 examples/BasicExample.krn    1  6:         0              1 Example 1     1 examples/BasicExample.krn    1  7:         0              2 Example 1     1 examples/BasicExample.krn    1  8:         0              3 Example 1     1 examples/BasicExample.krn    1  9:         1        =    NA Example 1     1 examples/BasicExample.krn    1 10:         1        =    NA Example 1     1 examples/BasicExample.krn    1 11:         0     <NA>    NA Example 1     1 examples/BasicExample.krn    1 12:         0     <NA>    NA Example 1     1 examples/BasicExample.krn    1 13:         0     <NA>    NA Example 1     1 examples/BasicExample.krn    1 14:         0             NA Example 1     1 examples/BasicExample.krn    1 15:         0              1 Example 1     1 examples/BasicExample.krn    1 16:         0              2 Example 1     1 examples/BasicExample.krn    1 17:         0              3 Example 1     1 examples/BasicExample.krn    1 18:         1        =    NA Example 1     1 examples/BasicExample.krn    1 19:         1        =    NA Example 1     1 examples/BasicExample.krn    1     Label         Filename  Null Filter Global  Key TimeSignature  1:    _1 BasicExample.krn FALSE  FALSE   TRUE <NA>          <NA>  2:    _1 BasicExample.krn FALSE  FALSE  FALSE <NA>          <NA>  3:    _1 BasicExample.krn FALSE  FALSE  FALSE <NA>          M4/4  4:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4  5:    _1 BasicExample.krn  TRUE  FALSE  FALSE   C:          M4/4  6:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4  7:    _1 BasicExample.krn  TRUE  FALSE  FALSE   C:          M4/4  8:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4  9:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4 10:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4 11:    _1 BasicExample.krn FALSE  FALSE  FALSE <NA>          <NA> 12:    _1 BasicExample.krn FALSE  FALSE  FALSE <NA>          M4/4 13:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4 14:    _1 BasicExample.krn  TRUE  FALSE  FALSE   C:          M4/4 15:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4 16:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4 17:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4 18:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4 19:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4 colnames(humtab)  [1] \"Token\"         \"Record\"        \"Type\"          \"Column\"         [5] \"Spine\"         \"Path\"          \"Stop\"          \"Exclusive\"      [9] \"Tandem\"        \"Bar\"           \"DoubleBar\"     \"BarLabel\"      [13] \"NData\"         \"OTL\"           \"Piece\"         \"Filepath\"      [17] \"File\"          \"Label\"         \"Filename\"      \"Null\"          [21] \"Filter\"        \"Global\"        \"Key\"           \"TimeSignature\" fields(example1)              Name     Class           Type  1:         Token character           Data  2:      Filename character      Structure  3:      Filepath character      Structure  4:          File   integer      Structure  5:         Label character      Structure  6:         Piece   integer      Structure  7:        Column   integer      Structure  8:         Spine   integer      Structure  9:          Path   integer      Structure 10:          Stop   integer      Structure 11:        Record   integer      Structure 12:         NData   integer      Structure 13:        Global   logical      Structure 14:          Null   logical      Structure 15:        Filter   logical      Structure 16:          Type character      Structure 17:     Exclusive character Interpretation 18:        Tandem character Interpretation 19:           Key character Interpretation 20: TimeSignature character Interpretation 21:           Bar   integer         Formal 22:     DoubleBar   integer         Formal 23:      BarLabel character         Formal 24:           OTL character      Reference              Name     Class           Type fields(chorales)                Name     Class           Type  1:           Token character           Data  2:        Filename character      Structure  3:        Filepath character      Structure  4:            File   integer      Structure  5:           Label character      Structure  6:           Piece   integer      Structure  7:          Column   integer      Structure  8:           Spine   integer      Structure  9:            Path   integer      Structure 10:            Stop   integer      Structure 11:          Record   integer      Structure 12:           NData   integer      Structure 13:          Global   logical      Structure 14:            Null   logical      Structure 15:          Filter   logical      Structure 16:            Type character      Structure 17:       Exclusive character Interpretation 18:          Tandem character Interpretation 19:             Key character Interpretation 20:    KeySignature character Interpretation 21:            Clef character Interpretation 22:   TimeSignature character Interpretation 23:     Mensuration character Interpretation 24:             BPM character Interpretation 25:      Instrument character Interpretation 26: InstrumentClass character Interpretation 27:          Formal character         Formal 28:             Bar   integer         Formal 29:       DoubleBar   integer         Formal 30:        BarLabel character         Formal 31:             COM character      Reference 32:             CDT character      Reference 33:         OTL@@DE character      Reference 34:          OTL@EN character      Reference 35:             SCT character      Reference 36:             PC# character      Reference 37:             AGN character      Reference 38:         hum2abc character      Reference 39:           title character      Reference 40:             YOR character      Reference 41:             SMS character      Reference 42:             EED character      Reference 43:             EEV character      Reference 44:             OPR character      Reference                Name     Class           Type"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/GettingStarted.html","id":"main-fields","dir":"Articles","previous_headings":"The Data Model > data.frames","what":"Main Fields","title":"Getting started with humdrumR","text":"important fields always present humdrumR humtable 1) “Token” field contains original character tokens read humdrum data!; 2) “Structural” fields tell us original humdrum data token came . “Structural” fields allow humdrumR (re)construct original humdrum data—translating humdrum-table (data.table) plain-text humdrum syntax. can inspect field humdrumR data using $ operator: Just call humdrumR data object $ name field. Using , can see content structural fields ! important Spine, Record, (Record) Type, File(name) fields. “record types” : \"G\": global comment (including reference records) \"L\": local comment \"\": interpretation \"M\": measure (.e., barlines) \"D\": (non-null) data token \"d\": null data token (\".\")","code":"example1$Spine  vvv BasicExample.krn vvv     1:  !!    2:    1  2    3:    1  2    4:    1  2    5:    1  2    6:    1  2    7:    1  2    8:    1  2    9:    1  2   10:    1  2  ^^^ BasicExample.krn ^^^       Data fields:               Token :: character  # example1$Record  example1$Type  vvv BasicExample.krn vvv     1:    G       2:    I  I    3:    I  I    4:    I  I    5:    M  M    6:    D  D    7:    D  D    8:    D  D    9:    M  M   10:    I  I  ^^^ BasicExample.krn ^^^       Data fields:               Token :: character  example1$Filename ######## vvv BasicExample.krn vvv #########    1:    BasicExample.krn                      2:    BasicExample.krn  BasicExample.krn    3:    BasicExample.krn  BasicExample.krn    4:    BasicExample.krn  BasicExample.krn    5:    BasicExample.krn  BasicExample.krn    6:    BasicExample.krn  BasicExample.krn    7:    BasicExample.krn  BasicExample.krn    8:    BasicExample.krn  BasicExample.krn    9:    BasicExample.krn  BasicExample.krn   10:    BasicExample.krn  BasicExample.krn ######## ^^^ BasicExample.krn ^^^ #########      Data fields:               Token :: character"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/GettingStarted.html","id":"stops","dir":"Articles","previous_headings":"The Data Model > data.frames","what":"Stops","title":"Getting started with humdrumR","text":"humdrum syntax, multiple tokens can placed “place” (.e., record, spine) simply separating spaces. (commonly used represent chords **kern data.) humdrumR, call “Stops”—always, every humdrum token, including stops, get row humdrumR humtable. Thus, need Stop field tell us stop token came ! much data, /tokens simply Stop == 1 (first position), one tokens record/spine, numbered ascending one: Let’s look example make sense ! file chords second spine: individual note tokens separated spaces. Let’s inspect humtable: can see note chords gets row, numbered 1, 2, 3 Stop field!","code":"stops <- readHumdrum('examples/Stops.krn') Finding and reading files...     REpath-pattern 'examples/Stops.krn' matches 1 text files in 1 directory. One files read from disk. Validating one files...all valid. Parsing one files...Assembling corpus...Done!  stops ##### vvv Stops.krn vvv #####    1:  !!!OTL: \"Stop\" example    2:    **kern    **kern    3:     *M4/4     *M4/4    4:       *C:       *C:    5:        =-        =-    6:        2G  4g cc ee    7:         .   4f b dd    8:       2C;   2e; cc;    9:         =         =   10:        *-        *- ##### ^^^ Stops.krn ^^^ #####      Data fields:              *Token :: character getHumtab(stops)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/GettingStarted.html","id":"paths","dir":"Articles","previous_headings":"The Data Model > data.frames","what":"Paths","title":"Getting started with humdrumR","text":"humdrum data contains “spine paths”—places single spine splits two. humdrumR treats spine paths “subspines” main spine split , one numbered Path field. starting path (leftmost) numbered path 0—datasets spine paths, Path field zeros. paths numbered higher integers. Let’s look simple example: complex example: Notice humdrumR prints paths way readable reading humdrum syntax directly: paths “shifted” columns align. Column field used .","code":"paths1 <- readHumdrum('examples/Paths.krn') Finding and reading files...     REpath-pattern 'examples/Paths.krn' matches 1 text files in 1 directory. One files read from disk. Validating one files...all valid. Parsing one files...Assembling corpus...Done!  paths1 ###### vvv Paths.krn vvv ######    1:  !!!OTL: \"Path\" example    2:    **kern     **kern         3:     *M4/4      *M4/4         4:       *C:        *C:         5:        =-         =-         6:        4C    4cc 4ee         7:        4D     4b 4dd         8:        4E     2a 2cc         9:        4F          .        10:         =          =        11:         *         *^        12:        1G         8g  4cc   13:         .         8a    .   14:         .         8g   4a   15:         .        8f#    .   16:         .         4g   2b   17:         .         4f    .   18:         *         *v   *v   19:         =          =        20:        1C  1e 1g 1cc        21:        ==         ==        22:        *-         *-      ###### ^^^ Paths.krn ^^^ ######      Data fields:              *Token :: character  paths1$Path  vvv Paths.krn vvv #    1:  !!    2:    0      0       3:    0      0       4:    0      0       5:    0      0       6:    0    0 0       7:    0    0 0       8:    0    0 0       9:    0      0      10:    0      0      11:    0      0      12:    0      0  1   13:    0      0  1   14:    0      0  1   15:    0      0  1   16:    0      0  1   17:    0      0  1   18:    0      0  1   19:    0      0      20:    0  0 0 0      21:    0      0      22:    0      0     ^^^ Paths.krn ^^^ #      Data fields:               Token :: character  getHumtab(paths1) paths2 <- readHumdrum('examples/Paths2.krn') Finding and reading files...     REpath-pattern 'examples/Paths2.krn' matches 1 text files in 1 directory. One files read from disk. Validating one files...all valid. Parsing one files...Assembling corpus...Done!  paths2 ######## vvv Paths2.krn vvv #########    1:  !!!OTL: complex \"Path\" example    2:    **path                3:         a                4:        *^                5:         b       c        6:         d       e        7:        *^       *        8:         f   g   h        9:         i   j   k       10:        *v  *v   *       11:         l       m       12:         n       o       13:         *      *^       14:         p       q   r   15:         s       t   u   16:         *      *v  *v   17:         v       w       18:         x       y       19:        *v      *v       20:         z               21:        *-             ######## ^^^ Paths2.krn ^^^ #########      Data fields:              *Token :: character  paths2$Path  vvv Paths2.krn vvv     1:  !!    2:    0          3:    0          4:    0          5:    0  2       6:    0  2       7:    0  2       8:    0  1  2    9:    0  1  2   10:    0  1  2   11:    0  2      12:    0  2      13:    0  2      14:    0  2  3   15:    0  2  3   16:    0  2  3   17:    0  2      18:    0  2      19:    0  2      20:    0         21:    0        ^^^ Paths2.krn ^^^       Data fields:               Token :: character  getHumtab(paths2)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/GettingStarted.html","id":"doing-stuff","dir":"Articles","previous_headings":"","what":"Doing Stuff!","title":"Getting started with humdrumR","text":"Ok, ’ve now seen read inspect humdrumR data. ’ve also got idea humdrum data looks like surface: humdrum table. can ? create humdrumR corpus object, using readHumdrum, object encapsulates humdrum-table (data.table) object, data really stored. ’ve already seen can extract humdrum table directly using getHumtab—aleady R pro, might just want extract table work directly. However, humdrumR object give us convenient ways working table. example, ’ve already seen print humdrumR objects, print humdrum syntax, easier read complex humdrum table! humdrumR ! main thing humdrumR allow us work fields humdrum-tables way convenient powerful. First, create special “-expressions” refer humtable’s fields. create expression, use R ~ operator. instance, can write things like: ~ Spine + File ~ nchar(Token) ~ paste0(Token, Record) Notice three expressions contain names humdrumR fields. execute lines R session, nothing much happen: ’ll see saved—‘quoted’—returned R formula objects. However, can tell humdrumR evaluate expressions using fields humdrum tables. simplest way using %hum>% pipe operator, takes humdrumR object (left side), formula right side: expression evaluated, result put back place humdrum data! ’ll also notice printout, new Data field, called Pipe1—default name humdrumR assigns new fields create. want, can pick names using $<- (.e., assigning new name create using $). instance, lets use humdrumR’s semit function (see humdrum pitch vignette) calculate semitone value pitch chorales: worked! Lets , save result new field, call Semits—course, give name want, just let called Pipe1 want! now new Data field humdrum table, called Semits. Meanwhile, original Token field still , safely unchanged! Just like , can use $ operator look fields: Whats , can use Semits field just like field:","code":"~ Spine + File ~Spine + File  ~ nchar(Token) ~nchar(Token)  ~ paste0(Token, Record) ~paste0(Token, Record) chorales %hum>% ~ Spine + File ########## vvv chor001.krn vvv ##########      1:  !!      2:  !!      3:  !!      4:  !!      5:  !!      6:  !!      7:  !!      8:    **kern  **kern  **kern  **kern      9:         *       *       *       *     10:         *       *       *       *     11:         *       *       *       *     12:         *       *       *       *     13:         *       *       *       *     14:         *       *       *       *     15:         *       *       *       *     16:         *       *       *       *     17:         *       *       *       *     18:         *       *       *       *     19:         *       *       *       *     20:         *       *       *       *     21:         2       3       4       5     22:         =       =       =       =     23:         2       3       4       5     24:         2       3       4       .     25:         .       3       .       .     26:         2       3       4       5     27:         =       =       =       =     28:         2       3       4       5     29:         2       3       .       .     30:         .       .       .       5     31:         2       3       4       5     32:         =       =       =       =     33:         2       3       4       5     34:         .       3       4       .     35:         2       3       4       .     36:         2       .       4       5     37:         2       3       4       5     38:         =       =       =       =     39:         2       3       4       5     40:         2       3       4       5 41-134::::::::::::::::::::::::::::::::::: ########## ^^^ chor001.krn ^^^ ##########          (8 more files...)  ########## vvv chor010.krn vvv ##########   1-60:::::::::::::::::::::::::::::::::::     61:        11      12      13      14     62:        11      12      13      14     63:         =       =       =       =     64:        11      12      13      14     65:        11      12      13      14     66:        11       .       .       .     67:        11      12      13      14     68:         .       .      13       .     69:        11      12      13      14     70:         =       =       =       =     71:        11      12      13      14     72:         .      12       .       .     73:        11       .      13      14     74:         .      12       .       .     75:        11      12      13      14     76:         =       =       =       =     77:        11      12      13      14     78:        11      12      13      14     79:        11      12      13      14     80:         .       .      13       .     81:         =       =       =       =     82:        11      12      13      14     83:        11      12      13      14     84:        11      12      13      14     85:        11      12       .      14     86:         =       =       =       =     87:        11      12      13      14     88:        11      12      13       .     89:        11      12      13       .     90:         =       =       =       =     91:         *       *       *       *     92:  !!     93:  !!     94:  !!     95:  !!     96:  !!     97:  !!     98:  !!     99:  !!    100:  !! ########## ^^^ chor010.krn ^^^ ##########      humdrumR corpus of ten files.      Data fields:               Token :: character             *Pipe1 :: integer  chorales %hum>% ~ nchar(Token) ########## vvv chor001.krn vvv ##########      1:  !!      2:  !!      3:  !!      4:  !!      5:  !!      6:  !!      7:  !!      8:    **kern  **kern  **kern  **kern      9:         *       *       *       *     10:         *       *       *       *     11:         *       *       *       *     12:         *       *       *       *     13:         *       *       *       *     14:         *       *       *       *     15:         *       *       *       *     16:         *       *       *       *     17:         *       *       *       *     18:         *       *       *       *     19:         *       *       *       *     20:         *       *       *       *     21:         3       2       2       2     22:         =       =       =       =     23:         2       2       2       2     24:         2       3       2       .     25:         .       3       .       .     26:         3       2       2       3     27:         =       =       =       =     28:         2       2       2       3     29:         2       3       .       .     30:         .       .       .       2     31:         2       2       2       2     32:         =       =       =       =     33:         2       3       3       3     34:         .       3       2       .     35:         4       2       2       .     36:         4       .       4       2     37:         3       2       2       2     38:         =       =       =       =     39:         3       3       4       3     40:         3       2       2       2 41-134::::::::::::::::::::::::::::::::::: ########## ^^^ chor001.krn ^^^ ##########          (8 more files...)  ########## vvv chor010.krn vvv ##########   1-60:::::::::::::::::::::::::::::::::::     61:         4       3       3       3     62:         2       2       2       3     63:         =       =       =       =     64:         2       2       2       2     65:         3       2       2       3     66:         3       .       .       .     67:         3       2       3       3     68:         .       .       3       .     69:         2       2       2       2     70:         =       =       =       =     71:         2       3       2       2     72:         .       2       .       .     73:         2       .       2       2     74:         .       3       .       .     75:         4       3       3       3     76:         =       =       =       =     77:         2       2       2       2     78:         3       2       2       3     79:         2       3       3       2     80:         .       .       3       .     81:         =       =       =       =     82:         2       2       2       2     83:         2       2       2       2     84:         4       2       3       2     85:         3       2       .       2     86:         =       =       =       =     87:         4       2       3       3     88:         3       2       2       .     89:         4       5       3       .     90:         =       =       =       =     91:         *       *       *       *     92:  !!     93:  !!     94:  !!     95:  !!     96:  !!     97:  !!     98:  !!     99:  !!    100:  !! ########## ^^^ chor010.krn ^^^ ##########      humdrumR corpus of ten files.      Data fields:               Token :: character             *Pipe1 :: integer  chorales %hum>% ~ paste0(Token, Record) ########## vvv chor001.krn vvv ###########      1:  !!      2:  !!      3:  !!      4:  !!      5:  !!      6:  !!      7:  !!      8:    **kern   **kern  **kern  **kern      9:         *        *       *       *     10:         *        *       *       *     11:         *        *       *       *     12:         *        *       *       *     13:         *        *       *       *     14:         *        *       *       *     15:         *        *       *       *     16:         *        *       *       *     17:         *        *       *       *     18:         *        *       *       *     19:         *        *       *       *     20:         *        *       *       *     21:     4GG21     4B21    4d21    4g21     22:         =        =       =       =     23:      4G23     4B23    4d23    2g23     24:      4E24    8cL24    4e24       .     25:         .    8BJ25       .       .     26:     4F#26     4A26    4d26   4dd26     27:         =        =       =       =     28:      4G28     4G28    2d28   4.b28     29:      4D29    4F#29       .       .     30:         .        .       .    8a30     31:      4E31     4G31    4B31    4g31     32:         =        =       =       =     33:      4C33    8cL33   8eL33   4.g33     34:         .    8BJ34    8d34       .     35:    8BBL35     4c35    8e35       .     36:    8AAJ36        .  8f#J36    8a36     37:     4GG37     4d37    4g37    4b37     38:         =        =       =       =     39:     2D;39    2d;39  2f#;39   2a;39     40:     4GG40     4d40    4g40    4b40 41-134:::::::::::::::::::::::::::::::::::: ########## ^^^ chor001.krn ^^^ ###########          (8 more files...)  ########## vvv chor010.krn vvv ###########   1-60::::::::::::::::::::::::::::::::::::     61:    2AA;61    2c;61   2e;61   2a;61     62:      2A62     2e62    2a62   2cc62     63:         =        =       =       =     64:      4E64     4e64    4g64    4b64     65:     8DL65     4e65    4g65   4cc65     66:     8CJ66        .       .       .     67:     4BB67     4d67   8gL67   4dd67     68:         .        .   8fJ68       .     69:      4C69     4c69    4e69    4g69     70:         =        =       =       =     71:      4D71    8F#71    4d71    4b71     72:         .     4G72       .       .     73:      4D73        .    4c73    4a73     74:         .    8F#74       .       .     75:    2GG;75    2G;75   2B;75   2g;75     76:         =        =       =       =     77:      2C77     2G77    2e77    2g77     78:     4AA78     4A78    4e78   4cc78     79:      4E79    4G#79   8eL79    4b79     80:         .        .   8dJ80       .     81:         =        =       =       =     82:      4F82     4A82    4c82    4a82     83:      4C83     4G83    4c83    4e83     84:    4BB-84     4G84   [2d84    4g84     85:     4AA85     4A85       .    4f85     86:         =        =       =       =     87:    4GG#87     4B87   4d]87   1e;87     88:     4AA88     4A88    4c88       .     89:    2EE;89  2G#X;89   2B;89       .     90:         =        =       =       =     91:         *        *       *       *     92:  !!     93:  !!     94:  !!     95:  !!     96:  !!     97:  !!     98:  !!     99:  !!    100:  !! ########## ^^^ chor010.krn ^^^ ###########      humdrumR corpus of ten files.      Data fields:               Token :: character             *Pipe1 :: character chorales %hum>% ~ semit(Token) ########## vvv chor001.krn vvv ##########      1:  !!      2:  !!      3:  !!      4:  !!      5:  !!      6:  !!      7:  !!      8:    **kern  **kern  **kern  **kern      9:         *       *       *       *     10:         *       *       *       *     11:         *       *       *       *     12:         *       *       *       *     13:         *       *       *       *     14:         *       *       *       *     15:         *       *       *       *     16:         *       *       *       *     17:         *       *       *       *     18:         *       *       *       *     19:         *       *       *       *     20:         *       *       *       *     21:       -17      -1       2       7     22:         =       =       =       =     23:        -5      -1       2       7     24:        -8       0       4       .     25:         .      -1       .       .     26:        -6      -3       2      14     27:         =       =       =       =     28:        -5      -5       2      11     29:       -10      -6       .       .     30:         .       .       .       9     31:        -8      -5      -1       7     32:         =       =       =       =     33:       -12       0       4       7     34:         .      -1       2       .     35:       -13       0       4       .     36:       -15       .       6       9     37:       -17       2       7      11     38:         =       =       =       =     39:       -10       2       6       9     40:       -17       2       7      11 41-134::::::::::::::::::::::::::::::::::: ########## ^^^ chor001.krn ^^^ ##########          (8 more files...)  ########## vvv chor010.krn vvv ##########   1-60:::::::::::::::::::::::::::::::::::     61:       -15       0       4       9     62:        -3       4       9      12     63:         =       =       =       =     64:        -8       4       7      11     65:       -10       4       7      12     66:       -12       .       .       .     67:       -13       2       7      14     68:         .       .       5       .     69:       -12       0       4       7     70:         =       =       =       =     71:       -10      -6       2      11     72:         .      -5       .       .     73:       -10       .       0       9     74:         .      -6       .       .     75:       -17      -5      -1       7     76:         =       =       =       =     77:       -12      -5       4       7     78:       -15      -3       4      12     79:        -8      -4       4      11     80:         .       .       2       .     81:         =       =       =       =     82:        -7      -3       0       9     83:       -12      -5       0       4     84:       -14      -5       2       7     85:       -15      -3       .       5     86:         =       =       =       =     87:       -16      -1       2       4     88:       -15      -3       0       .     89:       -20      -4      -1       .     90:         =       =       =       =     91:         *       *       *       *     92:  !!     93:  !!     94:  !!     95:  !!     96:  !!     97:  !!     98:  !!     99:  !!    100:  !! ########## ^^^ chor010.krn ^^^ ##########      humdrumR corpus of ten files.      Data fields:               Token :: character             *Pipe1 :: integer chorales %hum>% ~ semit(Token) -> chorales$Semits chorales$Token ############################# vvv chor001.krn vvv #############################      1:  !!!COM: Bach, Johann Sebastian      2:  !!!CDT: 1685/02/21/-1750/07/28/      3:  !!!OTL@@DE: Aus meines Herzens Grunde      4:  !!!OTL@EN:      From the Depths of My Heart      5:  !!!SCT: BWV 269      6:  !!!PC#: 1      7:  !!!AGN: chorale      8:          **kern        **kern        **kern        **kern      9:          *ICvox        *ICvox        *ICvox        *ICvox     10:          *Ibass       *Itenor        *Ialto       *Isoprn     11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano     12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B]     14:             *>A           *>A           *>A           *>A     15:         *clefF4      *clefGv2       *clefG2       *clefG2     16:          *k[f#]        *k[f#]        *k[f#]        *k[f#]     17:             *G:           *G:           *G:           *G:     18:             *F:             *             *             *     19:           *M3/4         *M3/4         *M3/4         *M3/4     20:          *MM100        *MM100        *MM100        *MM100     21:             4GG            4B            4d            4g     22:              =1            =1            =1            =1     23:              4G            4B            4d            2g     24:              4E           8cL            4e             .     25:               .           8BJ             .             .     26:             4F#            4A            4d           4dd     27:              =2            =2            =2            =2     28:              4G            4G            2d           4.b     29:              4D           4F#             .             .     30:               .             .             .            8a     31:              4E            4G            4B            4g     32:              =3            =3            =3            =3     33:              4C           8cL           8eL           4.g     34:               .           8BJ            8d             .     35:            8BBL            4c            8e             .     36:            8AAJ             .          8f#J            8a     37:             4GG            4d            4g            4b     38:              =4            =4            =4            =4     39:             2D;           2d;          2f#;           2a;     40:             4GG            4d            4g            4b 41-134::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: ############################# ^^^ chor001.krn ^^^ #############################          (8 more files...)  ############################# vvv chor010.krn vvv #############################   1-60:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::     61:            2AA;           2c;           2e;           2a;     62:              2A            2e            2a           2cc     63:              =9            =9            =9            =9     64:              4E            4e            4g            4b     65:             8DL            4e            4g           4cc     66:             8CJ             .             .             .     67:             4BB            4d           8gL           4dd     68:               .             .           8fJ             .     69:              4C            4c            4e            4g     70:             =10           =10           =10           =10     71:              4D           8F#            4d            4b     72:               .            4G             .             .     73:              4D             .            4c            4a     74:               .           8F#             .             .     75:            2GG;           2G;           2B;           2g;     76:             =11           =11           =11           =11     77:              2C            2G            2e            2g     78:             4AA            4A            4e           4cc     79:              4E           4G#           8eL            4b     80:               .             .           8dJ             .     81:             =12           =12           =12           =12     82:              4F            4A            4c            4a     83:              4C            4G            4c            4e     84:            4BB-            4G           [2d            4g     85:             4AA            4A             .            4f     86:             =13           =13           =13           =13     87:            4GG#            4B           4d]           1e;     88:             4AA            4A            4c             .     89:            2EE;         2G#X;           2B;             .     90:              ==            ==            ==            ==     91:              *-            *-            *-            *-     92:  !!!hum2abc: -Q ''     93:  !!!title: @{PC#}. @{OTL@@DE}     94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B***     95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a***     96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 ***     97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1***     98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10     99:  !!!EED:  Craig Stuart Sapp    100:  !!!EEV:  2009/05/22 ############################# ^^^ chor010.krn ^^^ #############################                        (***four global comments truncated due to screen size***)      humdrumR corpus of ten files.      Data fields:              *Token  :: character              Semits :: integer  chorales$Semits ########## vvv chor001.krn vvv ##########      1:  !!      2:  !!      3:  !!      4:  !!      5:  !!      6:  !!      7:  !!      8:    **kern  **kern  **kern  **kern      9:         *       *       *       *     10:         *       *       *       *     11:         *       *       *       *     12:         *       *       *       *     13:         *       *       *       *     14:         *       *       *       *     15:         *       *       *       *     16:         *       *       *       *     17:         *       *       *       *     18:         *       *       *       *     19:         *       *       *       *     20:         *       *       *       *     21:       -17      -1       2       7     22:         =       =       =       =     23:        -5      -1       2       7     24:        -8       0       4       .     25:         .      -1       .       .     26:        -6      -3       2      14     27:         =       =       =       =     28:        -5      -5       2      11     29:       -10      -6       .       .     30:         .       .       .       9     31:        -8      -5      -1       7     32:         =       =       =       =     33:       -12       0       4       7     34:         .      -1       2       .     35:       -13       0       4       .     36:       -15       .       6       9     37:       -17       2       7      11     38:         =       =       =       =     39:       -10       2       6       9     40:       -17       2       7      11 41-134::::::::::::::::::::::::::::::::::: ########## ^^^ chor001.krn ^^^ ##########          (8 more files...)  ########## vvv chor010.krn vvv ##########   1-60:::::::::::::::::::::::::::::::::::     61:       -15       0       4       9     62:        -3       4       9      12     63:         =       =       =       =     64:        -8       4       7      11     65:       -10       4       7      12     66:       -12       .       .       .     67:       -13       2       7      14     68:         .       .       5       .     69:       -12       0       4       7     70:         =       =       =       =     71:       -10      -6       2      11     72:         .      -5       .       .     73:       -10       .       0       9     74:         .      -6       .       .     75:       -17      -5      -1       7     76:         =       =       =       =     77:       -12      -5       4       7     78:       -15      -3       4      12     79:        -8      -4       4      11     80:         .       .       2       .     81:         =       =       =       =     82:        -7      -3       0       9     83:       -12      -5       0       4     84:       -14      -5       2       7     85:       -15      -3       .       5     86:         =       =       =       =     87:       -16      -1       2       4     88:       -15      -3       0       .     89:       -20      -4      -1       .     90:         =       =       =       =     91:         *       *       *       *     92:  !!     93:  !!     94:  !!     95:  !!     96:  !!     97:  !!     98:  !!     99:  !!    100:  !! ########## ^^^ chor010.krn ^^^ ##########      humdrumR corpus of ten files.      Data fields:               Token  :: character             *Semits :: integer chorales %hum>% ~ paste0(Token, ' = ', Semits) ################ vvv chor001.krn vvv ################      1:  !!      2:  !!      3:  !!      4:  !!      5:  !!      6:  !!      7:  !!      8:        **kern      **kern    **kern    **kern      9:             *           *         *         *     10:             *           *         *         *     11:             *           *         *         *     12:             *           *         *         *     13:             *           *         *         *     14:             *           *         *         *     15:             *           *         *         *     16:             *           *         *         *     17:             *           *         *         *     18:             *           *         *         *     19:             *           *         *         *     20:             *           *         *         *     21:     4GG = -17     4B = -1    4d = 2    4g = 7     22:             =           =         =         =     23:       4G = -5     4B = -1    4d = 2    2g = 7     24:       4E = -8     8cL = 0    4e = 4         .     25:             .    8BJ = -1         .         .     26:      4F# = -6     4A = -3    4d = 2  4dd = 14     27:             =           =         =         =     28:       4G = -5     4G = -5    2d = 2  4.b = 11     29:      4D = -10    4F# = -6         .         .     30:             .           .         .    8a = 9     31:       4E = -8     4G = -5   4B = -1    4g = 7     32:             =           =         =         =     33:      4C = -12     8cL = 0   8eL = 4   4.g = 7     34:             .    8BJ = -1    8d = 2         .     35:    8BBL = -13      4c = 0    8e = 4         .     36:    8AAJ = -15           .  8f#J = 6    8a = 9     37:     4GG = -17      4d = 2    4g = 7   4b = 11     38:             =           =         =         =     39:     2D; = -10     2d; = 2  2f#; = 6   2a; = 9     40:     4GG = -17      4d = 2    4g = 7   4b = 11 41-134::::::::::::::::::::::::::::::::::::::::::::::: ################ ^^^ chor001.krn ^^^ ################          (8 more files...)  ################ vvv chor010.krn vvv ################   1-60:::::::::::::::::::::::::::::::::::::::::::::::     61:    2AA; = -15     2c; = 0   2e; = 4   2a; = 9     62:       2A = -3      2e = 4    2a = 9  2cc = 12     63:             =           =         =         =     64:       4E = -8      4e = 4    4g = 7   4b = 11     65:     8DL = -10      4e = 4    4g = 7  4cc = 12     66:     8CJ = -12           .         .         .     67:     4BB = -13      4d = 2   8gL = 7  4dd = 14     68:             .           .   8fJ = 5         .     69:      4C = -12      4c = 0    4e = 4    4g = 7     70:             =           =         =         =     71:      4D = -10    8F# = -6    4d = 2   4b = 11     72:             .     4G = -5         .         .     73:      4D = -10           .    4c = 0    4a = 9     74:             .    8F# = -6         .         .     75:    2GG; = -17    2G; = -5  2B; = -1   2g; = 7     76:             =           =         =         =     77:      2C = -12     2G = -5    2e = 4    2g = 7     78:     4AA = -15     4A = -3    4e = 4  4cc = 12     79:       4E = -8    4G# = -4   8eL = 4   4b = 11     80:             .           .   8dJ = 2         .     81:             =           =         =         =     82:       4F = -7     4A = -3    4c = 0    4a = 9     83:      4C = -12     4G = -5    4c = 0    4e = 4     84:    4BB- = -14     4G = -5   [2d = 2    4g = 7     85:     4AA = -15     4A = -3         .    4f = 5     86:             =           =         =         =     87:    4GG# = -16     4B = -1   4d] = 2   1e; = 4     88:     4AA = -15     4A = -3    4c = 0         .     89:    2EE; = -20  2G#X; = -4  2B; = -1         .     90:             =           =         =         =     91:             *           *         *         *     92:  !!     93:  !!     94:  !!     95:  !!     96:  !!     97:  !!     98:  !!     99:  !!    100:  !! ################ ^^^ chor010.krn ^^^ ################      humdrumR corpus of ten files.      Data fields:               Token  :: character              Semits :: integer             *Pipe1  :: character"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/HumdrumSyntax.html","id":"structure-vs-content","dir":"Articles","previous_headings":"","what":"Structure vs Content","title":"The Humdrum Syntax","text":"humdrum syntax lays simple structure encoding data, says nothing content. information encoded, information represented flexible. flexibility, structure humdrum data—humdrum syntax—always , makes easy work ! fill content humdrum files, define “interpretations. Interpretations schemes represent information characters. sounds complicated/scary, can simple! instance, wanted encode drum beats humdrum invent simple scheme encoding drum beats : Kick drum = “K” Snare drum = “S” Hi-Hat = “H” treat newline text file sixteenth-note tick (read humdrum “timebase” ) start encoding. thing need make conform humdrum syntax name : call overarching interpretations like “exclusive interpretations”, prefixed **. call **drums ’d ready create humdrum data!","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/HumdrumSyntax.html","id":"syntax","dir":"Articles","previous_headings":"","what":"Syntax","title":"The Humdrum Syntax","text":"humdrum syntax , first glange, nothing simple, tab-delineated spread sheet. (“tab-delineated” just means columns spreadsheet separated TABs.) basic idea, extra features learn! Let’s take look basic humdrum file:  file can broken different types information like :  file two columns data, separated tabs. However, special terminology use: “columns” humdrum file called spines. line, row, file called record.  twenty records two spines file. character-string, located spine/record position, called token. Examples tokens file include *M4/4, 4A, =1, !Suspension.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/HumdrumSyntax.html","id":"global-vs-local","dir":"Articles","previous_headings":"Syntax","what":"Global vs Local","title":"The Humdrum Syntax","text":"’ll notice two records file (1 10) don’t seem two columns. Indeed, called “global” records—don’t belong particular column, whole row/file. image illustrates two spines file don’t include records 1 10:  real data :","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/HumdrumSyntax.html","id":"time","dir":"Articles","previous_headings":"Syntax","what":"Time","title":"The Humdrum Syntax","text":"one fundamental assumption regarding humdrum syntax encodes information: travel downward file (top bottom) encoding information order occurs time. true data records—interpetation comment records associated moment time first data record occurs . Information appears record (within one spine, different spines) assumed happen time.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/HumdrumSyntax.html","id":"record-types","dir":"Articles","previous_headings":"Syntax","what":"Record Types","title":"The Humdrum Syntax","text":"humdrum syntax recognizes four broad types records, five sub-types: Exclusive (**) Tandem (*) Reference (!!!) Global (!!) Local (!) Barlines (=) Data know type record ’re dealing looking first character token. tokens single record must type—can’t interpretation token comment token line. result, can refer type token, type whole record, tokens within record always type.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/HumdrumSyntax.html","id":"interpretations","dir":"Articles","previous_headings":"Syntax > Record Types","what":"Interpretations","title":"The Humdrum Syntax","text":"token starts *, interpretation token. Two stars ** indicates exclusive interpretation. Every spine must start exclusive interpretation, can one. exclusive interpretation spine tells us type information encoded spine, whole spine. instance, **drums interpration invented exclusive interpetation. examples ’re using , exclusive interpretation spines **kern, widely used humdrum interpretation, used encode music notation. Note humdrum file can different exclusive interpretations spine—don’t , example. read various humdrum interpretations defined, check humdrum.org.  token starts one *, called tandem interpretation. Tandem interpretations tell us specific, localized information interpret data. can different, overlapping tandem interpretations within spine. example, *C:, *Ibass, *M4/4, *M3/4, tandem interpretations. *C: used **kern indicate key C major. *Ibass indicates instrument associated spine (bass voice). *M4/4 *M3/4 indicate 4/4 3/4 meter respectively. last case brings something important tandem interprations: tandem interpretation applied subsequent data points, unless cancelled replaced another tandem intepretation type. Thus, humdrum file indicates 4/4 time starting record 5, switches 3/4 time record 13. However, *M4/4 record 4 doesn’t replace *C: record 3, different types tandem intepretations. One special token *- token. token indicates spine ends. *- missing end—one every spine—invalid humdrum file!","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/HumdrumSyntax.html","id":"comments","dir":"Articles","previous_headings":"Syntax > Record Types","what":"Comments","title":"The Humdrum Syntax","text":"token begins !, comment token. Comments used freely include comments data. global comments (!!) associated spine—apply whole file point appear—local comments (!) specific particular spine. example, !! Ritardando global comment, !Suspension local comment, specific second spine.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/HumdrumSyntax.html","id":"reference-records","dir":"Articles","previous_headings":"Syntax > Record Types > Comments","what":"Reference Records","title":"The Humdrum Syntax","text":"one final type comment: reference records. Reference records global comments placed beginning end file. Reference records encode global metadata entire file: things like composed piece title piece . Reference records specific “reference codes,” usually three digits, come !!!, followed colon, whatever content record . instance, code !!!OTL: refers original title piece. Learn various standard humdrum reference records .","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/Intervals.html","id":"intervals","dir":"Articles","previous_headings":"","what":"Intervals","title":"Rhythm and Pitch Intervals","text":"pitch time perceived relatively: relationship two points. Thus represent , conceptually, interval—difference. case pitch, interval two frequencies (abstractly, “tonal” interval circle--fifths). case rhythm, interval two time points—two onsets, onset offset. humdrumR, abstract intervals represented tonalInterval rhythmInterval objects, respectively. concretize abstract intervals, must establish relative . reference? actually multiple, useful ways can represent information. Since intervals relative, always implicit reference—origin, zero. tonalIntervals origin unison interval. rhythmIntervals origin zero. tonalIntervals rhythmIntervals constitute constitute algebraic module integers (module \\(\\mathbb{Z}\\)), appropriate arithmetic operations fully defined humdrumR. Since intervals can added/subtracted, interval can thought combination (addition) intervals. humdrumR, often “partition” interval combination useful sub-intervals.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/Intervals.html","id":"serial-and-fixed-reference","dir":"Articles","previous_headings":"Intervals","what":"Serial and Fixed Reference","title":"Rhythm and Pitch Intervals","text":"Vectors humdrumR intervals can represented two fundamental ways: serial reference representation fixed reference representation. illustrate, use two examples, one rhythmic, one pitched: major scale “tag-line” rhythm 3+3+3+3+2+2","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/Intervals.html","id":"fixed-reference","dir":"Articles","previous_headings":"Intervals > Serial and Fixed Reference","what":"Fixed reference","title":"Rhythm and Pitch Intervals","text":"fixed-reference representation, intervals interpreted relative fixed point (implicitly 0). Fixed-reference representations major scale (using semitones) tag-line rhythm follows: Note representation quite commonly used musicians, various forms, pitch. contrast, fixed-reference representations commonly used musicians rhythm. However, used contexts, essentially represent “time beginning” piece: Thus, timestamps/timelines DAWs “offsets” music21 examples fixed-reference representations time.","code":"referenceMajor   <- c(0, 2, 4, 5, 7, 9, 11, 12)  referenceTagline <- c(0, 3, 6, 9, 12, 14, 16)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/Intervals.html","id":"serial-reference","dir":"Articles","previous_headings":"Intervals > Serial and Fixed Reference","what":"Serial reference","title":"Rhythm and Pitch Intervals","text":"alternative representation serial-reference representation, interval measured relative previous one. Thus, data point represents local change (\\(\\Delta\\)) parameter. lossless (explained ) first element serial data vector measured relative implicit reference (0). Serial representations tag-line major scale follows: representations also fairly intuitive musicians—representing “melodic intervals”—music notation sequencers represent pitch. contrast, serial-reference representation rhythm normative: traditional music notation note values serial-reference representation.","code":"serialMajor   <- c(0, 2, 2, 1, 2, 2, 2, 1)  serialTagline <- c(0, 3, 3, 3, 3, 2, 2)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/Intervals.html","id":"transformations-interval-calculus","dir":"Articles","previous_headings":"Intervals > Serial and Fixed Reference","what":"Transformations (“Interval Calculus”)","title":"Rhythm and Pitch Intervals","text":"Since addition defined intervals fixed-reference serial-reference representations can translated . serial-reference representation can calculated pairwise differences elements fixed-reference data, first reference element appended beginning. Conversely, fixed-reference representation can calculated cumulative sum serial-reference data. Thus: humdrumR, refer two transformations delta (\\(\\Delta\\)) sigma (\\(\\Sigma\\)), differences sums respecticely. humdrumR, note relationship fixed- serial-reference representations analogous relationship function derivative. fixed-reference representation represents sequence independent values function (serial) index position. serial-reference representation represents sequence differences adjacent elements index—much fixed representation changes index. (Since first element serial-reference representation relative fixed (implicit) reference, normal one--many relationship derivatives functions removed, lossless one--one relationship maintained.) two transformations thus inverses : \\(x = sigma(delta(x))\\) \\(x = delta(sigma(x))\\). Derivative/Integral relationship Major Scale Derivative/Integral relationship Tagline Rhythm","code":"identical(cumsum(serialMajor), referenceMajor) ## [1] TRUE identical(cumsum(serialTagline), referenceTagline) ## [1] TRUE identical(c(referenceMajor[1], diff(referenceMajor)), serialMajor) ## [1] TRUE identical(c(referenceTagline[1], diff(referenceTagline)), serialTagline) ## [1] TRUE library(humdrumR) ## Loading required package: rlang ##  ## Attaching package: 'humdrumR' ## The following objects are masked from 'package:stats': ##  ##     integrate, lag, sigma ## The following object is masked from 'package:methods': ##  ##     signature identical(referenceMajor, sigma(delta(referenceMajor))) ## [1] TRUE identical(referenceMajor, delta(sigma(referenceMajor))) ## [1] TRUE"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/Intervals.html","id":"dynamic-reference","dir":"Articles","previous_headings":"Intervals","what":"Dynamic Reference","title":"Rhythm and Pitch Intervals","text":"Since intervals additive, another possibilty use one vector intervals reference point second vector intervals. allows us create dynamic reference points. examples Figured Bass: bass voice texture encoded (serial/reference reprsentation) voices represented relative bass voice. Chord Tones: abstract “root” chord progression represented one vector, vectors representing “chord tones” (root, 3rd, 5th, 7th, etc.) relative chord root. Scale degrees: tonic key used dynamic reference, notes calculated relative tonic. Figured Bass Calculating dynamic reference intervals lossless complete information reference intervals maintained. instance, keep track serial fixed intervals bass voice. , keep track local key (usually using fixed interval “C”).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/KeysAndChord.html","id":"diatonic-sets","dir":"Articles","previous_headings":"","what":"Diatonic Sets","title":"Diatonic and Tertian Sets in humdrumR","text":"mentioned Pitch Tonality vignette, normative diatonic key consists set seven consetutive pitch chroma Line Fifths. diatonic set can orderd either line--fifths position: “scale-order,” corresponds steps \\(+2\\) (\\(-5\\)) modulo 7.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/KeysAndChord.html","id":"tertian-sets","dir":"Articles","previous_headings":"","what":"Tertian Sets","title":"Diatonic and Tertian Sets in humdrumR","text":"set seven notes diatonic key can reimagined chord—set notes played time. Specifically, full seven-note diatonic chord refered 13th chord. However, chords used tonal music subsets full diatonic set, particular three-note triads. viewing diatonic set chord, traditionally order set sequence ascending thirds, corresponding intervals \\(+4\\) line--fifths, modulo 7. tertian steps usually wrapped octave, resulting steps 9, 11, 13, instead 2, 4, 6. \\(2^7=\\) 128 possible subsets can formed full diatonic set. , seven possiblities built consecutive tertian steps theoritically priveledged : .e., \\(\\{\\{1\\}, \\{1,3\\}, \\{1,3,5\\}, \\{1,3,5,7\\}, \\{1,3,5,7,9\\}, \\{1,3,5,7,9,11\\}, \\{1,3,5,7,9,11,13\\}\\}\\). possible sets fairly commonplace Western theory well: \\(\\{1,5, 11\\}\\) (“sus4”), \\(\\{1,3,5,9\\}\\) (“add9”), \\(\\{1,3,5,13\\}\\) (“add6”), etc.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/KeysAndChord.html","id":"concrete-representations","dir":"Articles","previous_headings":"Tertian Sets","what":"Concrete Representations","title":"Diatonic and Tertian Sets in humdrumR","text":"numerous ways tertian sets notes traditionally notated annotated character strings. Unfortunately, systems always rigorously consisistent logical, convenient shorthands common chords lead ambiguity, /practices rooted traditional practices little relavance. humdrumR aims provide general approach make reading/writing chord annotations many forms possible. chord representation consists set least one following elements: root note. bass note. subset tertian steps present. Qualities chord steps, relative implicit explicit key. Traditional chord notation symbols often conflate merge various elements various ways, numerous common shorthands. particular, common diatonic traids—abstractly different combinations qualities 3rd 5th—represented various shorthands.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/KeysAndChord.html","id":"section","dir":"Articles","previous_headings":"","what":"Diatonic and Tertian Sets in humdrumR","title":"Diatonic and Tertian Sets in humdrumR","text":"Chord symbols tonal chroma practice often used indicate bass note part ostensible chord. instance, C7/Ab. consist form, unique symbol appended indicate one four unique triad types: major, minor, diminished, augmetned. However, cases, major assumed default, can ommitted. cases, either major minor symbol ommited, case root symbol used indicate major minor. (cases, case root symbol also matched diminished (lower) augmented (major) symbols).) Roman numerals 7ths 753 7, 653 65, 643 43, 642 42 2 9ths 9753: 1111100 7653: 1111001 6543: 1110011 6432: 1100111 7642: 1001111 11ths 11","code":"753:     1111000 653:     1110001 643:     1100011 642:     1000111"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/Overview.html","id":"what-is-humdrum","dir":"Articles","previous_headings":"","what":"What is humdrum?","title":"Overview of humdrumR","text":"Humdrum system analyzing blah blah.","code":"library(humdrumR) #> Loading required package: rlang #>  #> Attaching package: 'humdrumR' #> The following objects are masked from 'package:stats': #>  #>     integrate, lag, sigma #> The following object is masked from 'package:methods': #>  #>     signature"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"tonal-intervals","dir":"Articles","previous_headings":"","what":"Tonal Intervals","title":"Pitch and Tonality in humdrumR","text":"tl;dr: humdrumR encodes tonal pitch information intervals fundamental line--fifths (tonal), combined octave value indicate pitch height,. tonalInterval class core pitch representation humdrumR. name suggests, pitch encoded tonally. means focus representation line--fifths (LoF). Pitch names (letters accidentals), intervals, diatonic keys tertian harmonies make logical sense defined line--fifths. want define specific pitches frequency space, add specific “pitch-height” information, encoded separate octaves field.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"psychoacoustics-and-the-western-tuning-system","dir":"Articles","previous_headings":"Tonal Intervals","what":"Psychoacoustics and the Western Tuning System","title":"Pitch and Tonality in humdrumR","text":"tl;dr: Tonal intervals represented combinations octaves (second harmonic, 2:1 ratio) perfect 12ths (third harmonic, ~3:1 ratio). perfect 12ths represent circle--fifths diatonic collections octaves help specific specific pitch height. first glance, pitch appears straightforward, one-dimensional phenomenon: every “pitched event” frequency (perceptually) associated . refer frequency associated event ’s “pitch”—, ’ll use term frequency pitch interchangeably. Human can percieve frequencies ranging approximately \\(20\\)–\\(20,000_{Hz}\\). (“Hz” abbreviation Hertz; e.g. cycles-per-second.)  However, perception pitch predominantly relative, absolute. words, (us) can’t identify specific frequenncies isolation; instead, percieve “distance” pitches, call interval. specfically, percieved distance/intervals frequencies rationally: distance percieve ratio pitches. example, “distance” frequencies \\(200_{Hz}\\) \\(300_{Hz}\\) distance \\(2,400_{Hz}\\) \\(3,600_{Hz}\\). ? ratios: \\(\\frac{200}{300} = \\frac{2,400}{3,600}\\)! means makes sense think enormous \\(20\\)–\\(20,000_{Hz}\\) frequency range percieve logarithmic scale, makes equal distance look equal paper:","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"octave-equivalence","dir":"Articles","previous_headings":"Tonal Intervals > Psychoacoustics and the Western Tuning System","what":"Octave Equivalence","title":"Pitch and Tonality in humdrumR","text":"perceive distance (interval) pitches based ratio frequencies. ratios created equal! simplest, integer ratios privileged perception—simply sound better, consonant, us! Integer ratios frequencies called harmonics. simplest, purest harmonic relationship 2--1 ratio, call octave. Pitches separated octave consonant actually perceive “pitch” (respects). call sameness octave equivalence. two pitches octave equivalent—.e., ratio frequencies power two—say pitch chroma. following figure, three rows frequencies represent groups pitches equivalent chroma:  Due perceptual reality octave equivalence, (essentially ) musical scales use octave bounding point—patterns pitch chroma (e.g., scales) repeated octave can perceive. Thus, even though can perceive close ten octaves worth frequencies, organization pitch music mostly based pitches can squeezed single octave.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"tonal-harmonics","dir":"Articles","previous_headings":"Tonal Intervals > Psychoacoustics and the Western Tuning System","what":"Tonal Harmonics","title":"Pitch and Tonality in humdrumR","text":"2--1 harmonic octave, however, whole story. next couple integer (harmonic) ratios also special, perceptually: third fifth harmonics—corresponding major scale degrees \\(\\hat{5}\\) (perfect fifth) \\(\\hat{3}\\) (major third) respectively—influenced development Western tonality. say, musical scales tuned way create ratios scale degrees close 3--1 5--1 possible. “Just intonation” preeminent Western example. third harmonic (\\(\\approx\\hat{5}\\)) primary factor Western tonal system—humdruMR call tonal harmonic. Western diatonic scale constructed, fundamentally, arranging 3rd-harmonic intervals within octave. logical result approach octave divided five (pentatonic), seven (diatonic), twelve (chromatic) unequal steps.  seven-note diatonic fundamental unit Western tonality several thousand years. chromatic (12-note) superset gradually grown prominence last five centuries, yet tonal contexts, chromatic set still distinctly superset diatonic, seen diatonic set plus five “alterations.”  Thus, 3rd-harmonic fundamental generator Western diatonic scale, diatonic keys, tonality general. Throughout humdrumR often refer line--fifths (circle--fifths), “fifths” stacked 3rd harmonics.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"pythagorean-tuning","dir":"Articles","previous_headings":"Tonal Intervals > Psychoacoustics and the Western Tuning System","what":"Pythagorean Tuning","title":"Pitch and Tonality in humdrumR","text":"tl;dr: sections talks abstract line--fifths “tonal harmonics” tuned actual pitches. part, doesn’t really matter much within Western music; assume equal temperament time. tonal analyses don’t really depend specific flavor Western tuning/temperament use. scale actually tuned “pure” 3rd-harmonics results pythagorean tuning. However, centuries, Western musicians systematically mistuned, tempered, 3rd-harmonic ratios order produce pure 5th harmonics (meantone temperament) minimize dissonance 2nd harmonic (equal temperament). example, twelve fifths flattened \\(\\sqrt[{12}]{\\frac{3^{19}}{2^{12}}}\\) (2 cents), result chromatic scale equally divides octave—creating semitones. equal temperament tuning system dominant West less 250 years. Despite ubiquity equal temperament modern era, Pythagorean tuning—variants incorporate pure 5th harmonic—remains conceptual basis Western tonality. Notably, Pythagorean tuning, pitches separated twelve fifths . traditional notation theory distinguishes , example, G# Ab, minor-3rd augmented-2nd. contrast, equal temperament, values “enharmonic”—.e., equivalent. Equally-tempered G# Ab played frequency within tonal organization Western music still reflect perceptually distinct categories: example, G# key E major Ab key F minor quite distinct!","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"line-of-fifths","dir":"Articles","previous_headings":"Tonal Intervals > Psychoacoustics and the Western Tuning System","what":"Line-of-Fifths","title":"Pitch and Tonality in humdrumR","text":"fifth-based tonal system results general structure known line fifths (LoF). “step” LoF corresponds fifth (.e., 3rd-harmonic ratio). LoF ranges \\(-\\infty\\)–\\(\\infty\\), zero corresponding “unison” interval, root, note C. complete chromatic set consists 12 contiguous steps LoF—apply modulo 12 transformation, chromatic twelfth step first “enharmonically.” modulus operation turns line--fifths circle--fifths (CoF). Seven contiguous values line--fifths form diatonic scale, tonal key. Shifting contiguous block /line gets us different keys Western music. perform modulo 7 operation LoF, get pure diatonic set—“chromatic” notes mapped diatonic counterpoints.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"encoding-tonal-pitches","dir":"Articles","previous_headings":"Tonal Intervals","what":"Encoding Tonal Pitches","title":"Pitch and Tonality in humdrumR","text":"mimic fundamental logic Western tonality, tonalIntervals represented combination 2nd- 3rd- harmonic powers. encoded integers Octave Fifth fields respectively. Fifth slot represents “tonal chroma”—line--fifths space diatonic chromatic structures defined. Octave slot specifies specific shifts absolute frequency. Fifth Octave fields combined represent specific notes. combination modeled way harmonic ratios combine Pythagorean tuning. Octave value represents power 2 (\\(2^n\\)), Fifth value represents power 3 (\\(3^n\\)), values multiplied together (human rational/logarithmic perception pitch works). Thus, \\(2^{Octave} * 3^{Fifth} = \\text{tonal interval}\\) example, tonalInterval (Octave = -2, Fifth = 2) represents \\(2^{-2} * 3^{2} = \\frac{1}{4} * 9 = \\frac{9}{4}\\) corresponds (Pythagorean) major-9th. tonalInterval representation sense “locked” Pythagorean tuning. “tempered fifth” can used generating “tonal harmonic” ratio: \\(2^{Octave} * \\text{tonalHarmonic}^{Fifth} = \\text{tonal interval}\\) instance, \\(\\text{tonalHarmonic} = 2^{\\frac{19}{12}}\\), result equal temperament. humdrumR functions relate precise frequency values—frequency—tonalHarmonic argument. discussion illustrates “actual” harmonic use generate frequencies largely irrelevant. combination Octave Fifth integer slots represents Western “pitch space” abstractly. many research use cases, ignore Octave field altogether, considering abstract “tonal chroma” (.e., line--fifths) described Fifth slot. (Indeed, diatonicSet tertianSet classes concerned abstract “tonal space.”) following figure illustrate dimensions tonalInterval vector map pitches labeled “scientific pitch notation.” Scientific Pitch representation tonalIntervals can see, Fifth (x) dimension simply line--fifths. However, way Octave dimension relates specific pitches intuitive. design. tonalInterval \\(2^{Octave} * 3^{Fifth}\\) scheme meant engaged directly users. Rather back-end, nice properties:","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"algebra-and-arithmetic","dir":"Articles","previous_headings":"Tonal Intervals > Encoding Tonal Pitches","what":"Algebra and Arithmetic","title":"Pitch and Tonality in humdrumR","text":"Tonal intervals defined constitute algebraic module integers (module \\(\\mathbb{Z}\\)), appropriate arithmetic operations fully defined humdrumR. module, necessarily abelian groups, requisite operations: tonalIntervals can added (+) subtracted (-), resulting new tonalIntervals. example, \\(\\text{P5} + \\text{M2} = \\text{M6}\\). tonalIntervals “negative,” inverted counterpart. Summing tonalInterval ’s negative/inversion results identity element. example, \\(-\\text{M3} + \\text{M3} = \\text{P1}\\). identify element—“reference point”, middle C, unison. (Octave\\(= 0\\) Fifth \\(=0\\).) modules, tonalIntervals can also multiplied “scalar” integer values. instance, \\(\\text{P5} * 2 = \\text{M9}\\). Finally, tonalIntervals euclidean division (%/%) modulo/remainder (%%) operations defined. (Rational division (/ R) defined.) Euclidean division tonalIntervals based tonal (fifths) space, frequency space. useful articulating tonal structures (modulo 7 example), can unintuitive applied specific pitches.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"tonal-interval-representations","dir":"Articles","previous_headings":"","what":"Tonal Interval Representations","title":"Pitch and Tonality in humdrumR","text":"Western music theory/practice rich set interrelated ways describing pitch: “C#”, “G”, “Eb” “+M3”, “+P5”, “-M2” “M3”, “P11”, “P8” “P1”, “P5”, “d5” “”, “mi”, “” humdrumR, concrete representations simply different perspectives abstract information—“tonal intervals” can represented tonalInterval objects. differ 1) fixed-reference, dynamic-reference, serial-reference interpretations; 2) whether Octave information included; 3) “tonal modulo” used. first, musicians may taken aback system: accustomed thinking values like F# “absolute” pitch representations, “” “relative” pitch representations, melodic intervals , well, melodic intervals. However, recognizing essentially equivalent powerful. Thus, “middle C” equivalent “unison”, “”, “P1”, “Tonic.” letter names really “absolute” quite evident many musical practices. Transposing instruments notated relative middle C, middle C defined relative “concert pitch.” Similarly, guitars often “drop-tuned” capoed, chords still identified using names relative open strings. following figure equivalent figure XXX, shows interval values instead. Interval Representation tonalIntervals","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"tonalinterval-partitions","dir":"Articles","previous_headings":"Tonal Interval Representations","what":"tonalInterval Partitions","title":"Pitch and Tonality in humdrumR","text":"Many practical distinctions different “concrete” representation pitch (previous section) boil different ways partition (discard) tonalInterval information. begin, can distinguish tonal height dimensions pitch. Tonal pitch information (like “Major third” “c#”) can abstract, corresponding specific frequencies. Thus, abstract c# neither “” “” g#. However, tonal intervals ordered scales—wrapped within octave. can “round” differently unison. Scaled tonal intervals still best regarded abstract. combination octave information get complex intervals. \\[ \\begin{aligned} TonalInterval = Octave \\times LoF Octave = \\mathbb{Z} LoF = \\mathbb{Z} \\end{aligned} \\] Every tonal interval combines simple interval octave offset. simple interval octave complex interval. \\[ \\begin{aligned} Complex = Simple \\times Octave  Specific = Alteration + Quality + Generic Generic = Step Alteration = Comma + Accidental \\end{aligned} \\] scale step one seven numbers line--fifths, 0 6, corresponding seven scale steps: 0 = Unison, 2 = Second, 4 = Third, 6 = Fourth, 1 = Fifth, 3 = Sixth, 5 = Seventh. \\[ \\] \\[ \\begin{aligned} Step = \\{0, 1, 2, 3, 4, 5 ,6\\} Quality(Key) \\subset Step \\times \\{7q\\ |\\ q \\\\Mathbb{z}\\} \\end{aligned} \\] \\[ \\begin{aligned} Octave + (Key + (Quality + Step) + Alteration + Comma) = Pitch Pitch - Octave = Specific (Step + Quality) + Alteration = Specific \\end{aligned} \\] \\[ Amajor_{Key} + \\hat{3}_{Step} + Major_{Quality} + Flat_{Alteration} = C natural \\]","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"simple-and-complex","dir":"Articles","previous_headings":"Tonal Interval Representations > tonalInterval Partitions","what":"Simple and Complex","title":"Pitch and Tonality in humdrumR","text":"HumdrumR tonalIntervals can represent complex interval: .e., intervals octave. instance, can distinguish “M2” “M9”. many cases, want partition intervals simple part octave part: simple part interval “within” one octave; general part simply number octaves.1 interval includes ’s octave part, called complex interval: \\(\\text{interval}_{simple} + \\text{interval}_{octave} = \\text{interval}_{complex}\\) actually four different ways make simple/octave partition, depending “round” intervals octave. four methods correspond four different ways rounding numbers general. terms base:: R functions: floor: round towards \\(-\\infty\\)—simple part always positive. common (default) approach simple intervals, used many pitch representations (notably, scale degrees). ceiling: round towards \\(\\infty\\)—simple part always negative. unusual use case. trunc: “truncate” (round) towards zero—two parts sign complex interval. method preserves direction interval. expand: “expand” (round) away zero—octave part always sign complex interval, whiel simple part opposite sign complex interval. round: round nearest octave, regardless direction. method results simple intervals always less 5th size. combined abs, result interval class (intervals equivalent inversions).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"contour","dir":"Articles","previous_headings":"Tonal Interval Representations > tonalInterval Partitions > Simple and Complex","what":"Contour","title":"Pitch and Tonality in humdrumR","text":"completely represent tonal interval, octave specific parts required. Many common analytical representations use “pure line--fifths,” simple part—solfege, scale degree, roman numerals, chord degrees, etc.. octave part discarded, (specific) original pitches reconstructed. Another useful representation combination fixed-reference simple part serial-reference (delta) octave part. representation, octave part represents contour melody. call derived contour. Throughout humdrumR, adopt representation Rolling Stone dataset use \"^\" \"v\" represent upward downward derived contours. Thus, \"vla\" means, go nearest \"la\". mentioned , tonalIntervals invertible—can positive negative. corresponds “direction” motion frequency space, relative reference. reference serial, corresponds melodic contour. Throughout humdrumR, adopt standard (obvious) **mint representation’s use \"+\" \"-\" represent true (sigma) contour.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"generic-and-specific","dir":"Articles","previous_headings":"Tonal Interval Representations > tonalInterval Partitions","what":"Generic and Specific","title":"Pitch and Tonality in humdrumR","text":"HumdrumR tonalIntervals can represent specific tonal, interval: instance, can distinguish “M2” “m2”. many cases, want partition intervals tonally, generic parts alteration parts: generic part interval within (diatonic) key—also called generic step; alteration part represents specific quality interval relative key (.e., perfect/major/minor), including shifts outside key (augment/diminish, sharp/flat, etc.). generic/alteration partition must made given key, including root mode. means generic/alteration partition can lossy key used lost—words, need know key used partition reconstruct specific interval. default key C major (\\(-1\\) \\(5\\) circle--fifths). \\(\\text{key} + \\text{interval}_{generic} + \\text{interval}_{alteration} = \\text{interval}_{specific}\\)","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"cautionary-qualities","dir":"Articles","previous_headings":"Tonal Interval Representations > tonalInterval Partitions > Generic and Specific","what":"Cautionary Qualities","title":"Pitch and Tonality in humdrumR","text":"cases want know tonally partition tonalInterval relative key, relative another key! One example “cautionary” accidentals music notation—“cautionary” accidentals involve pitches generic particular key (like major), generic C major. Another example chord quality annotations given key (instance, major IV chord minor key raised 6th scale degree, scale degrees secondary key. Condsider piece written C major, subsection modulates E major. E major section, observe D natural—generic interval ? Obviously, many analytical purposes, ’d want think Emajor, correspond \\(\\text{Emaj} + \\text{B}_{generic} + \\text{b}_{alteration}\\)—.e., flatted seventh degree E major. However, accidental note notated ? flat course, even though “flattened” seventh. (C major) key signature require accidental D natural, ’d like one clarify note’s relationship current key. first partition note E major, partition resulting generic interval C major, get: \\(\\text{Emaj} + (\\text{Cmaj} + \\text{D}_{generic} + \\text{#}_{alteration}) + \\text{b}_{alteration}\\) sharp flat—cases, use symbol natural.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"enharmonic-and-comma","dir":"Articles","previous_headings":"Tonal Interval Representations > tonalInterval Partitions","what":"Enharmonic and Comma","title":"Pitch and Tonality in humdrumR","text":"HumdrumR tonalIntervals can represent tonal pitch circle--fifths, even G#######! context equal-temperament tuning, consider tones separated 12 steps circle--fifths “”—enharmonic. Thus, equal temperament, interval diminished second—also known pythagorean comma—identical unison. can thus partition notes combinations harmonic part comma part. \\(\\text{interval}_{enharmonic} + \\text{interval}_{comma} = \\text{interval}_{tonal}\\) strictly wrap around every 12 steps line--fifths (.e., modulo 12), remove enharmonic equivalencies, creating circle--fifths. However, wrap matters: musical practice, typically aim center circle fifths around C, get roughly equal number flats sharps. However, since five accidentals, strict enharmonics either 2-flats/3 sharps, 3-flats/3-sharps. Since, natural diatonic scale spans range -1:5 line--fifths, real center 2 (D). (change key signatures, want shift accordingly, allowing higher sharps sharp key, instance.) Thus, default behavior humdrumR center set tints relative center given key, enharmonically shift notes >= 6 < -6. cases, don’t actually want strict enharmonicism. instance, might want allow Dbi—even Gb Cbi—alongside C#, F#, B, still want Bbb Gbbb ##. humdrumR, can specify wider “enharmonicWrap” value argument enharmonicpart. enharmonicWrap argument specifies width band “legal” LoF values want allow. default 12, results perfect enharmonic circle fifths (Eb:G#), enharmonic equivalences. increase 13, allow Ab G# exist; increase 14, allow Eb D# exist; etc. enharmonicWrap 21 allows single-flat single-sharp notes, double flat/sharps.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"methods","dir":"Articles","previous_headings":"","what":"Methods","title":"Pitch and Tonality in humdrumR","text":"humdrumR exports numerous functions converting /tonalIntervals various string representations, well integer/numeric representations: tonalInterval -> tonalInterval integer -> (semit) -> tonalInterval numeric -> (semit) -> tonalInterval character -> (regex) -> tonalInterval double + tonalInterval -> numeric (ratio) tonalInterval -> integer character -> integer numeric -> integer tonalInterval -> integer character -> (regex) -> integer numeric -> integer tonalInterval -> character integer -> (fifth -> tonalInterval) -> character tonalInterval -> character character -> (regex -> tonalInterval) -> character tonalInterval -> tonalInterval character -> (regex -> tonalInterval) -> character integer -> (semits) -> character numeric -> (ratio) -> character tonalInterval -> character tonalInterval -> character character -> (regex -> tonalInterval) -> character integer -> (semits -> tonalInterval) -> character numeric -> (ratio -> tonalInterval) -> character tonalInterval -> character character -> (regex -> tonalInterval) -> character integer -> (semits -> tonalInterval) -> character numeric -> (ratio -> tonalInterval) -> character tonalInterval -> character character -> (regex -> tonalInterval) -> character integer -> (fifth -> tonalInterval) -> character tonalInterval -> numeric character -> (regex -> tonalInterval) -> numeric integer -> (fifth -> tonalInterval) -> numeric numeric -> numeric tonalInterval -> character character -> (regex -> tonalInterval) -> character integer -> (fifth -> tonalInterval) -> character numeric -> character tonalInterval -> numeric character -> (regex -> tonalInterval) -> numeric integer -> (fifth -> tonalInterval) -> numeric numeric -> numeric","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"arguments","dir":"Articles","previous_headings":"Methods","what":"Arguments","title":"Pitch and Tonality in humdrumR","text":"Various tonal interval functions share number common arguments.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"diatonicset","dir":"Articles","previous_headings":"Methods","what":"diatonicSet","title":"Pitch and Tonality in humdrumR","text":"diatonicSet S4 class represents diatonic keys. Like tonalIntervals, conceptualize keys interval—distance reference point, Cmajor. means can represent key “G major” key “V” (major dominant key) way. diatonicSet contains three integer slots: Root, Mode, Alterations. addition, slot can hold another diatonicSet, allowing recursive representation, la “V/V/V.”","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"root-and-key","dir":"Articles","previous_headings":"Methods > diatonicSet","what":"Root and Key","title":"Pitch and Tonality in humdrumR","text":"Root integer slot simply line--fifths tonal chroma value representing root key relative 0 (C). Key value represents key signature: number sharps (positive integers) flats (negative integers) key. Alternatively, equivalently, can think Key like : C major represents contiguous block seven fifths (-1–5), Key argument shifts block . Key = 2, block line--fifths 1–7 (key signature two sharps). relationship Root Key determines mode diatonic set. Root == Key, mode major. modes can created : specific examples:","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"alteration","dir":"Articles","previous_headings":"Methods > diatonicSet","what":"Alteration","title":"Pitch and Tonality in humdrumR","text":"Alteration slot diatonicSet allows representation “altered” diatonic scales. One way thinking Key slot, takes one edge 7-fifth contiguous block moves opposite side. Alteration slot takes second extreme element moves 7 fifths.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/PitchAndTonality.html","id":"tertianset","dir":"Articles","previous_headings":"Methods","what":"TertianSet","title":"Pitch and Tonality in humdrumR","text":"Roman numerals.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/ReadWrite.html","id":"reading-humdrum-data","dir":"Articles","previous_headings":"","what":"Reading humdrum data","title":"Reading and writing data with humdrumR","text":"readHumdrum function gateway humdrumR: function use read humdrum data, encoded humdrum-syntax text files, R.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/ReadWrite.html","id":"practice-data","dir":"Articles","previous_headings":"Reading humdrum data","what":"Practice Data","title":"Reading and writing data with humdrumR","text":"following examples, make use small number raw humdrum data files included humdrumR. access files, need navigate directory computer installed humdrumR—fortunately, humdrumR records directory computer variable called humdrumRroot. load humdrumR library, just need set R “working directory” location using command setwd. humdrum data stored subdirectory called “HumdrumData”—can look contents directory using dir(recursive = TRUE): can see, five directories containing total fifty files.","code":"library(humdrumR) setwd(humdrumRroot) dir('HumdrumData', recursive = TRUE) #>  [1] \"BachChorales/chor001.krn\"                   #>  [2] \"BachChorales/chor002.krn\"                   #>  [3] \"BachChorales/chor003.krn\"                   #>  [4] \"BachChorales/chor004.krn\"                   #>  [5] \"BachChorales/chor005.krn\"                   #>  [6] \"BachChorales/chor006.krn\"                   #>  [7] \"BachChorales/chor007.krn\"                   #>  [8] \"BachChorales/chor008.krn\"                   #>  [9] \"BachChorales/chor009.krn\"                   #> [10] \"BachChorales/chor010.krn\"                   #> [11] \"BeethovenVariations/B075_00_01_a.krn\"       #> [12] \"BeethovenVariations/B075_00_02_a.krn\"       #> [13] \"BeethovenVariations/B075_00_03_a.krn\"       #> [14] \"BeethovenVariations/B075_00_04_a.krn\"       #> [15] \"BeethovenVariations/B075_00_05_a.krn\"       #> [16] \"BeethovenVariations/B075_00_06_a.krn\"       #> [17] \"BeethovenVariations/B075_01_01_a.krn\"       #> [18] \"BeethovenVariations/B075_01_02_a.krn\"       #> [19] \"BeethovenVariations/B075_01_03_a.krn\"       #> [20] \"BeethovenVariations/B075_01_04_a.krn\"       #> [21] \"BeethovenVariations/B075_01_05_a.krn\"       #> [22] \"BeethovenVariations/B075_01_06_a.krn\"       #> [23] \"MozartVariations/M354_00_01a_a.krn\"         #> [24] \"MozartVariations/M354_00_02b_a.krn\"         #> [25] \"MozartVariations/M354_00_03c_a.krn\"         #> [26] \"MozartVariations/M354_00_04d_a.krn\"         #> [27] \"MozartVariations/M354_01_01a_a.krn\"         #> [28] \"MozartVariations/M354_01_02b_a.krn\"         #> [29] \"MozartVariations/M354_01_03c_a.krn\"         #> [30] \"MozartVariations/M354_01_04d_a.krn\"         #> [31] \"RapFlow/2pac_IGetAround.rap\"                #> [32] \"RapFlow/BeastieBoys_BrassMonkey.rap\"        #> [33] \"RapFlow/Coolio_GangstasParadise.rap\"        #> [34] \"RapFlow/Ludacris_MoneyMaker.rap\"            #> [35] \"RapFlow/NotoriousBIG_Hypnotize.rap\"         #> [36] \"RapFlow/RobBase_ItTakesTwo.rap\"             #> [37] \"RapFlow/WillSmith_Summertime.rap\"           #> [38] \"RollingStoneCorpus/all_apologies.hum\"       #> [39] \"RollingStoneCorpus/back_in_black.hum\"       #> [40] \"RollingStoneCorpus/blue_suede_shoes.hum\"    #> [41] \"RollingStoneCorpus/born_to_be_wild.hum\"     #> [42] \"RollingStoneCorpus/god_only_knows.hum\"      #> [43] \"RollingStoneCorpus/hey_jude.hum\"            #> [44] \"RollingStoneCorpus/i_walk_the_line.hum\"     #> [45] \"RollingStoneCorpus/kashmir.hum\"             #> [46] \"RollingStoneCorpus/layla.hum\"               #> [47] \"RollingStoneCorpus/lets_stay_together.hum\"  #> [48] \"RollingStoneCorpus/living_for_the_city.hum\" #> [49] \"RollingStoneCorpus/me_and_bobby_mcgee.hum\"  #> [50] \"RollingStoneCorpus/your_song.hum\""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/ReadWrite.html","id":"targeting-files","dir":"Articles","previous_headings":"Reading humdrum data","what":"Targeting files","title":"Reading and writing data with humdrumR","text":"use readHumdrum call function one () character-string arguments. (function documentation (?readHumdrum), ’ll see arguments called ...—R, ... means number arguments.) arguments interpreted regular expressions, matched directories files system. call “REpath-patterns,” short Regular Expression directory-path patterns. example, uses REpath-pattern \"HumdrumData/BachChorales/chor.*.krn\" match files ‘HumdrumData/BachChorales’ directory whose name matches regular expression “chor..krn.” can see, REpath-pattern includes directory (folder) paths (relative absolute)—using operating system’s appopriate delimeter (”\" windows, ”/” everybody else)—* pattern matching file paths. directory also treated regular expression, possibly matching multiple directories. Let’s break : humdrumR splits REpath-pattern input string three parts: \"HumdrumData\", \"BachChorales\", \"chor.*.krn\", treats three regular expressions. first two expressions used match directories, last expression used match files. , readHumdrum('HumdrumData/BeethovenVariations/.*.krn') matches files ”.krn” extension “BeethovenVariations” directories readHumdrum('HumdrumData/MozartVariations/.*.krn') matches files “MozartVariations” directories, command readHumdrum('HumdrumData/.*Variations/.*.krn') match kern files directories! careful: since directory/file name always treated like regular expression, can sometimes specify something general intend. instance, command readHumdrum('MyFolder/.*') match files folder called “MyFolder,” also match folders names “MyFolder_Also”, “ThisIsMyFolder.” want sure match exactly one one directory/file, use “^” “$” regular-expression markers explicitely mark beginning end pattern: command readHumdrum('^MyFolder$/.*') read files one directory “MyFolder.” read test files can enter: Note: Since humdrumR can read files multiple directories , possible two files file name, different directories matched. happens, humdrumR identifies file enough ’s directory path make sure unique.","code":"library(humdrumR) setwd(humdrumRroot)  readHumdrum('HumdrumData/BachChorales/chor.*.krn') #> ############################# vvv chor001.krn vvv ############################# #>      1:  !!!COM: Bach, Johann Sebastian #>      2:  !!!CDT: 1685/02/21/-1750/07/28/ #>      3:  !!!OTL@@DE: Aus meines Herzens Grunde #>      4:  !!!OTL@EN:      From the Depths of My Heart #>      5:  !!!SCT: BWV 269 #>      6:  !!!PC#: 1 #>      7:  !!!AGN: chorale #>      8:          **kern        **kern        **kern        **kern #>      9:          *ICvox        *ICvox        *ICvox        *ICvox #>     10:          *Ibass       *Itenor        *Ialto       *Isoprn #>     11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano #>     12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] #>     13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] #>     14:             *>A           *>A           *>A           *>A #>     15:         *clefF4      *clefGv2       *clefG2       *clefG2 #>     16:          *k[f#]        *k[f#]        *k[f#]        *k[f#] #>     17:             *G:           *G:           *G:           *G: #>     18:             *F:             *             *             * #>     19:           *M3/4         *M3/4         *M3/4         *M3/4 #>     20:          *MM100        *MM100        *MM100        *MM100 #>     21:             4GG            4B            4d            4g #>     22:              =1            =1            =1            =1 #>     23:              4G            4B            4d            2g #>     24:              4E           8cL            4e             . #>     25:               .           8BJ             .             . #>     26:             4F#            4A            4d           4dd #>     27:              =2            =2            =2            =2 #>     28:              4G            4G            2d           4.b #>     29:              4D           4F#             .             . #>     30:               .             .             .            8a #>     31:              4E            4G            4B            4g #>     32:              =3            =3            =3            =3 #>     33:              4C           8cL           8eL           4.g #>     34:               .           8BJ            8d             . #>     35:            8BBL            4c            8e             . #>     36:            8AAJ             .          8f#J            8a #>     37:             4GG            4d            4g            4b #>     38:              =4            =4            =4            =4 #>     39:             2D;           2d;          2f#;           2a; #>     40:             4GG            4d            4g            4b #> 41-134::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: #> ############################# ^^^ chor001.krn ^^^ ############################# #>  #>      (8 more files...) #>  #> ############################# vvv chor010.krn vvv ############################# #>   1-60::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: #>     61:            2AA;           2c;           2e;           2a; #>     62:              2A            2e            2a           2cc #>     63:              =9            =9            =9            =9 #>     64:              4E            4e            4g            4b #>     65:             8DL            4e            4g           4cc #>     66:             8CJ             .             .             . #>     67:             4BB            4d           8gL           4dd #>     68:               .             .           8fJ             . #>     69:              4C            4c            4e            4g #>     70:             =10           =10           =10           =10 #>     71:              4D           8F#            4d            4b #>     72:               .            4G             .             . #>     73:              4D             .            4c            4a #>     74:               .           8F#             .             . #>     75:            2GG;           2G;           2B;           2g; #>     76:             =11           =11           =11           =11 #>     77:              2C            2G            2e            2g #>     78:             4AA            4A            4e           4cc #>     79:              4E           4G#           8eL            4b #>     80:               .             .           8dJ             . #>     81:             =12           =12           =12           =12 #>     82:              4F            4A            4c            4a #>     83:              4C            4G            4c            4e #>     84:            4BB-            4G           [2d            4g #>     85:             4AA            4A             .            4f #>     86:             =13           =13           =13           =13 #>     87:            4GG#            4B           4d]           1e; #>     88:             4AA            4A            4c             . #>     89:            2EE;         2G#X;           2B;             . #>     90:              ==            ==            ==            == #>     91:              *-            *-            *-            *- #>     92:  !!!hum2abc: -Q '' #>     93:  !!!title: @{PC#}. @{OTL@@DE} #>     94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** #>     95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** #>     96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** #>     97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** #>     98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 #>     99:  !!!EED:  Craig Stuart Sapp #>    100:  !!!EEV:  2009/05/22 #> ############################# ^^^ chor010.krn ^^^ ############################# #>                        (***four global comments truncated due to screen size***) #>  #>  humdrumR corpus of ten files. #>   Data fields:  #>          *Token :: character readHumdrum('HumdrumData/.*Variations/.*.krn') #> ################ vvv B075_00_01_a.krn vvv ################ #>     1:  !!!COM: Beethoven #>     2:  !!!OTL: 7 Variations on a Quartet by Winter #>     3:  !!!Variation: Theme a #>     4:    **function  **harm     **kern             **kern #>     5:             *       *    *clefG2            *clefG2 #>     6:             *       *     *k[b-]             *k[b-] #>     7:         *M2/4   *M2/4      *M2/4              *M2/4 #>     8:           *F:     *F:        *F:                *F: #>     9:            4T      4I         4r           4aa 4ccc #>    10:            =1      =1         =1                 =1 #>    11:            2T      2I         2f         8ff'L 8aa' #>    12:             .       .          .         8cc'J 8ff' #>    13:             .       .          .         8ff'L 8aa' #>    14:             .       .          .        8aa'J 8ccc' #>    15:            =2      =2         =2                 =2 #>    16:            4T     4V7  (4c 4e 4g          (4gg 4bb- #>    17:            4T      4I        4f)           4ff) 4aa #>    18:            =3      =3         =3                 =3 #>    19:            2T      2V         4c         8ee'L 8gg' #>    20:             .       .          .         8dd'J 8ff' #>    21:             .       .         4c         8cc'L 8ee' #>    22:             .       .          .         8dd'J 8ff' #>    23:            =4      =4         =4                 =4 #>    24:            4T      4V         8c            8ee 8gg #>    25:             .       .         8r                 8r #>    26:            4T      4I         4r           4aa 4ccc #>    27:            =5      =5         =5                 =5 #>    28:            2T      2I         2f         8ff'L 8aa' #>    29:             .       .          .         8cc'J 8ff' #>    30:             .       .          .         8ff'L 8aa' #>    31:             .       .          .        8aa'J 8ccc' #>    32:            =6      =6         =6                 =6 #>    33:            4T     4V7  (4c 4e 4g          (4gg 4bb- #>    34:            4T      4I     4f) 4a           4ff) 4aa #>    35:            =7      =7         =7                 =7 #>    36:            4P    4iib       8B-L           8ddL 8gg #>    37:             .       .       8B-J           8ddJ 8gg #>    38:            4D     4V7        8cL          (8b-L 8ee #>    39:             .       .        8cJ         16b-L 16dd #>    40:             .       .          .            16eeJJ) #> 41-45::::::::::::::::::::::::::::::::::::::::::::::::::::: #> ################ ^^^ B075_00_01_a.krn ^^^ ################ #>  #>      (18 more files...) #>  #> ############### vvv M354_01_04d_a.krn vvv ################ #>  1-14::::::::::::::::::::::::::::::::::::::::::::::::::::: #>    15:             .       .          .     .      (16ccLL #>    16:             .       .          .     .         16b- #>    17:             .       .         8f     .          16a #>    18:             .       .          .     .      16b-JJ) #>    19:           =41     =41        =41   =41          =41 #>    20:            2D    2V7d         8r   2A-     (16ee-LL #>    21:             .       .          .     .         16dd #>    22:             .       .     4B- 4f     .        16cc# #>    23:             .       .          .     .      16ddJJ) #>    24:             .       .          .     .      (16ccLL #>    25:             .       .          .     .         16b- #>    26:             .       .     8B- 8f     .          16a #>    27:             .       .          .     .      16b-JJ) #>    28:             *       *         *v    *v            * #>    29:           =42     =42        =42                =42 #>    30:             *       *    *clefF4                  * #>    31:            4T     4Ib         8r           (16ee-LL #>    32:             .       .          .               16ff #>    33:             .       .     8G 8e-              16gg) #>    34:             .       .          .             16b'JJ #>    35:            4P     4IV         8r            (16ccLL #>    36:             .       .          .               16dd #>    37:             .       .    8A- 8e-             16ee-) #>    38:             .       .          .            16a-'JJ #>    39:           =43     =43        =43                =43 #>    40:             *       *         *^                  * #>    41:            4D     4Cc         8r  2BB-       (16gLL #>    42:             .       .          .     .         16a- #>    43:             .       .        (8G     .        16b-) #>    44:             .       .          .     .       16e'JJ #>    45:            4D     4V7       8A-L     .       (16fLL #>    46:             .       .          .     .          16g #>    47:             .       .       8FJ)     .        16a-) #>    48:             .       .          .     .       16d'JJ #>    49:             *       *         *v    *v            * #>    50:           =44     =44        =44                =44 #>    51:            2T      2I       8E-L                4e- #>    52:             .       .      8BB-J                  . #>    53:             .       .       4EE-                 4r #>    54:            *-      *-         *-                 *- #> ############### ^^^ M354_01_04d_a.krn ^^^ ################ #>  #>  humdrumR corpus of twenty files. #>   Data fields:  #>          *Token :: character readHumdrum('HumdrumData/.*/.*') #> ############################ vvv chor001.krn vvv ############################ #>      1:  !!!COM: Bach, Johann Sebastian #>      2:  !!!CDT: 1685/02/21/-1750/07/28/ #>      3:  !!!OTL@@DE: Aus meines Herzens Grunde #>      4:  !!!OTL@EN:      From the Depths of My Heart #>      5:  !!!SCT: BWV 269 #>      6:  !!!PC#: 1 #>      7:  !!!AGN: chorale #>      8:          **kern        **kern        **kern        **kern #>      9:          *ICvox        *ICvox        *ICvox        *ICvox #>     10:          *Ibass       *Itenor        *Ialto       *Isoprn #>     11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano #>     12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] #>     13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] #>     14:             *>A           *>A           *>A           *>A #>     15:         *clefF4      *clefGv2       *clefG2       *clefG2 #>     16:          *k[f#]        *k[f#]        *k[f#]        *k[f#] #>     17:             *G:           *G:           *G:           *G: #>     18:             *F:             *             *             * #>     19:           *M3/4         *M3/4         *M3/4         *M3/4 #>     20:          *MM100        *MM100        *MM100        *MM100 #>     21:             4GG            4B            4d            4g #>     22:              =1            =1            =1            =1 #>     23:              4G            4B            4d            2g #>     24:              4E           8cL            4e             . #>     25:               .           8BJ             .             . #>     26:             4F#            4A            4d           4dd #>     27:              =2            =2            =2            =2 #>     28:              4G            4G            2d           4.b #>     29:              4D           4F#             .             . #>     30:               .             .             .            8a #>     31:              4E            4G            4B            4g #>     32:              =3            =3            =3            =3 #>     33:              4C           8cL           8eL           4.g #>     34:               .           8BJ            8d             . #>     35:            8BBL            4c            8e             . #>     36:            8AAJ             .          8f#J            8a #>     37:             4GG            4d            4g            4b #>     38:              =4            =4            =4            =4 #>     39:             2D;           2d;          2f#;           2a; #>     40:             4GG            4d            4g            4b #> 41-134::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: #> ############################ ^^^ chor001.krn ^^^ ############################ #>  #>      (48 more files...) #>  #> ########################### vvv your_song.hum vvv ########################### #> 1-1194::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: #>   1195:               .             .             3             . #>   1196:               .             .             .             . #>   1197:               .             .             2             . #>   1198:               .             .             1             . #>   1199:               .             .             .             . #>   1200:            =119          =119          =119          =119 #>   1201:            ii65            IV             2       222.340 #>   1202:               .             .             .             . #>   1203:               .             .             .             . #>   1204:               .             .             6             . #>   1205:               .             .             .             . #>   1206:               .             .             .             . #>   1207:               .             .             .             . #>   1208:               .             .             6             . #>   1209:            =120          =120          =120          =120 #>   1210:               .             .            b3       224.253 #>   1211:               .             .             2             . #>   1212:               .             .             .             . #>   1213:               .             .             1             . #>   1214:               .             .             .             . #>   1215:               .             .             1             . #>   1216:               .             .             1             . #>   1217:               .             .             .             . #>   1218:            =121          =121          =121          =121 #>   1219:            *tb1          *tb1          *tb1             * #>   1220:               I             I             .       226.135 #>   1221:            =122          =122          =122          =122 #>   1222:              IV          IV64             .       228.013 #>   1223:            =123          =123          =123          =123 #>   1224:               V           Vs4             .       229.838 #>   1225:            =124          =124          =124          =124 #>   1226:              IV          IV64             .       231.691 #>   1227:            =125          =125          =125          =125 #>   1228:               I             I             .       233.583 #>   1229:              *-            *-            *-            *- #>   1230:  !!!ONB: Translated from original encodings in the Rolling Stone C*** #>   1231:  !!!ONB: Original transcribers noted in comments in each spine: !D*** #>   1232:  !!!YOE: David Temperley, Trevor de Clercq #>   1233:  !!!EED: Nathaniel Condit-Schultz (fathermckenzie.net) #>   1234:  !!!ENC: Nathaniel Condit-Schultz (fathermckenzie.net), automated #> ########################### ^^^ your_song.hum ^^^ ########################### #>                     (***three global comments truncated due to screen size***) #>  #>  humdrumR corpus of fifty files. #>   Data fields:  #>          *Token :: character"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/ReadWrite.html","id":"multi-argument-approach","dir":"Articles","previous_headings":"Reading humdrum data > Targeting files","what":"Multi-Argument Approach","title":"Reading and writing data with humdrumR","text":"Earlier mentioned can one RE-path patterns. one? Well, can divided RE-path patterns across multiple arguments (left right): Instead writing readHumdrum(\"HumdrumData/BachChorales/chor.*.krn\"), can write readHumdrum(\"HumdrumData\", \"BachChorales\", \"chor.*.krn\"). Thus two approaches identical. ’s advantage approach? ’ll see next section.","code":"readHumdrum(\"HumdrumData/BachChorales/chor.*.krn\")  readHumdrum(\"HumdrumData\", \"BachChorales\", \"chor.*.krn\")"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/ReadWrite.html","id":"multiple-patterns","dir":"Articles","previous_headings":"Reading humdrum data > Targeting files","what":"Multiple Patterns","title":"Reading and writing data with humdrumR","text":"Sometimes, expressing files want single regular expression possible. Luckily, readHumdrum can accept many separate patterns want, just group vector. Instead writing readHumdrum('HumdrumData/.*Variations/.*.krn'), explicit write ’ve used c command create vector two REpath-patterns. However, lot (bug-prone) typing…combine multiple patterns Multi-Argument Approach ?: get result! work exactly? ’ve fed three arguments readHumdrum. first last arguments (\"HumdrumData\" \".*.krn\") length one. However, middle argument (\"...Variations\") length two. readHumdrum concatenates three arguments together, making two separate REpath-patterns: Note: possible write multiple patterns match () files. argument multipleInstances = FALSE, unique file read (first matching pattern). multipleInstances = TRUE, file(s) can read .","code":"readHumdrum(c('HumdrumData/BeethovenVariations/.*.krn', 'HumdrumData/MozartVariations/.*.krn')) #> ################ vvv B075_00_01_a.krn vvv ################ #>     1:  !!!COM: Beethoven #>     2:  !!!OTL: 7 Variations on a Quartet by Winter #>     3:  !!!Variation: Theme a #>     4:    **function  **harm     **kern             **kern #>     5:             *       *    *clefG2            *clefG2 #>     6:             *       *     *k[b-]             *k[b-] #>     7:         *M2/4   *M2/4      *M2/4              *M2/4 #>     8:           *F:     *F:        *F:                *F: #>     9:            4T      4I         4r           4aa 4ccc #>    10:            =1      =1         =1                 =1 #>    11:            2T      2I         2f         8ff'L 8aa' #>    12:             .       .          .         8cc'J 8ff' #>    13:             .       .          .         8ff'L 8aa' #>    14:             .       .          .        8aa'J 8ccc' #>    15:            =2      =2         =2                 =2 #>    16:            4T     4V7  (4c 4e 4g          (4gg 4bb- #>    17:            4T      4I        4f)           4ff) 4aa #>    18:            =3      =3         =3                 =3 #>    19:            2T      2V         4c         8ee'L 8gg' #>    20:             .       .          .         8dd'J 8ff' #>    21:             .       .         4c         8cc'L 8ee' #>    22:             .       .          .         8dd'J 8ff' #>    23:            =4      =4         =4                 =4 #>    24:            4T      4V         8c            8ee 8gg #>    25:             .       .         8r                 8r #>    26:            4T      4I         4r           4aa 4ccc #>    27:            =5      =5         =5                 =5 #>    28:            2T      2I         2f         8ff'L 8aa' #>    29:             .       .          .         8cc'J 8ff' #>    30:             .       .          .         8ff'L 8aa' #>    31:             .       .          .        8aa'J 8ccc' #>    32:            =6      =6         =6                 =6 #>    33:            4T     4V7  (4c 4e 4g          (4gg 4bb- #>    34:            4T      4I     4f) 4a           4ff) 4aa #>    35:            =7      =7         =7                 =7 #>    36:            4P    4iib       8B-L           8ddL 8gg #>    37:             .       .       8B-J           8ddJ 8gg #>    38:            4D     4V7        8cL          (8b-L 8ee #>    39:             .       .        8cJ         16b-L 16dd #>    40:             .       .          .            16eeJJ) #> 41-45::::::::::::::::::::::::::::::::::::::::::::::::::::: #> ################ ^^^ B075_00_01_a.krn ^^^ ################ #>  #>      (18 more files...) #>  #> ############### vvv M354_01_04d_a.krn vvv ################ #>  1-14::::::::::::::::::::::::::::::::::::::::::::::::::::: #>    15:             .       .          .     .      (16ccLL #>    16:             .       .          .     .         16b- #>    17:             .       .         8f     .          16a #>    18:             .       .          .     .      16b-JJ) #>    19:           =41     =41        =41   =41          =41 #>    20:            2D    2V7d         8r   2A-     (16ee-LL #>    21:             .       .          .     .         16dd #>    22:             .       .     4B- 4f     .        16cc# #>    23:             .       .          .     .      16ddJJ) #>    24:             .       .          .     .      (16ccLL #>    25:             .       .          .     .         16b- #>    26:             .       .     8B- 8f     .          16a #>    27:             .       .          .     .      16b-JJ) #>    28:             *       *         *v    *v            * #>    29:           =42     =42        =42                =42 #>    30:             *       *    *clefF4                  * #>    31:            4T     4Ib         8r           (16ee-LL #>    32:             .       .          .               16ff #>    33:             .       .     8G 8e-              16gg) #>    34:             .       .          .             16b'JJ #>    35:            4P     4IV         8r            (16ccLL #>    36:             .       .          .               16dd #>    37:             .       .    8A- 8e-             16ee-) #>    38:             .       .          .            16a-'JJ #>    39:           =43     =43        =43                =43 #>    40:             *       *         *^                  * #>    41:            4D     4Cc         8r  2BB-       (16gLL #>    42:             .       .          .     .         16a- #>    43:             .       .        (8G     .        16b-) #>    44:             .       .          .     .       16e'JJ #>    45:            4D     4V7       8A-L     .       (16fLL #>    46:             .       .          .     .          16g #>    47:             .       .       8FJ)     .        16a-) #>    48:             .       .          .     .       16d'JJ #>    49:             *       *         *v    *v            * #>    50:           =44     =44        =44                =44 #>    51:            2T      2I       8E-L                4e- #>    52:             .       .      8BB-J                  . #>    53:             .       .       4EE-                 4r #>    54:            *-      *-         *-                 *- #> ############### ^^^ M354_01_04d_a.krn ^^^ ################ #>  #>  humdrumR corpus of twenty files. #>   Data fields:  #>          *Token :: character readHumdrum('HumdrumData',             c('BeethovenVariations', 'MozartVariations'),             '.*.krn') #> ################ vvv B075_00_01_a.krn vvv ################ #>     1:  !!!COM: Beethoven #>     2:  !!!OTL: 7 Variations on a Quartet by Winter #>     3:  !!!Variation: Theme a #>     4:    **function  **harm     **kern             **kern #>     5:             *       *    *clefG2            *clefG2 #>     6:             *       *     *k[b-]             *k[b-] #>     7:         *M2/4   *M2/4      *M2/4              *M2/4 #>     8:           *F:     *F:        *F:                *F: #>     9:            4T      4I         4r           4aa 4ccc #>    10:            =1      =1         =1                 =1 #>    11:            2T      2I         2f         8ff'L 8aa' #>    12:             .       .          .         8cc'J 8ff' #>    13:             .       .          .         8ff'L 8aa' #>    14:             .       .          .        8aa'J 8ccc' #>    15:            =2      =2         =2                 =2 #>    16:            4T     4V7  (4c 4e 4g          (4gg 4bb- #>    17:            4T      4I        4f)           4ff) 4aa #>    18:            =3      =3         =3                 =3 #>    19:            2T      2V         4c         8ee'L 8gg' #>    20:             .       .          .         8dd'J 8ff' #>    21:             .       .         4c         8cc'L 8ee' #>    22:             .       .          .         8dd'J 8ff' #>    23:            =4      =4         =4                 =4 #>    24:            4T      4V         8c            8ee 8gg #>    25:             .       .         8r                 8r #>    26:            4T      4I         4r           4aa 4ccc #>    27:            =5      =5         =5                 =5 #>    28:            2T      2I         2f         8ff'L 8aa' #>    29:             .       .          .         8cc'J 8ff' #>    30:             .       .          .         8ff'L 8aa' #>    31:             .       .          .        8aa'J 8ccc' #>    32:            =6      =6         =6                 =6 #>    33:            4T     4V7  (4c 4e 4g          (4gg 4bb- #>    34:            4T      4I     4f) 4a           4ff) 4aa #>    35:            =7      =7         =7                 =7 #>    36:            4P    4iib       8B-L           8ddL 8gg #>    37:             .       .       8B-J           8ddJ 8gg #>    38:            4D     4V7        8cL          (8b-L 8ee #>    39:             .       .        8cJ         16b-L 16dd #>    40:             .       .          .            16eeJJ) #> 41-45::::::::::::::::::::::::::::::::::::::::::::::::::::: #> ################ ^^^ B075_00_01_a.krn ^^^ ################ #>  #>      (18 more files...) #>  #> ############### vvv M354_01_04d_a.krn vvv ################ #>  1-14::::::::::::::::::::::::::::::::::::::::::::::::::::: #>    15:             .       .          .     .      (16ccLL #>    16:             .       .          .     .         16b- #>    17:             .       .         8f     .          16a #>    18:             .       .          .     .      16b-JJ) #>    19:           =41     =41        =41   =41          =41 #>    20:            2D    2V7d         8r   2A-     (16ee-LL #>    21:             .       .          .     .         16dd #>    22:             .       .     4B- 4f     .        16cc# #>    23:             .       .          .     .      16ddJJ) #>    24:             .       .          .     .      (16ccLL #>    25:             .       .          .     .         16b- #>    26:             .       .     8B- 8f     .          16a #>    27:             .       .          .     .      16b-JJ) #>    28:             *       *         *v    *v            * #>    29:           =42     =42        =42                =42 #>    30:             *       *    *clefF4                  * #>    31:            4T     4Ib         8r           (16ee-LL #>    32:             .       .          .               16ff #>    33:             .       .     8G 8e-              16gg) #>    34:             .       .          .             16b'JJ #>    35:            4P     4IV         8r            (16ccLL #>    36:             .       .          .               16dd #>    37:             .       .    8A- 8e-             16ee-) #>    38:             .       .          .            16a-'JJ #>    39:           =43     =43        =43                =43 #>    40:             *       *         *^                  * #>    41:            4D     4Cc         8r  2BB-       (16gLL #>    42:             .       .          .     .         16a- #>    43:             .       .        (8G     .        16b-) #>    44:             .       .          .     .       16e'JJ #>    45:            4D     4V7       8A-L     .       (16fLL #>    46:             .       .          .     .          16g #>    47:             .       .       8FJ)     .        16a-) #>    48:             .       .          .     .       16d'JJ #>    49:             *       *         *v    *v            * #>    50:           =44     =44        =44                =44 #>    51:            2T      2I       8E-L                4e- #>    52:             .       .      8BB-J                  . #>    53:             .       .       4EE-                 4r #>    54:            *-      *-         *-                 *- #> ############### ^^^ M354_01_04d_a.krn ^^^ ################ #>  #>  humdrumR corpus of twenty files. #>   Data fields:  #>          *Token :: character \"HumdrumData/BeethovenVariations/.*.krn\" \"HumdrumData/MozartVariations/.*.krn\""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/ReadWrite.html","id":"pattern-names","dir":"Articles","previous_headings":"Reading humdrum data > Targeting files > Multiple Patterns","what":"Pattern Names","title":"Reading and writing data with humdrumR","text":"Whenever specific one REpath-pattern, humdrumR gives names can access Label field resulting humdrumR data object. can choose labels giving names patterns multi-pattern vectors: Thus, write two separate patterns matched read names \"Rap\" \"Rock\" associated resulting Label field. feature useful working multiple heterogenous datasets want able apply analyses/parsing one data subsets.","code":"readHumdrum('HumdrumData',             c(Rap  = 'Rap/.*',               Rock = 'RollingStone/.*')) -> rapAndRock"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/ReadWrite.html","id":"contains","dir":"Articles","previous_headings":"Reading humdrum data > Targeting files","what":"Contains","title":"Reading and writing data with humdrumR","text":"Sometimes want read humdrum files contain particular data. instance, might want read files minor key. One option read files corpus filter files don’t want (see humdrumR filtering vignette learn . However, cases, can save lot time effort filter files want parsing . contains argument readHumdrum can used just way! contains argument must character vector—character string treated regular expression, files contain matches regular expressions read. Thus, read pieces minor keys writing: (regular expression matches standard humdrum tandem interpretations minor keys.)","code":"readHumdrum('HumdrumData', 'BachChorales', 'chor.*.krn',             contains = '\\\\*[a-g][-b#]*:')  #> ############################# vvv chor003.krn vvv ############################# #>      1:  !!!COM: Bach, Johann Sebastian #>      2:  !!!CDT: 1685/02/21/-1750/07/28/ #>      3:  !!!OTL@@DE: Ach Gott, vom Himmel sieh darein #>      4:  !!!OTL@EN: Oh God, look down from Heaven #>      5:  !!!OPR: Cantata BWV 153: Schau, lieber Gott, wie meine Feind #>      6:  !!!SCT: BWV 153/1 #>      7:  !!!PC#: 3 #>      8:  !!!AGN: chorale #>      9:          **kern        **kern        **kern        **kern #>     10:          *ICvox        *ICvox        *ICvox        *ICvox #>     11:          *Ibass       *Itenor        *Ialto       *Isoprn #>     12:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano #>     13:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] #>     14:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] #>     15:             *>A           *>A           *>A           *>A #>     16:         *clefF4      *clefGv2       *clefG2       *clefG2 #>     17:          *k[f#]        *k[f#]        *k[f#]        *k[f#] #>     18:             *a:           *a:           *a:           *a: #>     19:         !dorian       !dorian       !dorian       !dorian #>     20:           *M4/4         *M4/4         *M4/4         *M4/4 #>     21:         *met(c)       *met(c)       *met(c)       *met(c) #>     22:          *MM100        *MM100        *MM100        *MM100 #>     23:              4E            4e           4g#            4b #>     24:              =1            =1            =1            =1 #>     25:              4A            4e            4a           4cc #>     26:              4B            4d           4g#            4b #>     27:              4c            4e            4a            4a #>     28:             8BL           8dL          8g#L           4ee #>     29:             8AJ           8cJ           8aJ             . #>     30:              =2            =2            =2            =2 #>     31:             4G#            4B            4b          8eeL #>     32:               .             .             .          8ddJ #>     33:              4A           8cL           8eL           4cc #>     34:               .           8dJ          8f#J             . #>     35:             4E;           4e;          4g#;           4b; #>     36:             4BB            4f           4g#           4dd #>     37:              =3            =3            =3            =3 #>     38:             8CL            4e            4a           4cc #>     39:             8DJ             .             .             . #>     40:              4E           8eL           4g#            4b #> 41-110::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: #> ############################# ^^^ chor003.krn ^^^ ############################# #>  #>      (1 more files...) #>  #> ############################# vvv chor010.krn vvv ############################# #>   1-60::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: #>     61:            2AA;           2c;           2e;           2a; #>     62:              2A            2e            2a           2cc #>     63:              =9            =9            =9            =9 #>     64:              4E            4e            4g            4b #>     65:             8DL            4e            4g           4cc #>     66:             8CJ             .             .             . #>     67:             4BB            4d           8gL           4dd #>     68:               .             .           8fJ             . #>     69:              4C            4c            4e            4g #>     70:             =10           =10           =10           =10 #>     71:              4D           8F#            4d            4b #>     72:               .            4G             .             . #>     73:              4D             .            4c            4a #>     74:               .           8F#             .             . #>     75:            2GG;           2G;           2B;           2g; #>     76:             =11           =11           =11           =11 #>     77:              2C            2G            2e            2g #>     78:             4AA            4A            4e           4cc #>     79:              4E           4G#           8eL            4b #>     80:               .             .           8dJ             . #>     81:             =12           =12           =12           =12 #>     82:              4F            4A            4c            4a #>     83:              4C            4G            4c            4e #>     84:            4BB-            4G           [2d            4g #>     85:             4AA            4A             .            4f #>     86:             =13           =13           =13           =13 #>     87:            4GG#            4B           4d]           1e; #>     88:             4AA            4A            4c             . #>     89:            2EE;         2G#X;           2B;             . #>     90:              ==            ==            ==            == #>     91:              *-            *-            *-            *- #>     92:  !!!hum2abc: -Q '' #>     93:  !!!title: @{PC#}. @{OTL@@DE} #>     94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** #>     95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** #>     96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** #>     97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** #>     98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 #>     99:  !!!EED:  Craig Stuart Sapp #>    100:  !!!EEV:  2009/05/22 #> ############################# ^^^ chor010.krn ^^^ ############################# #>                        (***four global comments truncated due to screen size***) #>  #>  humdrumR corpus of three files. #>   Data fields:  #>          *Token :: character"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/ReadWrite.html","id":"finding-files","dir":"Articles","previous_headings":"Reading humdrum data","what":"Finding Files","title":"Reading and writing data with humdrumR","text":"readHumdrum interprets REpath-patterns finds files using helper function findHumdrum. sure humdrum files , pattern want use find , might start using findHumdrum. findHumdrum takes input readHumdrum, doesn’t fully parse input humdrumR. Instead, returns data.table containing matching filenames () raw file content. use verbose = TRUE option either findHumdrum readHumdrum, complete list matches files printed. useful check reading files intend read.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/ReadWrite.html","id":"validation","dir":"Articles","previous_headings":"Reading humdrum data > Finding Files","what":"Validation","title":"Reading and writing data with humdrumR","text":"findHumdrum, extension readHumdrum, smart functions ignore non-humdrum files matched pattern. Non-text files (like .pdf .jpg) ignored. Whatsmore, text files fail conform humdrum syntax read either. see message checks files “valid humdrum,” tell many () text files read. trying read file think valid humdrum, readHumdrum won’t read , use validateHumdrum exact REpath-pattern arguments, specify errorReport.path see detailed report problem. humdrumR won’t read files humdrum-syntax violations—might minor problems data need fix. Call ?validateHumdrum read humdrum data validation vignette learn humdrumR’s data validation tools, can used identify errors humdrum data. (validateHumdrum automatically check humdrum data encoded correctly makes sense, just structurally sound, accordance humdrum syntax.)","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/ReadWrite.html","id":"reading","dir":"Articles","previous_headings":"Reading humdrum data","what":"Reading","title":"Reading and writing data with humdrumR","text":", actually happens run readHumdrum? now, ’ve seen readHumdrum prints messages describing process. First, files match search patterns () identified, text read R. Next, files checked see valid humdrum files. files parsed—.e., translated humdrumR‘s data.table backend. step takes longest far, includes parsing humdrum files’ data tokens, interpretations, reference records, (worst ) spine paths. Indeed, reading humdrum data spine paths take significantly longer reading pathless data. save time, can potentially use tandems reference arguments (see “Parsing Metadata” ).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/ReadWrite.html","id":"parsing-metadata","dir":"Articles","previous_headings":"Reading humdrum data","what":"Parsing Metadata","title":"Reading and writing data with humdrumR","text":"default, humdrumR parses metadata humdrum files reads. includes true global metadata files, encoded humdrum reference records, well local tandem interpretations.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/ReadWrite.html","id":"reference-records","dir":"Articles","previous_headings":"Reading humdrum data > Parsing Metadata","what":"Reference Records","title":"Reading and writing data with humdrumR","text":"default, humdrumR parses reference records files reads, creating unique field reference key. (one instance given key, combined string separated semicolons.) lot unique reference keys dataset, can end taking lot memory humdrum table. cases, might find useful limit readHumdrum parsing reference records actually going use. can accomplished quite easily reference argument. reference argument defaults \"\", means reference records parsed. However, reference can also character vector reference codes. Thus, parse COM reference record piece. can use rename reference fields like—case, COM reference records parsed saved field called Composer instead COM. don’t want parse reference records, specify reference = NULL.","code":"readHumdrum('HumdrumData',             c('BeethovenVariations', 'MozartVariations'),             '.*.krn',             reference = 'COM') #> ################ vvv B075_00_01_a.krn vvv ################ #>     1:  !!!COM: Beethoven #>     2:  !!!OTL: 7 Variations on a Quartet by Winter #>     3:  !!!Variation: Theme a #>     4:    **function  **harm     **kern             **kern #>     5:             *       *    *clefG2            *clefG2 #>     6:             *       *     *k[b-]             *k[b-] #>     7:         *M2/4   *M2/4      *M2/4              *M2/4 #>     8:           *F:     *F:        *F:                *F: #>     9:            4T      4I         4r           4aa 4ccc #>    10:            =1      =1         =1                 =1 #>    11:            2T      2I         2f         8ff'L 8aa' #>    12:             .       .          .         8cc'J 8ff' #>    13:             .       .          .         8ff'L 8aa' #>    14:             .       .          .        8aa'J 8ccc' #>    15:            =2      =2         =2                 =2 #>    16:            4T     4V7  (4c 4e 4g          (4gg 4bb- #>    17:            4T      4I        4f)           4ff) 4aa #>    18:            =3      =3         =3                 =3 #>    19:            2T      2V         4c         8ee'L 8gg' #>    20:             .       .          .         8dd'J 8ff' #>    21:             .       .         4c         8cc'L 8ee' #>    22:             .       .          .         8dd'J 8ff' #>    23:            =4      =4         =4                 =4 #>    24:            4T      4V         8c            8ee 8gg #>    25:             .       .         8r                 8r #>    26:            4T      4I         4r           4aa 4ccc #>    27:            =5      =5         =5                 =5 #>    28:            2T      2I         2f         8ff'L 8aa' #>    29:             .       .          .         8cc'J 8ff' #>    30:             .       .          .         8ff'L 8aa' #>    31:             .       .          .        8aa'J 8ccc' #>    32:            =6      =6         =6                 =6 #>    33:            4T     4V7  (4c 4e 4g          (4gg 4bb- #>    34:            4T      4I     4f) 4a           4ff) 4aa #>    35:            =7      =7         =7                 =7 #>    36:            4P    4iib       8B-L           8ddL 8gg #>    37:             .       .       8B-J           8ddJ 8gg #>    38:            4D     4V7        8cL          (8b-L 8ee #>    39:             .       .        8cJ         16b-L 16dd #>    40:             .       .          .            16eeJJ) #> 41-45::::::::::::::::::::::::::::::::::::::::::::::::::::: #> ################ ^^^ B075_00_01_a.krn ^^^ ################ #>  #>      (18 more files...) #>  #> ############### vvv M354_01_04d_a.krn vvv ################ #>  1-14::::::::::::::::::::::::::::::::::::::::::::::::::::: #>    15:             .       .          .     .      (16ccLL #>    16:             .       .          .     .         16b- #>    17:             .       .         8f     .          16a #>    18:             .       .          .     .      16b-JJ) #>    19:           =41     =41        =41   =41          =41 #>    20:            2D    2V7d         8r   2A-     (16ee-LL #>    21:             .       .          .     .         16dd #>    22:             .       .     4B- 4f     .        16cc# #>    23:             .       .          .     .      16ddJJ) #>    24:             .       .          .     .      (16ccLL #>    25:             .       .          .     .         16b- #>    26:             .       .     8B- 8f     .          16a #>    27:             .       .          .     .      16b-JJ) #>    28:             *       *         *v    *v            * #>    29:           =42     =42        =42                =42 #>    30:             *       *    *clefF4                  * #>    31:            4T     4Ib         8r           (16ee-LL #>    32:             .       .          .               16ff #>    33:             .       .     8G 8e-              16gg) #>    34:             .       .          .             16b'JJ #>    35:            4P     4IV         8r            (16ccLL #>    36:             .       .          .               16dd #>    37:             .       .    8A- 8e-             16ee-) #>    38:             .       .          .            16a-'JJ #>    39:           =43     =43        =43                =43 #>    40:             *       *         *^                  * #>    41:            4D     4Cc         8r  2BB-       (16gLL #>    42:             .       .          .     .         16a- #>    43:             .       .        (8G     .        16b-) #>    44:             .       .          .     .       16e'JJ #>    45:            4D     4V7       8A-L     .       (16fLL #>    46:             .       .          .     .          16g #>    47:             .       .       8FJ)     .        16a-) #>    48:             .       .          .     .       16d'JJ #>    49:             *       *         *v    *v            * #>    50:           =44     =44        =44                =44 #>    51:            2T      2I       8E-L                4e- #>    52:             .       .      8BB-J                  . #>    53:             .       .       4EE-                 4r #>    54:            *-      *-         *-                 *- #> ############### ^^^ M354_01_04d_a.krn ^^^ ################ #>  #>  humdrumR corpus of twenty files. #>   Data fields:  #>          *Token :: character readHumdrum('HumdrumData',             c('BeethovenVariations', 'MozartVariations'),             '.*.krn',             reference = c(Composer = 'COM')) #> ################ vvv B075_00_01_a.krn vvv ################ #>     1:  !!!COM: Beethoven #>     2:  !!!OTL: 7 Variations on a Quartet by Winter #>     3:  !!!Variation: Theme a #>     4:    **function  **harm     **kern             **kern #>     5:             *       *    *clefG2            *clefG2 #>     6:             *       *     *k[b-]             *k[b-] #>     7:         *M2/4   *M2/4      *M2/4              *M2/4 #>     8:           *F:     *F:        *F:                *F: #>     9:            4T      4I         4r           4aa 4ccc #>    10:            =1      =1         =1                 =1 #>    11:            2T      2I         2f         8ff'L 8aa' #>    12:             .       .          .         8cc'J 8ff' #>    13:             .       .          .         8ff'L 8aa' #>    14:             .       .          .        8aa'J 8ccc' #>    15:            =2      =2         =2                 =2 #>    16:            4T     4V7  (4c 4e 4g          (4gg 4bb- #>    17:            4T      4I        4f)           4ff) 4aa #>    18:            =3      =3         =3                 =3 #>    19:            2T      2V         4c         8ee'L 8gg' #>    20:             .       .          .         8dd'J 8ff' #>    21:             .       .         4c         8cc'L 8ee' #>    22:             .       .          .         8dd'J 8ff' #>    23:            =4      =4         =4                 =4 #>    24:            4T      4V         8c            8ee 8gg #>    25:             .       .         8r                 8r #>    26:            4T      4I         4r           4aa 4ccc #>    27:            =5      =5         =5                 =5 #>    28:            2T      2I         2f         8ff'L 8aa' #>    29:             .       .          .         8cc'J 8ff' #>    30:             .       .          .         8ff'L 8aa' #>    31:             .       .          .        8aa'J 8ccc' #>    32:            =6      =6         =6                 =6 #>    33:            4T     4V7  (4c 4e 4g          (4gg 4bb- #>    34:            4T      4I     4f) 4a           4ff) 4aa #>    35:            =7      =7         =7                 =7 #>    36:            4P    4iib       8B-L           8ddL 8gg #>    37:             .       .       8B-J           8ddJ 8gg #>    38:            4D     4V7        8cL          (8b-L 8ee #>    39:             .       .        8cJ         16b-L 16dd #>    40:             .       .          .            16eeJJ) #> 41-45::::::::::::::::::::::::::::::::::::::::::::::::::::: #> ################ ^^^ B075_00_01_a.krn ^^^ ################ #>  #>      (18 more files...) #>  #> ############### vvv M354_01_04d_a.krn vvv ################ #>  1-14::::::::::::::::::::::::::::::::::::::::::::::::::::: #>    15:             .       .          .     .      (16ccLL #>    16:             .       .          .     .         16b- #>    17:             .       .         8f     .          16a #>    18:             .       .          .     .      16b-JJ) #>    19:           =41     =41        =41   =41          =41 #>    20:            2D    2V7d         8r   2A-     (16ee-LL #>    21:             .       .          .     .         16dd #>    22:             .       .     4B- 4f     .        16cc# #>    23:             .       .          .     .      16ddJJ) #>    24:             .       .          .     .      (16ccLL #>    25:             .       .          .     .         16b- #>    26:             .       .     8B- 8f     .          16a #>    27:             .       .          .     .      16b-JJ) #>    28:             *       *         *v    *v            * #>    29:           =42     =42        =42                =42 #>    30:             *       *    *clefF4                  * #>    31:            4T     4Ib         8r           (16ee-LL #>    32:             .       .          .               16ff #>    33:             .       .     8G 8e-              16gg) #>    34:             .       .          .             16b'JJ #>    35:            4P     4IV         8r            (16ccLL #>    36:             .       .          .               16dd #>    37:             .       .    8A- 8e-             16ee-) #>    38:             .       .          .            16a-'JJ #>    39:           =43     =43        =43                =43 #>    40:             *       *         *^                  * #>    41:            4D     4Cc         8r  2BB-       (16gLL #>    42:             .       .          .     .         16a- #>    43:             .       .        (8G     .        16b-) #>    44:             .       .          .     .       16e'JJ #>    45:            4D     4V7       8A-L     .       (16fLL #>    46:             .       .          .     .          16g #>    47:             .       .       8FJ)     .        16a-) #>    48:             .       .          .     .       16d'JJ #>    49:             *       *         *v    *v            * #>    50:           =44     =44        =44                =44 #>    51:            2T      2I       8E-L                4e- #>    52:             .       .      8BB-J                  . #>    53:             .       .       4EE-                 4r #>    54:            *-      *-         *-                 *- #> ############### ^^^ M354_01_04d_a.krn ^^^ ################ #>  #>  humdrumR corpus of twenty files. #>   Data fields:  #>          *Token :: character"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/ReadWrite.html","id":"tandem-interpretations","dir":"Articles","previous_headings":"Reading humdrum data > Parsing Metadata","what":"Tandem Interpretations","title":"Reading and writing data with humdrumR","text":"Tandem interpretations used humdrum data represent “local,” real-time metainformation associated specific spines—review humdrum syntax vignette details. HumdrumR can read arbitrary tandem interpertations humdrum data. However, non-standard intrepretations used, humdrumR way knowing parse . default, humdrumR always reads tandem interpretations field called Tandem. field tabulates tandem interperations far appeared spine order, concatenating single comma-delimited, recent distant. instance, Tandem field spine parsed , interpretations pile longer longer string piece progresses. Notice \"D:\" \"C:\" intrerpretations get piled separately, just like interpretation, even though tandem class, \"D:\" supercede \"C:\". ? Well, general way know arbitrary tandem interpretations class. create humdrum data new interpretations , humdrumR doesn’t know parse , just pile like Tandem field. Fortunately, humdrumR know parse many standard tandem interpretations. run command see currently ten classes tandem interpretations humdrumR recognizes, associated regular expression. Thus, really apply readHumdrum file recognize tokens \"C:\" \"D:\" match known regular expression Key tandem interpretation, parse field called Key, look like: Likewise, ’d get TimeSignature BPM fields.","code":"**kern *C: *M4/4 *MM100 c e c g *D: d f# *- \"\" C: M4/4,C: MM100,M4/4,C: MM100,M4/4,C: MM100,M4/4,C: D:,MM100,M4/4,C: D:,MM100,M4/4,C: D:,MM100,M4/4,C: knownInterpretations[Type == 'Tandem']  #>                      Name Exclusive #>  1:                   Key           #>  2:          KeySignature           #>  3:                  Clef           #>  4:         TimeSignature           #>  5:           Mensuration           #>  6:                   BPM           #>  7:              Timebase           #>  8:            Instrument           #>  9:       InstrumentClass           #> 10: TransposingInstrument           #>                                                      RE Pretty   Type #>  1: [A-Ga-g][-#b]*:(mix|dor|phr|lyd|loc)?([#bn]?[1-7])*     _: Tandem #>  2:                              k\\\\[([a-g][#-]* *)*\\\\]   k[_] Tandem #>  3:                                   clef[A-G]v*[1-5]*  clef_ Tandem #>  4:                     M[1-9][0-9]*/((16)|(32)|[1248])   M_/_ Tandem #>  5:                                      met\\\\([^)]*\\\\) met(_) Tandem #>  6:                                            MM[0-9]+    MM_ Tandem #>  7:                     tb[1-9][0-9]*%?[1-9]?[0-9]*[.]*    tb_ Tandem #>  8:                                             I[^C,]+     I_ Tandem #>  9:                                             IC[^,]*    IC_ Tandem #> 10:                                            ITr[^,]*   ITr_ Tandem **kern *C: *M4/4 *MM100 c e c g *D: d f# *- NA C: C: C: C: C: D: D: D:"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/ReadWrite.html","id":"custom-tandems","dir":"Articles","previous_headings":"Reading humdrum data > Parsing Metadata > Tandem Interpretations","what":"Custom Tandems","title":"Reading and writing data with humdrumR","text":"readHumdrum tandems argument allows us take control tandem interpretation parsing process. tandems character vector, defaulting known, parses known interpretations fields (following knownInterpretations table). can use tandems two ways. 1.) can remove \"known\" vector specify Name specific tandem interpretations want parse. instance, write tandem = \"Clef\", Clef pattern knownInterpretations table parsed, (others). 2.) character string tandems \"known\" exact match Name knownInterpretations, instead treated regular expression match new tandem interpretation class. instance, tandems = \"[Aa]pple|[Bb]anana\" match “*Apple”, “*apple”, “*Banana”, “*banana,” parsing four patterns field (called [Aa]pple|[Bb]anana]). give field name writing tandems = c(Fruit = \"[Aa]pple|[Bb]anana\"). (fact, can rename known interpretations well, instance writing tandems = c(Meter = \"TimeSignature\".) tandems = NULL, tandem interpretations parsed —can used shorten parsing time.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/Reshaping.html","id":"filtering-data","dir":"Articles","previous_headings":"","what":"Filtering Data","title":"Shaping Humdrum Data","text":"first step might remove data don’t need.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/Reshaping.html","id":"indexing","dir":"Articles","previous_headings":"Filtering Data","what":"Indexing","title":"Shaping Humdrum Data","text":"example, studying tonality, might simply want ignore lyric data. easiest way index spines don’t want, either using numeric indices exclusive interpretation:","code":"example[[ , c(1,3,5)]] #         vvv Reshaping_example.hum vvv # #           1:    **kern   **kern  **harm #           2:    *ICvox   *ICvox       * #           3:    *Ialto  *Isoprn       * #           4:     *M4/4    *M4/4       * #           5:       *C:      *C:     *C: #           6:       4.c      4.e       I #           7:        8d       8f       . #           8:        4e       4g       . #           9:        4f       4a      IV #          10:         =        =       = #          11:        2g      4dd     I64 #          12:         .      4cc       . #          13:        2g       2b       V #          14:        *-       *-      *- #         ^^^ Reshaping_example.hum ^^^ # #            Data fields:  #                   *Token :: character example[[ , c('**kern', '**harm')]] #         vvv Reshaping_example.hum vvv # #           1:    **kern   **kern  **harm #           2:    *ICvox   *ICvox       * #           3:    *Ialto  *Isoprn       * #           4:     *M4/4    *M4/4       * #           5:       *C:      *C:     *C: #           6:       4.c      4.e       I #           7:        8d       8f       . #           8:        4e       4g       . #           9:        4f       4a      IV #          10:         =        =       = #          11:        2g      4dd     I64 #          12:         .      4cc       . #          13:        2g       2b       V #          14:        *-       *-      *- #         ^^^ Reshaping_example.hum ^^^ # #            Data fields:  #                   *Token :: character"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/Reshaping.html","id":"parsing-token","dir":"Articles","previous_headings":"Filtering Data","what":"Parsing Token","title":"Shaping Humdrum Data","text":"file, **kern spines example file include rhythmic data (**recip) pitch data. just studying tonality, extract just pitch information Token field, save new field. example, can use kern() extract pitch information Token, put new field—let’s call Pitch. new Pitch field, can still access original Token field. can see easily setting “active” field back Token:","code":"withinHumdrum(example, ~kern(Token)) -> example$Pitch #        Warning in slotx[i.internal] <- slotv: number of items to replace is not a #        multiple of replacement length  #        Warning in slotx[i.internal] <- slotv: number of items to replace is not a #        multiple of replacement length  #        Warning in slotx[i.internal] <- slotv: number of items to replace is not a #        multiple of replacement length  example #        ######### vvv Reshaping_example.hum vvv ######### #           1:    **kern  **silbe  **kern  **silbe  **harm #           2:         *        *       *        *       * #           3:         *        *       *        *       * #           4:         *        *       *        *       * #           5:         *        *       *        *       * #           6:         c        .       e        .       . #           7:         d        .       f        .       . #           8:         e        .       g        .       . #           9:         f        .       a        .       . #          10:         =        =       =        =       = #          11:         g        .      dd        .       . #          12:         .        .      cc        .       . #          13:         g        .       b        .       . #          14:         *        *       *        *       * #        ######### ^^^ Reshaping_example.hum ^^^ ######### #            Data fields:  #                    Token :: character #                   *Pitch :: character example$Token #        ######### vvv Reshaping_example.hum vvv ########## #           1:    **kern  **silbe   **kern  **silbe  **harm #           2:    *ICvox        *   *ICvox        *       * #           3:    *Ialto        *  *Isoprn        *       * #           4:     *M4/4        *    *M4/4        *       * #           5:       *C:        *      *C:        *     *C: #           6:       4.c     This      4.e     This       I #           7:        8d       is       8f       is       . #           8:        4e       an       4g       an       . #           9:        4f      ex-       4a      ex-      IV #          10:         =        =        =        =       = #          11:        2g     -am-      4dd     -am-     I64 #          12:         .        .      4cc        _       . #          13:        2g     -ple       2b     -ple       V #          14:        *-       *-       *-       *-      *- #        ######### ^^^ Reshaping_example.hum ^^^ ########## #            Data fields:  #                   *Token :: character #                    Pitch :: character"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/Reshaping.html","id":"splittingseparating-data","dir":"Articles","previous_headings":"","what":"Splitting/Separating Data","title":"Shaping Humdrum Data","text":"Humdrum data often packs multiple pieces information compact, concise, readable tokens. classic example, course, **kern often includes rhythm, pitch, phrasing, beaming, pitch ornamentation information! tokens great reading/writing, analyzing, typically want separate information want.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/Reshaping.html","id":"pitch-and-rhythm","dir":"Articles","previous_headings":"Splitting/Separating Data","what":"Pitch and Rhythm","title":"Shaping Humdrum Data","text":"’ve seen, **kern spines example file include rhythmic data (**recip) pitch data. cases, might want access pieces information, separately. can separate applying different functions Token field, saving output new fields. example, uses pitch() function extract pitch information saves new field call Pitch uses recip() function extract rhythm information saves new field call Rhythm. (course, choose different names new fields, instead Pitch Rhythm.) can use either new fields, , call withinHumdrum(), make active fields see print:","code":"withinHumdrum(example, ~pitch(Token)) -> example$Pitch #        Warning in slotx[i.internal] <- slotv: number of items to replace is not a #        multiple of replacement length  #        Warning in slotx[i.internal] <- slotv: number of items to replace is not a #        multiple of replacement length  #        Warning in slotx[i.internal] <- slotv: number of items to replace is not a #        multiple of replacement length withinHumdrum(example, ~recip(Token)) -> example$Rhythm  example #        ######### vvv Reshaping_example.hum vvv ######### #           1:    **kern  **silbe  **kern  **silbe  **harm #           2:         *        *       *        *       * #           3:         *        *       *        *       * #           4:         *        *       *        *       * #           5:         *        *       *        *       * #           6:        4.        .      4.        .       . #           7:         8        .       8        .       . #           8:         4        .       4        .       . #           9:         4        .       4        .       . #          10:         =        =       =        =       = #          11:         2        .       4        .       . #          12:         .        .       4        .       . #          13:         2        .       2        .       . #          14:         *        *       *        *       * #        ######### ^^^ Reshaping_example.hum ^^^ ######### #            Data fields:  #                    Token  :: character #                    Pitch  :: character #                   *Rhythm :: character example$Pitch #        ######### vvv Reshaping_example.hum vvv ######### #           1:    **kern  **silbe  **kern  **silbe  **harm #           2:         *        *       *        *       * #           3:         *        *       *        *       * #           4:         *        *       *        *       * #           5:         *        *       *        *       * #           6:        C4        .      E4        .       . #           7:        D4        .      F4        .       . #           8:        E4        .      G4        .       . #           9:        F4        .      A4        .       . #          10:         =        =       =        =       = #          11:        G4        .      D5        .       . #          12:         .        .      C5        .       . #          13:        G4        .      B4        .       . #          14:         *        *       *        *       * #        ######### ^^^ Reshaping_example.hum ^^^ ######### #            Data fields:  #                    Token  :: character #                   *Pitch  :: character #                    Rhythm :: character  example$Rhythm #        ######### vvv Reshaping_example.hum vvv ######### #           1:    **kern  **silbe  **kern  **silbe  **harm #           2:         *        *       *        *       * #           3:         *        *       *        *       * #           4:         *        *       *        *       * #           5:         *        *       *        *       * #           6:        4.        .      4.        .       . #           7:         8        .       8        .       . #           8:         4        .       4        .       . #           9:         4        .       4        .       . #          10:         =        =       =        =       = #          11:         2        .       4        .       . #          12:         .        .       4        .       . #          13:         2        .       2        .       . #          14:         *        *       *        *       * #        ######### ^^^ Reshaping_example.hum ^^^ ######### #            Data fields:  #                    Token  :: character #                    Pitch  :: character #                   *Rhythm :: character"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/Reshaping.html","id":"pastingaligning","dir":"Articles","previous_headings":"","what":"Pasting/Aligning","title":"Shaping Humdrum Data","text":"next step might align/combine information currently separated. many humrum datasets, multiple pieces information spread across multiple spines, cases, across spine paths stops. , given research question, need think multiple pieces information describing single data point, ’ll reshape data. example, example file **silbe (lyric) spines associate syllable exactly one note adjacent **kern spines.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/Reshaping.html","id":"folding-data","dir":"Articles","previous_headings":"Pasting/Aligning","what":"Folding Data","title":"Shaping Humdrum Data","text":"powerful approach aligning separated data “folding” information new field using family “folding functions.” Folding means taking information one spine, path, stop, moving new data field “top ” another spine. means taking, example, data Spine 2 putting new field Spine 1.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/Reshaping.html","id":"lyrics","dir":"Articles","previous_headings":"Pasting/Aligning > Folding Data > Folding Spines","what":"Lyrics","title":"Shaping Humdrum Data","text":"example, want align notes **kern spines syllables **silbe spine. can directly using foldHumdrum(): use fold argument indicate spine fold, onto argument indicate spine move onto. Notice second spine disappeared, now new field called Pipe1, first (onto) spine, containing data old Spine 2. **silbe spines like : datasets, might different numbers **kern/**silbe spines different files within dataset. Though foldHumdrum() can handle case, usually easier use special foldExclusive() function, folds based exclusive interpretation. Just specify fold onto arguments character strings matching names exclusive interpretations file: Notice foldExclusive() automatically folded **sible spines onto respective **kern spines, new field name.","code":"foldHumdrum(example, fold = 2, onto = 1) #        ##### vvv Reshaping_example.hum vvv ##### #           1:    **silbe  **kern  **silbe  **harm #           2:          *       *        *       * #           3:          *       *        *       * #           4:          *       *        *       * #           5:          *       *        *       * #           6:       This       .        .       . #           7:         is       .        .       . #           8:         an       .        .       . #           9:        ex-       .        .       . #          10:          =       =        =       = #          11:       -am-       .        .       . #          12:          .       .        .       . #          13:       -ple       .        .       . #          14:         *-       *        *       * #        ##### ^^^ Reshaping_example.hum ^^^ ##### #            Data fields:  #                    Token  :: character #                    Pitch  :: character #                    Rhythm :: character #                   *Pipe3  :: character foldHumdrum(example, fold = c(2, 4), onto = c(1, 3)) #        # vvv Reshaping_example.hum vvv # #           1:    **silbe  **silbe  **harm #           2:          *        *       * #           3:          *        *       * #           4:          *        *       * #           5:          *        *       * #           6:       This     This       . #           7:         is       is       . #           8:         an       an       . #           9:        ex-      ex-       . #          10:          =        =       = #          11:       -am-     -am-       . #          12:          .        _       . #          13:       -ple     -ple       . #          14:         *-       *-       * #        # ^^^ Reshaping_example.hum ^^^ # #            Data fields:  #                    Token  :: character #                    Pitch  :: character #                    Rhythm :: character #                   *Pipe3  :: character foldExclusive(example, 'silbe', 'kern') #        # vvv Reshaping_example.hum vvv # #           1:    **silbe  **silbe  **harm #           2:          *        *       * #           3:          *        *       * #           4:          *        *       * #           5:          *        *       * #           6:       This     This       . #           7:         is       is       . #           8:         an       an       . #           9:        ex-      ex-       . #          10:          =        =       = #          11:       -am-     -am-       . #          12:          .        _       . #          13:       -ple     -ple       . #          14:         *-       *-       * #        # ^^^ Reshaping_example.hum ^^^ # #            Data fields:  #                    Token  :: character #                    Pitch  :: character #                    Rhythm :: character #                   *silbe  :: character"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/Reshaping.html","id":"harmonic-interval","dir":"Articles","previous_headings":"Pasting/Aligning > Folding Data > Folding Spines","what":"Harmonic Interval","title":"Shaping Humdrum Data","text":"Let’s consider another common use case “folding” humdrum data. Lots humdrum files multiple spines **kern. cases, research question lead us think note, across spines, individual data points. However, research question concerns harmonic intervals (combinations pitches happening time) might think record multiple pitches single data observation. case, might want fold kern data one spine, top another! can using foldHumdrum() well: now cross tabulate two spines data:","code":"example <- readHumdrum(humdrumRroot, 'examples/Reshaping_example.hum')  kernonly <- example[[ , '**kern']]  foldHumdrum(kernonly, 2, 1) -> kernonly$Spine2 withHumdrum(kernonly, ~table(Token, Spine2)) #            2b 4.e 4a 4dd 4g 8f #        2g   1   0  0   1  0  0 #        4.c  0   1  0   0  0  0 #        4e   0   0  0   0  1  0 #        4f   0   0  1   0  0  0 #        8d   0   0  0   0  0  1"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/Reshaping.html","id":"harmony-spreading-data","dir":"Articles","previous_headings":"Pasting/Aligning > Folding Data > Folding Spines","what":"Harmony (Spreading Data)","title":"Shaping Humdrum Data","text":"another common use case, might one spine data actually describes happening entire record data. example, example’s **harm spine. chords indicated spine associated pitches , either, **kern spines. Luckily, foldHumdrum() foldExclusive() given onto spines fold spines, fold spine duplicated fill one target spines: harm spine copied new field “top ” **kern spines!","code":"example <- readHumdrum(humdrumRroot, 'examples/Reshaping_example.hum')  foldExclusive(example, 'harm', 'kern')  #        ######## vvv Reshaping_example.hum vvv ######## #           1:    **harm  **silbe  **harm  **silbe       #           2:         *        *       *        *       #           3:         *        *       *        *       #           4:         *        *       *        *       #           5:       *C:        *     *C:        *       #           6:         I        .       I        .       #           7:         .        .       .        .  .  . #           8:         .        .       .        .  .  . #           9:        IV        .      IV        .       #          10:         =        =       =        =       #          11:       I64        .     I64        .       #          12:         .        .       .        .  .    #          13:         V        .       V        .       #          14:        *-        *      *-        *       #        ######## ^^^ Reshaping_example.hum ^^^ ######## #            Data fields:  #                    Token :: character #                   *harm  :: character"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/Reshaping.html","id":"folding-stops-and-paths","dir":"Articles","previous_headings":"Pasting/Aligning > Folding Data","what":"Folding Stops and Paths","title":"Shaping Humdrum Data","text":"Though spines common structure humdrum data might need “fold,” can also fold structures. course, depends questions trying ask data! Consider example, multi-stop chords **kern spine: default, humdrumR treats token (note) stop separate data observation, row humdrum table. studying harmony, might want align stops “top” , different fields. Try foldStops() function! working spine paths, often less obvious interpret different paths terms data observations, want fold , can using foldPaths():","code":"example_stops <- readHumdrum(humdrumRroot, 'examples/Reshaping_example2_stops.hum')  example_stops #         vvv Reshaping_example2_stops.hum vvv  #           1:     **kern  **harm #           2:      *M4/4       * #           3:        *C:     *C: #           4:     4c e g       I #           5:     4B d g      Vb #           6:    4B- d g      vb #           7:     4A d f     IVb #           8:          =       = #           9:     2G c e     I64 #          10:     2G B d       V #          11:         *-      *- #         ^^^ Reshaping_example2_stops.hum ^^^  #            Data fields:  #                   *Token :: character foldStops(example_stops) #         vvv Reshaping_example2_stops.hum vvv  #           1:    ., .  ., . #           2:    ., .  ., . #           3:    ., .  ., . #           4:    e, g  ., . #           5:    d, g  ., . #           6:    d, g  ., . #           7:    d, f  ., . #           8:    ., .  ., . #           9:    c, e  ., . #          10:    B, d  ., . #          11:    ., .  ., . #         ^^^ Reshaping_example2_stops.hum ^^^  #            Data fields:  #                    Token       :: character #                   *Token_Stop1 :: character #                   *Token_Stop2 :: character example_paths <- readHumdrum(humdrumRroot, 'examples/Reshaping_example3_paths.hum')  example_paths #         vvv Reshaping_example3_paths.hum vvv  #           1:    **kern      **harm #           2:     *M4/4           * #           3:       *C:         *C: #           4:        4c           I #           5:        4d           . #           6:        4e           . #           7:        *^           * #           8:        4d  4f      ii #           9:         =   =       = #          10:        2c  2g       I #          11:        2B  2g      Vb #          12:        *v  *v       * #          13:         =           = #          14:        *-          *- #         ^^^ Reshaping_example3_paths.hum ^^^  #            Data fields:  #                   *Token :: character  foldPaths(example_paths) #         vvv Reshaping_example3_paths.hum vvv  #           1:    **kern  **harm #           2:         *       * #           3:         *       * #           4:         .       . #           5:         .       . #           6:         .       . #           7:         *       * #           8:        4f       . #           9:         =       = #          10:        2g       . #          11:        2g       . #          12:        *v       * #          13:         =       = #          14:         *       * #         ^^^ Reshaping_example3_paths.hum ^^^  #            Data fields:  #                    Token      :: character #                   *Token_Path :: character"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/Reshaping.html","id":"folding-grace-notes","dir":"Articles","previous_headings":"Pasting/Aligning > Folding Data","what":"Folding Grace Notes","title":"Shaping Humdrum Data","text":"functionality hasn’t implemented yet. Bug us !","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/articles/Reshaping.html","id":"other-folding","dir":"Articles","previous_headings":"Pasting/Aligning > Folding Data","what":"Other Folding","title":"Shaping Humdrum Data","text":"Using foldHumdrum(), also possible fold data structures. obvious example, folding consecutive records bars top . ’m sure want ! , use argument foldHumdrum().","code":""},{"path":[]},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Nathaniel Condit-Schultz. Author, maintainer.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Condit-Schultz N (2022). humdrumR: humdrumR. R package version 0.3.0.9000, https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR.","code":"@Manual{,   title = {humdrumR: humdrumR},   author = {Nathaniel Condit-Schultz},   year = {2022},   note = {R package version 0.3.0.9000},   url = {https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR}, }"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/index.html","id":"humdrumr","dir":"","previous_headings":"","what":"humdrumR","title":"humdrumR","text":"humdrumR R library analyzing musicological data encoded humdrum data format.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/index.html","id":"installing-r","dir":"","previous_headings":"Installation","what":"Installing R","title":"humdrumR","text":"use humdrumR, ’ll first need install R, version 4.1 later. highly recommend install Integrated Development Environment Rstudio well! link—Installing R RStudio—good starting place.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/index.html","id":"installing-humdrumr","dir":"","previous_headings":"Installation","what":"Installing humdrumR","title":"humdrumR","text":"humdrumR yet available standard R package repository, CRAN, (now) can installed github repository. install latest version (master branch) humdrumR, ’ll first need install R package devtools—devtools used creating maintaining R packages. Luckily, devtools CRAN, open R session machine type: successfuly installed devtools, now ready use install humdrumR straight github. R session, type:","code":"install.packages('devtools') devtools::install_github(\"Computational-Cognitive-Musicology-Lab/humdrumR\", build_vignettes = TRUE)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/index.html","id":"humdrumr-source","dir":"","previous_headings":"Installation","what":"humdrumR source","title":"humdrumR","text":"Another option—useful, want inspect, contribute , humdrumR source code—actually download humdrumR package source github install directly. ’ll first need install git. git installed computer, can download humdrumR repository clicking “Clone download” github page. Alternatively, can use git directly: navigate directory machine ’d like save package source type: ’ve done , can install source computer using devtools: Open R session use setwd move working directory inside repository just downloaded (.e., cloned). , type downloaded Rstudio, can use “Open Project” option select file humdrumR.Rproj repository. ’ve done can just click “Install Restart” “Build” pane. ’ve completed installtion humdrumR can used simply calling:","code":"git clone https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR devtools::install() library(humdrumR)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"humdrumR","text":"stage, humdrumR functions least partially documented, can easily read using ? operator name function. good place start : also check “vignettes” humdrumR, offer easier introduction package. installed github using build_vignettes = TRUE option, able simply call:","code":"library(humdrumR)  ?humdrumR browseVignettes(\"humdrumR\")"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/LO5th.html","id":null,"dir":"Reference","previous_headings":"","what":"Line of Fifths — LO5th","title":"Line of Fifths — LO5th","text":"function LO5th S3-generic function methods extract \"line--fifths\" value various pitch objects representations.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/LO5th.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Line of Fifths — LO5th","text":"","code":"LO5th(x, generic = FALSE, ...)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/LO5th.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Line of Fifths — LO5th","text":"Returns integer vector array, matching input.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/LO5th.html","id":"the-line-of-fifths","dir":"Reference","previous_headings":"","what":"The Line of Fifths","title":"Line of Fifths — LO5th","text":"Every interval Western music associated integer line fifths: Bb = m7 = -2 F =  P4  = -1 C =  P1 = 0 G =  P5 = 1 D =  M2 = 2 =  M6 = 3 E =  M3 = 4 B =  M7 = 5 F# = A4 = 6 etc. natural notes (C) major scale---also call generic intervals---fall range -1:5. fact, diatonic key block seven consecutive numbers line--fifths: example, Eb major -4:2. \"Sharps\" \"flats\" represent +7 -7 line--fifths respectively.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/REparser.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse String Using Regular expressions — REparser","title":"Parse String Using Regular expressions — REparser","text":"Takes input string parses sequence regular expressions.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/REparser.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse String Using Regular expressions — REparser","text":"","code":"REparser(   res,   parse.strict = TRUE,   parse.exhaust = TRUE,   parse.lead = FALSE,   parse.rest = FALSE,   toEnv = FALSE )  REparse(   str,   res,   parse.strict = TRUE,   parse.exhaust = TRUE,   parse.lead = FALSE,   parse.rest = FALSE,   reverse = FALSE,   sep = NULL,   toEnv = FALSE )"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/REparser.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parse String Using Regular expressions — REparser","text":"exhaustive TRUE, string must exhaustively broken matching regular expressions. Superfluous (non-match) characters begginning, end, bettween matches, result NA returned. ------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/RegexFind.html","id":null,"dir":"Reference","previous_headings":"","what":"Match strings against regular expression — RegexFind","title":"Match strings against regular expression — RegexFind","text":"infix functions simply syntactic sugar existing R regular expression matching functions. vector regexes given right argument, matches regexes returned.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/RegexFind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match strings against regular expression — RegexFind","text":"","code":"x %grepl% pattern  x %grepi% pattern  x %grepn% pattern  x %grepm% pattern  x %grep% pattern  list %lgrepl% pattern  list %lgrepi% pattern  list %lgrepn% pattern"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/RegexFind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Match strings against regular expression — RegexFind","text":"x vector search pattern One regular expression list list vectors (length) search ","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/RegexFind.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Match strings against regular expression — RegexFind","text":"%grepl%: Matches pattern x returns logical. Shorthand base::grepl(). %grep%: \"default\"---%grepl%. %grepi%: Matches pattern x returns integer indices. Shorthand base::grep(). %grepn%: Matches pattern x returns integer counts (can greater one one match occurs token). Shorthand stringi::stri_count_regex(). %grepm%: Matches pattern x returns matching strings (NA match). Shorthand stringi::stri_extract_first_regex() regex infix \"lapply\" version, called %lgrepx%.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/SOI.html","id":null,"dir":"Reference","previous_headings":"","what":"Onset/Offset interval since beginning. — SOI","title":"Onset/Offset interval since beginning. — SOI","text":"Refers duration rhythmic time elapsed since starting point (usually, beginning piece). music21 described \"offsets\"---however, prefer reserve words \"onset\" \"offset\" refer beginning (attacK) end (release) rhythmic events. STO takes vector numbers representing durations (numeric values) cummulatively sums starting value. Unlike sigma(), SOI returns timestamp onset rhythmic duration offset. SOI interprets first duration starting zero---different value specified start argument.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/SOI.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Onset/Offset interval since beginning. — SOI","text":"","code":"SOI(durations, start = 0L)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/SOI.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Onset/Offset interval since beginning. — SOI","text":"durations vector numeric values representing durations. start duration value (coerced class durations), offset begins.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/SOI.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Onset/Offset interval since beginning. — SOI","text":"S3 object class \"rhythmOffset\", essentially data.frame two columns---Onset Offset--- numeric values class input durations argument.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/accidental.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract accidental from pitch — accidental","title":"Extract accidental from pitch — accidental","text":"Extract accidental pitch","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/accidental.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract accidental from pitch — accidental","text":"","code":"accidental(x, ..., parseArgs = list(), inPlace = FALSE)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/accidental.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract accidental from pitch — accidental","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). parseArgs (list) parseArgs can list arguments passed pitch parser. convenient syntactic sugar, instead writing parseArgs = list(= x, b = y, etc.), can write parse(= x, b = y, etc.). inPlace (logical, length == 1) argument effect input (x argument) character strings, extral, non-pitch information strings \"beside\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/bhatk.html","id":null,"dir":"Reference","previous_headings":"","what":"Swara representation — bhatk","title":"Swara representation — bhatk","text":"Swara syllabes used represent scale degrees hindustani music---like solfege.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/bhatk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Swara representation — bhatk","text":"","code":"bhatk(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/bhatk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Swara representation — bhatk","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). generic (logical, length == 1) generic = TRUE \"specific\" pitch information discarded. tonal representations, means accidentals/qualities equivalent information printed. atonal representations, generic pitch returned. alternative, can specify specific alternative (opposite) generic argument: generic == !specific. simple (logical, length == 1) simple = TRUE \"complex\" pitch information discarded. means octave information discarded, resulting output confined within default octave. absolute pitch representations, octave middle C. relative pitch representations, octave unison. (special octave.round argument can used modify behavior). transposeArgs (list) transposeArgs can list arguments passed special call transpose. convenient syntactic sugar, instead writing transposeArgs = list(= x, b = y, etc.), can write transpose(= x, b = y, etc.). parseArgs (list) parseArgs can list arguments passed pitch parser. convenient syntactic sugar, instead writing parseArgs = list(= x, b = y, etc.), can write parse(= x, b = y, etc.). inPlace (logical, length == 1) argument effect input (x argument) character strings, extral, non-pitch information strings \"beside\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/bhatk.html","id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Swara representation — bhatk","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/cents.html","id":null,"dir":"Reference","previous_headings":"","what":"12-tone equal-temperament cent representation — cents","title":"12-tone equal-temperament cent representation — cents","text":"default, output cent simply semits(x) * 100. However, tonalHarmonic value can modified cents produce cent-values alternate tunings. example, cents('g', tonalHarmonic = 3) returns 701.955000865387, \"pure\" third harmonic (3) 1.955 sharper equal-temperment. Thus, midi semits return integers, cents always returns real-number (double) values.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/cents.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"12-tone equal-temperament cent representation — cents","text":"","code":"cents(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE,   tonalHarmonic = 2^(19/12) )"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/cents.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"12-tone equal-temperament cent representation — cents","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). generic (logical, length == 1) generic = TRUE \"specific\" pitch information discarded. tonal representations, means accidentals/qualities equivalent information printed. atonal representations, generic pitch returned. alternative, can specify specific alternative (opposite) generic argument: generic == !specific. simple (logical, length == 1) simple = TRUE \"complex\" pitch information discarded. means octave information discarded, resulting output confined within default octave. absolute pitch representations, octave middle C. relative pitch representations, octave unison. (special octave.round argument can used modify behavior). transposeArgs (list) transposeArgs can list arguments passed special call transpose. convenient syntactic sugar, instead writing transposeArgs = list(= x, b = y, etc.), can write transpose(= x, b = y, etc.). parseArgs (list) parseArgs can list arguments passed pitch parser. convenient syntactic sugar, instead writing parseArgs = list(= x, b = y, etc.), can write parse(= x, b = y, etc.). inPlace (logical, length == 1) argument effect input (x argument) character strings, extral, non-pitch information strings \"beside\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ). tonalHarmonic (numeric, length == 1) frequency \"tonal harmonic\" (perfect 10th) tuned ? default, value 2^(19/12), 12-tone equal-temperament10th. Pythagorean tuning, set tonalHarmonic = 3.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/cents.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"12-tone equal-temperament cent representation — cents","text":"TonalIntervals parsed frequency might also arbitrary cent deviations. example, cents(440 * 10/9, Exclusive = 'freq') returns 1082.404---correspond \"minor tone\" =440.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/cents.html","id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"12-tone equal-temperament cent representation — cents","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/chordTransformer.html","id":null,"dir":"Reference","previous_headings":"","what":"Parsing and deparsing chord information. — chordTransformer","title":"Parsing and deparsing chord information. — chordTransformer","text":"functions used work chord information.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/chordTransformer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parsing and deparsing chord information. — chordTransformer","text":"","code":"figuredBass(   x,   ...,   Key = NULL,   Exclusive = NULL,   parseArgs = list(),   transposeArgs = list(),   figurationArgs = list(),   inPlace = FALSE,   memoize = TRUE,   deparse = TRUE )"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/chordTransformer.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parsing and deparsing chord information. — chordTransformer","text":"xxx Tertian sets can read/wrote various ways.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/collapseHumdrum.html","id":null,"dir":"Reference","previous_headings":"","what":"HumdrumR data ","title":"HumdrumR data ","text":"functions used change \"shape\" data stored humdrum tables (held within humdrumRclass objects course).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/collapseHumdrum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"HumdrumR data ","text":"","code":"collapseHumdrum(   humdrumR,   byfields,   collapseAtomic = TRUE,   sep = \" \",   padPaths = FALSE )  collapseStops(humdrumR, collapseAtomic = TRUE, sep = \" \")  collapsePaths(humdrumR, collapseAtomic = TRUE, sep = \" \")  collapseRecords(humdrumR, collapseAtomic = TRUE, sep = \" \", padPaths = FALSE)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/collapseHumdrum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"HumdrumR data ","text":"humdrumR humdrumRclass data object. (see humdrum table documentation Fields section explanation.). collapseAtomic logical. collapseAtomic == TRUE, stop collapsed single string collapseAtomic == FALSE, stop collapsed list tokens. sep character. collapseAtomic == TRUE, collapsed tokens separated string. pad logical. path/column padding tokens included?","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/collapseHumdrum.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"HumdrumR data ","text":"collapseXXX family allows collapse user fields across groups another field.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/decimal.html","id":null,"dir":"Reference","previous_headings":"","what":"Decimal numbers — decimal","title":"Decimal numbers — decimal","text":"functions create decimal numbers identical base R numeric (real) numbers. However, numbers understood humdrumR rational numbers.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/decimal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Decimal numbers — decimal","text":"","code":"decimal(x)  as.decimal(x, ...)"},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/degree.html","id":null,"dir":"Reference","previous_headings":"","what":"Tonal scale degree representation (absolute) — degree","title":"Tonal scale degree representation (absolute) — degree","text":"humdrum **degree **deg interpretations represent Western \"scale degrees\" two slightly different formats. **degree representation, octave pitch represented \"absolutely,\" standard octave scheme scientific pitch. **deg representation, octave pitch indicated relative previous pitch--- \"^\" indicates pitch higher previous pitch \"v\" indicates pitch lower previous pitch.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/degree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tonal scale degree representation (absolute) — degree","text":"","code":"degree(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )  deg(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/degree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tonal scale degree representation (absolute) — degree","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). generic (logical, length == 1) generic = TRUE \"specific\" pitch information discarded. tonal representations, means accidentals/qualities equivalent information printed. atonal representations, generic pitch returned. alternative, can specify specific alternative (opposite) generic argument: generic == !specific. simple (logical, length == 1) simple = TRUE \"complex\" pitch information discarded. means octave information discarded, resulting output confined within default octave. absolute pitch representations, octave middle C. relative pitch representations, octave unison. (special octave.round argument can used modify behavior). transposeArgs (list) transposeArgs can list arguments passed special call transpose. convenient syntactic sugar, instead writing transposeArgs = list(= x, b = y, etc.), can write transpose(= x, b = y, etc.). parseArgs (list) parseArgs can list arguments passed pitch parser. convenient syntactic sugar, instead writing parseArgs = list(= x, b = y, etc.), can write parse(= x, b = y, etc.). inPlace (logical, length == 1) argument effect input (x argument) character strings, extral, non-pitch information strings \"beside\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/degree.html","id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Tonal scale degree representation (absolute) — degree","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/diatonicRepresentations.html","id":null,"dir":"Reference","previous_headings":"","what":"Diatonic set representations — diatonicRepresentations","title":"Diatonic set representations — diatonicRepresentations","text":"Diatonic sets can read/wrote various ways.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/diatonicSet.html","id":null,"dir":"Reference","previous_headings":"","what":"Tonal (diatonic) sets — diatonicSet","title":"Tonal (diatonic) sets — diatonicSet","text":"diatonicSet one humdrumR's types tonal data, representing Western diatonic keys. part, users need interact diatonicSets directly---rather, diatonicSets work behind scene numerous humdrumR pitch functions. See keyRepresentations keyTransformations documentation details usage functionality Tonality humdrumR vignette detailed explanation theory specifics diatonicSets.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/diatonicSet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tonal (diatonic) sets — diatonicSet","text":"","code":"dset(root = 0L, signature = root, alterations = 0L)  is.diatonicSet(x)  is.diatonicSet(x)  order.diatonicSet(   x,   ...,   parallel = TRUE,   na.last = TRUE,   decreasing = FALSE,   method = c(\"auto\", \"shell\", \"radix\") )  # S4 method for diatonicSet,diatonicSet ==(e1, e2)  # S4 method for diatonicSet,diatonicSet Compare(e1, e2)  # S3 method for diatonicSet diatonicSet(x, ...)  # S3 method for logical diatonicSet(x, ...)  # S3 method for numeric diatonicSet(x)  # S3 method for integer diatonicSet(x)  # S3 method for character diatonicSet(str, Exclusive = NULL, Key = NULL, ..., multiDispatch = FALSE)  # S4 method for tertianSet as.character(x)  # S4 method for tertianSet,tertianSet ==(e1, e2)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/diatonicSet.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tonal (diatonic) sets — diatonicSet","text":"diatonicSet S4 subclass humdrumR's virtual class struct, inherits lot useful \"vector-like\" behaviors/functionality. constructor function dset can used create diatonicSets directly. three arguments corespond three slots: root, mode, alteration. inputs coerced match length. root argument attempt coerce character strings tonalIntervals, use LO5th value root. default, .character method, thus (via struct) show method, diatonicSets call key(). Thus, return diatonicSet command line (call print one one), see key interpretation representation printed.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/diatonicSet.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Tonal (diatonic) sets — diatonicSet","text":"Root integers representing root key line--fifths Signature integers representing signature (number accidentals) key. Alteration integers representing alterations diatonic set key represented two integers, Root Signature. Root simply tonic note key circle fifths. Signature value circle fifths, indicating diatonic mode. can think Signature value indicating number accidentals, negative numbers flats positive numbers sharps. can also think signature indicating much \"natural key\" (C major) slid line--fifths. traditional diatonic modes Western music occur wherever Signature - Tonic range -5:1: Signature - Tonic = +1 => Lydian Signature - Tonic = +0 => Major (Ionian) Signature - Tonic = -1 => Mixolydian Signature - Tonic = -2 => Dorian Signature - Tonic = -3 => Minor (Aeolian) Signature - Tonic = -5 => Locrian Signature - Tonic = -4 => Phyrgian Note can make diatonicSets Root outside Key. unusual, may result sets predict.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/diatonicSet.html","id":"alterations","dir":"Reference","previous_headings":"","what":"Alterations","title":"Tonal (diatonic) sets — diatonicSet","text":"Alteration slots (also integer) can used represent various \"altered\" scales. integer values interpreted seven-trit balanced ternary string. (\"trits\" ternary equivalent binary \"bits.\") Balanced ternary allows three digits, 0 (unaltered degree), 1 (sharpened degree), -1 (flattened degree). seven trits correspond seven scale degrees line--fifth indicated signature---.e., ordered lowest hightest line--fifths, relative root. (instance, Signature == 0, degrees c(-1, 0, 1, 2, 3, 4, 5).) ternary arrangement maps powers three scale degree, Alteration integer: ± 1: raise flatten 7th scale degree. ± 3: raise flatten 3rd scale degree. ± 9: raise flatten 6th scale degree. ± 27: raise flatten 2nd scale degree. ± 81: raise flatten 5th scale degree. ± 243: raise flatten 1st scale degree. ± 749: raise flatten 4th scale degree. example, consider Alteration == 26: balanced ternary representation, decimal integer 26 represented 1 0 0 1 0 -1 0. (words 1 \"27s  place\" -1 \"ones place\"---.e., 27 - 1). represents raised 2nd (27) lowered 7th (-1). Alteration integer allows us concisely represent 2,187 possible combinations raised lowered diatonic scale degrees! However, combined Signature slot, redundancy scale representation. example, melodic minor scale can represented major scale (Signature - Root == 0) lowered third degree (Alteration == -3) minor scale (Signature - Root == -3) raised 6ths 7ths (Alteration == 10). However, though two representations result set line--fifths, might consider conceptually different contexts, consider redundancy acceptable. Another case encoding redundancy Alteration - 1 (flatten 7th) exactly equivalent Signature - 1. Similarly, Alteration + 749 (raise 4th) exactly equivalent Signature + 1. Double-flat double-sharp degrees encodable diatonicSet. However, combination Signature slot, sets double-flat/sharps (like doubly-diminished 7ths) can encoded.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/diatonicSet.html","id":"arithmatic","dir":"Reference","previous_headings":"","what":"Arithmatic","title":"Tonal (diatonic) sets — diatonicSet","text":"Arithmetic diatonicSets defined. However, number useful arithmetic operations diatonicSets data types defined: XXXX Elaborate XXXX Need implement special logic adding Alterations! (Taking account Signature addition.)","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/diatonicSet.html","id":"relational-operators","dir":"Reference","previous_headings":"","what":"Relational Operators","title":"Tonal (diatonic) sets — diatonicSet","text":"diatonicSets can compared using standard relational operations ==, !=. Two diatonicSets equal (according ==) slots (Root, Signature, Alteration) exactly identical. Ordinal comparisons (e.g., >, <=) diatonicSets Signature .","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/diatonicSet.html","id":"coercion","dir":"Reference","previous_headings":"","what":"Coercion","title":"Tonal (diatonic) sets — diatonicSet","text":"humdrumR knows coerce several base-R atomic types diatonicSets. can done using function---e.g., (3, \"diatonicSet\")---intuitively using function diatonicSet(). Coercision methods defined integer: interpreted root major key numeric: rounded nearest integer intepreted root major key character: interpreted using humdrumRs regular expression dispatch system, explained fully .","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/ditto.html","id":null,"dir":"Reference","previous_headings":"","what":"------------------------------------------->             NEEDS DOCUMENTATION             <------------------------------------------- — ditto","title":"------------------------------------------->             NEEDS DOCUMENTATION             <------------------------------------------- — ditto","text":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/ditto.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"------------------------------------------->             NEEDS DOCUMENTATION             <------------------------------------------- — ditto","text":"","code":"ditto"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/ditto.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"------------------------------------------->             NEEDS DOCUMENTATION             <------------------------------------------- — ditto","text":"object class list length 2.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/expand.html","id":null,"dir":"Reference","previous_headings":"","what":"Expand numbers outwards from zero — expand","title":"Expand numbers outwards from zero — expand","text":"Expand complement base R rounding functions, particularly trunc.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/expand.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expand numbers outwards from zero — expand","text":"","code":"expand(x)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/expand.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Expand numbers outwards from zero — expand","text":"four base R functions---round, ceiling, floor, trunc---follow different logic round real numbers ingegers: round: round nearest integer either direction. floor: round downward towards negative infinity. Negative numbers rounded \"negative\" numbers. ceiling: round upward towards infinity. Negative numbers rounded \"less negative\" numbers. trunc: round \"inward\" towards zero. Negative numbers rounded \"less negative\" numbers, positive numbers still rounded downwards \"less positive\" numbers. Just ceiling compliments floor, humdrumR function expand acts compliment trunc: expand rounds \"outward\" away zero. Negative numbers rounded \"negative\" numbers positive numbers rounded \"positive\" numbers. table explains better words:","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/fillThru.html","id":null,"dir":"Reference","previous_headings":"","what":"Propogate data points to ","title":"Propogate data points to ","text":"fillThru function allow \"fill\" null values vector non-null values earlier/later vector. default, \"foward,\" behavior fills null value previous (lower index) non-null value, . reverse argument can used cause \"backeward\" filling, next (higher index) non-null value used.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/fillThru.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Propogate data points to ","text":"","code":"fillThru(x, nonnull = function(x) !is.na(x) & x != \".\", reverse = FALSE)  fillForward(...)  fillBackwards(...)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/fillThru.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Propogate data points to ","text":"values considered \"non-null\" can controlled using nonnull argument. nonnull argument can either logical vector length input (x) argument, numeric vector positive indices, function , applied x returns appropriate logical/numeric vector.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/filterHumdrum.html","id":null,"dir":"Reference","previous_headings":"","what":"Filter humdrum data — filterHumdrum","title":"Filter humdrum data — filterHumdrum","text":"filterHumdrum command used filter humdrumR corpus Indexing humdrumR corpus (using [] [[]] operators) uses calls filterHumdrum!","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/filterHumdrum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filter humdrum data — filterHumdrum","text":"","code":"filterHumdrum(humdrumR, ...)  removeEmptyFiles(humdrumR, fillfromTypes = \"D\")  removeEmptySpines(humdrumR, fillfromTypes = \"D\")  removeEmptyRecords(humdrumR, fillfromTypes = \"D\")  humdata[] # returns unchanged  humdata[x:y]  humdata['regex']  humdata[~expression]  humdata[[x:y]]  humdata[[ , x:y]]  humdata[['regex']]  humdata[[x:y, l:m]]"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/filterHumdrum.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Filter humdrum data — filterHumdrum","text":"filterHumdrum used similar manner withinHumdrum, taking number \"expressions\" (functions) arguments. (fact, expressions/function arguments passed directly internal call withinHumdrum.) difference expressions/functions fed filterHumdrum must predicate expressions return logical (TRUE/FALSE) vector. returned vector must also length input data (number rows humdrum table). (can use dofill~ expression want \"expand\" shorter outputs filtering pusposes.) filterHumdrum updates humdrum table's Filter field using logical (|) existing Filter field negation predicate: Filter | !Predicate. HumdrumR functions (mostly) ignore data points Filter == TRUE: print filtered humdrumR see filtered data points turned null data (.), calls withinHumdrum ignore filtered data. default, filterHumdrum completely removes files corpus data records filtered . However, can stop specifying removeEmptyFiles argumet FALSE. want remove empty files, spines, records, call removeEmptyFiles, removeEmptySpines, removeEmptyRecords.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/filterHumdrum.html","id":"indexing","dir":"Reference","previous_headings":"","what":"Indexing","title":"Filter humdrum data — filterHumdrum","text":"R, basic indexing operators, [] [[]], used select subsets data. many R data types (instance, base R lists) [single brackets] used \"shallower\" extraction [[double brackets]] used \"deeper\" extraction. HumdrumR corpus indexing follows basic pattern: [single brackets] used index humdrumR objects piece [[double brackets]] used index within pieces. (Accidentally writing [] need [[]] common error, watch !) Whether, indexing piece within, humdrumR objects can use three types indexing arguments: numeric (ordinal integers) character string (regular expressions) formula (arbitrary expressions) last option (formula) powerful option, indeed, first two options (numeric character indexing) just convenient shorthands indexing can accomplished using formula method.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/filterHumdrum.html","id":"numeric-indexing-","dir":"Reference","previous_headings":"","what":"Numeric indexing:","title":"Filter humdrum data — filterHumdrum","text":"Indexing humdrumR corpora [single brackets] accept one numeric argument. argument used pick pieces within humdrumR object ordinally. Thus, humdata[1:10] select first ten pieces data humdata[42] select 42nd piece. Indexing humdrumR objects [[double brackets]] accept one two numeric arguments, j, either can used isolation combination. (j used isolation, must placed comma, humdata[[ , j ]].) used index data records (.e., based humtable Record field) ordinally. Thus, humdata[[1:20]] indexes first twenty records file corpus, humdata[[42]] extracts 42nd record file. j used index spines  (.e., based Spine field) ordinally. Thus, humdata[[ , 3:4]] returns third fourth spines file corpus. indexing humdrumR corpora numbers, numeric (double) inputs converted integers. Note numeric humdrumR indexing entirely ordinal, meaning pieces/data records/spines matched based value respective fields, rather order among existing values. Thus, [single-bracket] indexing $i_th$ piece corpus taken, regardless FileN field associated piece. example, return 12th piece original humdata object, second piece. beacuse first call [] returns 11th 20th pieces, second call returns second piece still present (12th). Similarly, return third spine original data. normal R indexing, negative numbers can used, causing corresponding elements removed instead retained. Thus, humdata[-3:-5] remove third, fourth, fifth pieces data humdata[[ , -3:-5]] remove third, fourth, fifth spines piece. Positive negative indices mixed single argument. cases, indices outside range (value 0) ignored. E.g., corpus twenty files call corpus[21], 21st piece, 21 \"range\". input indices 0 error result. input indices range empty humdrumR object returned. instance, humdata[[401:500, ]] return empty humdrumR object pieces 400 data records.","code":"humsubset <- humdata[11:20] humsubset[2] humsubset2 <- humdata[[ , 2:4]] humsubset2[[ , 2]]"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/filterHumdrum.html","id":"character-indexing-","dir":"Reference","previous_headings":"","what":"Character indexing:","title":"Filter humdrum data — filterHumdrum","text":"Indexing humdrumR objects [single brackets] accept one vector character strings. strings treated regular expressions (regexes). tokens humdrumR object's Active fields searched matches regular expressions input. piece contains match regular expressions retained---pieces filtered . Note ([single-bracket] indexing) entire piece retained, even one match. matches occur pieces, empty humdrumR object returned. Indexing humdrumR objects [[double brackets]] accept one two vectors character strings, j, either can used isolation combination. (j used isolation, must placed comma, humdata[[ , j]].) strings treated regular expressions (regexes). tokens humdrumR object's Active fields searched matches regular expressions input. record contains least one token matching regex retained. Similarly, spine contains least one token matching regex j retained. j used together, matching spines (j) indexed first, tokens matching regular expression(s) must found matching spines. third argument, k, can also used, j arguments missing. order work, need put two commas mark \"missing\" j arguments: e.g., humdata[[ , , '[Ee]-']]. case k, matching tokens retained, regardless spine record number(s).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/filterHumdrum.html","id":"formula-indexing-","dir":"Reference","previous_headings":"","what":"Formula indexing:","title":"Filter humdrum data — filterHumdrum","text":"Indexing humdrumR objects formulae powerful, flexible indexing option. Either [single] [[double]] brackets accept (single) formula. formula fed directly arguments filterHumdrum---, music evaluate logical vector length input. case [single-bracket] indexing, one formula accepted, every piece evalues least one TRUE retained. instance, humdata[~Spine > 4] return pieces contain five () spines. [single-bracket] formula indexing especially useful indexing meta-data properties like reference records: instance, humdata[~COM == \"Paul McCartney\"] return pieces !!!COM: Paul McCartney reference record. case [[double-bracket]] indexing, one two formulas accepted, arguments j, either can used isolation combination. (j used isolation, must placed comma, humdata[[ , j]].) case formulae, record evaluates least one TRUE value retained. case j, spine evaluates least one TRUE value retained. piece contains matches dropped entirely. [[double-bracket]] formula indexing, third argument, k may used absence j. order work, need put two commas mark \"missing\" j arguments: e.g., humdata[[ , , ~formula]]. case k tokens evaluate TRUE retained, regardless piece/spine/record. Pieces, spines, records TRUE values simply dropped. Using k argument exactly \"plain\" call filterHumdrum.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/foldExclusive.html","id":null,"dir":"Reference","previous_headings":"","what":"","title":"","text":"foldExclusive() special version foldHumdrum(), \"folds\" spines based exclusive interpretations. instance, can \"fold\" **silbe spines corpus onto respective **kern spines.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/foldExclusive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"","text":"","code":"foldExclusive(humdrumR, fold, onto, fromField = activeFields(humdrumR)[1])"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/foldExclusive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"","text":"humdrumR humdrumR data object. fold (character) target exclusive interpretation(s) \"fold\" spines new fields. Must specified without ** prefix: \"kern\" \"**kern\". onto (character, whole number) target exclusive interpretation(s) \"fold\" data moved. Must specified without ** prefix: \"kern\" \"**kern\". fromField (character, length == 1) string (partially) matching name data field humdrumR-object input. field field \"folded\" new field.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/foldExclusive.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"","text":"fold onto arguments (character, length == 1) must match exclusive interpretations humdrumR object input. Within file, mismatches number matching onto fold spines handled \"parallel,\" just like foldHumdrum(). Multi-matching spines matched left--right. matching exclusive interpetation pairs found, unchanged humdrumR object returned warning.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/foldGraceNotes.html","id":null,"dir":"Reference","previous_headings":"","what":"","title":"","text":"\"Fold\" grace notes neighbos","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/foldGraceNotes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"","text":"","code":"foldGraceNotes(humdrumR)"},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/foldHumdrum.html","id":null,"dir":"Reference","previous_headings":"","what":"","title":"","text":"Many humdrum datasets encode data spread across multiple spines, spine-paths, stops. default, humdrumR parses separate spine, spine-path, stop individual data points, taking one row humdrum table. want treat data multiple spines/paths/stops different aspects data easiest reshape data information different humdrumR fields rather separate spines/paths/stops. \"fold\" data structural field \"top\" data using foldHumdrum. convenient foldStops() foldPaths() functions automatically fold stops/paths dataset onto first stop/path, creating new fields named, e.g., Path1, Path2, etc.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/foldHumdrum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"","text":"","code":"foldHumdrum(   humdrumR,   fold,   onto,   what = \"Spine\",   File = NULL,   fromField = activeFields(humdrumR)[1],   newFieldNames = NULL )  foldPaths(humdrumR, fromField = activeFields(humdrumR)[1])  foldStops(humdrumR, fromField = activeFields(humdrumR)[1])"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/foldHumdrum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"","text":"humdrumR humdrumR data object. fold (numeric, whole number) target structure (spine, path, etc.) \"fold\" data another structural position field(s). onto (numeric, whole number) target structure (spine, path, etc.) \"fold\" data moved. (character, length == 1) structural field folded across. Valid options \"Spine\", \"Path\", \"Stop\", \"Record\",\"NData\". File (NULL numeric, length == length(onto), whole number) Used specify specific folds different files corpus (see \"File-Specific Folding\" section, ). fromField (character, length == 1) string (partially) matching name data field humdrumR-object input. field field \"folded\" new field. newFieldNames (character) Names use new fields created folding.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/foldHumdrum.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"","text":"numeric fold onto arguments, specify fold /. fold indicates Spine/Path/Stop fold , \"\" Spine/Path/Stop indicated onto. example, specify foldHumdrum(mydata, fold = 2, onto = 1, = 'Spine') spine 2 folded \"top spine 1. fold onto targets may overlap. fold onto arguments can vectors length, interpreted parallel: example, combination fold = 1:2 onto = 3:4 map first spine third spine (1 -> 3) second spine 4th spine (2 -> 4). onto targets duplicated, fold spines folded onto multiple new fields: example, combination fold = 1:2 onto = c(3, 3) map first spine second spine two new fields third spine. fold target duplicated, fold spines can copied onto multiple onto spines: example, combination fold = 1 onto = 2:3 map contents first spine onto second third spine, duplicating spine one data. lengths fold onto automatically matched, arguments like fold = 1:2 onto = 3 equivalent (fold = 1:2, onto = c(3, 3)). makes east things like \"copy four spines onto spine 1\": just write (fold = 2:4, onto = 1). specify structural field want fold across, use argument (character, length == 1). default value \"Spine\"; common fold options \"Path\", \"Stop\", though might want use convenient foldPaths() foldStops() functions directly (details ). (may also fold across \"Record\" \"NData\"), advanced/tricky!) fromField (character, length == 1) controls field fold spine/path/stop folded new field. fromField argument defaults (first) active field, must match (partially match) field humdrumR argument data set. resulting new fields automatically named appropriate pipes. newFieldNames argument (character) can used control output names: one new field created fold. specify many newFieldNames, later names ignored. specify newFieldNames, later names given pipe names, consistent default behavior.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/foldHumdrum.html","id":"file-specific-folding","dir":"Reference","previous_headings":"","what":"File-Specific Folding","title":"","text":"default, \"fold\" carried file input corpus (humdrumR argument). need specify different folds different files, specify File argument (numeric, whole number). every file corpus want apply folds , must specify fold onto arguments parallel vectors File argument (even reduendant files). example, specify combinations, File one: first spine mapped second spine third spine mapped fourth spine File two: first spine mapped second spine fourth spine mapped third spine files corpus included, affected !","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/freq.html","id":null,"dir":"Reference","previous_headings":"","what":"Translate pitches to frequency (Hz) — freq","title":"Translate pitches to frequency (Hz) — freq","text":"Translate pitches frequency (Hz)","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/freq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Translate pitches to frequency (Hz) — freq","text":"","code":"freq(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE,   tonalHarmonic = 2^(19/12),   frequency.reference = 440,   frequence.reference.note = \"a\" )"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/freq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Translate pitches to frequency (Hz) — freq","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). generic (logical, length == 1) generic = TRUE \"specific\" pitch information discarded. tonal representations, means accidentals/qualities equivalent information printed. atonal representations, generic pitch returned. alternative, can specify specific alternative (opposite) generic argument: generic == !specific. simple (logical, length == 1) simple = TRUE \"complex\" pitch information discarded. means octave information discarded, resulting output confined within default octave. absolute pitch representations, octave middle C. relative pitch representations, octave unison. (special octave.round argument can used modify behavior). transposeArgs (list) transposeArgs can list arguments passed special call transpose. convenient syntactic sugar, instead writing transposeArgs = list(= x, b = y, etc.), can write transpose(= x, b = y, etc.). parseArgs (list) parseArgs can list arguments passed pitch parser. convenient syntactic sugar, instead writing parseArgs = list(= x, b = y, etc.), can write parse(= x, b = y, etc.). inPlace (logical, length == 1) argument effect input (x argument) character strings, extral, non-pitch information strings \"beside\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ). tonalHarmonic (numeric, length == 1) frequency \"tonal harmonic\" (perfect 10th) tuned ? default, value 2^(19/12), 12-tone equal-temperament10th. Pythagorean tuning, set tonalHarmonic = 3. frequency.reference (numeric, length == 1) reference frequency---default 440 (Hz). frequency.reference.note (parsable pitch representation, length == 1) note reference.frequency tuned ? Default \"\"---middle-C.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/freq.html","id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Translate pitches to frequency (Hz) — freq","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/getFields.html","id":null,"dir":"Reference","previous_headings":"","what":"Get named — getFields","title":"Get named — getFields","text":"Get named ------------------------------------------->             NEEDS DOCUMENTATION             <------------------------------------------- Get named","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/getFields.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get named — getFields","text":"","code":"getFields(humdrumR, fieldnames = NULL, dataTypes = \"D\")"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/getTandem.html","id":null,"dir":"Reference","previous_headings":"","what":"Get tandem interpretation information from humdrum data. — getTandem","title":"Get tandem interpretation information from humdrum data. — getTandem","text":"every humdrumR object field called ======= Every humdrumRclass object field called >>>>>>> master Tandem vector strings accumulates tandem interpretations Spine. function (getTandem) extracts tandem interpretations field, based matching regular expression. obligatory '*' need included regex, added automatically. Thus, want find tandem interpretations match '*clef..', just write regex = 'clef..'.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/getTandem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get tandem interpretation information from humdrum data. — getTandem","text":"","code":"getTandem(tandem, regex)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/grapes-.-grapes.html","id":null,"dir":"Reference","previous_headings":"","what":"------------------------------------------->             NEEDS DOCUMENTATION             <------------------------------------------- — %.%","title":"------------------------------------------->             NEEDS DOCUMENTATION             <------------------------------------------- — %.%","text":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/grapes-.-grapes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"------------------------------------------->             NEEDS DOCUMENTATION             <------------------------------------------- — %.%","text":"","code":"e1 %.% e2"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/helmholtz.html","id":null,"dir":"Reference","previous_headings":"","what":"Helmholtz pitch representation — helmholtz","title":"Helmholtz pitch representation — helmholtz","text":"Helmholtz notation","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/helmholtz.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helmholtz pitch representation — helmholtz","text":"","code":"helmholtz(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/helmholtz.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helmholtz pitch representation — helmholtz","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). generic (logical, length == 1) generic = TRUE \"specific\" pitch information discarded. tonal representations, means accidentals/qualities equivalent information printed. atonal representations, generic pitch returned. alternative, can specify specific alternative (opposite) generic argument: generic == !specific. simple (logical, length == 1) simple = TRUE \"complex\" pitch information discarded. means octave information discarded, resulting output confined within default octave. absolute pitch representations, octave middle C. relative pitch representations, octave unison. (special octave.round argument can used modify behavior). transposeArgs (list) transposeArgs can list arguments passed special call transpose. convenient syntactic sugar, instead writing transposeArgs = list(= x, b = y, etc.), can write transpose(= x, b = y, etc.). parseArgs (list) parseArgs can list arguments passed pitch parser. convenient syntactic sugar, instead writing parseArgs = list(= x, b = y, etc.), can write parse(= x, b = y, etc.). inPlace (logical, length == 1) argument effect input (x argument) character strings, extral, non-pitch information strings \"beside\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/helmholtz.html","id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Helmholtz pitch representation — helmholtz","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humActive.html","id":null,"dir":"Reference","previous_headings":"","what":"The ","title":"The ","text":"\"Active\" expression used default value lot humdrumR code. one, data printed show calls, .e., whenever return humdrumR object terminal. expression within call ()Humdrum . automatically replaced Active expression.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humActive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The ","text":"","code":"evalActive(   humdrumR,   dataTypes = \"D\",   forceVector = FALSE,   sep = \", \",   nullAs = NA )  getActive(humdrumR)  setActive(humdrumR, form)  setActiveFields(humdrumR, fieldnames)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humActive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The ","text":"humdrumR humdrumRclass data object. dataTypes dataTypes humdrum records include. Legal values 'G', 'L', '', 'M', 'D', 'd', 'P' combination single string (e.g., \"LIM\"). (see humdrum table documentation Fields section explanation.). forceVector logical. TRUE, result forced atomic vector. sep length-one character string. forceVector == TRUE value used separator tokens collapsed. nullAsDot single atomic value. null tokens coerced value (default .).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humActive.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The ","text":"active expression can changed commands setActive $ operator. handy way quickly look different fields data. Active expression often just name field: instance, default value Token. However, can actually complex expression evaluates within humdrum table. instance, Active expression : paste0(Token, \" \", Record), automatically print Token record number pasted .","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humActive.html","id":"null-data","dir":"Reference","previous_headings":"","what":"Null data","title":"The ","text":"HumdrumR identifies \"null data\" based active field. Anywhere current active field evaluates \".\" NA considered Null data, assigned type \"d\" internal humdrum table. work, often data tokens null one field, another field. example, load **kern data, token like \"4r\" (quarter-note rest) token NA call pitch, NA call recip (rhythm). Now, change active field Pitch Rhythm see different numbers (non-null) data tokens: ntokens(kerndata$Pitch) vs ntokens(kerndata$Rhythm) return different numbers! (different number rest tokens.) Similarly, apply functions/expressions data (using withinHumdrum example), result depend active field : , get different numbers ! (Assuming rests data.) case even though -expression actually using Pitch Rhythm fields! Pitch active field rest tokens null-data ignored!","code":"kerndata <- readHumdrum(...)  kerndata$Token %hum>% pitch -> kerndata$Pitch kerndata$Token %hum>% recip -> kerndata$Rhythm kerndata$Pitch %hum<% ~length(Token) kerndata$Rhythm %hum<% ~length(Token)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humAssignment.html","id":null,"dir":"Reference","previous_headings":"","what":"Assigning new fields — humAssignment","title":"Assigning new fields — humAssignment","text":"R objects often ways assigning new values part object using indexing operators. HumdrumR objects objects different, allow us insert new fields !","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humAssignment.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Assigning new fields — humAssignment","text":"new field can inserted humdrumR object two ways: field can copied one humdrumR object another internal humdrum tables exact number data tokens (.e., rows). might seem obvious, mechanism useful can used rename existing fields within humdrumR object (explained ). vector list vectors can inserted new fields humdrumR object. Fields can assigned using two syntaxes: \"fieldname\" can whatever want , course!","code":"humdata['fieldname'] <- x # or humdata[c('fieldname1', 'fieldname2')] <- x humdata$fieldname <- x"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humAssignment.html","id":"humdrumr-gt-humdrumr-assignment-","dir":"Reference","previous_headings":"","what":"humdrumR -> humdrumR assignment:","title":"Assigning new fields — humAssignment","text":"Assigning field one humdrumR object another works like : (Recall two objects must exact numbers data tokens.) name(s) given indexing expression left side assignment (.e., humdata[c('name1', 'name2')] humdata$name) used new field names. fields extracted right side assignment little trickier: fields right-side humdrumR object named $PipeN$ ($N$ integer) copied descending order named fields left side. $PipeN$ fields right side, fields used current Active formula (right side) copied instead. system might seem odd first, useful combination withinHumdrum function, convenient pipe operator %hum>% withinHumdrum creates new fields, calls $Pipe1 ... Pipe2 ... PipeN$. Since output withinHumdrum always input except new \"Pipe\" fields, Byou can use humdrumR <- humdrumR assignment immediately assign pipe fields meaningful names original object. makes sense example: humdrumR, actually favor left--right \"piping\" style. Luckily, R allows assign left--right, proper humdrumR style actually: Calls withinHumdrum (%hum>%) keep producing new pipe fields. one pipe fields, can assign multiple fields using []<- syntax: #' IMPORTANT NOTE!: \"PipeN\" fields humdrumR object assign assign field names simply dropped. nice, often might proceed serious piped steps, want last one (two). want keep pipe fields either re-assign (.e., keep \"PipeN\" names) assign names using ->[c(\"name1\", \"name2\", \"name3\", ...)] syntax.","code":"humdata$Semits <- humdata %hum>% ~semit(Token) humdata %hum>% ~semit(Token) -> humdata$Semits humdata %hum>% ~semit(Token) %hum>% ~pitch(Token) -> humdata[c('semit', 'pitch')]"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humAssignment.html","id":"humdrumr-gt-vector-assignment-","dir":"Reference","previous_headings":"","what":"humdrumR -> vector assignment:","title":"Assigning new fields — humAssignment","text":"can assign vectors lists vectors straight humdrumR object. vectors must length number data tokens target object. provide multiple vectors assign (list data.frame vectors) must provide number fieldnames using ->[c('name1', 'name2', ...)] syntax. can use ntokens command determine right length vectors need!","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humCensus.html","id":null,"dir":"Reference","previous_headings":"","what":"Tabulate records and tokens in a humdrumR corpus — humCensus","title":"Tabulate records and tokens in a humdrumR corpus — humCensus","text":"census one humdrumR's summary functions, used tabulate raw size humdrumR corpus. census takes humdrumR object returns humCensus table. dataType argument controls types records tabulate: legal values 'G', 'L', '', 'M', 'D', 'd' combination (e.g., \"LIM\"). default \"D\".","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humCensus.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tabulate records and tokens in a humdrumR corpus — humCensus","text":"","code":"census(humdrumR, dataTypes = \"GLIMDd\", by = \"Filename\", removeEmpty = FALSE)  census(humdata)[i]  # S3 method for humCensus print(censusTable, showEach = TRUE, screenWidth = options(\"width\")$width - 10L)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humCensus.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tabulate records and tokens in a humdrumR corpus — humCensus","text":"humdrumR humdrumR object dataTypes character string length 1. character string length 1. Must field humdrumR object.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humCensus.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tabulate records and tokens in a humdrumR corpus — humCensus","text":"humCensus table five columns information: Records total number records. Tokens total number tokens. (unique) number unique tokens Characters total numder characters. includes humdrum control characters like * !!. (per token) simply Characters / Tokens, indicating mean length token. humCensus table one row file corpus. Rows labeled file's corresponding number (humTable's File field) name (Filename field). addition, humCensus object printed, totals across files printed well---(unique) (per token) across files calculated across files well, summed.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humCensus.html","id":"indexing","dir":"Reference","previous_headings":"","what":"Indexing","title":"Tabulate records and tokens in a humdrumR corpus — humCensus","text":"Rows humCensus object can selected single argument : e.g., censusTable[]. numeric, corresponding rows selected ordinally (File number). character string, string mached regular expression file names. formula, right-hand side formula evaluated within table---evaluates logical vector, files selected accordingly. instance, censusTable[~Tokens > 100] select files 100 tokens. ('(unique)' '(per token)' columns must referred names enclosed \\``---example, censusTable~\\verb(unique)\\ > 100` return files 100 unique tokens. drop argument also available. TRUE, plain data.table::data.table() returned.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humCoercion.html","id":null,"dir":"Reference","previous_headings":"","what":"humdrumR Coercion. — humCoercion","title":"humdrumR Coercion. — humCoercion","text":"Many users may wish work humdrum data without using [humdrumR:humdrumR][humdrumR] API, instead using basic R data types. purpose, humdrumRclass data objects can coerced basic R data types.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humCoercion.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"humdrumR Coercion. — humCoercion","text":"","code":"# S4 method for humdrumR as.vector(x, mode = \"any\")  as.lines(   humdrumR,   dataTypes = \"GLIMDd\",   fieldname = NULL,   alignColumns = FALSE,   padPaths = FALSE,   padder = \".\" )  # S3 method for humdrumR as.matrix(   x,   dataTypes = \"D\",   fieldnames = NULL,   alignColumns = TRUE,   padder = NA,   path.collapse = TRUE )  # S4 method for humdrumR as.data.frame(   x,   dataTypes = \"D\",   fieldname = NULL,   padder = NA,   collapse.path = TRUE )  as.matrices(   humdrumR,   dataTypes = \"D\",   fieldnames = NULL,   padder = NA,   path.collapse = TRUE,   alignColumns = FALSE )  as.data.frames(   humdrumR,   dataTypes = \"D\",   fieldnames = NULL,   padder = NA,   path.collapse = TRUE )"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humCoercion.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"humdrumR Coercion. — humCoercion","text":"mode mode argument '', can single character string naming atomic mode---output coerced mode (possible). dataTypes types humdrum records include. Legal values 'G', 'L', '', 'M', 'D', 'd' combination (e.g., \"LIM\"). (see humdrum table documentation Fields section explanation.). padder atomic value length one. par.files pad.paths true, padder argument used fill desired gaps. pad.files logical (default TRUE). pieces humdrumRclass corpus fewer [humdrumR:humTable][spines/columns] maximum, padded padder argument (par.files == TRUE) error occur (pad.files == FALSE)? Note \"padded\" points represented original humdrum data. pad.paths logical spine path splits ('*^') occur humdrumR data, padded padder argument (par.files == TRUE) error occur (pad.paths == FALSE)? Note \"padded\" points represented original humdrum data. field(s) field argument NULL, can instead character string matching humdrumRclass object's fields. , fields extracted instead Active expression. calls .vector .data.frame, one field can extracted. However, calls .matrix, multiple fields can extraced---fields returned third matrix dimension, field forming one rectangular slice.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humCoercion.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"humdrumR Coercion. — humCoercion","text":".vector(humdata) evaluates humdrumRclass object's Active expression, (attempts) force result vector mode. method essentially wrapper evalActive. .matrix(humdata also evaluates humdrumRclass object's Active expression, wraps matrix dimensions c([humdrumR:humSize][nrow(humdata), ncol(humdata)]). Note \"[humdrumR:humTable][Columns]\" humdrum data necesarily spines. .data.frame(humdata) first calls .matrix converts matrix data.frame. .data.table(humdata) first calls .matrix converts matrix data.table::data.table(). .matrices, .data.frames, .data.tables call .matrix/.data.frame/.data.table individual file humdrumRclass corpus, returning list matices/data.frames/data.tables.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humColumns.html","id":null,"dir":"Reference","previous_headings":"","what":"Spines vs Paths vs Columns — humColumns","title":"Spines vs Paths vs Columns — humColumns","text":"humdrum syntax, data placed \"spines,\" \"columns\" spreadsheet. \"column\" refers tab-delineated group values. \"Spines\" can single column, may (time) split multiple columns, can turn split , using \"*^\" interpretation token. reverse can happen well, two columns merging single column, using \"v\" token. means , humdrum data first glance looks like simple two-dimensional table, actually flexible tree structure. spines split merge, total number columns can change piece, creating \"ragged\" edge. Another similar issue corpus humdrum files may varying numbers spines/columns, pieces. (\"Global\" comment/reference records also special case, always single value, even interspersed multi-column local records.)","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humColumns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spines vs Paths vs Columns — humColumns","text":"","code":"alignColumns(humdrumR, padder = \"_C\")"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humColumns.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spines vs Paths vs Columns — humColumns","text":"humdrumR, spines, columns, spine paths work like . First , actually assume slightly strict version humdrum syntax: assume spines appear beginning file (headed exlusive interpretations like \"**kern\") can never merge . Thus, humdrum file read humdrumR must end fewer columns starts. Spine merges (\"*v\") can happen within spine paths originally split spine. extra-strict specification spine paths humdrum syntax , fortunately, something informally followed humdrum datasets. strict spine-path definition makes everything work fairly simply: Within piece, spines appear beginning piece \"true\" spines rest piece, numbered left right, starting 1L. local token, value Spine field integer indicating \"true\" spines belongs ---global tokens NA value Spine field, considerd belong spine. spine path splits (\"*^\" main spines form subspines, call Paths. Every spine's paths numbered, right left, starting 0L. spine splits 0Ls Path field.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humColumns.html","id":"columns","dir":"Reference","previous_headings":"","what":"Columns","title":"Spines vs Paths vs Columns — humColumns","text":"useful sometimes turn humdrum data true two dimensional structure, ragged edges. (always requires removing global records.) order , maintaining sensible relationship spine spine paths, humRead automatically pads humdrum data complete, non-ragged 2d table. instance, given file humRead pads file : (example, Spine, Path, Column values shown data.) \"_P\" tokens stand \"padded path.\" appraoch assures every Spine contiguous block tokens, constant width. humdrumR use cases, padding tokens (Column field) can safely ignored.","code":"**kern  **kern A       E *^      * A       C       E G       B       D *v      *v      * A       C         *-      *- **kern   _P       **kern A        _P       E *^       _P       * A        C        E G        B        D *v       *v       * A        _P       C         *-       _P       *-  ########################################## 1        1        2        Spine 0        1        0        Path 1        2        3        Column"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humColumns.html","id":"corpus-padding","dir":"Reference","previous_headings":"","what":"Corpus padding","title":"Spines vs Paths vs Columns — humColumns","text":"humRead automatically pads spine paths within pieces. However, mentioned , also (sometimes) need pad across pieces, order create logical, clean 2d structure. Consider example, humdrum data two pieces: Piece 1: Piece 2: example, two pieces, one three spines, two. way squish two pieces one regular 2d table. pad missing columns, : Piece 1: Piece 2: function alignColumns used achieve just effect. example, \"_C\" token stands \"padded column.\" presence spine paths makes padding columns across pieces bit complicated. alignColumns , match pieces corpus every Spine/Path field pair allign column. example, paths already padded: Piece 1: Piece 2: two pieces, two spines, first piece, first spine splits, second piece, second spine splits. Thus, padded output four columns: Piece 1: Piece 2: Note alignColumns actually adds rows humdrumRclass object's internal humdrum tables.","code":"**kern   **kern  **kern E        D       C D        .       . C        C       E *-       *-      *- **kern   **kern A        A .        B C        C *-       *- **kern   **kern  **kern E        D       C D        .       . C        C       E *-       *-      *- **kern  **kern   _C A        A       _C .        B       _C C        C       _C *-       *-      _C **kern      _P        **kern A           _P        E B           _P        D *^          _P        * A           C         E G#          B         E *v          *v        * A           _P        E *-          _P        *- ################################################# 1           1         2         Spine 0           1         0         Path 1           2         3         Column **kern     **kern    _P A          E         _P *          *^        _P G#         D         F A          C         E *          *v        *v E          D         _P *-         *-        _P         ################################################# 1          2         2        Spine 0          0         1        Path 1          2         3        Column **kern    _P        **kern   _C A         _P        E        _C B         _P        D        _C *^        _P        *        _C A         C         E        _C G#        B         E        _C *v        *v        *        _C A         _P        E        _C *-        _P        *-       _C  ########################################################### 1         1         2        2         Spine 0         1         0        1         Path 1         2         3        4         Column **kern    _C        **kern   _P A         _C        E        _P *         _C        *^       _P G#        _C        D        F A         _C        C        E *         _C        *v       *v E         _C        D        _P *-        _C        *-       _P  #########################################################        1         1         2        2         Spine 0         1         0        1         Path 1         2         3        4         Column"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humFormulae.html","id":null,"dir":"Reference","previous_headings":"","what":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------\nStandard humdrumR formulae. — humFormulae","title":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------\nStandard humdrumR formulae. — humFormulae","text":"humdrumR predefines ()humdrum command combinations, R formulae lists formulae.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humFormulae.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------\nStandard humdrumR formulae. — humFormulae","text":"","code":"ditto"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humFormulae.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------\nStandard humdrumR formulae. — humFormulae","text":"object class list length 3.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humFormulae.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------\nStandard humdrumR formulae. — humFormulae","text":"ditto calls fillThru() across pieces/spines/paths, replicating classic humdrum toolkit ditto command.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humInterpretations.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize humdrum corpus interpretations. — humInterpretations","title":"Summarize humdrum corpus interpretations. — humInterpretations","text":"function provides summary interpretations pieces humdrumR corpus.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humInterpretations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize humdrum corpus interpretations. — humInterpretations","text":"","code":"interpretations(humdrumR)  # S3 method for humInterpretations print(interps, showEach = TRUE, screenWidth = options(\"width\")$width - 10L)"},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humMerge.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge two (or more) humdrumR datasets — humMerge","title":"Merge two (or more) humdrumR datasets — humMerge","text":"Merge two () humdrumR datasets ------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humMerge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge two (or more) humdrumR datasets — humMerge","text":"","code":"mergeHumdrum(...)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humMeter.html","id":null,"dir":"Reference","previous_headings":"","what":"Tools for analyzing rhythm and meter. — humMeter","title":"Tools for analyzing rhythm and meter. — humMeter","text":"humdrumR includes number useful functions working rhythms meter.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humMeter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tools for analyzing rhythm and meter. — humMeter","text":"rhythmDecompose() decomposes series rhythms terms desired pulses. rhythmOffset() Calculates cummulative offset durations starting point.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humPipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Piping humdrumR data — humPipe","title":"Piping humdrumR data — humPipe","text":"infix operators make possible use [humdrumR:--Humdrum][()Humdrum] functions piping style, similar | (pipe) unix-style terminals, |>  pipe operator. R package magrittr.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humPipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Piping humdrumR data — humPipe","text":"","code":"humdrumR %hum>% formula  humdrumR %hum<% formula  humdrumR %humT% formula  e1 %s>% e2  list %hums>% formula  list %hums<% formula  list %humsT% formula  list %hums[]% formula"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humPipe.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Piping humdrumR data — humPipe","text":"key function [withinHumdrum][withinHumdrum] always returns new [humdrumR][humdrumR] data object. Thus, can always send output [withinHumdrum][withinHumdrum] back new call [withinHumdrum][withinHumdrum]. exactly %hum>% : left-hand side, input [humdrumR][humdrumR] object, right-hand side suitable arguments [withinHumdrum][withinHumdrum] (.e., formula, function, list formulae, functions, named arguments). can chain call another call %hum>% [withinHumdrum][withinHumdrum] arguments. %hum<% acts way %hum>% except calls [withHumdrum][withinHumdrum]. Since [withHumdrum][withinHumdrum] return [humdrumR][humdrumR], output piped (using %hum>% %hum<%). Thus, \\%hum<\\% used last step pipe---want extract last step pipe data's [humdrumR:humtable][Humdrum Table] normal vector list R data. ' \\%humT\\% creates \"T\" pipe, applying desired expression keeping result---unaltered humdrumR input object returned. works simply replacing ~ doplot~ call [withinHumdrum][withinHumdrum]. purpose option, want apply expressions side effects, instance, plotting. %hum[]% similar %hum>% except apply formulae right-hand side using [humdrumR][filterHumdrum]. Thus, can used filter/index [humdrumR][humdrumR] data object fly.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humPipe.html","id":"plural-pipes","dir":"Reference","previous_headings":"","what":"Plural pipes","title":"Piping humdrumR data — humPipe","text":"R often apply function list data. \"Plural pipes\" expand idea piping: take list data pipe element list expression/function. plural pipe versions singular pipe operator. Just add \"s\" make plural: |> (singular) : %s>% (plural); %hum>% (singular) : %hums>% (plural); %hum<% (singular) : %hums<% (plural); %humT% (singular) : %humsT% (plural); %hum[]% (singular) : %hums[]% (plural); Note: %s>% expansion \\> pipe operator, makes use clever meta-programming---guarantee always behave way might like!","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humPipe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Piping humdrumR data — humPipe","text":"","code":"humdata <- readHumdrum('path*.krn') #> Finding and reading files... #> \tREpath-pattern 'path*.krn' matches 0 text files in 1 directory. #> Zero files read from disk. #> No files to validate.  humdata %hum>% ~table(.) #> humdrumR error in: #> \ttryCatch(withCallingHandlers({ #>   NULL #>   saveRDS(do.call(do.call, c(readRDS( #>     \"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), list(envir = .GlobalEnv, #>     quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\") #>   flush(stdout()) #>   flush(stderr()) #>   NULL #>   invisible() #> }, error = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, interrupt = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, callr_message = function(e) { #>   try(signalCondition(e)) #> }), error = function(e) { #>   NULL #>   try(stop(e)) #> }, interrupt = function(e) { #>   NULL #>   e #> }) #> \t -> tryCatchList(expr, classes, parentenv, handlers) #> \t -> tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), names[nh], #> parentenv, handlers[[nh]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> tryCatchList(expr, names[-nh], parentenv, handlers[-nh]) #> \t -> tryCatchOne(expr, names, parentenv, handlers[[1L]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> withCallingHandlers({ #>   NULL #>   saveRDS(do.call(do.call, c(readRDS( #>     \"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), list(envir = .GlobalEnv, #>     quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\") #>   flush(stdout()) #>   flush(stderr()) #>   NULL #>   invisible() #> }, error = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, interrupt = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, callr_message = function(e) { #>   try(signalCondition(e)) #> }) #> \t -> saveRDS(do.call(do.call, c(readRDS( #>   \"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), list(envir = .GlobalEnv, #>   quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\") #> \t -> do.call(do.call, c(readRDS(\"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), #> list(envir = .GlobalEnv, quote = TRUE)), envir = .GlobalEnv, quote = TRUE) #> \t -> <function(what, args, quote = FALSE, envir = parent.frame()) { #>   if (!is.list(args)) stop(\"second argument must be a list\") #>   if (quote) args <- lapply(args, enquote) #>   .Internal(do.call(what, args, envir)) #> }>(base::quote(<function(..., crayon_enabled, crayon_colors, pkgdown_internet) { #>   options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, #>     pkgdown.internet = pkgdown_internet) #>   pkgdown::build_site(...) #> }>), base::quote(<list: pkg = <pkgdown>, examples = TRUE, run_dont_run = FALSE, #>   seed = 1014, lazy = FALSE, ...>), envir = base::quote(<environment>), quote = base::quote( #>   TRUE)) #> \t -> <function(..., crayon_enabled, crayon_colors, pkgdown_internet) { #>   options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, #>     pkgdown.internet = pkgdown_internet) #>   pkgdown::build_site(...) #> }>(pkg = base::quote(<pkgdown>), examples = base::quote(TRUE), run_dont_run = base::quote( #>   FALSE), seed = base::quote(1014), lazy = base::quote(FALSE), override = base::quote( #>   <list: >), install = base::quote(FALSE), preview = base::quote(FALSE), #> new_process = base::quote(FALSE), devel = base::quote(FALSE), crayon_enabled = base::quote( #>   TRUE), crayon_colors = base::quote(256L), pkgdown_internet = base::quote(TRUE)) #> \t -> pkgdown::build_site(...) #> \t -> build_site_local(pkg = pkg, examples = examples, run_dont_run = run_dont_run, #>   seed = seed, lazy = lazy, override = override, preview = preview, devel = devel) #> \t -> build_reference(pkg, lazy = lazy, examples = examples, run_dont_run = run_dont_run, #>   seed = seed, override = override, preview = FALSE, devel = devel) #> \t -> purrr::map(topics, build_reference_topic, pkg = pkg, lazy = lazy, examples_env = examples_env, #>   run_dont_run = run_dont_run) #> \t -> .f(.x[[i]], ...) #> \t -> withCallingHandlers(data_reference_topic(topic, pkg, examples_env = examples_env, #>   run_dont_run = run_dont_run), error = function(err) { #>   msg <- c(paste0(\"Failed to parse Rd in \", topic$file_in), i = err$message) #>   abort(msg, parent = err) #> }) #> \t -> data_reference_topic(topic, pkg, examples_env = examples_env, run_dont_run = run_dont_run) #> \t -> run_examples(tags$tag_examples[[1]], env = if (is.null(examples_env) #> ) NULL else new.env(parent = examples_env), topic = tools::file_path_sans_ext( #>   topic$file_in), run_dont_run = run_dont_run) #> \t -> highlight_examples(code, topic, env = env) #> \t -> downlit::evaluate_and_highlight(code, fig_save = fig_save_topic, env = child_env( #>   env), output_handler = evaluate::new_output_handler(value = pkgdown_print)) #> \t -> evaluate::evaluate(code, child_env(env), new_device = TRUE, output_handler = output_handler) #> \t -> evaluate_call(expr, parsed$src[[i]], envir = envir, enclos = enclos, debug = debug, #> last = i == length(out), use_try = stop_on_error != 2L, keep_warning = keep_warning, #> keep_message = keep_message, output_handler = output_handler, include_timing = include_timing) #> \t -> timing_fn(handle(ev <- withCallingHandlers(withVisible(eval(expr, envir, enclos)), #> warning = wHandler, error = eHandler, message = mHandler))) #> \t -> handle(ev <- withCallingHandlers(withVisible(eval(expr, envir, enclos)), #> warning = wHandler, error = eHandler, message = mHandler)) #> \t -> try(f, silent = TRUE) #> \t -> tryCatch(expr, error = function(e) { #>   call <- conditionCall(e) #>   if (!is.null(call)) { #>     if (identical(call[[1L]], quote(doTryCatch))) call <- sys.call(-4L) #>     dcall <- deparse(call, nlines = 1L) #>     prefix <- paste(\"Error in\", dcall, \": \") #>     LONG <- 75L #>     sm <- strsplit(conditionMessage(e), \"\\n\")[[1L]] #>     w <- 14L + nchar(dcall, type = \"w\") + nchar(sm[1L], type = \"w\") #>     if (is.na(w)) w <- 14L + nchar(dcall, type = \"b\") + nchar(sm[1L], type = \"b\") #>     if (w > LONG) prefix <- paste0(prefix, \"\\n  \") #>   } else prefix <- \"Error : \" #>   msg <- paste0(prefix, conditionMessage(e), \"\\n\") #>   .Internal(seterrmessage(msg[1L])) #>   if (!silent && isTRUE(getOption(\"show.error.messages\"))) { #>     cat(msg, file = outFile) #>     .Internal(printDeferredWarnings()) #>   } #>   invisible(structure(msg, class = \"try-error\", condition = e)) #> }) #> \t -> tryCatchList(expr, classes, parentenv, handlers) #> \t -> tryCatchOne(expr, names, parentenv, handlers[[1L]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> withCallingHandlers(withVisible(eval(expr, envir, enclos)), warning = wHandler, #> error = eHandler, message = mHandler) #> \t -> withVisible(eval(expr, envir, enclos)) #> \t -> eval(expr, envir, enclos) #> \t -> eval(expr, envir, enclos) #> \t -> humdata %hum>% (~ table(.)) #> \t #> Error: In the call `%hum>%`(humdrumR = _), the argument humdrumR must be a humdrumR object.  humdata %hum>%      c(by~Spine, do ~ table(.)) %hum>%      c(mfcol ~ c(2,2), doplot~barplot(.)) #> humdrumR error in: #> \ttryCatch(withCallingHandlers({ #>   NULL #>   saveRDS(do.call(do.call, c(readRDS( #>     \"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), list(envir = .GlobalEnv, #>     quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\") #>   flush(stdout()) #>   flush(stderr()) #>   NULL #>   invisible() #> }, error = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, interrupt = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, callr_message = function(e) { #>   try(signalCondition(e)) #> }), error = function(e) { #>   NULL #>   try(stop(e)) #> }, interrupt = function(e) { #>   NULL #>   e #> }) #> \t -> tryCatchList(expr, classes, parentenv, handlers) #> \t -> tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), names[nh], #> parentenv, handlers[[nh]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> tryCatchList(expr, names[-nh], parentenv, handlers[-nh]) #> \t -> tryCatchOne(expr, names, parentenv, handlers[[1L]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> withCallingHandlers({ #>   NULL #>   saveRDS(do.call(do.call, c(readRDS( #>     \"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), list(envir = .GlobalEnv, #>     quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\") #>   flush(stdout()) #>   flush(stderr()) #>   NULL #>   invisible() #> }, error = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, interrupt = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, callr_message = function(e) { #>   try(signalCondition(e)) #> }) #> \t -> saveRDS(do.call(do.call, c(readRDS( #>   \"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), list(envir = .GlobalEnv, #>   quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\") #> \t -> do.call(do.call, c(readRDS(\"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), #> list(envir = .GlobalEnv, quote = TRUE)), envir = .GlobalEnv, quote = TRUE) #> \t -> <function(what, args, quote = FALSE, envir = parent.frame()) { #>   if (!is.list(args)) stop(\"second argument must be a list\") #>   if (quote) args <- lapply(args, enquote) #>   .Internal(do.call(what, args, envir)) #> }>(base::quote(<function(..., crayon_enabled, crayon_colors, pkgdown_internet) { #>   options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, #>     pkgdown.internet = pkgdown_internet) #>   pkgdown::build_site(...) #> }>), base::quote(<list: pkg = <pkgdown>, examples = TRUE, run_dont_run = FALSE, #>   seed = 1014, lazy = FALSE, ...>), envir = base::quote(<environment>), quote = base::quote( #>   TRUE)) #> \t -> <function(..., crayon_enabled, crayon_colors, pkgdown_internet) { #>   options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, #>     pkgdown.internet = pkgdown_internet) #>   pkgdown::build_site(...) #> }>(pkg = base::quote(<pkgdown>), examples = base::quote(TRUE), run_dont_run = base::quote( #>   FALSE), seed = base::quote(1014), lazy = base::quote(FALSE), override = base::quote( #>   <list: >), install = base::quote(FALSE), preview = base::quote(FALSE), #> new_process = base::quote(FALSE), devel = base::quote(FALSE), crayon_enabled = base::quote( #>   TRUE), crayon_colors = base::quote(256L), pkgdown_internet = base::quote(TRUE)) #> \t -> pkgdown::build_site(...) #> \t -> build_site_local(pkg = pkg, examples = examples, run_dont_run = run_dont_run, #>   seed = seed, lazy = lazy, override = override, preview = preview, devel = devel) #> \t -> build_reference(pkg, lazy = lazy, examples = examples, run_dont_run = run_dont_run, #>   seed = seed, override = override, preview = FALSE, devel = devel) #> \t -> purrr::map(topics, build_reference_topic, pkg = pkg, lazy = lazy, examples_env = examples_env, #>   run_dont_run = run_dont_run) #> \t -> .f(.x[[i]], ...) #> \t -> withCallingHandlers(data_reference_topic(topic, pkg, examples_env = examples_env, #>   run_dont_run = run_dont_run), error = function(err) { #>   msg <- c(paste0(\"Failed to parse Rd in \", topic$file_in), i = err$message) #>   abort(msg, parent = err) #> }) #> \t -> data_reference_topic(topic, pkg, examples_env = examples_env, run_dont_run = run_dont_run) #> \t -> run_examples(tags$tag_examples[[1]], env = if (is.null(examples_env) #> ) NULL else new.env(parent = examples_env), topic = tools::file_path_sans_ext( #>   topic$file_in), run_dont_run = run_dont_run) #> \t -> highlight_examples(code, topic, env = env) #> \t -> downlit::evaluate_and_highlight(code, fig_save = fig_save_topic, env = child_env( #>   env), output_handler = evaluate::new_output_handler(value = pkgdown_print)) #> \t -> evaluate::evaluate(code, child_env(env), new_device = TRUE, output_handler = output_handler) #> \t -> evaluate_call(expr, parsed$src[[i]], envir = envir, enclos = enclos, debug = debug, #> last = i == length(out), use_try = stop_on_error != 2L, keep_warning = keep_warning, #> keep_message = keep_message, output_handler = output_handler, include_timing = include_timing) #> \t -> timing_fn(handle(ev <- withCallingHandlers(withVisible(eval(expr, envir, enclos)), #> warning = wHandler, error = eHandler, message = mHandler))) #> \t -> handle(ev <- withCallingHandlers(withVisible(eval(expr, envir, enclos)), #> warning = wHandler, error = eHandler, message = mHandler)) #> \t -> try(f, silent = TRUE) #> \t -> tryCatch(expr, error = function(e) { #>   call <- conditionCall(e) #>   if (!is.null(call)) { #>     if (identical(call[[1L]], quote(doTryCatch))) call <- sys.call(-4L) #>     dcall <- deparse(call, nlines = 1L) #>     prefix <- paste(\"Error in\", dcall, \": \") #>     LONG <- 75L #>     sm <- strsplit(conditionMessage(e), \"\\n\")[[1L]] #>     w <- 14L + nchar(dcall, type = \"w\") + nchar(sm[1L], type = \"w\") #>     if (is.na(w)) w <- 14L + nchar(dcall, type = \"b\") + nchar(sm[1L], type = \"b\") #>     if (w > LONG) prefix <- paste0(prefix, \"\\n  \") #>   } else prefix <- \"Error : \" #>   msg <- paste0(prefix, conditionMessage(e), \"\\n\") #>   .Internal(seterrmessage(msg[1L])) #>   if (!silent && isTRUE(getOption(\"show.error.messages\"))) { #>     cat(msg, file = outFile) #>     .Internal(printDeferredWarnings()) #>   } #>   invisible(structure(msg, class = \"try-error\", condition = e)) #> }) #> \t -> tryCatchList(expr, classes, parentenv, handlers) #> \t -> tryCatchOne(expr, names, parentenv, handlers[[1L]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> withCallingHandlers(withVisible(eval(expr, envir, enclos)), warning = wHandler, #> error = eHandler, message = mHandler) #> \t -> withVisible(eval(expr, envir, enclos)) #> \t -> eval(expr, envir, enclos) #> \t -> eval(expr, envir, enclos) #> \t -> humdata %hum>% c(by ~ Spine, do ~ table(.)) %hum>% c(mfcol ~ c(2, 2), doplot ~ #>   barplot(.)) #> \t -> is.humdrumR((x)) #> \t -> humdata %hum>% c(by ~ Spine, do ~ table(.)) #> \t #> Error: In the call `%hum>%`(humdrumR = _), the argument humdrumR must be a humdrumR object.       humdata %hum>%      c(by ~ Spine, do ~ table(.)) %hum<%      (do ~ sort(.))     #> humdrumR error in: #> \ttryCatch(withCallingHandlers({ #>   NULL #>   saveRDS(do.call(do.call, c(readRDS( #>     \"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), list(envir = .GlobalEnv, #>     quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\") #>   flush(stdout()) #>   flush(stderr()) #>   NULL #>   invisible() #> }, error = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, interrupt = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, callr_message = function(e) { #>   try(signalCondition(e)) #> }), error = function(e) { #>   NULL #>   try(stop(e)) #> }, interrupt = function(e) { #>   NULL #>   e #> }) #> \t -> tryCatchList(expr, classes, parentenv, handlers) #> \t -> tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), names[nh], #> parentenv, handlers[[nh]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> tryCatchList(expr, names[-nh], parentenv, handlers[-nh]) #> \t -> tryCatchOne(expr, names, parentenv, handlers[[1L]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> withCallingHandlers({ #>   NULL #>   saveRDS(do.call(do.call, c(readRDS( #>     \"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), list(envir = .GlobalEnv, #>     quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\") #>   flush(stdout()) #>   flush(stderr()) #>   NULL #>   invisible() #> }, error = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, interrupt = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, callr_message = function(e) { #>   try(signalCondition(e)) #> }) #> \t -> saveRDS(do.call(do.call, c(readRDS( #>   \"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), list(envir = .GlobalEnv, #>   quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\") #> \t -> do.call(do.call, c(readRDS(\"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), #> list(envir = .GlobalEnv, quote = TRUE)), envir = .GlobalEnv, quote = TRUE) #> \t -> <function(what, args, quote = FALSE, envir = parent.frame()) { #>   if (!is.list(args)) stop(\"second argument must be a list\") #>   if (quote) args <- lapply(args, enquote) #>   .Internal(do.call(what, args, envir)) #> }>(base::quote(<function(..., crayon_enabled, crayon_colors, pkgdown_internet) { #>   options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, #>     pkgdown.internet = pkgdown_internet) #>   pkgdown::build_site(...) #> }>), base::quote(<list: pkg = <pkgdown>, examples = TRUE, run_dont_run = FALSE, #>   seed = 1014, lazy = FALSE, ...>), envir = base::quote(<environment>), quote = base::quote( #>   TRUE)) #> \t -> <function(..., crayon_enabled, crayon_colors, pkgdown_internet) { #>   options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, #>     pkgdown.internet = pkgdown_internet) #>   pkgdown::build_site(...) #> }>(pkg = base::quote(<pkgdown>), examples = base::quote(TRUE), run_dont_run = base::quote( #>   FALSE), seed = base::quote(1014), lazy = base::quote(FALSE), override = base::quote( #>   <list: >), install = base::quote(FALSE), preview = base::quote(FALSE), #> new_process = base::quote(FALSE), devel = base::quote(FALSE), crayon_enabled = base::quote( #>   TRUE), crayon_colors = base::quote(256L), pkgdown_internet = base::quote(TRUE)) #> \t -> pkgdown::build_site(...) #> \t -> build_site_local(pkg = pkg, examples = examples, run_dont_run = run_dont_run, #>   seed = seed, lazy = lazy, override = override, preview = preview, devel = devel) #> \t -> build_reference(pkg, lazy = lazy, examples = examples, run_dont_run = run_dont_run, #>   seed = seed, override = override, preview = FALSE, devel = devel) #> \t -> purrr::map(topics, build_reference_topic, pkg = pkg, lazy = lazy, examples_env = examples_env, #>   run_dont_run = run_dont_run) #> \t -> .f(.x[[i]], ...) #> \t -> withCallingHandlers(data_reference_topic(topic, pkg, examples_env = examples_env, #>   run_dont_run = run_dont_run), error = function(err) { #>   msg <- c(paste0(\"Failed to parse Rd in \", topic$file_in), i = err$message) #>   abort(msg, parent = err) #> }) #> \t -> data_reference_topic(topic, pkg, examples_env = examples_env, run_dont_run = run_dont_run) #> \t -> run_examples(tags$tag_examples[[1]], env = if (is.null(examples_env) #> ) NULL else new.env(parent = examples_env), topic = tools::file_path_sans_ext( #>   topic$file_in), run_dont_run = run_dont_run) #> \t -> highlight_examples(code, topic, env = env) #> \t -> downlit::evaluate_and_highlight(code, fig_save = fig_save_topic, env = child_env( #>   env), output_handler = evaluate::new_output_handler(value = pkgdown_print)) #> \t -> evaluate::evaluate(code, child_env(env), new_device = TRUE, output_handler = output_handler) #> \t -> evaluate_call(expr, parsed$src[[i]], envir = envir, enclos = enclos, debug = debug, #> last = i == length(out), use_try = stop_on_error != 2L, keep_warning = keep_warning, #> keep_message = keep_message, output_handler = output_handler, include_timing = include_timing) #> \t -> timing_fn(handle(ev <- withCallingHandlers(withVisible(eval(expr, envir, enclos)), #> warning = wHandler, error = eHandler, message = mHandler))) #> \t -> handle(ev <- withCallingHandlers(withVisible(eval(expr, envir, enclos)), #> warning = wHandler, error = eHandler, message = mHandler)) #> \t -> try(f, silent = TRUE) #> \t -> tryCatch(expr, error = function(e) { #>   call <- conditionCall(e) #>   if (!is.null(call)) { #>     if (identical(call[[1L]], quote(doTryCatch))) call <- sys.call(-4L) #>     dcall <- deparse(call, nlines = 1L) #>     prefix <- paste(\"Error in\", dcall, \": \") #>     LONG <- 75L #>     sm <- strsplit(conditionMessage(e), \"\\n\")[[1L]] #>     w <- 14L + nchar(dcall, type = \"w\") + nchar(sm[1L], type = \"w\") #>     if (is.na(w)) w <- 14L + nchar(dcall, type = \"b\") + nchar(sm[1L], type = \"b\") #>     if (w > LONG) prefix <- paste0(prefix, \"\\n  \") #>   } else prefix <- \"Error : \" #>   msg <- paste0(prefix, conditionMessage(e), \"\\n\") #>   .Internal(seterrmessage(msg[1L])) #>   if (!silent && isTRUE(getOption(\"show.error.messages\"))) { #>     cat(msg, file = outFile) #>     .Internal(printDeferredWarnings()) #>   } #>   invisible(structure(msg, class = \"try-error\", condition = e)) #> }) #> \t -> tryCatchList(expr, classes, parentenv, handlers) #> \t -> tryCatchOne(expr, names, parentenv, handlers[[1L]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> withCallingHandlers(withVisible(eval(expr, envir, enclos)), warning = wHandler, #> error = eHandler, message = mHandler) #> \t -> withVisible(eval(expr, envir, enclos)) #> \t -> eval(expr, envir, enclos) #> \t -> eval(expr, envir, enclos) #> \t -> humdata %hum>% c(by ~ Spine, do ~ table(.)) %hum<% (do ~ sort(.)) #> \t -> is.humdrumR((x)) #> \t -> humdata %hum>% c(by ~ Spine, do ~ table(.)) #> \t #> Error: In the call `%hum>%`(humdrumR = _), the argument humdrumR must be a humdrumR object."},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humPrint.html","id":null,"dir":"Reference","previous_headings":"","what":"Show a humdrumR object in the terminal. — humPrint","title":"Show a humdrumR object in the terminal. — humPrint","text":"Show humdrumR object terminal. ------------------------------------------->             NEEDS DOCUMENTATION             <------------------------------------------- Show humdrumRclass object terminal.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humPrint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Show a humdrumR object in the terminal. — humPrint","text":"","code":"# S4 method for humdrumR show(object)  print_humtab(   humdrumR,   dataTypes = \"GLIMDd\",   firstAndLast = FALSE,   max.records.file = 40L,   max.token.length = 30L,   collapseNull = 10L )"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humReference.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize reference records in a humdrumR corpus — humReference","title":"Summarize reference records in a humdrumR corpus — humReference","text":"reference one humdrumR's summary functions, used tabulate reference records present humdrumR corpus. reference takes humdrumR object returns humReference table. Alternatively, reference can take character string, check known reference codes print information matching codes. instance, reference('OTL') returns description standard humdrum !!!OTL reference record (original title metadata).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humReference.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize reference records in a humdrumR corpus — humReference","text":"","code":"reference(x)  reference('OTL')  reference(humdata)  # S3 method for humReference [(refTable, i, j, drop = FALSE)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humReference.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summarize reference records in a humdrumR corpus — humReference","text":"humReference table one column reference code appears humdrumR corpus. Since reference records can long (much print one screen), humdrum files can multiple type reference code (instance multiple composers annotated \"!!!COM\"), default, humReference prints number type reference record appear file. However, one type reference code present humReference table, complete reference records code printed file. Likewise, one file present table, file's complete reference records printed. Thus, want see actualy reference records, try indexing humReference table one column row (see ). humReference table one row file corpus. Rows labeled file's corresponding number (humTable's File field) name (Filename field). addition, humReference object printed, three different summary totals printed reference code: indicates many files corpus least one example code . Sum indicates total number reference code appear corpus, including multiple appearances one file (like multiple \"!!!COM\" records). Finally, Unique tabulates number unique tokens reference code---corpus hase two unique composers (encoded \"!!!COM\"), Unique total 2.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humReference.html","id":"indexing","dir":"Reference","previous_headings":"","what":"Indexing","title":"Summarize reference records in a humdrumR corpus — humReference","text":"humReference tables can indexed much like base R [data.frames][base::data.frame()],  two arguments: (rows) andj(columns). Ifiorjarenumeric, select rows columns respectively, ordinally. iis acharacter, matched regular expression filenames corpus. jis acharacter`, partially matched column names. drop argument also available. TRUE, plain [data.table][data.table::data.table()] returned.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humShape.html","id":null,"dir":"Reference","previous_headings":"","what":"HumdrumR data ","title":"HumdrumR data ","text":"functions used change \"shape\" data stored humdrum tables (held within humdrumRclass objects course). ------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humShape.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"HumdrumR data ","text":"","code":"foldHumdrum(humdrumR, byfields, foldAtomic = TRUE, sep = \" \", padPaths = FALSE)  foldStops(humdrumR, foldAtomic = TRUE, sep = \" \")  foldPaths(humdrumR, foldAtomic = TRUE, sep = \" \")  foldRecords(humdrumR, foldAtomic = TRUE, sep = \" \", padPaths = FALSE)  spinePipe(humdrumR, targetSpines, destinationSpines)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humShape.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"HumdrumR data ","text":"humdrumR humdrumRclass data object. (see humdrum table documentation Fields section explanation.). foldAtomic logical. foldAtomic == TRUE, stop collapsed single string foldAtomic == FALSE, stop collapsed list tokens. sep character. foldAtomic == TRUE, collapsed tokens separated string. pad logical. path/column padding tokens included?","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humShape.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"HumdrumR data ","text":"foldXXX family allows collapse user fields across groups another field.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humSize.html","id":null,"dir":"Reference","previous_headings":"","what":"humdrumR size and shape — humSize","title":"humdrumR size and shape — humSize","text":"functions can used quickly get basic information size \"shape\" humdrumRclass corpus. details, use census function. HumdrumR objects can divided \"subcorpora.\" anySubcorpora namesSubcorpora functions tell us subcorpora , , called.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humSize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"humdrumR size and shape — humSize","text":"","code":"nrecords(humdrumR, dataTypes = \"D\")  ntokens(humdrumR, dataTypes = \"D\")  npieces(humdrumR)  anySubcorpora(humdrumR)  namesSubcorpora(humdrumR)  nfiles(humdrumR)  # S4 method for humdrumR length(x)  # S4 method for humdrumR nrow(x)  is.empty(humdrumR)  anyPaths(humdrumR)  anyStops(humdrumR)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humSize.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"humdrumR size and shape — humSize","text":"common base R methods defined synonyms humdrumR-specific sizing functions: length(humdata) equivalent npieces(humdata); nrow(humdata) shortand nrecords(., dataTypes = 'LIMDd') (.e., local records ). ncol(humdata) returns maximum value Column field---maximum number tab-delineated columns humdrum files (irrespective Spines/Paths). results nrow ncol match dimensions matrices/data.frames produced calls .matrix/.data.frame. dim(humdata) returns c(nrow(humdata), ncol(humdata)), usual. .empty(humdata) asks ntokens(humdata, dataTypes = 'D') == 0L.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humSpines.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize spines in humdrum dataset — humSpines","title":"Summarize spines in humdrum dataset — humSpines","text":"function provides summary spines spine paths pieces humdrumR corpus.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humSpines.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize spines in humdrum dataset — humSpines","text":"","code":"spines(humdrumR)  # S3 method for humSpines [(spines, i, j)  # S3 method for humSpines print(spineTable, showEach = TRUE)"},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humSummary.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize humdrumR corpora — humSummary","title":"Summarize humdrumR corpora — humSummary","text":"humdrumR includes number built functions creating quick summaries humdrumR corpora: census Tabulates raw size humdrumR corpus. reference Tabulates reference records (metadata) file. spines Tabulates number spines spine paths files corpus. interpretations Tabulates types exclusive tandem interpretations corpus. sections Tabulates formal data (\"*>\") corpus. summary Calls functions, prints condensed version . function takes humdrumR object returns special class data.table. humdrumR includes number built functions creating quick summaries humdrumR corpora:","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humSummary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize humdrumR corpora — humSummary","text":"","code":"# S4 method for humdrumR summary(object, ...)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humSummary.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summarize humdrumR corpora — humSummary","text":"census Tabulates raw size humdrumR corpus. reference Tabulates reference records (metadata) file. spines Tabulates number spines spine paths files corpus. interpretations Tabulates types exclusive tandem interpretations corpus. sections Tabulates formal data (*>) corpus. function takes humdrumR object returns special class data.table. summary method humdrumR objects calls functions prints condensed version .","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humTable.html","id":null,"dir":"Reference","previous_headings":"","what":"Humdrum Tables — humTable","title":"Humdrum Tables — humTable","text":"humdrumR package, fundamental data structure called Humdrum Table. humdrum table encodes information collection one humdrum-syntax files single data.table (data.table \"enhanced\" version R's standard data.frame). Humdrum tables stored \"inside\" every humdrumRclass object work , various humdrumR functions allow study manipulate . want directly access humdrum table within humdrumRclass object, use getHumtab function. getHumtab extracts humdrum table humdrumRclass object.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humTable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Humdrum Tables — humTable","text":"","code":"getHumtab(humdrumR, dataTypes = c(\"G\", \"L\", \"I\", \"M\", \"D\", \"d\"))"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humTable.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Humdrum Tables — humTable","text":"humdrumR humdrumR object. dataTypes character vector. Specifies types data tokens/records extract. See humTable documentation /humdrum syntax vignette clarification! dataTypes, values can : \"G\": global comments \"L\": local comments \"\": interpretations \"M\": barlines \"D\": non-null data \"d\": null data Multiple types can specified vector, smooshed single string: e.g., \"GLIMD\".","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humTable.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Humdrum Tables — humTable","text":"humdrum table, row represents single \"token\" original humdrum data. Even multistops---tokens separated spaces---broken onto rows. Meanwhile, column humdrum table represents single piece information associated token, call field. Throughout documentation, keep mind \"token\" refers row humdrum table \"field\" refers column: Token = Row Field = Column","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humTable.html","id":"fields-","dir":"Reference","previous_headings":"","what":"Fields:","title":"Humdrum Tables — humTable","text":"five types fields humdrum table: Data fields Structure fields Interpretation fields Formal fields Reference fields first created call readHumdrum every humdrum table least nineteen fields: one data field (Token), two interpretation fields (Tandem Exclusive), three formal fields, fifteen structure fields. Additional interpretation reference fields may present depending content humdrum file(s), users can create additional data fields assigning object.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humTable.html","id":"data-fields-","dir":"Reference","previous_headings":"","what":"Data fields:","title":"Humdrum Tables — humTable","text":"Data fields used describe individual data points humdrum data (opposed groups points). Every humdrum table starts data field called Token, contains character strings representing original strings read humdrum files. Users can create many additional data fields like. Every call withinHumdrum---can also called using humdrumR:humPipe piping operator---generates one N new data fields named Pipe1, Pipe2, ..., PipeN. fields can renamed using $<- operator.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humTable.html","id":"structure-fields-","dir":"Reference","previous_headings":"","what":"Structure fields:","title":"Humdrum Tables — humTable","text":"Every humdrum table starts fifteen Structure fields, describe data token \"located\" original humdrum data: file, spine, record, etc. See vignette humdrum syntax fully understand terms . File info: Filename :: character unique name humdrum file. may include appended path one file name read different directories (see readHumdrum docs). Filepath :: character full file name (always includes full path). Label :: character label specified call readHumdrum, associated particular readHumdrum \"REpath-pattern.\" label specified, patterns just labeled \"_n\", \"n\" number pattern. (Labels can also created merging two humdrumR objects.) File :: integer unique number associated file (ordered alphabetically, starting 1). Piece :: integer number specifying number piece corpus. identical File field except one piece read file. Location info: Spine :: integer spine, numbered (left--right) starting 1. field NA wherever Global == TRUE. Path :: integer \"spine path.\" time *^ spine path split occurs humdrum data, right side split becomes new \"path.\" original path numbered 0 additional paths numbered integers right. (spine path splits, Path field zeros.) field always NA Global == TRUE. Read humdrum columns documentation thorough explanation spine paths. Column :: integer tab-delineated column humdrum file---irrespective Spine/Paths---, numbered starting 1. field always NA Global == TRUE. See explanation columns humdrumR. Record :: integer record (.e., line) number original file. NData :: integer data record enumeration file, starting 1. Stop :: integer token multistop token, numbered starting 1. files multistops, Stop field 1s. field always NA Global == TRUE. Global :: logical token come global record (opposed local record)? Global == TRUE, Spine, Column, Stop fields always NA. Token info: Type :: character type record ? \"D\" = non-null data \"d\" = null data \"\" = interpretation \"M\" = measure/barline \"L\" = local comment \"G\" = global comment. \"P\" = null \"non-tokens\" (see humdrumR columns documentation explanation.) Null :: logical active data field null? See detailed discussion , section documentation called \"Null Data.\" Filter :: logical record/token filtered ?","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humTable.html","id":"interpretation-fields-","dir":"Reference","previous_headings":"","what":"Interpretation fields:","title":"Humdrum Tables — humTable","text":"Interpretation fields describe interpretation metadata humdrum file(s). Humdrum interpretations tokens \"carry forward\" data points , unless cancelled subsequent interpretation. (See humdrum syntax vignette detailed explanation.) humdrum data must exclusive interpretation humdrum tables always Exclusive (:: character) field indicating exclusive interpretation associated token/row active field. Humdrum data may, may , include additional tandem interpretations. universal rule parsing tandem intepretations impossible, ) tandem interpretations can \"overwrite\" B) users can create tandem interpretations. best can cases identify tandem interpretations appeared previously spine (counting recent first). previous interpretations encoded single character string Tandem field. working non-standard intrepretations, users can parse Tandem field using getTandem function. tandem interpretations occur file, Tandem field full empty strings (\"\"). Fortunately, many tandem interpretations widely used standardized, interpretations known humdrumR. Recognized interpretations (*clefG4 *k[b-]) automatically parsed fields call readHumdrum. See readHumdrum documentation details.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humTable.html","id":"formal-fields-","dir":"Reference","previous_headings":"","what":"Formal fields:","title":"Humdrum Tables — humTable","text":"Formal fields indicate musical sections, time windows within piece, including formal designations (\"verse\", \"chorus\", etc.) measures/bars. Humdrum data may may include formal metadata fields, indicated token \"*>\". Classified formal marks put fields matching name. Unclassified formal marks placed field called Formal default. Nested formal categories appended underscore number level descent: Formal_1, Formal_2, ..., Formal_N. part section given name lower hierarchical level, field simply empty (\"\") point. Humdrum data may, may , also include barlines (tokens beginning \"=\"). Humdrum tables always include three formal fields related barlines: Bar :: integer many barline records (single double) passed token? \"=\" tokens occur file, Bar zeros. Note field independent whether barlines labeled numbers humdrum file! DoubleBar :: integer many double-barline records passed token? \"==\" tokens occur file, DoubleBar zeros. BarLabel :: character characters occur barline-token initial \"=\" \"==\". include \"-\" common \"implied barline token \"=-\", repeat tokens (like \"=:||\"), also explicit bar numbers. Note Bar field always enumerate every bar record, measure-number labels humdrum data (appear BarLabel field) may weird things like skipping numbers, repeating numbers, suffixes (e.g., \"19a\"). barline tokens appear file, BarLabel empty strings (\"\").","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humTable.html","id":"reference-fields-","dir":"Reference","previous_headings":"","what":"Reference fields:","title":"Humdrum Tables — humTable","text":"Reference fields describe Reference Records humdrum data. Every reference record (records beginning \"!!!\") humdrum file corpus read readHumdrum parsed field named reference code: \"XXX\" \"!!!XXX\". Reference tokens identical throughout humdrum piece. reference code appears one file another, field NA file code. reference records appear files read readHumdrum, reference fields created. Examples common reference records \"!!!COM:\" (composer) \"!!!OTL:\" (original title). humdrum data records end COM OTL fields humdrum table.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humTable.html","id":"null-data-","dir":"Reference","previous_headings":"","what":"Null Data:","title":"Humdrum Tables — humTable","text":"humdrum syntax, requirement every spine-path contains data every record. Rather, spines often padded null tokens. cases, entire records may padded null tokens. type humdrum record uses different null token: Intepretation: * Comment: ! Barline: = Data: . Null tokens humdrum table identified logical Null field. Null field set humdrum table created (readHumdrum) updated everytime new active field set. Null set TRUE wherever, either active field character data token single \".\", \"!\", \"=\", \"*\"; active field NA (including NA_character_). parallel Null field, null data tokens (\".\") identified record type: \"d\". updates/changes Null field also propogated Type field---.e., setting Type == d wherever data record Null. important/useful withinHumdrum routines , default, applied \"D\" data, ignoring \"d\". Whenever print export humdrumRclass object, null data active field (.e., Null == TRUE) print \".\". Thus, working numeric data, NA values, NA values print \".\".","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humTable.html","id":"reshaping-","dir":"Reference","previous_headings":"","what":"Reshaping:","title":"Humdrum Tables — humTable","text":"Breaking complex syntax humdrum data \"flat\" structure humdrum table, every single token one line data.table, makes humdrum data easier analyze. course, thanks structure fields, can easily regroup reform original humdrum data use structure data (like spines) analyses. However, cases, might want work humdrum data different structure \"shape.\" HumdrumR several options \"collapseing\" tokens within humdrum tables, otherwise reshaping humdrum data data formats/structures might prefer.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humValidation.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate humdrum files — humValidation","title":"Validate humdrum files — humValidation","text":"function checks files violations humdrum syntax.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humValidation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate humdrum files — humValidation","text":"","code":"validateHumdrum(   ...,   contains = NULL,   recursive = FALSE,   errorReport.path = NULL )"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humValidation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate humdrum files — humValidation","text":"recursive logical. TRUE, final part search pattern (.e., file search) searched recursively sub directories. errorReport.path character. directory path , NULL, error report written file 'humdrumR_syntaxErrorReport_date.txt'. addition, files errors written directory ('errorMarkup' appended names), errors annotated inline. patterns character vector. Search pattern(s) identifying files (see [readHumdrum][readHumdrum]). files list character strings, representing record file.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humWindows.html","id":null,"dir":"Reference","previous_headings":"","what":"Applying functions across arbitrary windows. — humWindows","title":"Applying functions across arbitrary windows. — humWindows","text":"Applying functions across arbitrary windows. Applying functions across arbitrary windows. ---------------------------------------------->      NEEDS DOCUMENTATION          <----------------------------------------------------","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humWindows.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Applying functions across arbitrary windows. — humWindows","text":"","code":"windows(   df,   form,   with = list(),   ...,   start = 1L,   end = nrow(df),   bounds = \"exclude\" )  hop(vec, pattern, start = 1L, end = length(vec))  nest(vec, open, close, depth = 1)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumDispatch.html","id":null,"dir":"Reference","previous_headings":"","what":"Regular expression method dispatch and function application — humdrumDispatch","title":"Regular expression method dispatch and function application — humdrumDispatch","text":"humdrumR regular-expression method dispatch system simple system making new functions can smartly applied variety character strings. Humdrum dispatch works like normal R method dispatch, instead dispatching specific methods based class (integer, character, etc.) dispatches based regular expressions. addition, exclusive interpretations can used guide dispatch.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumDispatch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Regular expression method dispatch and function application — humdrumDispatch","text":"","code":"humdrumDispatch(   str,   dispatchDF,   Exclusive = NULL,   multiDispatch = FALSE,   ...,   outputClass = \"character\" )  makeDispatchDF(...)  makeHumdrumDispatcher(   ...,   funcName = \"humdrum-dispatch\",   outputClass = \"character\",   args = alist() )  # S3 method for humdrumDispatch print(x)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumDispatch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Regular expression method dispatch and function application — humdrumDispatch","text":"str input character string, dispatch called. dispatchDF data.frame describes function called regex input. (See details). Exclusive Defaults NULL. NULL, regexes used dispatch. multiDispatch logical, length 1. FALSE (default) \"best\" regex/exclusive match dispatched Exclusive segment. TRUE, differenet functions can dispatched within input vector. ... Arguments pass dispatch functions. outputClass Character string: default output class function return. Generally, make sense, dispatched functions return type, explicitly indicate outputClass argument. Dispatch functions also vectorized.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumDispatch.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Regular expression method dispatch and function application — humdrumDispatch","text":"Many humdrumR functions fact, humdrum-dispatch functions: example, tonalInterval.character(). call tonalInterval('ee-'), function recognize input string token  **kern representation, call appropriate parser. instead call tonalInterval(''), function recognize input string token **solfa representation, call appropriate parser .","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumDispatch.html","id":"dispatchdf","dir":"Reference","previous_headings":"","what":"dispatchDF","title":"Regular expression method dispatch and function application — humdrumDispatch","text":"dispatchDF must data.table::data.table() created using makeDispatchDF function. makeDispatchDF takes one arguments, list three components (ordered, nameed): character vector exclusive interpretations. (Specify \"\" want exclusive dispatch). regular expression (character string) function can generate regular expression, accepts ... arguments time dispatch. function dispatch.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumDispatch.html","id":"makehumdrumdispatcher","dir":"Reference","previous_headings":"","what":"makeHumdrumDispatcher","title":"Regular expression method dispatch and function application — humdrumDispatch","text":"makeHumdrumDispatcher function creates new function automatically performs humdrum-dispatch. number important humdrumR functions created makeHumdrumDispatcher: tonalInterval.character diatonicSet.character tertianSet.character rhythmInterval.character","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumDispatch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Regular expression method dispatch and function application — humdrumDispatch","text":"","code":"u <- c('A', 'B', 'CD', 'E', 'F', 'gh', 'L', 'KX') l <- c('a', 'b', 'cd', 'e', 'f', 'gh', 'l', 'kx')  lowercasefunc <- \\(x) 5L - nchar(x)  humdrumDispatch(l, outputClass = 'integer',                 makeDispatchDF(list('any', '[a-z]+',  lowercasefunc),                                list('any', '[A-Z]+',  nchar))) #> [1] 4 4 3 4 4 3 4 3 #> attr(,\"dispatch\") #> attr(,\"dispatch\")$Original #> [1] \"a\"  \"b\"  \"cd\" \"e\"  \"f\"  \"gh\" \"l\"  \"kx\" #>  #> attr(,\"dispatch\")$Regexes #>   [a-z]+  #> \"[a-z]+\"  #>  #> attr(,\"dispatch\")$Segments #> [1] 1 1 1 1 1 1 1 1 #> attr(,\"values\") #> [1] \"any\" #>  #> attr(,\"dispatch\")$Exclusives #> [1] \"any\" #>   # lowercasefunc will be called on l, nchar on u"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumPitch.html","id":null,"dir":"Reference","previous_headings":"","what":"humdrumR and pitch — humdrumPitch","title":"humdrumR and pitch — humdrumPitch","text":"humdrumR includes number intertwined data structures, associated functions, representing manipulating musical pitch information.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumPitch.html","id":"tonality","dir":"Reference","previous_headings":"","what":"Tonality","title":"humdrumR and pitch — humdrumPitch","text":"four data types extensively used humdrumR encode/process tonal musical information: integers --- used encode \"line--fifths\" tonal information tonalInterval --- embeds line--fifth tonal integers alongside octave cent information encode tonal pitch representations (solfege, intervals, letternames, etc.) diatonicSet --- combines line--fifth tonal integer representations represent diatonic tonality, including alterations basic diatonic scale(s). tertianSet --- extension diatonicSet used encode  tertian diatonic harmonies. detailed explanation theory specifics humdrumR's treatment tonality, see Tonality humdrumR vignette.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumPitch.html","id":"atonality","dir":"Reference","previous_headings":"","what":"Atonality","title":"humdrumR and pitch — humdrumPitch","text":"SECTION INCOMPLETE addition, xxx data types used encode non-tonal (atonal) pitch information. integers --- used encode semitones (well MIDI numbers). xxx --- sets? xxx --- 12-tone rows?","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumR-class.html","id":null,"dir":"Reference","previous_headings":"","what":"HumdrumR class — humdrumR-class","title":"HumdrumR class — humdrumR-class","text":"S4 class basic unit humdrumR package. humdrumR object represents data read one humdrum files. documentation refer collection files within humdrumR object \"corpus,\" file \"piece.\" However, though humdrum data usually encoded one \"piece\" per file, necessarily case: files might represent movements within piece, even just part score. Still, tend refer \"pieces.\" coding examples, name humdrumR objects \"humdata.\"","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumR-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"HumdrumR class — humdrumR-class","text":"","code":"is.humdrumR(x)  # S4 method for humdrumR $(x, name)  fields(   humdrumR,   fieldTypes = c(\"Data\", \"Structure\", \"Interpretation\", \"Formal\", \"Reference\") )  # S4 method for humdrumR,vector $(x, name) <- value  # S4 method for humdrumR,humdrumR $(x, name) <- value  # S4 method for humdrumR,character,ANY,vector [(x, i, j) <- value  # S4 method for humdrumR,character,ANY,humdrumR [(x, i, j) <- value  humdata[[ , 'regex']]  humdata[[ , , ~expression]] or humdata [[ , , 'regex']] or humdata[[z = ~expression]] or humdata[[z = 'regex']]  humdata[[~expression]]  humdata[[ , ~expression]]"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumR-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"HumdrumR class — humdrumR-class","text":"imporant part humdrumR object humdrum tables holds within . essence, humdrumR object simply wrapper around humdrum tables, helps users visualize, index, summarize, manipulate table variety ways. Basic information size shape humdrumR data can obtained calls nrecords, npieces, length, ncol, etc.. detailed summary information can obtained humdrumR corpus summary functions. HumdrumR data can also coerced basic R data types using .matrix, .data.frame, etc.. number helpful functions also defined reshape humdrumR data. powerful features humdrumR tools gives Filter humdrum data, using filterHumdrum standard R indexing operators: [] [[]]. Apply functions arbitrary commands humdrum data using ()Humdrum routines, associated piping operators.  Developed Nathaniel Condit-Schultz.  Site built pkgdown 2.0.2.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumR-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"HumdrumR class — humdrumR-class","text":"Humtable list humdrum tables, fields containing data different types records (e.g., interpretations, data, barlines, comments). Files list two elements. first, \"Search\", contains single character representing pattern used call readHumdrum created humdrumR object. second, \"Names\", vector strings representing files matched pattern read humdrumR object. Fields list containing strings corresponding existing fields humdrumR object. fields divided five categories: \"Data\", \"Structure\", \"Interpretation\", \"Formal\", \"Reference\"---see humdrum table documentation. Active quosure expression extracts data field(s) humdrum table: \"active expression.\" Active quosure expression extracts data field(s) humdrum table: \"active expression.\" LoadTime POSIXct value, indicating time readHumdrum called create humdrumR object. Patterns character vector original search patterns used match files system. Active slot humdrumR object contains expression refers fields internal humdrum table. Go dedicated active field documentation learn important slot!","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumR.html","id":null,"dir":"Reference","previous_headings":"","what":"humdrumR — humdrumR","title":"humdrumR — humdrumR","text":"humdrumR toolkit analysis data encoded humdrum syntax. humdrum syntax incredibly flexible, powerful, scheme encoding musical data. Tens thousands musical scores (musical data) encoded humdrum syntax, many available online repositories KernScores.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumR.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"humdrumR — humdrumR","text":"humdrumR intended modernized replacement original humdrum toolkit, levaraging power R give us enprecedented power manipulate analyze humdrum data using concise, expressive syntax.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumR.html","id":"package-design","dir":"Reference","previous_headings":"","what":"Package design","title":"humdrumR — humdrumR","text":"package humdrumR XXX main components: represent humdrum data R, humdrumR S4 class, core component humdrum table. create humdrumR data, sophisticated humdrum data parser: readHumdrum. humdrumR data can also written back humdrum-syntax text files using writeHumdrum. filter \"index\" humdrumR data, filterHumdrum function, can also called variety short hands using R's standard indexing operators: [] [[]]. manipulate modify humdrumR data, ()Humdrum humApply functions. set \"pipe\" operators (%hum>%, %hum<%, etc.), humdrumR data can manipulated filtered concise, bash-style pipes. facilate development functions work humdrum tokens---simple character strings packed information---, useful API call regular-expression dispatch system. Several modules representing manipulating musical pitch information, including core tonalInterval class represent tonal pitch. module representing manipulating musical rhythm information, core rhythmInterval class represent rhythms.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumRclass.html","id":null,"dir":"Reference","previous_headings":"","what":"HumdrumR class — humdrumRclass","title":"HumdrumR class — humdrumRclass","text":"S4 class basic unit humdrumR package. humdrumR object represents data read one humdrum files. documentation refer collection files within humdrumRclass object \"corpus,\" file \"piece.\" However, though humdrum data usually encoded one \"piece\" per file, necessarily case: files might represent movements within piece, even just part score. Still, tend refer \"pieces.\" coding examples, name humdrumR objects \"humdata.\"","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumRclass.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"HumdrumR class — humdrumRclass","text":"","code":"is.humdrumR(x)  # S4 method for humdrumR $(x, name)  fields(   humdrumR,   fieldTypes = c(\"Data\", \"Structure\", \"Interpretation\", \"Formal\", \"Reference\") )  # S4 method for humdrumR,vector $(x, name) <- value  # S4 method for humdrumR,humdrumR $(x, name) <- value  # S4 method for humdrumR,character,ANY,vector [(x, i, j) <- value  # S4 method for humdrumR,character,ANY,humdrumR [(x, i, j) <- value  humdata[[ , 'regex']]  humdata[[ , , ~expression]] or humdata [[ , , 'regex']] or humdata[[z = ~expression]] or humdata[[z = 'regex']]  humdata[[~expression]]  humdata[[ , ~expression]]"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumRclass.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"HumdrumR class — humdrumRclass","text":"imporant part humdrumR object humdrum tables holds within . essence, humdrumR object simply wrapper around humdrum tables, helps users visualize, index, summarize, manipulate table variety ways. Basic information size shape humdrumR data can obtained calls nrecords, npieces, length, ncol, etc.. detailed summary information can obtained humdrumR corpus summary functions. HumdrumR data can also coerced basic R data types using .matrix, .data.frame, etc.. number helpful functions also defined reshape humdrumR data. powerful features humdrumR tools gives Filter humdrum data, using filterHumdrum standard R indexing operators: [] [[]]. Apply functions arbitrary commands humdrum data using ()Humdrum routines, associated piping operators.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumRclass.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"HumdrumR class — humdrumRclass","text":"Humtable list humdrum tables, fields containing data different types records (e.g., interpretations, data, barlines, comments). Files list two elements. first, \"Search\", contains single character representing pattern used call readHumdrum created humdrumR object. second, \"Names\", vector strings representing files matched pattern read humdrumR object. Fields list containing strings corresponding existing fields humdrumR object. fields divided five categories: \"Data\", \"Structure\", \"Interpretation\", \"Formal\", \"Reference\"---see humdrum table documentation. Active quosure expression extracts data field(s) humdrum table: \"active expression.\" LoadTime POSIXct value, indicating time readHumdrum called create humdrumR object. Patterns character vector original search patterns used match files system.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumRclass.html","id":"active-field","dir":"Reference","previous_headings":"","what":"Active field","title":"HumdrumR class — humdrumRclass","text":"Active slot humdrumR object contains expression refers fields internal humdrum table. Go dedicated active field documentation learn important slot!","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumRroot.html","id":null,"dir":"Reference","previous_headings":"","what":"----------------------------------------------->      NEEDS DOCUMENTATION (A SECTION IS INCOMPLETE)       <------------------------------------------------------\nhumdrumR's root directory on your machine. — humdrumRroot","title":"----------------------------------------------->      NEEDS DOCUMENTATION (A SECTION IS INCOMPLETE)       <------------------------------------------------------\nhumdrumR's root directory on your machine. — humdrumRroot","text":"humdrumRroot path humdrumR package install machine. simple humdrum files stored .","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumRroot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"----------------------------------------------->      NEEDS DOCUMENTATION (A SECTION IS INCOMPLETE)       <------------------------------------------------------\nhumdrumR's root directory on your machine. — humdrumRroot","text":"","code":"humdrumRroot"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/humdrumRroot.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"----------------------------------------------->      NEEDS DOCUMENTATION (A SECTION IS INCOMPLETE)       <------------------------------------------------------\nhumdrumR's root directory on your machine. — humdrumRroot","text":"object class character length 1.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/interpolateArguments.html","id":null,"dir":"Reference","previous_headings":"","what":"Change or insert values in an expression — interpolateArguments","title":"Change or insert values in an expression — interpolateArguments","text":"function can used modify arguments functions within existing expression (quosure/formula).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/interpolateArguments.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Change or insert values in an expression — interpolateArguments","text":"","code":"interpolateArguments(quo, namedArgs)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/interpolateArguments.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Change or insert values in an expression — interpolateArguments","text":"namedArgs list named arguments. Unnamed arguments simply ignored. expr unevaluated expression object.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/interpolateArguments.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Change or insert values in an expression — interpolateArguments","text":"interpolateArguments inteprets named value namedArgs argument one two ways: named value list, interprets name list function call, inserts/swaps arguments list instances function call within expr. Named arguments inserted substituted already present expression. Unnamed argmuments simply added call. Examples: named valued namedArgs argument list, name/value pair substituted anywhere present expression. approach often conscise, arguments added expression way, substituted already present. Examples:","code":"myexpr <- quote(dnorm(x, mean = 5)) interpolateArguments(myexpr, list(dnorm = list(mean = 2, sd = 5, TRUE)))  # result is new expresson: dnorm(x, mean = 2, sd = 5, TRUE) myexpr <- quote(dnorm(x, mean = 5)) interpolateArguments(myexpr, mean = 2)  # result is new expression: dnorm(x, mean = 2) }"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/interpolateArguments.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Change or insert values in an expression — interpolateArguments","text":"","code":"myexpr2 <- quote(A + b*x + rnorm(length(a), mean(Z), sd = 2))  interpolateArguments(myexpr2,                      list(sd = 10, mean = list(na.rm = TRUE))) #> Error in rlang::quo_get_expr(quo): `quo` must be a quosure                         # result is new expression:  # a + b*x + rnorm(length(a), mean(Z, na.rm = TRUE), sd = 10)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/interval.html","id":null,"dir":"Reference","previous_headings":"","what":"Tonal (pitch) interval representation — interval","title":"Tonal (pitch) interval representation — interval","text":"returns standard representations intervals Western music.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/interval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tonal (pitch) interval representation — interval","text":"","code":"interval(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/interval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tonal (pitch) interval representation — interval","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). generic (logical, length == 1) generic = TRUE \"specific\" pitch information discarded. tonal representations, means accidentals/qualities equivalent information printed. atonal representations, generic pitch returned. alternative, can specify specific alternative (opposite) generic argument: generic == !specific. simple (logical, length == 1) simple = TRUE \"complex\" pitch information discarded. means octave information discarded, resulting output confined within default octave. absolute pitch representations, octave middle C. relative pitch representations, octave unison. (special octave.round argument can used modify behavior). transposeArgs (list) transposeArgs can list arguments passed special call transpose. convenient syntactic sugar, instead writing transposeArgs = list(= x, b = y, etc.), can write transpose(= x, b = y, etc.). parseArgs (list) parseArgs can list arguments passed pitch parser. convenient syntactic sugar, instead writing parseArgs = list(= x, b = y, etc.), can write parse(= x, b = y, etc.). inPlace (logical, length == 1) argument effect input (x argument) character strings, extral, non-pitch information strings \"beside\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/interval.html","id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Tonal (pitch) interval representation — interval","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/intervalCalculus.html","id":null,"dir":"Reference","previous_headings":"","what":"Interval ","title":"Interval ","text":"Interval \"calculus\"","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/intervalCalculus.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interval ","text":"","code":"integrate(intervals, skip = list(is.na))  sigma(intervals, skip = list(is.na))  derive(intervals, skip = list(is.na), boundaries = NULL)  delta(intervals, skip = list(is.na), boundaries = NULL)  calculus(x, n, skip = list(na))"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/is.ragged.html","id":null,"dir":"Reference","previous_headings":"","what":"Does the corpus vary in the number of spines? — is.ragged","title":"Does the corpus vary in the number of spines? — is.ragged","text":"Reference Getting started humdrumR Humdrum Syntax Rhythm Pitch Intervals HumdrumR Coders Diatonic Tertian Sets humdrumR Overview humdrumR Pitch Tonality humdrumR Reading writing data humdrumR Rhythm Meter humdrumR Validating Humdrum Data  humdrum corpora homogenous, number spines file. function returns TRUE corpora homogenous, FALSE otherwise.  Developed Nathaniel Condit-Schultz.  Site built pkgdown 2.0.2.  Developed Nathaniel Condit-Schultz.  Site built pkgdown 2.0.2.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/is.ragged.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Does the corpus vary in the number of spines? — is.ragged","text":"","code":"is.ragged(humdrumR)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/kern.html","id":null,"dir":"Reference","previous_headings":"","what":"Kern pitch representation — kern","title":"Kern pitch representation — kern","text":"Kern (**kern) common humdrum interpretation representing \"notes\" style traditional Western scores. humdrumR, kern function relates pitch part **kern interpretation: **kern rhythms created using recip function.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/kern.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Kern pitch representation — kern","text":"","code":"kern(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/kern.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Kern pitch representation — kern","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). generic (logical, length == 1) generic = TRUE \"specific\" pitch information discarded. tonal representations, means accidentals/qualities equivalent information printed. atonal representations, generic pitch returned. alternative, can specify specific alternative (opposite) generic argument: generic == !specific. simple (logical, length == 1) simple = TRUE \"complex\" pitch information discarded. means octave information discarded, resulting output confined within default octave. absolute pitch representations, octave middle C. relative pitch representations, octave unison. (special octave.round argument can used modify behavior). transposeArgs (list) transposeArgs can list arguments passed special call transpose. convenient syntactic sugar, instead writing transposeArgs = list(= x, b = y, etc.), can write transpose(= x, b = y, etc.). parseArgs (list) parseArgs can list arguments passed pitch parser. convenient syntactic sugar, instead writing parseArgs = list(= x, b = y, etc.), can write parse(= x, b = y, etc.). inPlace (logical, length == 1) argument effect input (x argument) character strings, extral, non-pitch information strings \"beside\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/kern.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Kern pitch representation — kern","text":"pitch part **kern tokens breakdown tonal pitch information : Steps 1: \"C\" \"c\" 2: \"D\" \"d\" 3: \"E\" \"e\" 4: \"F\" \"f\" 5: \"G\" \"g\" 6: \"\" \"\" 7: \"B\" \"b\" Accidentals Flat: \"-\" Sharp: \"#\" Octave Octave indicated case step characters, well repetition step character. Uppercase letters used octaves ; lowercase letters middle-C octave higher.  octave, octave get one character , higher lower octaves repeating character. example, using C# step value, relative  octave: -3: \"CCC#\" -2: \"CC#\" -1: \"C#\" 0: \"c#\" +1: \"cc#\" +2: \"ccc#\" +3: \"cccc#\" Tokens ordered Step/Octave + Accidentals, separator. Like humdrumR pitch functions, ways kern parses deparses tokens can modified accomodate variations standard **kern pitch representation.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/kern.html","id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Kern pitch representation — kern","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/keyTransformer.html","id":null,"dir":"Reference","previous_headings":"","what":"Parsing and deparsing key information — keyTransformer","title":"Parsing and deparsing key information — keyTransformer","text":"XXX","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/keyTransformer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parsing and deparsing key information — keyTransformer","text":"","code":"key(x, ..., Key = NULL, parseArgs = list(), memoize = TRUE, deparse = TRUE)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/lag.html","id":null,"dir":"Reference","previous_headings":"","what":"Shift data within a vector/matrix/data.frame — lag","title":"Shift data within a vector/matrix/data.frame — lag","text":"lag lead functions take input vectors, matrices, data.frames shifts data n indices. similiar data.table::shift function, additional options:","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/lag.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shift data within a vector/matrix/data.frame — lag","text":"","code":"lag(x, n = 1, fill = NA, wrap = FALSE, windows = NULL, ...)  lead(x, n, ...)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/lag.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shift data within a vector/matrix/data.frame — lag","text":"x input argument. vector (including lists), array, data.frame n amount lag/lead data. fill wrap = FALSE /windows = NULL, parts output padded fill argument. Defaults NA. wrap wrap = TRUE, data end (head tail) copied end output, \"wrapping\" data within data structure. windows vector list vectors, th length x. Lags crossing boundaries indicated windows filled. margin Arrays data.frames can lagged lead multiple dimensions using margin argument.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/lilypond.html","id":null,"dir":"Reference","previous_headings":"","what":"Lilypond pitch representation — lilypond","title":"Lilypond pitch representation — lilypond","text":"representation used represent (Western tonal) pitches Lilypond notation format. humdrumR, lilypond function relates pitch part Lilypond notation: Lilypond-like rhythms can creating using recip function.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/lilypond.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lilypond pitch representation — lilypond","text":"","code":"lilypond(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/lilypond.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lilypond pitch representation — lilypond","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). generic (logical, length == 1) generic = TRUE \"specific\" pitch information discarded. tonal representations, means accidentals/qualities equivalent information printed. atonal representations, generic pitch returned. alternative, can specify specific alternative (opposite) generic argument: generic == !specific. simple (logical, length == 1) simple = TRUE \"complex\" pitch information discarded. means octave information discarded, resulting output confined within default octave. absolute pitch representations, octave middle C. relative pitch representations, octave unison. (special octave.round argument can used modify behavior). transposeArgs (list) transposeArgs can list arguments passed special call transpose. convenient syntactic sugar, instead writing transposeArgs = list(= x, b = y, etc.), can write transpose(= x, b = y, etc.). parseArgs (list) parseArgs can list arguments passed pitch parser. convenient syntactic sugar, instead writing parseArgs = list(= x, b = y, etc.), can write parse(= x, b = y, etc.). inPlace (logical, length == 1) argument effect input (x argument) character strings, extral, non-pitch information strings \"beside\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/lilypond.html","id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Lilypond pitch representation — lilypond","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/line-of-fifths.html","id":null,"dir":"Reference","previous_headings":"","what":"Line-of-Fifths — line-of-fifths","title":"Line-of-Fifths — line-of-fifths","text":"fundamental tonal space.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/measure.html","id":null,"dir":"Reference","previous_headings":"","what":"Measure — measure","title":"Measure — measure","text":"Takes sequence rhythmic offsets regular irregular beat unit, counts many beats passed, offset attack nearest beat.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/measure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Measure — measure","text":"","code":"measure(   soi,   beat = rational(1L),   start = as(0, class(dur)),   phase = rational(0L),   Bar = NULL )"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/metric.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate metric positions from duration data. — metric","title":"Calculate metric positions from duration data. — metric","text":"Calculate metric positions duration data.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/metric.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate metric positions from duration data. — metric","text":"","code":"metric(ioi, meter = duple(5), ..., remainderSubdivides = TRUE)"},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/metricPosition.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate metric positions from duration data. — metricPosition","title":"Calculate metric positions from duration data. — metricPosition","text":"Calculate metric positions duration data.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/metricPosition.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate metric positions from duration data. — metricPosition","text":"","code":"metricPosition(rints, bars = NULL, beats = rint(c(2, 4, 8, 16, 32)))"},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/midi.html","id":null,"dir":"Reference","previous_headings":"","what":"MIDI pitch representation — midi","title":"MIDI pitch representation — midi","text":"function translates pitch information MIDI pitch values. midi function identical semit() function, except offset 60: midi('c') = 60 semit('c') = 0.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/midi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"MIDI pitch representation — midi","text":"","code":"midi(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.contour = FALSE,   parseArgs = list(),   transposeArgs = list(),   inPlace = FALSE )"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/midi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"MIDI pitch representation — midi","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). generic (logical, length 1) generic = TRUE \"specific\" pitch information discarded. tonal representations, means accidentals/qualities equivalent information printed. atonal representations, generic pitch returned. alternative, can specify specific alternative (opposite) generic argument: generic == !specific. simple (logical, length 1) simple = TRUE \"complex\" pitch information discarded. means octave information discarded, resulting output confined within default octave. absolute pitch representations, octave middle C. relative pitch representations, octave unison. (special octave.round argument can used modify behavior). parseArgs (list) parseArgs can list arguments passed pitch parser. convenient syntactic sugar, instead writing parseArgs = list(= x, b = y, etc.), can write parse(= x, b = y, etc.). transposeArgs (list) transposeArgs can list arguments passed special call transpose. convenient syntactic sugar, instead writing transposeArgs = list(= x, b = y, etc.), can write transpose(= x, b = y, etc.). inPlace (logical, length 1) argument effect input (x argument) character strings, extral, non-pitch information strings \"beside\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/midi.html","id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"MIDI pitch representation — midi","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semit, normally return numeric values, return character strings input character string.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/octave.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract octave — octave","title":"Extract octave — octave","text":"Extract octave","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/octave.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract octave — octave","text":"","code":"octave(x, ..., octave.relative = FALSE, parseArgs = list(), inPlace = FALSE)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/octave.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract octave — octave","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). parseArgs (list) parseArgs can list arguments passed pitch parser. convenient syntactic sugar, instead writing parseArgs = list(= x, b = y, etc.), can write parse(= x, b = y, etc.). inPlace (logical, length == 1) argument effect input (x argument) character strings, extral, non-pitch information strings \"beside\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pc.html","id":null,"dir":"Reference","previous_headings":"","what":"Representation of Atonal Pitch classes — pc","title":"Representation of Atonal Pitch classes — pc","text":"encoded humdrum **pc interpretation.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Representation of Atonal Pitch classes — pc","text":"","code":"pc(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Representation of Atonal Pitch classes — pc","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). generic (logical, length == 1) generic = TRUE \"specific\" pitch information discarded. tonal representations, means accidentals/qualities equivalent information printed. atonal representations, generic pitch returned. alternative, can specify specific alternative (opposite) generic argument: generic == !specific. simple (logical, length == 1) simple = TRUE \"complex\" pitch information discarded. means octave information discarded, resulting output confined within default octave. absolute pitch representations, octave middle C. relative pitch representations, octave unison. (special octave.round argument can used modify behavior). transposeArgs (list) transposeArgs can list arguments passed special call transpose. convenient syntactic sugar, instead writing transposeArgs = list(= x, b = y, etc.), can write transpose(= x, b = y, etc.). parseArgs (list) parseArgs can list arguments passed pitch parser. convenient syntactic sugar, instead writing parseArgs = list(= x, b = y, etc.), can write parse(= x, b = y, etc.). inPlace (logical, length == 1) argument effect input (x argument) character strings, extral, non-pitch information strings \"beside\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ). ten (character, length == 1) shorthand-symbol \"10.\" Defaults \"\". NULL, \"10\" used shorthand. eleven (character, length == 1) shorthand-symbol \"11.\" Defaults \"B\". NULL, \"11\" used shorthand.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pc.html","id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Representation of Atonal Pitch classes — pc","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":null,"dir":"Reference","previous_headings":"","what":"Pitch representations and translations — pitch","title":"Pitch representations and translations — pitch","text":"Functions creating /translating numerous representations pitch. Test","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pitch representations and translations — pitch","text":"","code":"semit(   x,   ...,   Key = NULL,   Exclusive = NULL,   deparse = TRUE,   inPlace = FALSE,   dropNA = FALSE,   parseArgs = list(),   transposeArgs = list(),   memoize = TRUE )"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Pitch representations and translations — pitch","text":"numerous ways musicians musicologists encode pitch information---solfege, scientific pitch, intervals, scale degrees, frequencies, etc.---different purposes uses. representations numeric, involve letters characters. concrete representations can translated abstract tonalInterval objects: tonalIntervals completely represent /standard representations, cocrete pitch representation -> tonalInterval guaranteed lossless. However, pitch representations encode complete tonal pitch information, tonalInterval -> concrete pitch representation may lossy. caneats asside, humdrumR can, via common tonalInterval representation, encode translate various representations: can read data reprsentation, manipulate , write different representation. documentation describes humdrumR's pitch representation translation features. (tonalIntervals also give us easy ways manipulate pitch information---see tonalTransform documentation.) humdrumR currently recognizes XXX \"standard\" pitch representations: equivalent examples standard pitch representation; representations column table represented tonalInterval---final two rows show tonalInterval slot (@Octave @Fifth) values associated interval well (users never really think ). table illustrates representations lossy, encode full pitch information. instance, degree representation drops octave information, semit drops tonal information (.e., C# != Db). means translating complete representation lossy (less complete representation) non-injective function.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"pitch-translation","dir":"Reference","previous_headings":"","what":"Pitch Translation","title":"Pitch representations and translations — pitch","text":"humdrumR exports functions read write standard representations , well custom non-standard representations (see tonalChroma ). input can converted representation calling appropriate function form .xxx: example, solfa. complete list .xxx functions pitch representations : Atonal semit midi Tonal tonalChroma step .accidental .quality octave kern lilypond pitch interval degree solfa Frequency decimal frequency fraction Note none functions plural name, semits intervals even applying multiple inputs! functions three things: Read parse input tonalInterval (details ). desired, transform tonalInterval (see tonalTransform). Deparse write tonalInterval output representation (details ). three steps numerous options can control via special arguments. details reading writing stages, associated arguments described subsequent sections. pitch translation functions also arguments perform various transformations pitch data (.e., inversion, transposition). transformation arguments tonalTransform function can applied pitch translation function. example, can write kern(x, generic = TRUE, Key = \"\") extract generic intervals key major output kernPitch format. transformation arguments listed \"common\" arguments table , explained detail tonalTransformations documentation.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"reading-pitch-information","dir":"Reference","previous_headings":"","what":"Reading Pitch Information","title":"Pitch representations and translations — pitch","text":"master function tonalInterval converts recognized pitch input tonalInterval object. main .xxx functions implicitely call tonalInterval. tonalInterval interprets input pitch information determined base R dispatch system (interpreting class input) , input character-string, humdrumR's regular expression dispatch system. process reading input tonalInterval follows two steps: First, base R dispatch system checks class input. currently methods three recognized classes: integer: integers interpreted semitones. numeric: numeric (floating point, integer values) interpreted frequency ratios. character: input character, humdrumRs dispatch system comes play (see next paragraph). Given character-string input, humdrumR regular expression dispatch system determines appropriate way parse pitch information string using two criteria: matching known regular expressions string based Exclusive argument, indicates exclusive interpretations associated (see Humdrum Syntax vingette know exclusive interpretation ). input string, humdrumR searches known regular expressions decides interpret input based whichever regular expression matches input strings. instance, call kern(\"A4\") (.xxx pitch function), dispatcher see \"A4\" string matches regular expression scientific pitch notation (.e., middle C) also regular expression intervals (.e., augmented fourth). case, one input string, humdrumR five scientific notation precedence interpret input middle C. However, input information, like kern(c(\"A4\", \"P5\")), humdrumR see inputs match intervals, first one matches scientific pitch notation---therefore, humdrumR interpret strings intervals (augmented fourth perfect 5th). Note humdrumR use two different interpretions string. Also, strings match known regular expressions, result NA (unless inPlace = TRUE; see ). want interpret kern(\"A4\") interval? Well, can use Exculusive argument. Exclusive argument gives information dispatcher, override purely-regex based decisions. instance, specify kern(\"A4\", Exclusive = 'interval'), humdrumR know exclusive interpretation \"**interval\" interpreted interval. run kern(c(\"A4\", \"P5\"), Exclusive = 'pitch'), humdrumR return (\"\", NA), second input interpreted scientfic pitch. However, Exclusive argument vectorized, gives us option using multiple input interpretations different parts input. instance, kern(c(\"A4\", \"A4\"), Exclusive = c('pitch', 'int') return (\"\", \"f#\")---'pitch' exclusive intepretation matched first \"A4\" 'int' interpretation matched second one! following regular expressions exclusive interpretations associated representation humdrumR: Exclusive           RE                                                             Example kernPitch        *kern              (-Ga-g)\\1(#-)\\2                                      c Beam             kern              ([/\\\\]?(L+K)?)|([/\\\\]?(J+k)?)                            /Jk MelodicSignifier **kern              [TtMmWw]R?|[TtMmWwS$O]                                         M Articulation     **kern              ['`\\\"~][vu]?|[vu]                                            v recip            **recip             [1-9][0-9]%?[1-9]?[0-9][.]|01,2\\.                       8. sciPitch         **pitch             [-G][b#-][-+]?[0-9][0-9]                                    C4 solfa            **solfa             [\\^v',]([sd]eoi|[fl]eai|[mt]eiy|r[aei]) interval         **mint,**hint,*int [+-]?([MmP]|[Ad#b]+)[1-9][0-9]                                +P5 scaleDegree      **deg               [\\^v',]([MmPn]|[Ad#b])[1-9][0-9]*                           P5 final useful option controlled using logical inPlace argument. inPlace = TRUE extra characters input string part matching regular expression left unchanged: example, kern(\"4.A5xxxv\", inPlace = TRUE) output \"4.aaxxxv---\"A5\" (scientific pitch) translated \"aa\" (kern pitch) \"4.\" \"xxxv\" changed. contrast, kern(\"4.A5xxxv\", inPlace = FALSE) just return \"aa\", stripping away \"4.\" \"xxxv\". (Thus, inPlace argument can used tool extract desired part strings.) Note inPlace = TRUE, inputs fail match anything just left unchanged.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"read-writing-tonal-pitch-information","dir":"Reference","previous_headings":"","what":"Read/Writing Tonal Pitch Information","title":"Pitch representations and translations — pitch","text":"pitch representations defined humdrumR based Western diatonic tonality---info atonal representations, see Read/Writing Atonal Pitch Information section . predefined kernPitch, pitch, lilyPitch, helmholtz, interval, degree, solfa encodings tonal representations---fact, represent essentially absract information,  exactly tonalIntervals encode. Specifically, condsider representations different representations call tonal chroma: , tonalChroma function master function used construct specific representations. following section(s) explain abstract principles pitch representation, function standard representations, , humdrumR, can use tonalChroma arguments create custom tonal representations pitch.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"tonal-pitch-partitions-","dir":"Reference","previous_headings":"","what":"Tonal Pitch \"Partitions\"","title":"Pitch representations and translations — pitch","text":"discussed Tonality humdrumR vignette, tonal intervals can \"partitioned\"---.e., broken constituent logical pieces. two main \"partitions\" frequently use: partitioning complex interval simple parts octave parts*. partitioning specific interval generic part alteration part. Simple intervals abstract (line--fifths ) information, without regards specific pitch frequency space---.e., actual \"pitch height.\" combination simple interval octave part creates complex interval, include information specific pitch height. Tonal \"line--fifths space\" can partitioned generic (diatonic) information specific interval information describes quality intervals, including zero alterations diatonic set. Thus, tonal interval/pitch composed octave part, generic part, quality part. Various pitch representation schemes (kern, solfege) represent three different parts (octave/generic/quality) tonalIntervals various ways, though representations lossy/incomplete, fully encode three partitions. example, scale degrees represent simple tonal information without complex octave information. schemes, tonal partition represented distinctly others, allowing us mix match different sub-representation create various full reprsentations. cases, representations blur partitions ways can broken apart. instance, solfege syllables neatly delineate generic quality information---\"e\" vowel means different qualities depending leading consonant paired (e.g., \"re\" vs \"\"). Since logic interval representation always conform abstract logic tonalInterval partitions, use different set terms refer representation distinct partitions: scale-step generic information,  quality/alteration/accidental alteration information,  octave octave information, Thus, terms step, octave, quality, alteration, accidental appear various pitch representation/translation function arguments (details ). humdrumR, tonal chroma representation combines combination three representation partions (scale, alteration, /octave). tonalChroma function master function writing tonal chroma. functionskern, pitch, lilypond, .helmholtz simply wrappers call tonalChroma various specific arguments. tonalChroma calls four constituent functions: step, .quality/.accidental, octave/octave. arguments tonalChroma, derived constituent functions (details following sections) : tonalChroma: parts: character string length 1--4, indicating parts tonalChroma print, order. Acceptable strings \"step\", \"qualities\", \"accidentals\", \"octave\". ([Partial matches][base::pmatch] matches like \"ste\" \"s\" step work .) output tonal chroma string part concatinated order appear parts argument. instance, put c(\"octave\", 'step', 'accidental') put octave simple interval, put c('step', 'accidental', \"octave\") put . sep: character string used separate elements (default \"\"). step (described ): step.labels .accidental (described ): accidental.labels accidental.maximum accidental.minimum accidental.cautionary accidental.memory Key .quality (described ): quality.labels quality.maximum quality.minimum quality.cautionary quality.memory Key octave (described ): octave.labels octave.maximum octave.minimum octave.offset octave.round octave.delta","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"scale-steps","dir":"Reference","previous_headings":"","what":"Scale Steps","title":"Pitch representations and translations — pitch","text":"particular area confusion pitch representation relationship tonal (line--fifths) space octave (frequency) space. line--fifths abstract space unrelated specific frequencies---e.g., G inherently \"\" \"\" C. Still, musicians play abstractions, must always realize line--fifths space concrete frequency space. convention, collections line--fifths conceptualized frequency-orded \"scales\": folding line--fifths sequence intervals octave \"\" unison. theoretical contexts, order/\"height\" elements scale actually completely irrelavant. Specifically, first seven (diatonic) elements line--fifths mapped generic scale-steps order [0, 2, 4, 6, 1, 3, 5]. Scale-steps strictly limited seven-step range single diatonic octave, always \"ascending\"/\"positive\"---steps pseudo-octave \"\" unison. representation line--fiths terms scale-steps basic approach representing pitch, associated arguments containing step; function step basic building block scale-step representations humdrumR. apply modulo-7 operation line--fifths space, intervals mapped seven generic steps. Alterations basic generic steps represented separately (see Qualities Alterations section ). However, note scale order defined entirely based generic interval: example, C-flat convention positioned \"\" C-natural scale, even though (often) equivalent B-natural, \"top\" scale. Generic, pseudo-ordered, scale-steps conventionally represented three forms: letters (-G), numbers (1-7 -VII), conventional syllables (, re, mi, fa...). HumdrumR predefines several representations include letters (-G) scale-step encoding: kernPitch, lilyPitch, helmholtz, pitch. also standard numeric (degree) syllable-based (solfa) based representations predefined. generic step function can used write variations scale step representations. step includes two arguments: step.labels: vector seven elements (default = c('C', 'D', 'E', 'F', 'G', '', 'B')) representing desired names seven steps scale order.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"quality-and-alterations","dir":"Reference","previous_headings":"","what":"Quality and Alterations","title":"Pitch representations and translations — pitch","text":"Generically, tonal interval's quality indicates diatonic mode relationship mode. Specifically, alterations/accidentals indicate alterations key/mode quality indicates mode . diatonic set primarily defined major mode, consisting line--fifth range -1 +5. seven intervals \"natural\" intervals---default, unless major context specifically counter-indicated, absence accidental indicates natural steps. intervals outside scale can indicated alterations natural steps using accidentals: two primary accidentals, sharp flat, though can added together create multi-sharps multi-flats. (Sharps flats mixed humdrumR.) alteration corresponds adding subtracting multiples 7 generic values (e.g., \"sharpen\" note means add 7 line--fifths value). Finally, natural accidental used default natural step needs explicitely labeled. encoding qualities subtly distinct alterations. Qualities encode information diatonic mode intervals, well alterations mode. five consonant diatonic modes---phyrigian (-5--+1), minor (-4--+2), dorian (-3--+3), mixolydian (-2--+4), major (-1--+5)---share \"perfect\" first, fourth,  fifth scale-steps---corresponding central -1--+1 line--fifths. However, five modes encompass two varieties \"imperfect\" second, third, sixth, seventh scale steps: major steps (+2--+5) minor steps (-2---5), (obviously) inverses line--fifths. minor/major pair separated line--fifths interval 7, thus one can altered . Anything line--fifths outside -5--+5 range represented one alterations perfect/imperfect degree. Postive alterations (+7)  augmented negative alterations (-7) diminished---like sharps flat, augmentations diminutions can multipled. following table illustrates relationship line--fifths, scale-steps, accidentals, qualities: Note accidentals symetrical around dorian mode (D), qualities symetrical around major mode. result, though sharp accidentals augmentation qualities always correspond, flat accidentals equivalent diminished qualities. HumdrumR's predefined tonal chroma representations (kernPitch, lilyPitch, helmholtz, pitch) include alteration information three accidental indications (sharp, flat, natural). degree interval representations encode general qualities using five categories (major, minor, diminished, augmented, perfect). solfa representation also encodes quality conventional (non-systematic) vowel modifications. generally, .quality .accidental functions can used extract quality information isolation. functions use () following arguments: _.labels: accidental.labels: [named][base::names()] character vector controls characters used represent accidentals. characters must named either flat, sharp, natural, doublesharp, doubleflat. defaults c(flat = \"b\", sharp = \"#\", natural = \"n\"). default, doubleflat doublesharp defined, doubles simply represented two normal accidental symbols. However, either double accidental defined, every pair accidentals collapsed double version. accidental.labels == FALSE, returns integer value counting number alterations (positive sharps, negative flats). quality.labels: [named][base::names()] character vector controls characters used represent qualities. characters must named either perfect, major, minor, augment, diminish, defaults c(perfect = \"P\", major = \"M\", minor = \"m\", augment = \"\", diminish = \"d\"). _.maximum _.minimum Single integer values---defaults Inf (maximum) -Inf (minimum). arguments define maximum number multi-accidentals permitted. instance, accidental.maximum == 2L, accidentals \"##\" output; triple sharp reduced just \"##\". The_.minimum argument must negative (-2 == two flats). default, minimum inverse maximum, want , just set maximum. Key: [diatonicSet] object describing key mode. Default NULL. Key specified, alterations relative key printed (unless _.cautionary _.memory arguments override ). _.cautionary: single logical value. Causes accidentals/qualities print (details ). Default FALSE accidentals TRUE qualities. _.memory: single logical value (default FALSE). Causes fewer accidentals/qualities print (details ). master tonalChroma calls functions, can thus pass arguments . example, write tonalChroma(x, accidental.maximum = 1).","code":"LO5th Step Accidental Quality    -10    E         --       d     -9    B         --       d     -8    F          -       d     -7    C          -       d     -6    G          -       d     -5    D          -       m     -4    A          -       m     -3    E          -       m     -2    B          -       m     -1    F                         0    C                         1    G                         2    D                         3    A                         4    E                         5    B                         6    F          #       A      7    C          #       A      8    G          #       A      9    D          #       A     10    A          #       A     11    E          #       A     12    B          #       A     13    F         ##      AA     14    C         ##      AA"},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"accidentals","dir":"Reference","previous_headings":"","what":"Accidentals","title":"Pitch representations and translations — pitch","text":"","code":"a-   a    b-   a    b-   a-   e    f    f#   e-   g-   f    b    c    d-   b-   e-   b-   a-   NFF  a-   a    b-   a    b-   a-   e    f    f#   e-   g-   f    b    c    d-   b-   e-   b-   a-   NFT  a-   a    b-   a    b-   a-   e    f    f#   e-   g-   f    b    c    d-   b-   e-   b-   a-   NTF  a-   a    b-   a    b-   a-   e    f    f#   e-   g-   f    b    c    d-   b-   e-   b-   a-   NTT  a-   a    b-   a    b-   a-   e    f    f#   e-   g-   f    b    c    d-   b-   e-   b-   a-   AbFF a-   a    b-   a    b-   a-   e    f    f#   e-   g-   f    b    c    d-   b-   e-   b-   a-   AbFT a-   a    b-   a    b-   a-   e    f    f#   e-   g-   f    b    c    d-   b-   e-   b-   a-   AbTF a-   a    b-   a    b-   a-   e    f    f#   e-   g-   f    b    c    d-   b-   e-   b-   a-   AbTT a-   a    b-   a    b-   a-   e    f    f#   e-   g-   f    b    c    d-   b-   e-   b-   a-"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"qualities","dir":"Reference","previous_headings":"","what":"Qualities","title":"Pitch representations and translations — pitch","text":"","code":"a-   a    b-   a    b-   a-   e    f    f#   e-   g-   f    b    c    d-   b-   e-   b-   a-   NFF  mA   A    mB   A    mB   mA   E    F    AF   mE   dG   F    B    C    mD   mB   mE   mB   mA   NFT  mA   A    mB   A    mB   mA   E    F    AF   mE   dG   F    B    C    mD   mB   mE   mB   mA   NTF  mA   A    mB   A    mB   mA   E    F    AF   mE   dG   F    B    C    mD   mB   mE   mB   mA   NTT  mA   A    mB   A    mB   mA   E    F    AF   mE   dG   F    B    C    mD   mB   mE   mB   mA   AbFF mA   A    mB   A    mB   mA   E    F    AF   mE   dG   F    B    C    mD   mB   mE   mB   mA   AbFT mA   A    mB   A    mB   mA   E    F    AF   mE   dG   F    B    C    mD   mB   mE   mB   mA   AbTF mA   A    mB   A    mB   mA   E    F    AF   mE   dG   F    B    C    mD   mB   mE   mB   mA   AbTT mA   A    mB   A    mB   mA   E    F    AF   mE   dG   F    B    C    mD   mB   mE   mB   mA"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"octave","dir":"Reference","previous_headings":"","what":"Octave","title":"Pitch representations and translations — pitch","text":"wish represent concrete, frequency-ordered information pitch, add additional octave information simple, line--fifth representation creating complex intervals. Since scale-step representations ostensibly encode frequency-space ordering already, first step take scale-ordering literally---e.g, G really \"\" D---, creating call simple octave. fully represent complex interval, can append zero octaves simple octave, call octave octave. humdrumR, symbols \"+\" \"-\" used indicate direction simple octave, various scale-step quality/alterations used indicate simple interval. (many representations, symbols implicit, thus ommitted.) contrast, octave octave interval simply integer value, can represented variety ways: either directly integer, using repetitions symbol pairs, commonly \"^\"/\"v\" \"'\"/\",\". approaches represent octave octave information changing case (upper lower) repeating parts simple-interval string. default, \"\" option (.e., unison) types octaves left blank empty string \"\". relationship simple octave octave octave determined scale step \"rounded\" octave (see Tonality humdrumR vignette), controlled octave.round argument. standard approach, scale steps ascending octave achieved floor function: call scale octave. Another approach use round function, rounds nearest octave , centering steps around unison instead : result scale like [-P4, -m3, -m2, P1, M2, M3, P4], call central octave. difference central octaves, scale octaves, simple octave options, illustrated .","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"serial-vs-fixed-octave-contour","dir":"Reference","previous_headings":"","what":"Serial vs Fixed Octave Contour","title":"Pitch representations and translations — pitch","text":"#' described Tonality humdrumR vignette, two general approaches representing intervals: fixed-reference serial-reference. pitch representations fixed-reference, token representing interval relative common reference (middle-C, tonic, unison, etc.). contrast, serial representation represents interval cummulatively, relative previous interval: common example melodic intervals. TonalIntervals can encode either fixed- serial-reference intervals, either approach can partitioned simple intervals octave offsets. common cases representing pitch, simple octave treated \"always ascending\" scale octave, octave octave simply kept fixed. Common approaches pairing octave information include: pitch style: octave offset simply printed integer, though offset +4 middle-C (unison) \"4\". kernPitch style: scale step lowercase octave octaves >= 0 uppercase otherwise. addition, scale step repeated absolute value octave octave times (offset +1 positive octaves). example, (CCC = -3, CC = -2, C = -1, c = 0, cc = 1, ccc = 2). lilyAbsolute absolute style: charactes \"'\" (positive) \",\" repeated absolute value octave octave. helmholtz style: intersection lilyPitch-absolute kernPitch style, case scale step changed kern-style, \"'\"/\",\" characters printed la lilypond absolute style. However, another particularly useful possibility encode octave part serial reference simple part fixed reference. compute serial-octave octave, set octave.round argument round, octave labels blank (\"\" marker) interval moved closest neighbor, octave octave indicating moves away \"closest note.\" instance, can say, \"play F# previous note.\" known \"relative pitch\" representation LilyPond]: relative = TRUE, lilypond compute markers labeled way. approach can combined scale-octave (octave.round = floor) representation pitch scale degrees, resulting scale degree representation lossless octave information! achieve serial octaves, use octave.delta octave.round arguments. delta = TRUE, octave serial representation input computed, octave-part octave computed using octave.round rounding function. floor create \"always ascending\" scale octave, round achieve centered octave. expand label octaves ascending/descending except unisons. following table illustrates different octave.round arguments delta = TRUE: following table illustrates three rounding functions, octave.delta = FALSE.","code":"round floor expand      0     0      0      0    -1     -1      0    -1     -1      0     0      0      0     0      1      0    -1     -1      0    -1     -1      0    -1     -1      0    -1     -1      0     0      1      0     0      1      0     0      1      0     0      1      0     0      1      0     0      1      0     0      0      1     1      2      1     1      2      1     1      2      1     1      1 Kern round floor expand     c     0     0      0     A     0    -1     -1     A     0    -1     -1     c     0     0      0     d     0     0      1     G     0    -1     -1     G     0    -1     -1     A     0    -1     -1    B-     0    -1     -1     f     0     0      1     f     0     0      1     e     0     0      1     d     0     0      1     e     0     0      1     d     0     0      1     c     0     0      0    ff     1     1      2    ee     1     1      2    dd     1     1      2    cc     1     1      1"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"complex-steps","dir":"Reference","previous_headings":"","what":"Complex Steps","title":"Pitch representations and translations — pitch","text":"final standard approach indicating complex octaves complex steps: .e., 9ths, 11ths, etc. approach directly represents full octave information scale steps, +7 added every octave octave. representation can accessed via interval function. limit intervals simple values, use tonalTransform arguments octave /roundMethod.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"octave-1","dir":"Reference","previous_headings":"","what":"octave","title":"Pitch representations and translations — pitch","text":"octave function can used directly generate representations octave/octave, can called indirectly via tonalChroma one standard pitch representation functions (kern, pitch, etc.). octave command synonym octave. following arguments defined octave: octave.labels: [named][base::names()] character vector controls characters used represent octave shifts. characters must named either , , ; defaults c(= \"^\", = \"v\", = \"\"). octave.labels = FALSE, octave offset (integer) returned. octave.labels == FALSE, returns integer value counting octave offset number. octave.maximum octave.minimum Single integer values---defaults Inf (maximum) -Inf (minimum). arguments define maximum number octave offset labels permitted. maximum == 2L, octave offsets (\"^^\") output; triple octave mark reduced just \"^^. Theminimum arguments negative. default, minimum inverse maximum, want , just set maximum. octave.offset: single integer, indicating \"center\" octave. default 0L, scientific pitch uses 4L (middle C \"C4\"). octave.delta: single logical vale. TRUE, serial octave calculated. octave.round: function, either floor, round, trunc, expand (see Tonality humdrumR vignette). default floor, standard delta = FALSE. [/\\\\]: R:/%5C%5C%5C%5C%5C%5C%5C [/\\\\]: R:/%5C%5C%5C%5C%5C%5C%5C [TtMmWw]: R:TtMmWw [TtMmWwS$O]: R:TtMmWwS$O [vu]: R:vu [vu]: R:vu [0-9]: R:0-9 [1-9]: R:1-9 [0-9]: R:0-9 [.]: R:. [b#-]: R:b#- [-+]: R:-+ [0-9]: R:0-9 [\\^v',]: R:%5C%5C%5C%5C%5Ev', [aei]: R:aei [+-]: R:+- [MmP]: R:MmP [Ad#b]: R:Ad#b [0-9]: R:0-9 [\\^v',]: R:%5C%5C%5C%5C%5Ev', [MmPn]: R:MmPn [Ad#b]: R:Ad#b [0-9]: R:0-9 [line--fifths]: R:line--fifths tonalTransformations: R:tonalTransformations [alterations]: R:alterations [base::pmatch]: R:base::pmatch [0, 2, 4, 6, 1, 3, 5]: R:0,%202,%204,%206,%201,%203,%205 [sharp]: R:sharp [flat]: R:flat [natural]: R:natural [modes]: R:modes [base::names()]: R:base::names() [base::names()]: R:base::names() [diatonicSet]: R:diatonicSet [-P4, -m3, -m2, P1, M2, M3, P4]: R:-P4,%20-m3,%20-m2,%20P1,%20M2,%20M3,%20P4 LilyPond: R:LilyPond tonalTransform: R:tonalTransform [base::names()]: R:base::names()","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"reading-writing-atonal-pitch-information","dir":"Reference","previous_headings":"","what":"Reading/Writing Atonal Pitch Information","title":"Pitch representations and translations — pitch","text":"Atonal pitch representations predefined humdrumR include semit, midi, frequency, ratio, fraction. mentioned , integer inputs interpreted semitones numeric interpreted frequency ratios.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"interpreting-frequencies-ratios","dir":"Reference","previous_headings":"","what":"Interpreting Frequencies/Ratios","title":"Pitch representations and translations — pitch","text":"Four additional arguments help humdrumR determing interpret frequencies ratios tonalIntervals. tonalHarmonic: determines assumed tuning system specifying \"tonal frequency ratio\" associated interval perfect 12th. default 3, corresponding pythagorean tuning; change 2^(19/12) use equal temeperament. centMargin: numeric argument determines close humdrumR tries get (cents) input ratio (default 10 cents). centMargin low, humdrumR may give crazy accidental like ---- get close input ratio. centMargin higher, humdrumR give reasonable (fewest accidentals) tonalInterval within margin. example, tonalInterval(1.44, centMargin = 10) return E##, pythagorean E## within 10 cents ratio 1.44. However, tonalInterval(1.44, centMargin = 20) return resonable F#. frequency.reference frequencyTint: arguments determing reference frequency note reading frequencies. standard = 440Hz corresponds (frequency.reference = 440, frequencyTint = tonalInterval('')).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitch.html","id":"tonal-decisions","dir":"Reference","previous_headings":"","what":"Tonal Decisions","title":"Pitch representations and translations — pitch","text":"interpreting atonal representation tonal one multiple possibilities (instance, midi note 61 C# Db). process humdrumR uses determine tonal representation atonal input influenced accidental.melodic Key arguments: default (Key == NULL & accidental.melodic == FALSE), line--fifths range -3--8 (E flat G sharp) used. However, Key argument specified, line--fifths range shifted match corresponding key signature. instance, key Bb minor read accidentals range -8--3 (Fb flat natural). accidental.melodic == TRUE) atonal notes interpreted \"melodically\"---.e., ascending chromatic steps sharps descending chromatic steps flats. reading frequencies/ratios, \"pure\" tonalHarmonic value---like pure 3 pythagorean tuning---help determine appropriate accidental. However, equal temperament provide useful information, Key accidental.melodic arguments can used instead.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchDeparsing.html","id":null,"dir":"Reference","previous_headings":"","what":"Deparsing pitch information — pitchDeparsing","title":"Deparsing pitch information — pitchDeparsing","text":"Deparsing pitch information","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchFunctions.html","id":null,"dir":"Reference","previous_headings":"","what":"Manipulate pitch data — pitchFunctions","title":"Manipulate pitch data — pitchFunctions","text":"Manipulate pitch data","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchFunctions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Manipulate pitch data — pitchFunctions","text":"","code":"semit(   x,   melodic = FALSE,   specific = TRUE,   complex = TRUE,   File = NULL,   Spine = NULL,   ...,   Key = NULL,   Exclusive = NULL,   parseArgs = list(),   transposeArgs = list(),   inPlace = FALSE,   deparse = TRUE,   memoize = !melodic )  midi(   x,   ...,   Key = NULL,   Exclusive = NULL,   parseArgs = list(),   transposeArgs = list(),   inPlace = FALSE,   deparse = TRUE,   memoize = TRUE )  pitch(   x,   ...,   Key = NULL,   Exclusive = NULL,   parseArgs = list(),   transposeArgs = list(),   inPlace = FALSE,   deparse = TRUE,   memoize = TRUE )  kern(   x,   complex = TRUE,   directed = FALSE,   ...,   Key = NULL,   Exclusive = NULL,   parseArgs = list(),   transposeArgs = list(),   inPlace = FALSE,   deparse = TRUE,   memoize = TRUE )  lilypond(   x,   ...,   Key = NULL,   Exclusive = NULL,   parseArgs = list(),   transposeArgs = list(),   inPlace = FALSE,   deparse = TRUE,   memoize = TRUE )  interval(   x,   directed = TRUE,   melodic = FALSE,   File = NULL,   Spine = NULL,   ...,   Key = NULL,   Exclusive = NULL,   parseArgs = list(),   transposeArgs = list(),   inPlace = FALSE,   deparse = TRUE,   memoize = !melodic )  degree(   x,   ...,   Key = NULL,   Exclusive = NULL,   parseArgs = list(),   transposeArgs = list(),   inPlace = FALSE,   deparse = TRUE,   memoize = TRUE )  solfa(   x,   parts = c(\"octave\", \"accidentals\", \"step\"),   factor = FALSE,   ...,   Key = NULL,   Exclusive = NULL,   parseArgs = list(),   transposeArgs = list(),   inPlace = FALSE,   deparse = TRUE,   memoize = TRUE )  bhatk(   x,   ...,   Key = NULL,   Exclusive = NULL,   parseArgs = list(),   transposeArgs = list(),   inPlace = FALSE,   deparse = TRUE,   memoize = TRUE )"},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchParsing.html","id":null,"dir":"Reference","previous_headings":"","what":"Parsing pitch information — pitchParsing","title":"Parsing pitch information — pitchParsing","text":"humdrumR includes easy--use powerful system parsing pitch information: various basic pitch representations (including numeric character-string representations) can \"parsed\"---read interpreted humdrumR. part, parsing automatically happens \"behind scenes\" whenever use humdrumR pitch function, like kern() semit(), solfa().","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchParsing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parsing pitch information — pitchParsing","text":"","code":"tonalInterval(...)  # S3 method for tonalInterval tonalInterval(x, ...)  # S3 method for logical tonalInterval(x, ...)  # S3 method for `NULL` tonalInterval(x, ...)  # S3 method for numeric tonalInterval(str, Exclusive = NULL, ..., multiDispatch = FALSE)  # S3 method for character tonalInterval(str, Exclusive = NULL, ..., multiDispatch = FALSE)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchParsing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parsing pitch information — pitchParsing","text":"tonalInterval object.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchParsing.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parsing pitch information — pitchParsing","text":"underlying parser used humdrumR pitch functions can called explicitly using function tonalInterval(). tonalInterval parser attempt parse input information tonalInterval object---back-end pitch representation probably need care ! use one main pitch functions, like kern() semits(), input parsed tonalInterval object, immediately deparsed representation asked (e.g., **kern **semits). Thus, underlying pipeline humdrumR pitch functions looks something like: Input representation (e.g., **pitch **semits) |> Parsing (done tonalInterval()) |> Intermediate (tonalInterval) representation |> Deparsing |> Output representation (e.g. **kern **solfa) documentation talks parsing step. overview \"deparsing\" process, look . learn \"deparsing\" specific representations, start go straight docs specific functions--- example, call ?kern learn kern().","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchParsing.html","id":"dispatch","dir":"Reference","previous_headings":"","what":"Dispatch","title":"Parsing pitch information — pitchParsing","text":"pitch parser (tonalInterval) generic function, meaning can accepts variety inputs automatically \"dispatches\" appropriate method parsing input. R's standard S3 system used dispatch either numeric character-string input: Generally, numeric (integer) inputs interpreted various atonal pitch representations character strings interpreted various tonal pitch representations. Given either character string number, humdrumR uses either regular-expression matching humdrum exclusive interpretation matching dispatch specific parsing methods.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchParsing.html","id":"tonal-parsing-character-string-inputs-","dir":"Reference","previous_headings":"","what":"Tonal Parsing (character-string inputs)","title":"Parsing pitch information — pitchParsing","text":"Since humdrum data inherently string-based, powerful part humdrumR pitch-parser system parsing pitch (mostly tonal) information character strings. (includes character tokens pitch information embedded alongside information; Details .) pitch parser (tonalInterval) uses combination regular-expressions exclusive interpretations decide parse input string. twelve regular-expression patterns pitch tonalInterval knows parse automatically:","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchParsing.html","id":"exclusive-dispatch","dir":"Reference","previous_headings":"","what":"Exclusive Dispatch","title":"Parsing pitch information — pitchParsing","text":"call tonalInterval (pitch function) character-string vector, non-NULL Exclusive argument, Exclusive argument used choose input interpretation want, based \"Exclusive\" column table . example, kern(x, Exclusive = 'solfa') force parser interpret x **solfa data. Similarly, solfa(x, Exclusive = 'kern') force parser interpret x **kern data. use pitch function within special call withinHumdrum (using humdrumR pipe, like %hum>%), humdrumR automatically pass Exclusive field humdrum data function---means, cases, need explicitly anything Exclusive argument!","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchParsing.html","id":"regex-dispatch","dir":"Reference","previous_headings":"","what":"Regex Dispatch","title":"Parsing pitch information — pitchParsing","text":"call tonalInterval (pitch function) character-string vector, Exclusive argument missing NULL, humdrumR instead use regular-expression patterns select known interpretation. example, pitch('') automatically recognize '' solfege, interpret data accordingly (output G4). one matches, humdrumR use longest match, tie, pick based order table (topmost first). match, tonalInterval (pitch function) return NA values. Remember, Exclusive specified, overrides regex-based dispatch, means pitch('', Exclusive = 'kern') return NA, '' interpreted **kern value.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchParsing.html","id":"-in-place-parsing","dir":"Reference","previous_headings":"","what":"\"In place\" parsing","title":"Parsing pitch information — pitchParsing","text":"lots humdrum data, character strings encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find , using appropriate known regular expressions. Various pitch parsing functions option keep original \"extra\" data, using inPlace argument.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchParsing.html","id":"advanced-tonal-parsing-options","dir":"Reference","previous_headings":"","what":"Advanced Tonal Parsing Options","title":"Parsing pitch information — pitchParsing","text":"eleven tonal representations listed parsed common intesrface. using \"advanced\" parsing arguments, can tweak parsing done, accommodate even input representations! means controlling behavior tonalInterval(), second step pipeline: Input representation |> Parsing (done tonalInterval(PARSE ARGS GO !)) |> Intermediate (tonalInterval) representation |> Deparsing |> Output representation Note arguments identical parallel deparsing arguments. following \"advanced\" parsing arguments available (read details ): Steps step.labels step.signed Species (accidentals qualities) qualities specifier.maximum Accidentals natural, flat, sharp, doubleflat, doublesharp Qualities perfect, major, minor, augment, diminish Implicit vs Explicit Species implicitSpecies absoluteSpecies explicitNaturals cautionary memory, memoryWindows Octave octave.integer , , octave.offset octave.round octave.relative, octave.absolute String parsing parts parse.exhaust sep. \"advanced\" arguments can used directly pitch function, call tonalInterval . use tonalInterval just specify directly arguments: example, tonalInterval(x, qualities = TRUE). use pitch functions, can either... Put parseArgs argument: kern(x, parseArgs = list(qualities = TRUE)) use \"syntactic sugar\" short-hand form: kern(x, parse(qualities = TRUE)) known Exclusive/Regex-dispatch combo (see table ) associated default parsing arguments. example, set Exclusive = 'kern' just use data look like **kern, flat argument set \"-\", However, , example, input data looked like **kern except used different flat symbol, like \"_\", modify parser: kern(\"EE_\", parse(flat = \"_\")) overrides default value **kern---notice, also updates **kern regular expression accordingly, works exactly standard kern() function.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchParsing.html","id":"steps","dir":"Reference","previous_headings":"","what":"Steps","title":"Parsing pitch information — pitchParsing","text":"representation \"tonal\" pitch information include representation diatonic steps. can control parser reads diatonic steps pitch representation using step.labels argument. step.labels argument must atomic vector unique values, length positive multiple seven. Examples step.labels arguments currently used humdrumR pitch functions include: parse(step.labels = c('', 'B', 'C', 'D', 'E', 'F', 'G')) parse(step.labels = c('', 'II', 'III', 'IV', 'V', 'VI', 'VII')) parse(step.labels = c('d', 'r', 'm', 'f', 's', 'l', 't')) step.labels NULL, steps assumed represented integers, including negative integers representing downward steps. also step.signed (logical, length == 1) argument: step.signed = TRUE, lowercase versions step.labels interpreted negative (downward) steps uppercase versions step.labels interpreted positive (upwards) steps. option used, example, default kern() helmholtz() parsers.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchParsing.html","id":"species","dir":"Reference","previous_headings":"","what":"Species","title":"Parsing pitch information — pitchParsing","text":"tonal pitch representations, \"specific\" versions tonal pitches---tonal \"species\"---indicated \"specifiers\": either accidentals qualities. qualities (logical, length == 1) argument indicates whether accidentals used (qualities = FALSE) qualities (qualities = TRUE). specifiers can repeated number times, like \"triple sharps\" \"doubly augmented\"; specifier.maximum (integer, length == 1) argument sets maximum limit number specifiers read. example, force triple sharps (\"###\") double sharps (\"##\") parse just \"#\", specifying specifier.maximum = 1L.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchParsing.html","id":"accidentals","dir":"Reference","previous_headings":"","what":"Accidentals","title":"Parsing pitch information — pitchParsing","text":"qualities = FALSE parser look accidentals input, recognizing three types: naturals, flats, sharps. natural, flat, /sharp (character, length == 1) arguments can used indicate accidentals represented input. example, input strings look like c(\"Eflat\", \"C\"), set argument flat = \"flat\". Examples accidental argument combinations currently used humdrumR pitch functions include: parse(flat = \"b\", sharp = \"#\") parse(flat = \"-\", sharp = \"#\") doubleflat, doublesharp (character, length == 1) arguments NULL default, can set special symbol used represent two sharps flats. example, might input represents double sharps \"x\". call kern(\"Fx\", parse(doublesharp = \"x\")) output \"F##\".","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchParsing.html","id":"qualities","dir":"Reference","previous_headings":"","what":"Qualities","title":"Parsing pitch information — pitchParsing","text":"qualities = TRUE parser look qualities input, recognizing five types: perfect, minor, major, augmented, diminished. perfect, major, minor, diminish, /augment (character, length == 1) arguments can used indicate qualities represented input. (Note: talking interval/degree qualities , chord qualities!) example, input strings look like c(\"maj3\", \"p4\"), set arguments major = \"maj\" perfect = \"p\". Examples quality argument combinations currently used humdrumR pitch functions include: parse(major = \"M\", minor = \"m\", perfect = \"P\", diminish = \"d\", augment = \"\") parse(diminish = \"o\", augment = \"+\")","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchParsing.html","id":"implicit-vs-explicit-species","dir":"Reference","previous_headings":"","what":"Implicit vs Explicit Species","title":"Parsing pitch information — pitchParsing","text":"musical data, specifiers (e.g., accidentals qualities) explicitly indicated; instead, must infer species pitch context---like key signature!.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchParsing.html","id":"from-the-key","dir":"Reference","previous_headings":"","what":"From the Key","title":"Parsing pitch information — pitchParsing","text":"important argument implicitSpecies (logical, length == 1): implicitSpecies = TRUE, species input without explicit species indicated interpreted using Key. example, kern('C', Key = ':', parse(implicitSpecies = TRUE)) parsed \"C#\" C sharp major. kern('C', Key = ':', parse(implicitSpecies = TRUE)) parsed \"C\" C natural minor. kern('C', Key = '-:', parse(implicitSpecies = TRUE)) parsed \"C-\" C flat -flat minor. default, input already specifiers, interpreted absolutely---overriding \"implicit\" Key---, even implicitSpecies = TRUE. Thus, major: kern(\"C#\", Key = ':', parse(implicitSpecies = TRUE)) parsed \"C#\". \"#\" unnecessary. kern(\"Cn\", Key = ':', parse(implicitSpecies = TRUE)) parsed \"C\". \"n\" overrides Key. kern(\"C#\", Key = ':', parse(implicitSpecies = TRUE)) parsed \"C#\". \"#\" overrides Key. However! can also change behavior setting absoluteSpecies (logical, length == 1) argument FALSE. , specifiers input interpreted \"top \" key accidental: kern(\"C#\", Key = ':', parse(implicitSpecies = TRUE, absoluteSpecies = FALSE)) parsed \"C##\". \"#\" input added \"#\" Key, resulting double sharp! unusual behavior, absolute pitch representations like **kern. However, use scale chord degrees, absoluteSpecies = FALSE might appropriate. example, reading figured bass key E minor, \"b7\" figure E bass interpreted double flat (diminished) 7th (Db E)! data encoded, use absoluteSpecies = FALSE.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchParsing.html","id":"memory","dir":"Reference","previous_headings":"","what":"Memory","title":"Parsing pitch information — pitchParsing","text":"musical data, assume accidental note \"stays effect\" scale step next bar, different accidental replaces . Fortunately, humdrumR parser (tonalInterval()) also knows parse data encoded \"memory\" way. memory = TRUE, accidental (quality) input note \"remembered\" previous appearances scale step. example, kern(c(\"D#\", \"E\", \"D\", \"E\", \"Dn\", \"C\", \"D\"), parse(memory = TRUE)) parsed c(\"D#\", \"E\", \"D#\", \"E\", \"D\", \"C\", \"D\") want \"memory\" last specific time windows (like bars), can also specify memoryWindows argument. memoryWindows must atomic vector length input (x argument). unique value within memoryWindows vector treated \"window\" within memory operates. common use case pass Bar field humdrumR dataset memoryWindows! memory memoryWindows argument work whatever values implicitSpecies absoluteSpecies specified! Though examples use accidentals, arguments effect parsing qualities (qualities = TRUE).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchParsing.html","id":"octave","dir":"Reference","previous_headings":"","what":"Octave","title":"Parsing pitch information — pitchParsing","text":"final piece information encoded () pitch representations indication \"complex pitch\"--- incorporating octave information. humdrumR octaves always defined terms scale steps: two notes scale degree/letter name always octave. mainly comes regards Cb B#: Cb4 semitone ; B#3 enharmonically middle-C.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchParsing.html","id":"integer-octaves","dir":"Reference","previous_headings":"","what":"Integer Octaves","title":"Parsing pitch information — pitchParsing","text":"simplest way octave information can encoded integer value, Scientific Pitch. need parse integer-encoded octaves, set octave.integer (logical, length == 1) argument TRUE. default, humdrumR considers \"central\" octave (octave == 0) octave , equivalently, unison. However, different octave used central octave, can specify octave.offset (integer, length == 1) argument. illustrate, default Scientific Pitch parser used arguments: kern('C5', parse(octave.integer = TRUE, octave.offset = 4) Returns \"cc\" (octave middle C).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchParsing.html","id":"non-integer-octave-markers","dir":"Reference","previous_headings":"","what":"Non-integer Octave Markers","title":"Parsing pitch information — pitchParsing","text":"octave.integer = FALSE, humdrumR parser instead looks three possible symbols indicate octave information. symbols controlled using , , (character, length == 1) arguments. symbol, symbol, interpreted \"central\" octave; repeating strings symbols indicate increasing positive () negative () octaves. example, lilypond notation, , represents lower octaves, ' (single apostrophe) represents upper octaves. default lilypond() parser uses arguments: pitch(c(\"c\", \"c\", \"c'\"), parse(octave.integer = FALSE, = \"'\", = \",\", octave.offset = 1)) Returns c(\"C2\", \"C3\", \"C4\"). (Note lilypond makes octave  central octave, using octave.offset = 1.)","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchParsing.html","id":"octave-rounding-","dir":"Reference","previous_headings":"","what":"Octave \"Rounding\"","title":"Parsing pitch information — pitchParsing","text":"situations, pitch data might interpret \"boundaries\" octaves little differently. absolute pitch representations (e.g., kern(), pitch()), \"boundary\" one octave next B (degree 7) C (degree 1). However, example, working data representing intervals, might think \"octave\" spanning range -P4 (G) +P4 (f). case, \"octave boundary\" centered around unison (), rather starting middle-C/unison. data represented way, use octave.round argument; octave.round must rounding function, either round, floor, ceiling, trunc, expand. functions indicate interpret simple pitches \"rounding\" nearest C/unison. default behavior pitch representations octave.round = floor: scale step rounded downwards nearest C. B associated C 7 steps . , hand, octave.round = round, scale-steps \"rounded\" closest C, B associated closer C . Indeed, octave.round = round gets us -P4 <-> +P4 behavior mentioned earlier! working parsing intervals, octave.round option allows control \"simple part\" (less octave) complex interval represented. example, might think ascending major 12th ascending octave plus ascending perfect 5th: ** +P8 + P5**. encode interval two ascending octaves minus perfect fourth: + P15 - P4. following table illustrates different octave.round arguments \"partition\" complex intervals simple parts octaves: Notice , octave.floor used, simple intervals represented ascending. parsing \"absolute\" pitch representations, octave.round option allows control octave notes associated . following table illustrates:","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchParsing.html","id":"absolute-or-relative-contour-octave","dir":"Reference","previous_headings":"","what":"Absolute or Relative (contour) Octave","title":"Parsing pitch information — pitchParsing","text":"notation encoding schemes, \"octave\" note interpreted relative previous note, rather absolute reference. prominent system Lilypond's relative octave entry style. style often used combination scale degree representations---RS200 corpus. example, data set might say Re Mi vSo La Ti , \"v\" indicating jump . activate relative-octave parsing, set octave.relative = TRUE---alternatively, can use octave.absolute = FALSE, equivalent. relative-octave data, assume octave indications indicate shift relative previous note. usually used combination octave markers like \"^\" () \"v\" (). Different combinations octave.round allow us parse different behaviors: octave.round = round, marker (marker) indicates note pitch closest previous pitch. Octave markers indicate alterations assumption. always, based scale steps, semitones! fourth \"closer\" fifth, regardless quality: C F# ascending C Gb descending! ascending diminished 5th written C ^Gb---= ^. octave.round = floor, marker (marker) indicates note octave previous pitch. Octave markers indicate alterations assumption. setting, going C B always requires mark.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchParsing.html","id":"string-parsing","dir":"Reference","previous_headings":"","what":"String Parsing","title":"Parsing pitch information — pitchParsing","text":"addition three types musical parsing considerations reviewed (steps, species, octaves), also general string-parsing issues can consider/control.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchParsing.html","id":"parts-and-order","dir":"Reference","previous_headings":"","what":"Parts and Order","title":"Parsing pitch information — pitchParsing","text":"far () discussed various ways tonal pitch information (step, species, octave) can encoded, humdrumR parser can modified handle different options. However, two general parsing issues/options consider: information encoded, order? parts argument can specifyied indicate . parts argument must character vector length 1--3. characters must partial match either \"step\", \"species\", \"octave\". presense strings parts vector indicate information parsed. order strings indicates order pieces pitch information encoded input strings. illustrate, imagine input data identical standard interval representation---e.g., M2 P5---except quality appears step---e.g., 2M 5P. call interval(c(\"2M\", \"5P\"), parse(parts = c(\"step\", \"species\"))) sure enough get correct parse! One final string-parsing argument sep, indicates character string separating pitch information components: common case comma space. example, use parse command like : kern(\"E flat 5\", parse(flat = \"flat\", sep = \" \")).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchParsing.html","id":"atonal-parsing-numeric-inputs-","dir":"Reference","previous_headings":"","what":"Atonal Parsing (numeric inputs)","title":"Parsing pitch information — pitchParsing","text":"humdrumR pitch parser (tonalInterval()) interpret numeric inputs atonal pitch information. default, numbers interpreted semitones. However, parses midi(), cents(),  frequencies also defined. Dispatch different parsers controlled Exclusive argument.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchParsing.html","id":"enharmonic-interpretation","dir":"Reference","previous_headings":"","what":"Enharmonic Interpretation","title":"Parsing pitch information — pitchParsing","text":"converting atonal representation tonal one, must decide interpret tonality input---specifically, enharmonic spelling notes use.  humdrumR numeric parser interprets atonal pitches \"enharmonic window\" 12 steps line--fifths. position window set enharmonic.center (integer, length == 1) argument. default, enharmonic.center = 0, creates window -5 (b2) +6) (#4). prefer #1 instead b2, set enharmonic.center = 1. flats, set enharmonic.center = -1. sharps, set enharmonic.center = 4. enharmonic.center argument work translating pitch representation, like kern(). However, present table terms scale degrees atonal -> enharmonic calculation centered key. , Key argument specified, \"enharmonic window\" centered around key. translating kern Key = F#:, output range Gn B#. want , set Key = NULL.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchParsing.html","id":"melodic-interpretation-of-chromatic-notes","dir":"Reference","previous_headings":"","what":"Melodic Interpretation of Chromatic Notes","title":"Parsing pitch information — pitchParsing","text":"common chromatic notes melodic passages labeled based melodic contour: .e., ascending chromatic notes labeled sharp descending chromatic notes labeled flat. behavior can engaged setting accidental.melodic (logical, length == 1) argument. accidental.melodic = TRUE, input first centered enharmonic window (), places chromatic alteration proceeds upwards non-chromatic note altered (necessary) sharp, vice verse descending notes flats. example, kern(0:2) returns c(\"c\", \"d-\", \"d\"), kern(0:2, parse(accidental.melodic = TRUE)) returns c(\"c\", \"c#\", \"d\").","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchParsing.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parsing pitch information — pitchParsing","text":"","code":"tonalInterval('II#', step.labels =c('I', 'II', 'III','IV','V','VI','VII')) #> tonalInterval[ , ] #> [1] D#  kern('E x 5', parse(doublesharp = 'x', sep = ' ')) #> [1] \"ee##\""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchRepresentations.html","id":null,"dir":"Reference","previous_headings":"","what":"Pitch representations and translations — pitchRepresentations","title":"Pitch representations and translations — pitchRepresentations","text":"Functions creating /translating numerous representations pitch.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchRepresentations.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Pitch representations and translations — pitchRepresentations","text":"numerous ways musicians musicologists encode pitch information---solfege, scientific pitch, intervals, scale degrees, frequencies, etc.---different purposes uses. representations numeric, involve letters characters. concrete representations can translated abstract tonalInterval objects: tonalIntervals completely represent /standard representations, cocrete pitch representation -> tonalInterval guaranteed lossless. However, pitch representations encode complete tonal pitch information, tonalInterval -> concrete pitch representation may lossy. caneats asside, humdrumR can, via common tonalInterval representation, encode translate various representations: can read data reprsentation, manipulate , write different representation. documentation describes humdrumR's pitch representation translation features. (tonalIntervals also give us easy ways manipulate pitch information---see tonalTransform documentation.) humdrumR currently recognizes XXX \"standard\" pitch representations: equivalent examples standard pitch representation; representations column table represented tonalInterval---final two rows show tonalInterval slot (@Octave @Fifth) values associated interval well (users never really think ). table illustrates reprsentations lossy, encode full pitch information. instance, degree representation drops octave information, semit drops tonal information (.e., C# != Db).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchRepresentations.html","id":"pitch-translation","dir":"Reference","previous_headings":"","what":"Pitch Translation","title":"Pitch representations and translations — pitchRepresentations","text":"humdrumR exports functions read write standard reprsentations , well custom non-standard representations (see tonalChroma ). input can converted representation calling appropriate function form .xxx: example, solfa. complete list .xxx functions pitch representations : Atonal semit midi Tonal tonalChroma step .accidental .quality contour kern lilypond pitch interval degree solfa Frequency .decimal .frequency .fraction Note none functions plural name, semits intervals even applying multiple inputs! .xxx functions three things: Read input tonalInterval (details ). desired, transform tonalInterval (see tonalTransform). Write tonalInterval output representation (details ). three steps numerous options can control via special arguments. details reading writing stages, associated arguments described subsequent sections. pitch translation functions also arguments perform various transformations pitch data (.e., inversion, transposition). transformation arguments tonalTransform function can applied pitch translation function. example, can write kern(x, generic = TRUE, Key = \"\") extract generic intervals key major output kernPitch format. transformation arguments listed \"common\" arguments table , explained detail tonalTransformations documentation.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchRepresentations.html","id":"reading-pitch-information","dir":"Reference","previous_headings":"","what":"Reading Pitch Information","title":"Pitch representations and translations — pitchRepresentations","text":"master function tonalInterval converts recognized pitch input tonalInterval object. main .xxx functions implicitely call tonalInterval. tonalInterval interprets input pitch information determined base R dispatch system (interpreting class input) , input character-string, humdrumR's regular expression dispatch system. process reading input tonalInterval follows two steps: First, base R dispatch system checks class input. currently methods three recognized classes: integer: integers interpreted semitones. numeric: numeric (floating point, integer values) interpreted frequency ratios. character: input character, humdrumRs dispatch system comes play (see next paragraph). Given character-string input, humdrumR regular expression dispatch system determines appropriate way parse pitch information string using two criteria: matching known regular expressions string based Exclusive argument, indicates exclusive interpretations associated (see Humdrum Syntax vingette know exclusive interpretation ). input string, humdrumR searches known regular expressions decides interpret input based whichever regular expression matches input strings. instance, call kern(\"A4\") (.xxx pitch function), dispatcher see \"A4\" string matches regular expression scientific pitch notation (.e., middle C) also regular expression intervals (.e., augmented fourth). case, one input string, humdrumR five scientific notation precedence interpret input middle C. However, input information, like kern(c(\"A4\", \"P5\")), humdrumR see inputs match intervals, first one matches scientific pitch notation---therefore, humdrumR interpret strings intervals (augmented fourth perfect 5th). Note humdrumR use two different interpretions string. Also, strings match known regular expressions, result NA (unless inPlace = TRUE; see ). want interpret kern(\"A4\") interval? Well, can use Exculusive argument. Exclusive argument gives information dispatcher, override purely-regex based decisions. instance, specify kern(\"A4\", Exclusive = 'interval'), humdrumR know exclusive interpretation \"**interval\" interpreted interval. run kern(c(\"A4\", \"P5\"), Exclusive = 'pitch'), humdrumR return (\"\", NA), second input interpreted scientfic pitch. However, Exclusive argument vectorized, gives us option using multiple input interpretations different parts input. instance, kern(c(\"A4\", \"A4\"), Exclusive = c('pitch', 'int') return (\"\", \"f#\")---'pitch' exclusive intepretation matched first \"A4\" 'int' interpretation matched second one! following regular expressions exclusive interpretations associated representation humdrumR: Exclusive           RE                                                             Example kernPitch        *kern              (-Ga-g)\\1(#-)\\2                                      c Beam             kern              ([/\\\\]?(L+K)?)|([/\\\\]?(J+k)?)                            /Jk MelodicSignifier **kern              [TtMmWw]R?|[TtMmWwS$O]                                         M Articulation     **kern              ['`\\\"~][vu]?|[vu]                                            v recip            **recip             [1-9][0-9]%?[1-9]?[0-9][.]|01,2\\.                       8. sciPitch         **pitch             [-G][b#-][-+]?[0-9][0-9]                                    C4 solfa            **solfa             [\\^v',]([sd]eoi|[fl]eai|[mt]eiy|r[aei]) interval         **mint,**hint,*int [+-]?([MmP]|[Ad#b]+)[1-9][0-9]                                +P5 scaleDegree      **deg               [\\^v',]([MmPn]|[Ad#b])[1-9][0-9]*                           P5 final useful option controlled using logical inPlace argument. inPlace = TRUE extra characters input string part matching regular expression left unchanged: example, kern(\"4.A5xxxv\", inPlace = TRUE) output \"4.aaxxxv---\"A5\" (scientific pitch) translated \"aa\" (kern pitch) \"4.\" \"xxxv\" changed. contrast, kern(\"4.A5xxxv\", inPlace = FALSE) just return \"aa\", stripping away \"4.\" \"xxxv\". (Thus, inPlace argument can used tool extract desired part strings.) Note inPlace = TRUE, inputs fail match anything just left unchanged.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchRepresentations.html","id":"read-writing-tonal-pitch-information","dir":"Reference","previous_headings":"","what":"Read/Writing Tonal Pitch Information","title":"Pitch representations and translations — pitchRepresentations","text":"pitch representations defined humdrumR based Western diatonic tonality---info atonal representations, see Read/Writing Atonal Pitch Information section . predefined kernPitch, pitch, lilyPitch, helmholtz, interval, degree, solfa encodings tonal representations---fact, represent essentially absract information,  exactly tonalIntervals encode. Specifically, condsider representations different representations call tonal chroma: , tonalChroma function master function used construct specific representations. following section(s) explain abstract principles pitch representation, function standard representations, , humdrumR, can use tonalChroma arguments create custom tonal representations pitch.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchRepresentations.html","id":"tonal-pitch-partitions-","dir":"Reference","previous_headings":"","what":"Tonal Pitch \"Partitions\"","title":"Pitch representations and translations — pitchRepresentations","text":"discussed Tonality humdrumR vignette, tonal intervals can \"partitioned\"---.e., broken constituent logical pieces. two main \"partitions\" frequently use: partitioning complex interval simple parts octave parts*. partitioning specific interval generic part alteration part. Simple intervals abstract (line--fifths ) information, without regards specific pitch frequency space---.e., actual \"pitch height.\" combination simple interval octave part creates complex interval, include information specific pitch height. Tonal \"line--fifths space\" can partitioned generic (diatonic) information specific interval information describes quality intervals, including zero alterations diatonic set. Thus, tonal interval/pitch composed octave part, generic part, quality part. Various pitch representation schemes (kern, solfege) represent three different parts (octave/generic/quality) tonalIntervals various ways, though representations lossy/incomplete, fully encode three partitions. example, scale degrees represent simple tonal information without complex octave information. schemes, tonal partition represented distinctly others, allowing us mix match different sub-representation create various full reprsentations. cases, representations blur partitions ways can broken apart. instance, solfege syllables neatly delineate generic quality information---\"e\" vowel means different qualities depending leading consonant paired (e.g., \"re\" vs \"\"). Since logic interval representation always conform abstract logic tonalInterval partitions, use different set terms refer representation distinct partitions: scale-step generic information,  quality/alteration/accidental alteration information,  contour octave information, Thus, terms step, contour, quality, alteration, accidental appear various pitch representation/translation function arguments (details ). humdrumR, tonal chroma representation combines combination three representation partions (scale, alteration, /contour). tonalChroma function master function writing tonal chroma. functionskern, pitch, lilypond, .helmholtz simply wrappers call tonalChroma various specific arguments. tonalChroma calls four constituent functions: step, .quality/.accidental, contour/octave. arguments tonalChroma, derived constituent functions (details following sections) : tonalChroma: parts: character string length 1--4, indicating parts tonalChroma print, order. Acceptable strings \"steps\", \"qualities\", \"accidentals\", \"contours\". ([Partial matches][base::pmatch] matches like \"ste\" \"s\" step work .) output tonal chroma string part concatinated order appear parts argument. instance, put c('contour', 'step', 'accidental') put contour simple interval, put c('step', 'accidental', 'contour') put . sep: character string used separate elements (default \"\"). step (described ): step.labels .accidental (described ): accidental.labels accidental.maximum accidental.minimum accidental.cautionary accidental.memory Key .quality (described ): quality.labels quality.maximum quality.minimum quality.cautionary quality.memory Key contour (described ): contour.labels contour.maximum contour.minimum contour.offset contour.round contour.delta","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchRepresentations.html","id":"scale-steps","dir":"Reference","previous_headings":"","what":"Scale Steps","title":"Pitch representations and translations — pitchRepresentations","text":"particular area confusion pitch representation relationship tonal (line--fifths) space contour (frequency) space. line--fifths abstract space unrelated specific frequencies---e.g., G inherently \"\" \"\" C. Still, musicians play abstractions, must always realize line--fifths space concrete frequency space. convention, collections line--fifths conceptualized frequency-orded \"scales\": folding line--fifths sequence intervals octave \"\" unison. theoretical contexts, order/\"height\" elements scale actually completely irrelavant. Specifically, first seven (diatonic) elements line--fifths mapped generic scale-steps order [0, 2, 4, 6, 1, 3, 5]. Scale-steps strictly limited seven-step range single diatonic octave, always \"ascending\"/\"positive\"---steps pseudo-octave \"\" unison. representation line--fiths terms scale-steps basic approach representing pitch, associated arguments containing step; function step basic building block scale-step representations humdrumR. apply modulo-7 operation line--fifths space, intervals mapped seven generic steps. Alterations basic generic steps represented separately (see Qualities Alterations section ). However, note scale order defined entirely based generic interval: example, C-flat convention positioned \"\" C-natural scale, even though (often) equivalent B-natural, \"top\" scale. Generic, pseudo-ordered, scale-steps conventionally represented three forms: letters (-G), numbers (1-7 -VII), conventional syllables (, re, mi, fa...). HumdrumR predefines several representations include letters (-G) scale-step encoding: kernPitch, lilyPitch, helmholtz, pitch. also standard numeric (degree) syllable-based (solfa) based representations predefined. generic step function can used write variations scale step representations. step includes two arguments: step.labels: vector seven elements (default = c('C', 'D', 'E', 'F', 'G', '', 'B')) representing desired names seven steps scale order.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchRepresentations.html","id":"quality-and-alterations","dir":"Reference","previous_headings":"","what":"Quality and Alterations","title":"Pitch representations and translations — pitchRepresentations","text":"Generically, tonal interval's quality indicates diatonic mode relationship mode. Specifically, alterations/accidentals indicate alterations key/mode quality indicates mode . diatonic set primarily defined major mode, consisting line--fifth range -1 +5. seven intervals \"natural\" intervals---default, unless major context specifically counter-indicated, absence accidental indicates natural steps. intervals outside scale can indicated alterations natural steps using accidentals: two primary accidentals, sharp flat, though can added together create multi-sharps multi-flats. (Sharps flats mixed humdrumR.) alteration corresponds adding subtracting multiples 7 generic values (e.g., \"sharpen\" note means add 7 line--fifths value). Finally, natural accidental used default natural step needs explicitely labeled. encoding qualities subtly distinct alterations. Qualities encode information diatonic mode intervals, well alterations mode. five consonant diatonic modes---phyrigian (-5--+1), minor (-4--+2), dorian (-3--+3), mixolydian (-2--+4), major (-1--+5)---share \"perfect\" first, fourth,  fifth scale-steps---corresponding central -1--+1 line--fifths. However, five modes encompass two varieties \"imperfect\" second, third, sixth, seventh scale steps: major steps (+2--+5) minor steps (-2---5), (obviously) inverses line--fifths. minor/major pair separated line--fifths interval 7, thus one can altered . Anything line--fifths outside -5--+5 range represented one alterations perfect/imperfect degree. Postive alterations (+7)  augmented negative alterations (-7) diminished---like sharps flat, augmentations diminutions can multipled. following table illustrates relationship line--fifths, scale-steps, accidentals, qualities: Note accidentals symetrical around dorian mode (D), qualities symetrical around major mode. result, though sharp accidentals augmentation qualities always correspond, flat accidentals equivalent diminished qualities. HumdrumR's predefined tonal chroma representations (kernPitch, lilyPitch, helmholtz, pitch) include alteration information three accidental indications (sharp, flat, natural). degree interval representations encode general qualities using five categories (major, minor, diminished, augmented, perfect). solfa representation also encodes quality conventional (non-systematic) vowel modifications. generally, .quality .accidental functions can used extract quality information isolation. functions use () following arguments: _.labels: accidental.labels: [named][base::names()] character vector controls characters used represent accidentals. characters must named either flat, sharp, natural, doublesharp, doubleflat. defaults c(flat = \"b\", sharp = \"#\", natural = \"n\"). default, doubleflat doublesharp defined, doubles simply represented two normal accidental symbols. However, either double accidental defined, every pair accidentals collapsed double version. accidental.labels == FALSE, returns integer value counting number alterations (positive sharps, negative flats). quality.labels: [named][base::names()] character vector controls characters used represent qualities. characters must named either perfect, major, minor, augment, diminish, defaults c(perfect = \"P\", major = \"M\", minor = \"m\", augment = \"\", diminish = \"d\"). _.maximum _.minimum Single integer values---defaults Inf (maximum) -Inf (minimum). arguments define maximum number multi-accidentals permitted. instance, accidental.maximum == 2L, accidentals \"##\" output; triple sharp reduced just \"##\". The_.minimum argument must negative (-2 == two flats). default, minimum inverse maximum, want , just set maximum. Key: [diatonicSet] object describing key mode. Default NULL. Key specified, alterations relative key printed (unless _.cautionary _.memory arguments override ). _.cautionary: single logical value. Causes accidentals/qualities print (details ). Default FALSE accidentals TRUE qualities. _.memory: single logical value (default FALSE). Causes fewer accidentals/qualities print (details ). master tonalChroma calls functions, can thus pass arguments . example, write tonalChroma(x, accidental.maximum = 1).","code":"LO5th Step Accidental Quality    -10    E         bb       d     -9    B         bb       d     -8    F          b       d     -7    C          b       d     -6    G          b       d     -5    D          b       m     -4    A          b       m     -3    E          b       m     -2    B          b       m     -1    F          n       P      0    C          n       P      1    G          n       P      2    D          n       M      3    A          n       M      4    E          n       M      5    B          n       M      6    F          #       A      7    C          #       A      8    G          #       A      9    D          #       A     10    A          #       A     11    E          #       A     12    B          #       A     13    F         ##      AA     14    C         ##      AA"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchRepresentations.html","id":"cautionary-alterations","dir":"Reference","previous_headings":"","what":"Cautionary Alterations","title":"Pitch representations and translations — pitchRepresentations","text":"interplay Key, _.cautionary, _.memory arguments control accidentals/qualities returned, allowing us achieve various useful representations. Generally, Key argument---NULL---causes accidentals/qualities outside specified key (.e., alterations) print. cautionary argument causes accidentals otherwise suppressed print---always adding accidentals output. Finally, _.memory argument implements common practice music notation alterations printed quality generic note different last time note appeared (.e., earlier input vector). instance, given input two F#s, second F# printed unless F natural sounded , case, natural two sharps print. Combinations Key, _.cautionary _.memory arguments achieve following effects: cases Key NULL: _.cautionary == FALSE & _.memory == FALSE: alterations C major set printed. naturals shown. _.cautionary == TRUE  & _.memory == FALSE: accidentals/qualities printed (including naturals). _.cautionary == FALSE & _.memory == TRUE: alterations C major set printed, unless previous instance step already altered. (Natural notes occuring previous alteration marked natural.) _.cautionary == TRUE  & _.memory == TRUE: accidentals/qualities print, unless previous instance note already altered. , hand, Key specified: _.cautionary == FALSE & _.memory == FALSE: alterations key printed. _.cautionary == TRUE  & _.memory == FALSE: alterations key printed well instances corresponding -key quality, assure ambiguity. _.cautionary == FALSE & _.memory == TRUE: alterations key printed, unless previous instance note already altered. -key accidentals printed previous instance note altered. _.cautionary == TRUE  & _.memory == TRUE: alterations key printed well corresponding -key quality, except -key accidentals appear corresponding alterations. words, cautionary rule applied generic note alteration introduced, . standard, useful represenations : Key == NULL & _.cautionary == FALSE & _.memory == FALSE: print accidentals always, naturals (normal kern style). Key == NULL & quality.cautionary == TRUE & quality.memory == FALSE: print qualities always (normal humdrum style intervals). Key == _ & _.cautionary == FALSE & _.memory == TRUE: print --key accidentals, unless previous note alteration (normal style music notation). following tables illustrate behaviors accidental/quality arguments eight different conditions. first four conditions, Key argument NULL, second group four key Ab major. group four columns represent four possible combinations _.cautionary _.memory arguments, pattern c(_.cautionary = FALSE, _.memory = FALSE), c(_.cautionary = FALSE, _.memory = TRUE), c(_.cautionary = TRUE, _.memory = FALSE), c(_.cautionary = TRUE, _.memory = TRUE).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchRepresentations.html","id":"accidentals","dir":"Reference","previous_headings":"","what":"Accidentals","title":"Pitch representations and translations — pitchRepresentations","text":"","code":"a-   a    b-   a    b-   a-   e    f    f#   e-   g-   f    b    c    d-   b-   e-   b-   a-   NFF  a-   a    b-   a    b-   a-   e    f    f#   e-   g-   f    b    c    d-   b-   e-   b-   a-   NFT  a-   an   b-   a    b    a-   e    f    f#   e-   g-   fn   bn   c    d-   b-   e    b    a    NTF  a-   an   b-   an   b-   a-   en   fn   f#   e-   g-   fn   bn   cn   d-   b-   e-   b-   a-   NTT  a-   an   b-   a    b    a-   en   fn   f#   e-   g-   fn   bn   cn   d-   b-   e    b    a    AbFF a    an   b    an   b    a    en   f    f#   e    g-   f    bn   c    d    b    e    b    a    AbFT a-   an   b-   a    b    a-   en   fn   f#   e-   g-   fn   bn   cn   d-   b-   e    b    a    AbTF a-   an   b-   an   b-   a-   en   fn   f#   e-   g-   fn   bn   c    d    b-   e-   b-   a-   AbTT a-   an   b-   a    b-   a-   en   fn   f#   e-   g-   fn   bn   cn   d-   b-   e-   b-   a-"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchRepresentations.html","id":"qualities","dir":"Reference","previous_headings":"","what":"Qualities","title":"Pitch representations and translations — pitchRepresentations","text":"","code":"a-   a    b-   a    b-   a-   e    f    f#   e-   g-   f    b    c    d-   b-   e-   b-   a-   NFF  m6   6    m7   6    m7   m6   3    4    A4   m3   d5   4    7    1    m2   m7   m3   m7   m6   NFT  m6   M6   m7   6    7    m6   3    4    A4   m3   d5   P4   M7   1    m2   m7   3    7    6    NTF  m6   M6   m7   M6   m7   m6   M3   P4   A4   m3   d5   P4   M7   P1   m2   m7   m3   m7   m6   NTT  m6   M6   m7   6    7    m6   M3   P4   A4   m3   d5   P4   M7   P1   m2   m7   3    7    6    AbFF 6    M6   7    M6   7    6    M3   4    A4   3    d5   4    M7   1    2    7    3    7    6    AbFT m6   M6   m7   6    7    m6   M3   P4   A4   m3   d5   P4   M7   P1   m2   m7   3    7    6    AbTF m6   M6   m7   M6   m7   m6   M3   P4   A4   m3   d5   P4   M7   1    2    m7   m3   m7   m6   AbTT m6   M6   m7   6    m7   m6   M3   P4   A4   m3   d5   P4   M7   P1   m2   m7   m3   m7   m6"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchRepresentations.html","id":"contour-e-g-octave-","dir":"Reference","previous_headings":"","what":"Contour (e.g., Octave)","title":"Pitch representations and translations — pitchRepresentations","text":"wish represent concrete, frequency-ordered information pitch, add additional contour information simple, line--fifth representation creating complex intervals. Since scale-step representations ostensibly encode frequency-space ordering already, first step take scale-ordering literally---e.g, G really \"\" D---, creating call simple contour. fully represent complex interval, can append zero octaves simple contour, call octave contour. humdrumR, symbols \"+\" \"-\" used indicate direction simple contour, various scale-step quality/alterations used indicate simple interval. (many representations, symbols implicit, thus ommitted.) contrast, octave contour interval simply integer value, can represented variety ways: either directly integer, using repetitions symbol pairs, commonly \"^\"/\"v\" \"'\"/\",\". approaches represent octave contour information changing case (upper lower) repeating parts simple-interval string. default, \"\" option (.e., unison) types contours left blank empty string \"\". relationship simple contour octave contour determined scale step \"rounded\" octave (see Tonality humdrumR vignette), controlled contour.round argument. standard approach, scale steps ascending octave achieved floor function: call scale contour. Another approach use round function, rounds nearest octave , centering steps around unison instead : result scale like [-P4, -m3, -m2, P1, M2, M3, P4], call central contour. difference central contours, scale contours, simple contour options, illustrated .","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchRepresentations.html","id":"serial-vs-fixed-octave-contour","dir":"Reference","previous_headings":"","what":"Serial vs Fixed Octave Contour","title":"Pitch representations and translations — pitchRepresentations","text":"#' described Tonality humdrumR vignette, two general approaches representing intervals: fixed-reference serial-reference. pitch representations fixed-reference, token representing interval relative common reference (middle-C, tonic, unison, etc.). contrast, serial representation represents interval cummulatively, relative previous interval: common example melodic intervals. TonalIntervals can encode either fixed- serial-reference intervals, either approach can partitioned simple intervals octave offsets. common cases representing pitch, simple contour treated \"always ascending\" scale contour, octave contour simply kept fixed. Common approaches pairing octave information include: pitch style: octave offset simply printed integer, though offset +4 middle-C (unison) \"4\". kernPitch style: scale step lowercase octave contours >= 0 uppercase otherwise. addition, scale step repeated absolute value octave contour times (offset +1 positive octaves). example, (CCC = -3, CC = -2, C = -1, c = 0, cc = 1, ccc = 2). lilyAbsolute absolute style: charactes \"'\" (positive) \",\" repeated absolute value octave contour. helmholtz style: intersection lilyPitch-absolute kernPitch style, case scale step changed kern-style, \"'\"/\",\" characters printed la lilypond absolute style. However, another particularly useful possibility encode octave part serial reference simple part fixed reference. compute serial-octave contour, set contour.round argument round, contour labels blank (\"\" marker) interval moved closest neighbor, octave contour indicating moves away \"closest note.\" instance, can say, \"play F# previous note.\" known \"relative pitch\" representation LilyPond]: relative = TRUE, lilypond compute markers labeled way. approach can combined scale-contour (contour.round = floor) representation pitch scale degrees, resulting scale degree representation lossless contour information! achieve serial contours, use contour.delta contour.round arguments. delta = TRUE, contour serial representation input computed, octave-part contour computed using contour.round rounding function. floor create \"always ascending\" scale contour, round achieve centered contour. expand label contours ascending/descending except unisons. following table illustrates different contour.round arguments delta = TRUE: following table illustrates three rounding functions, contour.delta = FALSE.","code":"round floor expand                                v      v                                       ^                   ^      v     v      v                                       ^                   ^      ^            ^                                v      v            v      v                   ^            v      v            v      v      ^     ^     ^^            v      v            v      v            v      v Kern round floor expand     c                        A           v      v     A           v      v     c                        d                  ^     G           v      v     G           v      v     A           v      v    B-           v      v     f                  ^     f                  ^     e                  ^     d                  ^     e                  ^     d                  ^     c                       ff     ^     ^     ^^    ee     ^     ^     ^^    dd     ^     ^     ^^    cc     ^     ^      ^"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchRepresentations.html","id":"complex-steps","dir":"Reference","previous_headings":"","what":"Complex Steps","title":"Pitch representations and translations — pitchRepresentations","text":"final standard approach indicating complex contours complex steps: .e., 9ths, 11ths, etc. approach directly represents full contour information scale steps, +7 added every octave contour. representation can accessed via interval function. limit intervals simple values, use tonalTransform arguments octave /roundMethod.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchRepresentations.html","id":"contour","dir":"Reference","previous_headings":"","what":"contour","title":"Pitch representations and translations — pitchRepresentations","text":"contour function can used directly generate representations octave/contour, can called indirectly via tonalChroma one standard pitch representation functions (kern, pitch, etc.). octave command synonym contour. following arguments defined contour: contour.labels: [named][base::names()] character vector controls characters used represent octave shifts. characters must named either , , ; defaults c(= \"^\", = \"v\", = \"\"). contour.labels = FALSE, octave offset (integer) returned. contour.labels == FALSE, returns integer value counting octave offset number. contour.maximum contour.minimum Single integer values---defaults Inf (maximum) -Inf (minimum). arguments define maximum number octave offset labels permitted. maximum == 2L, octave offsets (\"^^\") output; triple octave mark reduced just \"^^. Theminimum arguments negative. default, minimum inverse maximum, want , just set maximum. contour.offset: single integer, indicating \"center\" octave. default 0L, scientific pitch uses 4L (middle C \"C4\"). contour.delta: single logical vale. TRUE, serial contour calculated. contour.round: function, either floor, round, trunc, expand (see Tonality humdrumR vignette). default floor, standard delta = FALSE. [/\\\\]: R:/%5C%5C%5C%5C%5C%5C%5C [/\\\\]: R:/%5C%5C%5C%5C%5C%5C%5C [TtMmWw]: R:TtMmWw [TtMmWwS$O]: R:TtMmWwS$O [vu]: R:vu [vu]: R:vu [0-9]: R:0-9 [1-9]: R:1-9 [0-9]: R:0-9 [.]: R:. [b#-]: R:b#- [-+]: R:-+ [0-9]: R:0-9 [\\^v',]: R:%5C%5C%5C%5C%5Ev', [aei]: R:aei [+-]: R:+- [MmP]: R:MmP [Ad#b]: R:Ad#b [0-9]: R:0-9 [\\^v',]: R:%5C%5C%5C%5C%5Ev', [MmPn]: R:MmPn [Ad#b]: R:Ad#b [0-9]: R:0-9 [line--fifths]: R:line--fifths tonalTransformations: R:tonalTransformations [alterations]: R:alterations [base::pmatch]: R:base::pmatch [0, 2, 4, 6, 1, 3, 5]: R:0,%202,%204,%206,%201,%203,%205 [sharp]: R:sharp [flat]: R:flat [natural]: R:natural [modes]: R:modes [base::names()]: R:base::names() [base::names()]: R:base::names() [diatonicSet]: R:diatonicSet [-P4, -m3, -m2, P1, M2, M3, P4]: R:-P4,%20-m3,%20-m2,%20P1,%20M2,%20M3,%20P4 LilyPond: R:LilyPond tonalTransform: R:tonalTransform [base::names()]: R:base::names()","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchRepresentations.html","id":"reading-writing-atonal-pitch-information","dir":"Reference","previous_headings":"","what":"Reading/Writing Atonal Pitch Information","title":"Pitch representations and translations — pitchRepresentations","text":"Atonal pitch representations predefined humdrumR include semit, midi, frequency, ratio, fraction. mentioned , integer inputs interpreted semitones numeric interpreted frequency ratios.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchRepresentations.html","id":"interpreting-frequencies-ratios","dir":"Reference","previous_headings":"","what":"Interpreting Frequencies/Ratios","title":"Pitch representations and translations — pitchRepresentations","text":"Four additional arguments help humdrumR determing interpret frequencies ratios tonalIntervals. tonalHarmonic: determines assumed tuning system specifying \"tonal frequency ratio\" associated interval perfect 12th. default 3, corresponding pythagorean tuning; change 2^(19/12) use equal temeperament. centMargin: numeric argument determines close humdrumR tries get (cents) input ratio (default 10 cents). centMargin low, humdrumR may give crazy accidental like ---- get close input ratio. centMargin higher, humdrumR give reasonable (fewest accidentals) tonalInterval within margin. example, tonalInterval(1.44, centMargin = 10) return E##, pythagorean E## within 10 cents ratio 1.44. However, tonalInterval(1.44, centMargin = 20) return resonable F#. frequency.reference frequencyTint: arguments determing reference frequency note reading frequencies. standard = 440Hz corresponds (frequency.reference = 440, frequencyTint = tonalInterval('')).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/pitchRepresentations.html","id":"tonal-decisions","dir":"Reference","previous_headings":"","what":"Tonal Decisions","title":"Pitch representations and translations — pitchRepresentations","text":"interpreting atonal reprsentation tonal one multiple possibilities (instance, midi note 61 C# Db). process humdrumR uses determine tonal representation atonal input influenced accidental.melodic Key arguments: default (Key == NULL & accidental.melodic == FALSE), line--fifths range -3--8 (E flat G sharp) used. However, Key argument specified, line--fifths range shifted match corresponding key signature. instance, key Bb minor read accidentals range -8--3 (Fb flat natural). accidental.melodic == TRUE) atonal notes interpreted \"melodically\"---.e., ascending chromatic steps sharps descending chromatic steps flats. reading frequencies/ratios, \"pure\" tonalHarmonic value---like pure 3 pythagorean tuning---help determine appropriate accidental. However, equal temperament provide useful information, Key accidental.melodic arguments can used instead.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/plotRhythm.html","id":null,"dir":"Reference","previous_headings":"","what":"Plotting rhythmic symbols in R base graphics — plotRhythm","title":"Plotting rhythmic symbols in R base graphics — plotRhythm","text":"Plotting rhythmic symbols R base graphics ------------------------------------------->             NEEDS DOCUMENTATION             <------------------------------------------- Plotting rhythmic symbols R base graphics","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/plotRhythm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plotting rhythmic symbols in R base graphics — plotRhythm","text":"","code":"plotRhythm(x, y, notes, ...)  # S3 method for default plotRhythm(x, y, notes, ...)  # S3 method for rhythmInterval plotRhythm(x, y, notes, ...)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/quality.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract quality from pitch — quality","title":"Extract quality from pitch — quality","text":"Extract quality pitch","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/quality.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract quality from pitch — quality","text":"","code":"quality(x, ..., parseArgs = list(), inPlace = FALSE)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/quality.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract quality from pitch — quality","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). parseArgs (list) parseArgs can list arguments passed pitch parser. convenient syntactic sugar, instead writing parseArgs = list(= x, b = y, etc.), can write parse(= x, b = y, etc.). inPlace (logical, length == 1) argument effect input (x argument) character strings, extral, non-pitch information strings \"beside\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/rational.html","id":null,"dir":"Reference","previous_headings":"","what":"Rational numbers — rational","title":"Rational numbers — rational","text":"R built rational number representation; humdrumR defines one. #' @rdname real #' @export .real <- function(x, ...) UseMethod('.real') #' @export .real.character <- function(x)  x[grepl('^0-9.%/\\(\\)-', x)] <- NA .real.fraction(x)  #' @export .real.numeric <- real #' @export .real.rational <- function(x) real(.double(x)) #' @export .real.fraction <- function(x)  exprs <- parse(text = stringi::stri_replace_all_fixed(x, '%', '/')) real(sapply(exprs, eval) %<-matchdim% x)","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/rational.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rational numbers — rational","text":"","code":"rational(numerator, denominator = 1L)  e1 %R% e2  numerator(x)  denominator(x)  # S4 method for rational numerator(x)  # S4 method for rational denominator(x)  is.rational(x)  # S4 method for rational is.numeric(x)  order.rational(   x,   ...,   na.last = TRUE,   decreasing = FALSE,   method = c(\"auto\", \"shell\", \"radix\") )  # S4 method for rational,rational Compare(e1, e2)  # S4 method for rational,ANY Compare(e1, e2)  # S4 method for ANY,rational Compare(e1, e2)  # S4 method for rational Summary(x)  # S4 method for rational prod(x, ..., na.rm = FALSE)  # S4 method for rational abs(x)  # S4 method for rational sign(x)  # S4 method for rational max(x, ..., na.rm = FALSE)  # S4 method for rational min(x, ..., na.rm = FALSE)  # S4 method for rational mean(x)  # S4 method for rational sum(x, ..., na.rm = FALSE)  # S4 method for rational cumsum(x)  as.rational(x, ...)  # S4 method for integer as.rational(x)  # S4 method for numeric as.rational(x)  # S4 method for logical as.rational(x)  # S4 method for character as.rational(x, sep = \"/|%\")  fraction(numerator, denominator, sep = \"/\")  as.fraction(x, sep = \"/\")"},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/readHumdrum.html","id":null,"dir":"Reference","previous_headings":"","what":"Find and read humdrum files into R — readHumdrum","title":"Find and read humdrum files into R — readHumdrum","text":"functions find valid humdrum files local machine read humdrumR.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/readHumdrum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find and read humdrum files into R — readHumdrum","text":"","code":"findHumdrum(   ...,   contains = NULL,   recursive = FALSE,   allowDuplicates = FALSE,   verbose = FALSE )  readHumdrum(   ...,   recursive = FALSE,   contains = NULL,   allowDuplicates = FALSE,   verbose = FALSE,   tandems = \"known\",   reference = \"all\" )"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/readHumdrum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find and read humdrum files into R — readHumdrum","text":"... character: One patterns used identify files read. details: see \"REpath-patterns\" section . contains character. !.null(contains), contains argument treated regular expressions: files contain matches regular expressions read. Thus, readHumdrum('.*krn$', contains = \"EEE\") read kern files contain matches \"EE\"---kern E two octaves middle C (lower). recursive logical: TRUE, final part search pattern (.e., file search) searched recursively sub directories. allowDuplicates logical length one, indicating happen multiple search patterns match files. allowDuplicates = TRUE, files read multiple times, grouped respective corpora Label field. allowDuplicates = FALSE, redundant files read corpus first pattern match. verbose logical: TRUE, names matching files printed parsing begins. useful check make sure reading wrong files! tandems character. argument controls , , tandem interpretations parsed fields. default value \"known\". reference character. argument controls , , reference records parsed fields. default value \"\".","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/readHumdrum.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find and read humdrum files into R — readHumdrum","text":"findHumdrum work finding reading text files R. readHumdrum utilizes findHumdrum read files, parses create humTable build humdrumR data object around table.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/readHumdrum.html","id":"repath-patterns","dir":"Reference","previous_headings":"","what":"REpath-patterns","title":"Find and read humdrum files into R — readHumdrum","text":"\"REpath-patterns\" specified using ... arguments. combination, ... arguments used search file paths. part search path specify (\"dirpart/dirpart/filepart\", etc) matched regular expressions directories/files disc. Thus, can say things like findHumdrum(\"../^.*/.*krn$\"), match kern files directory beginning capital \"\" directory current working directory. conveniance, can break path across multiple arguments instead using delimited strings: example, code findHumdrum(\"..\", \"^.*\", \".*krn$\") give identical result previous example (findHumdrum(\"../^.*/,*krn$\")). useful searching one pattern (see next paragraph) directory. want search one pattern, can input character vector: instance, readHumdrum(c(\"mozart\", \"beethoven\")---command search filenames containing \"mozart\" \"beethoven.\" works directories : readHumdrum(c(\"Mozart\", \"Beethoven\"), \".*krn$\") look kern files directories containing \"Mozart\" \"Beethoven.\" patterns named, names show identifying patterns [humdrumR][humdrumR] object's Label field. Unnamed patterns simply labeled numbers. Normal (system appropriate) conventions (.e., directories separated \"/\", '~' beginning indicate home, \"..\" indicate directory working directory, etc.) followed. pattern contains solo dot followed file sep---e.g., \"./\", \"x/./y\"---treated current directory, regular expression. pattern contains two dots---e.g., \"../\"---treated directory , regular expression. want create regular expression match directory, use \".*/\". regex pattern \"\" matches file (changed \".*\"). specifiy ... argument, findHumdrum (readHumdrum) default \".*\" well. Thus, readHumdrum() read humdrum files working directory. (two files different directories share name, unique name created file appending names directories occupy, recursively names unique.) single humdrum file multiple pieces ---meaning spine paths close *-, open **---parsed separetely. distinguished Piece field. multi-piece files, Piece File identical.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/readHumdrum.html","id":"validity","dir":"Reference","previous_headings":"","what":"Validity","title":"Find and read humdrum files into R — readHumdrum","text":"findHumdrum readHumdrum automatically ignore non-text files. Whatsmore, files contain humdrum syntax errors (checked [validateHumdrum][validateHumdrum]) automatically skipped. want see specifically errors occured, call [validateHumdrum][validateHumdrum] directly errorReport.path argument.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/readHumdrum.html","id":"tandem-interpretations","dir":"Reference","previous_headings":"","what":"Tandem Interpretations","title":"Find and read humdrum files into R — readHumdrum","text":"tandems argument controls tandem interpretations parsed fields. can helpful either save processing time memory parsing interpretations need, parse interpretations humdrumR recognize. \"known\" tandem interpretations humdrumR recognizes encoded build humdrumR table called knownInterpretations. interpretation humdrumR name (\"Clef\", \"TimeSignature\", etc.) well regular expression associated . default value tandems argument \"known\". tandems argument contains \"known\" tandem interpretations built-knownInterpretations table parsed. Users may specify different interpretations parse two ways: character strings matching one name values Name column knownInterpretations. instance, specify tandems = c('Clef', 'TimeSignature'), clef (e.g., \"*clefG2\"), time signature (e.g., \"*M3/4\") intepretations parsed. chracter string(s) tandem exactly match one names knownInterpretations$Name, treated regular expressions used match tandem interpretations data. allows users parse non-standard tandem interpretations humdrumR already know . values tandems named, names used resulting fields. matches given interpretation found, field created interpretation. tandems = NULL, tandem interpretations parsed.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/readHumdrum.html","id":"reference-records","dir":"Reference","previous_headings":"","what":"Reference Records","title":"Find and read humdrum files into R — readHumdrum","text":"default (reference = \"\"), humdrumR reads reference records data. reference code record (e.g, \"OTL\", \"!!!OTL: xxx\") used name associated field. (reference record reference code (.e., lacks colon), field called \"Unkeyed.\") large datasets many reference records, reference data can actually make large portion humdrum table, eat lot memory. cases, might want read () reference records---can instead read reference records planning use analyses (). reference = NULL, reference records parsed. Otherwise, character values reference treated reference codes matching reference records parsed. instance, readHumdrum(_, reference = \"OTL\") parse OTL reference records. values reference named, names used name associated fields. Thus, specifing reference = c(Title = 'OTL'), can use \"OTL\" reference records populate field called \"Title\". one reference records reference code, either explicitely numbered (e.g., \"!!!COM1:\", \"!!!COM2:\") read rather making two fields, single field created (\"COM\" ) multiple values separated \";\".","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/readHumdrum.html","id":"result","dir":"Reference","previous_headings":"","what":"Result","title":"Find and read humdrum files into R — readHumdrum","text":"findHumdrum returns \"fileFrame\" (data.table), listing file names, patterns match, directories found , raw text content files. readHumdrum returns fully parsed humdrumR object.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/readHumdrum.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find and read humdrum files into R — readHumdrum","text":"","code":"readHumdrum() # loads all valid humdrum files in the current directory. #> Finding and reading files... #> \tREpath-pattern '.*' matches 120 text files in 1 directory. #> 120 files read from disk. #> Validating 120 files... #> 27,410 errors in 121 files... #> zero valid files. #> NULL  readHumdrum(\".*krn$\") # loads all files ending with \"krn\" in the currect directory #> Finding and reading files... #> \tREpath-pattern '.*krn$' matches 0 text files in 1 directory. #> Zero files read from disk. #> No files to validate. #> NULL  readHumdrum(\"^Composers$/^Be|^Mo/.*/^Joined$/.*krn$\")  #> Finding and reading files... #> \tREpath-pattern '^Composers$/^Be|^Mo/.*/^Joined$/.*krn$' matches 0 text files in 0 directories. #> Zero files read from disk. #> No files to validate. #> NULL # Goes inside the directory \"Composers\". # Inside \"Composers\" looks for directories that start with \"Be\" or \"Mo\". # If there are any \"Be|Mo\" matching directories within \"Composers\", matches all directories within them. # Within these directories, looks for directories called \"Joined\". # If there are any directories called \"Joined\", loads all files (if any) that end with \"krn\".  readHumdrum(\"^Composers$\", \"^Be|^Mo\", \".*\", \"^Joined$\", \".*krn$\") #> Finding and reading files... #> \tREpath-pattern '^Composers$/^Be|^Mo/.*/^Joined$/.*krn$' matches 0 text files in 0 directories. #> Zero files read from disk. #> No files to validate. #> NULL # exactly the same as the previous!  readHumdrum(\"^Composers$\", c(Beethoven = \"^Be\", Mozart = \"^Mo\"), \".*\", \"^Joined$\", \".*krn$\")  #> Finding and reading files... #> \tREpath-pattern Beethoven = '^Composers$/^Be/.*/^Joined$/.*krn$' matches 0 text files in 0 directories.\tREpath-pattern Mozart = '^Composers$/^Mo/.*/^Joined$/.*krn$' matches 0 text files in 0 directories. #> Zero files read from disk. #> No files to validate. #> NULL # exactly the same as the previous, except now the two matching patterns (\"^Be\", or \"^Mo\") will be grouped # in the Label field as \"Beethoven\" and \"Mozart\" respectively."},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/regexConstruction.html","id":null,"dir":"Reference","previous_headings":"","what":"Making Regular Expressions — regexConstruction","title":"Making Regular Expressions — regexConstruction","text":"humdrumR includes helpful functions creating new regular expressions work stringr package.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/regexConstruction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Making Regular Expressions — regexConstruction","text":"","code":"captureRE(strs, n = \"\")  captureUniq(strs, zero = TRUE)  orRE(...)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/regexConstruction.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Making Regular Expressions — regexConstruction","text":"captureRE take character vector collapse \"capture group.\" n argument can used append number tag, instance '*' (zero ) group. .e., captureRE(c(\"\", \"b\", \"c\"), '*') output \"[abc]*\". captureUniq make similar capture group captureRE, expression makes sure 1 character repeats. instance, captureUniq(c('', 'b','c')) return \"([abc])\\\\1*\"---expression match \"aaa\" \"bb\" \"aabb\".","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/regexDispatch.html","id":null,"dir":"Reference","previous_headings":"","what":"Regular expression method dispatch and function application — regexDispatch","title":"Regular expression method dispatch and function application — regexDispatch","text":"humdrumR regular-expression method dispatch system simple system making new functions can smartly applied complex character strings.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/regexDispatch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Regular expression method dispatch and function application — regexDispatch","text":"","code":"func %predate% predicate  <<<<<<< HEAD regexDispatch(...) ======= regexDispatch(..., defaultClass = \"character\") >>>>>>> master  REapply(x, regex, .func, inPlace = TRUE, ...)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/regexDispatch.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Regular expression method dispatch and function application — regexDispatch","text":"function do2RE accepts arbitrary function regular expression (regex) makes new function applies original function part string matches regex. function regexDispatch accepts list functions, matching regular expression, creates new function applies whichever function based regexs finds input.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/rhythmDecompose.html","id":null,"dir":"Reference","previous_headings":"","what":"Decompose durations in terms of other durations — rhythmDecompose","title":"Decompose durations in terms of other durations — rhythmDecompose","text":"Decompose durations terms durations","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/rhythmDecompose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Decompose durations in terms of other durations — rhythmDecompose","text":"","code":"rhythmDecompose(rhythmInterval, into = rint(c(1, 2, 4, 8, 16, 32)))"},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/rhythmFunctions.html","id":null,"dir":"Reference","previous_headings":"","what":"Manipulate pitch data — rhythmFunctions","title":"Manipulate pitch data — rhythmFunctions","text":"Manipulate pitch data","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/rhythmFunctions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Manipulate pitch data — rhythmFunctions","text":"","code":"recip(   x,   ...,   Exclusive = NULL,   parseArgs = list(),   timeArgs = list(),   inPlace = FALSE,   memoize = TRUE,   deparse = TRUE )  duration(   x,   ...,   Exclusive = NULL,   parseArgs = list(),   timeArgs = list(),   inPlace = FALSE,   memoize = TRUE,   deparse = TRUE )"},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/rhythmInterval.html","id":null,"dir":"Reference","previous_headings":"","what":"Representation of rhythmic information — rhythmInterval","title":"Representation of rhythmic information — rhythmInterval","text":"S4 class core rhythm representation humdrumR package. ======= S4 class core rhythm representation humdrumR package. >>>>>>> master object used represent rhythmic durations metric positions. duration represented whole note units. Numerically, whole note units represented ratio integers, held slots @Numerator @Denominator. allows use represent rational number loss precision due rounding errors weak decimal expansions (like 0.333333). Rhythm intervals similar standard musical termoniology (.e, \"three eighth-notes\" ratio (3/8).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/rhythmInterval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Representation of rhythmic information — rhythmInterval","text":"","code":"rhythmInterval(x, ...)  rint(denominator, numerator = 1L)  <<<<<<< HEAD is.rhythmInterval(x)  # S4 method for rhythmInterval is.numeric(x)  # S4 method for rhythmInterval as.character(x)  # S3 method for rhythmInterval as.double(x) ======= # S4 method for rhythmInterval as.character(x)  # S3 method for rhythmInterval as.double(x)  is.rhythmInterval(x)  # S4 method for rhythmInterval is.numeric(x) >>>>>>> master  order.rhythmInterval(   x,   ...,   na.last = TRUE,   decreasing = FALSE,   method = c(\"auto\", \"shell\", \"radix\") )  # S4 method for rhythmInterval,rhythmInterval Compare(e1, e2)  # S4 method for rhythmInterval Summary(x)  <<<<<<< HEAD rhythmInterval(x, ...)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/rhythmInterval.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Representation of rhythmic information — rhythmInterval","text":"#' @name RhythmScaling #' @export augment.character <- regexDispatch('Recip'   = recip.rhythmInterval %.% augment.rhythmInterval %.% read.recip2rhythmInterval, '0-9+%/+' = .ratio.rhythmInterval %.% augment.rhythmInterval %.% read.fraction2rhythmInterval, 'Decimal' = .decimal.rhythmInterval %.% augment.rhythmInterval %.% read.numeric2rhythmInterval) #' @name RhythmScaling #' @export diminish <- function(x, scalar = 2, ...) UseMethod('diminish') #' @name RhythmScaling #' @export diminish.rhythmInterval <- function(rint, scalar) rint / scalar #' @name RhythmScaling #' @export diminish.character <- regexDispatch('Recip'   = recip.rhythmInterval %.% diminish.rhythmInterval %.% read.recip2rhythmInterval, '0-9+%/+' = .ratio.rhythmInterval %.% diminish.rhythmInterval %.% read.fraction2rhythmInterval, 'Decimal' = .decimal.rhythmInterval %.% diminish.rhythmInterval %.% read.numeric2rhythmInterval)","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/rhythmOffset.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate rhythmic ","title":"Calculate rhythmic ","text":"Borrowing term music21, rhythmic \"offset\" refers duration time since starting point (usually, beginning piece). rhythmOffset takes vector numbers representing durations (maybe [rhythmInterval][rhythmInterval]s, maybe numeric values) cummulatively sums starting value. output vector durations type input output value corresponds duration time elapsed point.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/rhythmOffset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate rhythmic ","text":"","code":"rhythmOffset(durations, start = 0, bars = NULL, tatum = 1, as = duration)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/rhythmOffset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate rhythmic ","text":"durations vector numeric values representing durations. start duration value (coerced class durations), offset begins. groups vector equal length durations representing grouping factor, usable [base][tapply]. !.null(groups), offsets calculated duration values within group. start argument recycle match length number groups, different start value can applied group. .null(groups), offsets calculated whole durations vector, first start value.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/romanNumerals.html","id":null,"dir":"Reference","previous_headings":"","what":"Roman Numeral — romanNumerals","title":"Roman Numeral — romanNumerals","text":"Roman numerals can calculated diatonicSets (keys) tertian sets (chords). later case standard meaning \"roman numeral.\" However, former case used well, instance represent modulation schemes analyses classical music. instance, modulate -V, vi/V. importantly, many \"roman numerals\" harmonic analyses implicitely combine tertian diatonic roman numerals: \"applied\" roman numerals. Given roman numeral like \"V65/V\", \"V65\" represents chord \"/V\" represents key.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/semit.html","id":null,"dir":"Reference","previous_headings":"","what":"Semitone pitch representation — semit","title":"Semitone pitch representation — semit","text":"function translates pitch information semitones (integers). Middle-C unison values 0.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/semit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Semitone pitch representation — semit","text":"","code":"semit(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.contour = FALSE,   parseArgs = list(),   transposeArgs = list(),   inPlace = FALSE )"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/semit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Semitone pitch representation — semit","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). generic (logical, length 1) generic = TRUE \"specific\" pitch information discarded. tonal representations, means accidentals/qualities equivalent information printed. atonal representations, generic pitch returned. alternative, can specify specific alternative (opposite) generic argument: generic == !specific. simple (logical, length 1) simple = TRUE \"complex\" pitch information discarded. means octave information discarded, resulting output confined within default octave. absolute pitch representations, octave middle C. relative pitch representations, octave unison. (special octave.round argument can used modify behavior). parseArgs (list) parseArgs can list arguments passed pitch parser. convenient syntactic sugar, instead writing parseArgs = list(= x, b = y, etc.), can write parse(= x, b = y, etc.). transposeArgs (list) transposeArgs can list arguments passed special call transpose. convenient syntactic sugar, instead writing transposeArgs = list(= x, b = y, etc.), can write transpose(= x, b = y, etc.). inPlace (logical, length 1) argument effect input (x argument) character strings, extral, non-pitch information strings \"beside\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/semit.html","id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Semitone pitch representation — semit","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semit, normally return numeric values, return character strings input character string.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/semits.html","id":null,"dir":"Reference","previous_headings":"","what":"12-tone equal-temperament semitone representations — semits","title":"12-tone equal-temperament semitone representations — semits","text":"function translates pitch information basic atonal, 12-tone-equal-temperament pitch values: semitones (integers), MIDI pitch values, cents. midi semits identical, except semits returns values centered Middle-C (**0 = ), midi offset ** = 60.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/semits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"12-tone equal-temperament semitone representations — semits","text":"","code":"semits(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )  midi(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/semits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"12-tone equal-temperament semitone representations — semits","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). generic (logical, length == 1) generic = TRUE \"specific\" pitch information discarded. tonal representations, means accidentals/qualities equivalent information printed. atonal representations, generic pitch returned. alternative, can specify specific alternative (opposite) generic argument: generic == !specific. simple (logical, length == 1) simple = TRUE \"complex\" pitch information discarded. means octave information discarded, resulting output confined within default octave. absolute pitch representations, octave middle C. relative pitch representations, octave unison. (special octave.round argument can used modify behavior). transposeArgs (list) transposeArgs can list arguments passed special call transpose. convenient syntactic sugar, instead writing transposeArgs = list(= x, b = y, etc.), can write transpose(= x, b = y, etc.). parseArgs (list) parseArgs can list arguments passed pitch parser. convenient syntactic sugar, instead writing parseArgs = list(= x, b = y, etc.), can write parse(= x, b = y, etc.). inPlace (logical, length == 1) argument effect input (x argument) character strings, extral, non-pitch information strings \"beside\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/semits.html","id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"12-tone equal-temperament semitone representations — semits","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string. humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/silbeFormat.html","id":null,"dir":"Reference","previous_headings":"","what":"silbeFormat — silbeFormat","title":"silbeFormat — silbeFormat","text":"Check formatting lyrics correct, -'s right places (.e., denote start end syllable)","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/silbeFormat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"silbeFormat — silbeFormat","text":"","code":"silbeFormat(cVector)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/silbeFormat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"silbeFormat — silbeFormat","text":"cVector data checked improper formatting (now, please read spine dataframe 1 column)","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/silbeFormat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"silbeFormat — silbeFormat","text":"\"Formatted properly.\" lyrics formatted properly, else print error message corrections.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/silbeFormat.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"silbeFormat — silbeFormat","text":"function might detect multiple inconsistencies/errors given value particular index, help user determine exact issue(s) transcription.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/solfa.html","id":null,"dir":"Reference","previous_headings":"","what":"Relative-do Solfege representation — solfa","title":"Relative-do Solfege representation — solfa","text":"Relative-Solfege representation","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/solfa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relative-do Solfege representation — solfa","text":"","code":"solfa(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/solfa.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relative-do Solfege representation — solfa","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). generic (logical, length == 1) generic = TRUE \"specific\" pitch information discarded. tonal representations, means accidentals/qualities equivalent information printed. atonal representations, generic pitch returned. alternative, can specify specific alternative (opposite) generic argument: generic == !specific. simple (logical, length == 1) simple = TRUE \"complex\" pitch information discarded. means octave information discarded, resulting output confined within default octave. absolute pitch representations, octave middle C. relative pitch representations, octave unison. (special octave.round argument can used modify behavior). transposeArgs (list) transposeArgs can list arguments passed special call transpose. convenient syntactic sugar, instead writing transposeArgs = list(= x, b = y, etc.), can write transpose(= x, b = y, etc.). parseArgs (list) parseArgs can list arguments passed pitch parser. convenient syntactic sugar, instead writing parseArgs = list(= x, b = y, etc.), can write parse(= x, b = y, etc.). inPlace (logical, length == 1) argument effect input (x argument) character strings, extral, non-pitch information strings \"beside\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/solfa.html","id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Relative-do Solfege representation — solfa","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/solfg.html","id":null,"dir":"Reference","previous_headings":"","what":"Fixed-do Solfege representation — solfg","title":"Fixed-do Solfege representation — solfg","text":"Based common French system notating pitches, encoded humdrum **solfg interpretation.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/solfg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fixed-do Solfege representation — solfg","text":"","code":"solfg(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/solfg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fixed-do Solfege representation — solfg","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). generic (logical, length == 1) generic = TRUE \"specific\" pitch information discarded. tonal representations, means accidentals/qualities equivalent information printed. atonal representations, generic pitch returned. alternative, can specify specific alternative (opposite) generic argument: generic == !specific. simple (logical, length == 1) simple = TRUE \"complex\" pitch information discarded. means octave information discarded, resulting output confined within default octave. absolute pitch representations, octave middle C. relative pitch representations, octave unison. (special octave.round argument can used modify behavior). transposeArgs (list) transposeArgs can list arguments passed special call transpose. convenient syntactic sugar, instead writing transposeArgs = list(= x, b = y, etc.), can write transpose(= x, b = y, etc.). parseArgs (list) parseArgs can list arguments passed pitch parser. convenient syntactic sugar, instead writing parseArgs = list(= x, b = y, etc.), can write parse(= x, b = y, etc.). inPlace (logical, length == 1) argument effect input (x argument) character strings, extral, non-pitch information strings \"beside\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/solfg.html","id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Fixed-do Solfege representation — solfg","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/spinePipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Collapse spines into new fields — spinePipe","title":"Collapse spines into new fields — spinePipe","text":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/spinePipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Collapse spines into new fields — spinePipe","text":"","code":"spinePipe(humdrumR, targetSpines, destinationSpines)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/spines.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize humdrum corpus spine paths. — spines","title":"Summarize humdrum corpus spine paths. — spines","text":"function provides summary spines spine paths pieces humdrumR corpus.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/spines.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize humdrum corpus spine paths. — spines","text":"","code":"spines(humdrumR)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/step.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract scale step — step","title":"Extract scale step — step","text":"Extract scale step","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/step.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract scale step — step","text":"","code":"step(x, ..., simple = FALSE, parseArgs = list(), inPlace = FALSE)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/step.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract scale step — step","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). simple (logical, length == 1) simple = TRUE \"complex\" pitch information discarded. means octave information discarded, resulting output confined within default octave. absolute pitch representations, octave middle C. relative pitch representations, octave unison. (special octave.round argument can used modify behavior). parseArgs (list) parseArgs can list arguments passed pitch parser. convenient syntactic sugar, instead writing parseArgs = list(= x, b = y, etc.), can write parse(= x, b = y, etc.). inPlace (logical, length == 1) argument effect input (x argument) character strings, extral, non-pitch information strings \"beside\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/struct.html","id":null,"dir":"Reference","previous_headings":"","what":"struct — struct","title":"struct — struct","text":"Virtual class help create atomic-vector-like composite data objects.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/struct.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"struct — struct","text":"","code":"is.struct(x)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/struct.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"struct — struct","text":"humdrumR defines number S4 classes , underneath surface, composite data types made collections base-R atomic vectors, stuck together. \"vectorized\" nature R's atomic types one R's key strengths, humdrumR try ) mostly use standard atomic types B) make new types define act much like atomic vectors possible. struct virtual S4 class serves purpose: creating composite atomic vectors act (mostly) like base-R atomic vectors. \"virtual class\" structs really exist independent objects, struct class defines (abstractly) necessarry methods treat collection atomic vectors single vector/matrix-like object---simply make new subclass inherit struct taken care . (, specify contains = \"struct\" call setClass.) Important humdrumR classes inherit struct include: tonalInterval diatonicSet tertianSet rhythmInterval warned, R's S4 object-system limited regard: really define S4 classes act fully like R atomics, many features hard-coded R replicated. important limitation struct may encounter , though struct classes work (ok) data.frames, data.tables tibbles either work give strange behaviors put structs .","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/struct.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"struct — struct","text":"dim Either NULL non-negative integer-vector length == 2L, representing number rows columns respectively. Dimensions can zero. rownames Either NULL integer/character-vector length either ) dim == NULL, length struct B) dim != NULL, number rows struct. colnames Either NULL (must NULL dim == NULL) integer/character-vector length equal number columns struct.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/struct.html","id":"behavior","dir":"Reference","previous_headings":"","what":"Behavior","title":"struct — struct","text":"struct subclasses (.e., classes inherit struct) behave similarly normal R atomic vectors/matrices. However, differ respects, mostly ways intended avoid quirky behaviors R matrices: general, distinction dimensionless vectors dimensioned vectors (matrices) slightly weaker structs normal R atomic vectors/matrices. importantly, dimensioned structs drop dimensions various common operations (c, [], etc.), way base-R matrices . general, easier interact multi-column (matrix-)struct way dimensionless (vector-)struct. example, struct dimensions length(struct) == nrow(struct), instead length(matrix) == nrow(matrix) * ncol(matrix)---.e., \"height\" struct (number rows) length. Another big difference behaviors c: c always cause structs lose dimensions c can used concatinated multi-column structs, even mixes dimensionless dimensioned structs: struct arguments c dimensions, structs concatinated via call rbind, dimensionless vectors coerced 1-column matrices. course, (resulting) number columns must error occur! differences: structs can either dimensions (dim(struct) == NULL) two dimensions. Higher dimensional structs supported (yet). rowSums colSums coerce dimensionless struct column matrix. structs always throw error try index index value greater length/nrow struct. different atomic vectors, pad vector length index give---sometimes useful quirky behavior. structs two dimensions cartesian indexing argument. cartesian = TRUE, j arguments treated cartesian coordinates. (behavior can achieved base R matrices (structs) inputing matrix two columns.)","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/struct.html","id":"requirements","dir":"Reference","previous_headings":"","what":"Requirements","title":"struct — struct","text":"work, struct makes assumptions class. class must one slots vectors, length. struct's indexing method cause vectors indexed one. define new subclass struct, inherit validObject method assures elements dimension. Thus, writing validObject method (using setValidity) just worry specifically validity information slots, slots length.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/struct.html","id":"initialize","dir":"Reference","previous_headings":"","what":"Initialize","title":"struct — struct","text":"initialize method automatically makes slots length predefined structs. want make specialized initialize method, can still take advantage inherited method using callNextMethod beginning method.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/struct.html","id":"predefined-methods","dir":"Reference","previous_headings":"","what":"Predefined methods","title":"struct — struct","text":"main purpose struct virtual class defines many basic methods need manipulate subclass objects. importantly, indexing methods fully defined (mimic base-R atomic vector/matrix indexing), well basic \"structural\" methods like (col/row)names, dim, length, ncol, nrow, etc. addition: define > >=, < <= automatically defined. define .character subclass, show format methods automatically defined. , default arithmetic methods addition, subtraction, (scalar-integer) multiplication, negation (-x) defined. default addition behavior numeric (base::integer base::numeric) slot subclasses added together. Thus, struct1 + struct2 extract numeric/integer slot struct, add together create new struct result. -struct negate numeric fields, subtraction simply defined adding negation. Since scalar multiplication defined, two structs multiplied, struct can multiplied integer (numeric fields multiplied integer(s)). definitions work subclass, need create , specific, method!","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/struct.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"struct — struct","text":"","code":"setClass('mynewsubclass', contains = 'struct', slots = c(X= 'numeric', Y = 'numeric'))  test <- new('mynewsubclass', X = 1:10, Y = 10:1)  # all of these should work: test[1:5] #> mynewsubclass[ , ] #> [1] 1,10 2,9  3,8  4,7  5,6  rev(test)  == test #>  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE cbind(test, test) #> mynewsubclass #>       [,1] [,2] #>  [1,] 1,10 1,10 #>  [2,] 2,9  2,9  #>  [3,] 3,8  3,8  #>  [4,] 4,7  4,7  #>  [5,] 5,6  5,6  #>  [6,] 6,5  6,5  #>  [7,] 7,4  7,4  #>  [8,] 8,3  8,3  #>  [9,] 9,2  9,2  #> [10,] 10,1 10,1 c(test, test) #> mynewsubclass[ , ] #>  [1] 1,10 2,9  3,8  4,7  5,6  6,5  7,4  8,3  9,2  10,1 1,10 2,9  3,8  4,7  5,6  #> [16] 6,5  7,4  8,3  9,2  10,1 test * 3 #> mynewsubclass[ , ] #>  [1] 3,30  6,27  9,24  12,21 15,18 18,15 21,12 24,9  27,6  30,3  test - test #> mynewsubclass[ , ] #>  [1] 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tertianRepresentations.html","id":null,"dir":"Reference","previous_headings":"","what":"Tertian set representations — tertianRepresentations","title":"Tertian set representations — tertianRepresentations","text":"Tertian sets can read/wrote various ways.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tertianSet.html","id":null,"dir":"Reference","previous_headings":"","what":"Tertian set — tertianSet","title":"Tertian set — tertianSet","text":"tertianSet one humdrumR's types tonal data, representing Western tertian harmonies. tertianSet subclass diatonicSet (thence, struct).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tertianSet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tertian set — tertianSet","text":"","code":"tertianSet(...)  tset(   root = 0L,   signature = 0L,   alterations = 0L,   cardinality = 3L,   extension = NULL,   inversion = 0L )  is.tertianSet(x)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tertianSet.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tertian set — tertianSet","text":"structural addition, compared diatonicSet, Extensions slot. slot indicates tertian chord members active chord. seven possible chord members: root, third, fifth, seventh, ninth, eleventh, thirteenth. Every possible combination seven degrees represented single integer, corresponding 7-bit representation /offs seven degrees reverse order (13, 11, 9, 7, 5, 3, 1). example, integer 15 corresponds seventh chord: binary, 15 0001111. initial three zeros indicate 13th, 11th, 9th part harmony, four ones indicate root, third, fifth, seventh part harmony. Ultimately, adding removing chord degree harmony can achieved adding power two associated degree: Root: \\(\\pm 1\\) Third: \\(\\pm 2\\) Fifth: \\(\\pm 4\\) Seventh: \\(\\pm 8\\) Ninth: \\(\\pm 16\\) Eleventh: \\(\\pm 32\\) Thirteenth: \\(\\pm 64\\) tertianSet many specific methods defined reading/writing harmonic information.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/text.html","id":null,"dir":"Reference","previous_headings":"","what":"text — text","title":"text — text","text":"Transform humdrumR's syllabic form lyrics complete words, row contain either one word null data token.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/text.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"text — text","text":"","code":"text(silbe, nullTokens = TRUE, keepSilbe = FALSE, indices = FALSE)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/text.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"text — text","text":"nullTokens Boolean expression determines whether null tokens replace empty spaces syllables moved combine others make word. Default TRUE keepSilbe Boolean expression determines whether user wants save silbe format output case needed back translation later uses. Default FALSE indices Boolean expression determines whether linguistics version text printed. Default FALSE. data data transformed (character vector)","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/text.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"text — text","text":"transformed data","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/time.html","id":null,"dir":"Reference","previous_headings":"","what":"Time transformations — time","title":"Time transformations — time","text":"Time transformations","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/time.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Time transformations — time","text":"","code":"bpm2ms(bpm)  ms2bpm(ms)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalInterval.html","id":null,"dir":"Reference","previous_headings":"","what":"Representation of tonal pitch information — tonalInterval","title":"Representation of tonal pitch information — tonalInterval","text":"tonalInterval core tonal pitch representation humdrumR. tonalInterval abstract representation tonal pitch, can translated /standard \"concrete\" pitch representations: solfege, scientific pitch, semitones, frequencies, scale degrees, intervals, etc. part, users need interact tonalIntervals directly---rather, tonalIntervals work behind scene numerous humdrumR pitch functions. See pitchRepresentations tonalTransformations documentation details usage functionality Tonality humdrumR vignette detailed explanation theory specifics tonalIntervals.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalInterval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Representation of tonal pitch information — tonalInterval","text":"","code":"tonalInterval(...)  tint(   octave,   LO5th = 0L,   cent = numeric(length(octave)),   partition = FALSE,   Key = NULL,   roundContour = floor )  is.tonalInterval(x)  tonalInterval(...)  # S3 method for tonalInterval tonalInterval(x, ...)  # S3 method for logical tonalInterval(x, ...)  # S3 method for `NULL` tonalInterval(x, ...)  # S3 method for numeric tonalInterval(   x,   tonalHarmonic = 3,   centMargin = 10,   accidental.melodic = FALSE,   ... )  # S3 method for rational tonalInterval(x, tonalHarmonic = 3, accidental.melodic = FALSE, ...)  # S3 method for fraction tonalInterval(x, tonalHarmonic = 3)  # S3 method for integer tonalInterval(n, accidental.melodic = FALSE, ...)  # S3 method for character tonalInterval(str, Exclusive = NULL, ..., multiDispatch = FALSE)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalInterval.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Representation of tonal pitch information — tonalInterval","text":"tonalInterval S4 subclass humdrumR's virtual class struct, inherits lot useful \"vector-like\" behaviors/functionality. constructor function tint can used create tonalIntervals directly. three arguments corespond three slots: octave, LO5th (Fifth), cent. inputs coerced match length. , octave argument can left blank, case appropriate octave automatically computed place interval octave middle-C. default, .character method, thus (via struct) show method, tonalIntervals call kern(). Thus, return tonalInterval command line (call print one one) see kern pitch representation printed.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalInterval.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Representation of tonal pitch information — tonalInterval","text":"Octave integers representing octave offset. Fifth integers representing \"line--fifths\" value. Cent numeric values representing cents (1200th octave).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalInterval.html","id":"arithmetic","dir":"Reference","previous_headings":"","what":"Arithmetic","title":"Representation of tonal pitch information — tonalInterval","text":"Technically, tonalIntervals examples algebraic modules integers. means certain arithmetic operations defined tonalIntervals can called using standard arithmetic operators (+, -, etc.): Addition: tonalIntervals can added together, acting exactly expect (.e., \\(M3 + m3 = P5\\)). Subtraction: tonalIntervals can subtracted just added. Also, can negated single - operator (like -M3). Multiplication: tonalIntervals can multiplied together. However, scalar (integer) multiplication defined: thus, tonalIntervals can multiplied integers create new tonalIntervals: e.g., \\(M2 * 3L = A4\\). Division: natural inverse scale multiplication, Euclidean division defined tonalIntervals---.e., division /whole (integer) pieces, often leftover \"remainders\" (modulo). R, Euclidean division achieved %/% operator---/---, associated %% used remainder/modulo. Two tonalIntervals can divided produced integer; Conversely, tonalInterval can divided integer produce tonalInterval. Take note way humdrumR defines Euclidean division based tonal space---.e., line--fifths---frequency atonal-semitone space. example, augmented-fourth divided major-second 3L, diminished-fifth divided major-second 3L---d5 %/% M2 equals -3L remainder P8 (plus octave)! division algorithm works applying standard Euclidean division @Fifth slot (line--fifths tonal space), shifting @Octave value remainder match appropriate octave. definition useful properties specificinterval %% A1 = genericinterval interval %% d2 = enharmonicinterval. Since basic data types can parsed tonalInterval (see ), humdrumR attempt automatically coerce data tonalIntervals asked perform arithmetic. means arithmetic can applied one two arguments tonalInterval coercable atomic. instance, M3 + 2L interpret 2L two semitones add major-second major-third! clever dispatch system even ignore character strings recognized (see examples)! useful combined \"Predifined Intervals\" (like M3), described .","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalInterval.html","id":"relational-operators","dir":"Reference","previous_headings":"","what":"Relational Operators","title":"Representation of tonal pitch information — tonalInterval","text":"tonalIntervals can compared using standard relational operations---==, !=, >, >=, etc. Two tonalIntervals equal (according ==) slots (Octave, Fifth, Cent) exactly identical. Thus, enharmonic notes (like C# Db) equal. contrast, ordinal comparisons (e.g., >, <=) tonalIntervals based semitone (equal temperament) size, enharmonicity irrelevant. Thus, m3 >= A2 A2 >= m3 TRUE, even though m3 == A2 .","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalInterval.html","id":"predefined-intervals-","dir":"Reference","previous_headings":"","what":"Predefined Intervals:","title":"Representation of tonal pitch information — tonalInterval","text":"humdrumR automatically exports bunch tonalIntervals, named musical interval representation. Every generic interval 1 15 combined every interval quality dd (doubly diminished), d (diminished), m (minor), M (major), (augumented) AA (doubly augmented). Thus, loading humdrumR, can type things like M3 + M3 get A5. addition, variables unison (= P1 = tint(0, 0)),  pythagorean.comma (= d2 = tint(-19,12)), octave (tint(1, 0)) exported well.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalInterval.html","id":"parsing","dir":"Reference","previous_headings":"","what":"Parsing","title":"Representation of tonal pitch information — tonalInterval","text":"humdrumR includes easy--use powerful system parsing pitch information tonalInterval representation. Basic methods defined numeric values representing atonal pitch information: integer values interpreted semitones. Watch ! R, need append L number make explicit integer: example, tonalInterval(3L). numeric/double() rational() values interpreted frequency ratios, assuming Pythagorean tuning. example, value 2.0 interpreted octave (two one ratio.) However, useful tool humdrum data parsing pitch representations encoded character tokens. humdrumR regex/exclusive parsing system used interpret character strings tonalIntervals. includes character tokens pitch information embedded alongside information, like \"4.ee kern token. six regex-patterns tonalInterval known parse automatically: call tonalInterval (function uses tonalInterval parser) character string, regex-system automatically (attempt) interpret tokens pitch types ---conflict representations favored order presented table . matching exclusive interpretation (see table ) provided using Exclusive argument, choice overrides regex-dispatch. match, NA tonalInterval returned.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalInterval.html","id":"parsing-with-options","dir":"Reference","previous_headings":"","what":"Parsing with Options","title":"Representation of tonal pitch information — tonalInterval","text":"six tonal representations listed function common parsing interface.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalInterval.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Representation of tonal pitch information — tonalInterval","text":"","code":"M3 <- tint(   , 4L)  M2 <- tint(   , 2L) M9 <- tint(-1L, 2L)  M9 - M2  #> tonalInterval[ , ] #> Error in as(y, outclass) :  #>   no method or default for coercing “list” to “tonalInterval” #> humdrumR error in: #> \ttryCatch(withCallingHandlers({ #>   NULL #>   saveRDS(do.call(do.call, c(readRDS( #>     \"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), list(envir = .GlobalEnv, #>     quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\") #>   flush(stdout()) #>   flush(stderr()) #>   NULL #>   invisible() #> }, error = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, interrupt = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, callr_message = function(e) { #>   try(signalCondition(e)) #> }), error = function(e) { #>   NULL #>   try(stop(e)) #> }, interrupt = function(e) { #>   NULL #>   e #> }) #> \t -> tryCatchList(expr, classes, parentenv, handlers) #> \t -> tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), names[nh], #> parentenv, handlers[[nh]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> tryCatchList(expr, names[-nh], parentenv, handlers[-nh]) #> \t -> tryCatchOne(expr, names, parentenv, handlers[[1L]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> withCallingHandlers({ #>   NULL #>   saveRDS(do.call(do.call, c(readRDS( #>     \"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), list(envir = .GlobalEnv, #>     quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\") #>   flush(stdout()) #>   flush(stderr()) #>   NULL #>   invisible() #> }, error = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, interrupt = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, callr_message = function(e) { #>   try(signalCondition(e)) #> }) #> \t -> saveRDS(do.call(do.call, c(readRDS( #>   \"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), list(envir = .GlobalEnv, #>   quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\") #> \t -> do.call(do.call, c(readRDS(\"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), #> list(envir = .GlobalEnv, quote = TRUE)), envir = .GlobalEnv, quote = TRUE) #> \t -> <function(what, args, quote = FALSE, envir = parent.frame()) { #>   if (!is.list(args)) stop(\"second argument must be a list\") #>   if (quote) args <- lapply(args, enquote) #>   .Internal(do.call(what, args, envir)) #> }>(base::quote(<function(..., crayon_enabled, crayon_colors, pkgdown_internet) { #>   options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, #>     pkgdown.internet = pkgdown_internet) #>   pkgdown::build_site(...) #> }>), base::quote(<list: pkg = <pkgdown>, examples = TRUE, run_dont_run = FALSE, #>   seed = 1014, lazy = FALSE, ...>), envir = base::quote(<environment>), quote = base::quote( #>   TRUE)) #> \t -> <function(..., crayon_enabled, crayon_colors, pkgdown_internet) { #>   options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, #>     pkgdown.internet = pkgdown_internet) #>   pkgdown::build_site(...) #> }>(pkg = base::quote(<pkgdown>), examples = base::quote(TRUE), run_dont_run = base::quote( #>   FALSE), seed = base::quote(1014), lazy = base::quote(FALSE), override = base::quote( #>   <list: >), install = base::quote(FALSE), preview = base::quote(FALSE), #> new_process = base::quote(FALSE), devel = base::quote(FALSE), crayon_enabled = base::quote( #>   TRUE), crayon_colors = base::quote(256L), pkgdown_internet = base::quote(TRUE)) #> \t -> pkgdown::build_site(...) #> \t -> build_site_local(pkg = pkg, examples = examples, run_dont_run = run_dont_run, #>   seed = seed, lazy = lazy, override = override, preview = preview, devel = devel) #> \t -> build_reference(pkg, lazy = lazy, examples = examples, run_dont_run = run_dont_run, #>   seed = seed, override = override, preview = FALSE, devel = devel) #> \t -> purrr::map(topics, build_reference_topic, pkg = pkg, lazy = lazy, examples_env = examples_env, #>   run_dont_run = run_dont_run) #> \t -> .f(.x[[i]], ...) #> \t -> withCallingHandlers(data_reference_topic(topic, pkg, examples_env = examples_env, #>   run_dont_run = run_dont_run), error = function(err) { #>   msg <- c(paste0(\"Failed to parse Rd in \", topic$file_in), i = err$message) #>   abort(msg, parent = err) #> }) #> \t -> data_reference_topic(topic, pkg, examples_env = examples_env, run_dont_run = run_dont_run) #> \t -> run_examples(tags$tag_examples[[1]], env = if (is.null(examples_env) #> ) NULL else new.env(parent = examples_env), topic = tools::file_path_sans_ext( #>   topic$file_in), run_dont_run = run_dont_run) #> \t -> highlight_examples(code, topic, env = env) #> \t -> downlit::evaluate_and_highlight(code, fig_save = fig_save_topic, env = child_env( #>   env), output_handler = evaluate::new_output_handler(value = pkgdown_print)) #> \t -> evaluate::evaluate(code, child_env(env), new_device = TRUE, output_handler = output_handler) #> \t -> evaluate_call(expr, parsed$src[[i]], envir = envir, enclos = enclos, debug = debug, #> last = i == length(out), use_try = stop_on_error != 2L, keep_warning = keep_warning, #> keep_message = keep_message, output_handler = output_handler, include_timing = include_timing) #> \t -> handle(pv <- withCallingHandlers(withVisible(value_fun(ev$value, ev$visible)), #> warning = wHandler, error = eHandler, message = mHandler)) #> \t -> try(f, silent = TRUE) #> \t -> tryCatch(expr, error = function(e) { #>   call <- conditionCall(e) #>   if (!is.null(call)) { #>     if (identical(call[[1L]], quote(doTryCatch))) call <- sys.call(-4L) #>     dcall <- deparse(call, nlines = 1L) #>     prefix <- paste(\"Error in\", dcall, \": \") #>     LONG <- 75L #>     sm <- strsplit(conditionMessage(e), \"\\n\")[[1L]] #>     w <- 14L + nchar(dcall, type = \"w\") + nchar(sm[1L], type = \"w\") #>     if (is.na(w)) w <- 14L + nchar(dcall, type = \"b\") + nchar(sm[1L], type = \"b\") #>     if (w > LONG) prefix <- paste0(prefix, \"\\n  \") #>   } else prefix <- \"Error : \" #>   msg <- paste0(prefix, conditionMessage(e), \"\\n\") #>   .Internal(seterrmessage(msg[1L])) #>   if (!silent && isTRUE(getOption(\"show.error.messages\"))) { #>     cat(msg, file = outFile) #>     .Internal(printDeferredWarnings()) #>   } #>   invisible(structure(msg, class = \"try-error\", condition = e)) #> }) #> \t -> tryCatchList(expr, classes, parentenv, handlers) #> \t -> tryCatchOne(expr, names, parentenv, handlers[[1L]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> withCallingHandlers(withVisible(value_fun(ev$value, ev$visible)), warning = wHandler, #> error = eHandler, message = mHandler) #> \t -> withVisible(value_fun(ev$value, ev$visible)) #> \t -> value_fun(ev$value, ev$visible) #> \t -> pkgdown_print.default(ev$value, ev$visible) #> \t -> print(x) -> print.default(x) #> \t -> <stndrdGn>(<tnlIntrv>) #> \t -> <stndrdGn>(<tnlIntrv>) #> \t -> print(ifelse(is.na(object), \"NA\", as.character(object)), quote = FALSE) #> \t -> ifelse(is.na(object), \"NA\", as.character(object)) #> \t -> as.character(object) #> \t -> as.character(object) #> \t -> .local(x, ...) #> \t -> kern(x) -> pitchArgCheck(c(args, x = x, complex = complex, Key = Key, directed = directed, #>   ... = ...), \"kern\") #> \t -> .names(args) #> \t -> c(args, x = x, complex = complex, Key = Key, directed = directed, ... = ...) #> \t -> c(args, x = x, complex = complex, Key = Key, directed = directed, ... = ...) #> \t -> FUN(X[[i]], ...) #> \t #> Error: You can't concatinate a tonalInterval struct object with objects of classes try-error. # = octave M9 - 2L #> tonalInterval[ , ] #> Error in as(y, outclass) :  #>   no method or default for coercing “list” to “tonalInterval” #> humdrumR error in: #> \ttryCatch(withCallingHandlers({ #>   NULL #>   saveRDS(do.call(do.call, c(readRDS( #>     \"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), list(envir = .GlobalEnv, #>     quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\") #>   flush(stdout()) #>   flush(stderr()) #>   NULL #>   invisible() #> }, error = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, interrupt = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, callr_message = function(e) { #>   try(signalCondition(e)) #> }), error = function(e) { #>   NULL #>   try(stop(e)) #> }, interrupt = function(e) { #>   NULL #>   e #> }) #> \t -> tryCatchList(expr, classes, parentenv, handlers) #> \t -> tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), names[nh], #> parentenv, handlers[[nh]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> tryCatchList(expr, names[-nh], parentenv, handlers[-nh]) #> \t -> tryCatchOne(expr, names, parentenv, handlers[[1L]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> withCallingHandlers({ #>   NULL #>   saveRDS(do.call(do.call, c(readRDS( #>     \"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), list(envir = .GlobalEnv, #>     quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\") #>   flush(stdout()) #>   flush(stderr()) #>   NULL #>   invisible() #> }, error = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, interrupt = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, callr_message = function(e) { #>   try(signalCondition(e)) #> }) #> \t -> saveRDS(do.call(do.call, c(readRDS( #>   \"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), list(envir = .GlobalEnv, #>   quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\") #> \t -> do.call(do.call, c(readRDS(\"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), #> list(envir = .GlobalEnv, quote = TRUE)), envir = .GlobalEnv, quote = TRUE) #> \t -> <function(what, args, quote = FALSE, envir = parent.frame()) { #>   if (!is.list(args)) stop(\"second argument must be a list\") #>   if (quote) args <- lapply(args, enquote) #>   .Internal(do.call(what, args, envir)) #> }>(base::quote(<function(..., crayon_enabled, crayon_colors, pkgdown_internet) { #>   options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, #>     pkgdown.internet = pkgdown_internet) #>   pkgdown::build_site(...) #> }>), base::quote(<list: pkg = <pkgdown>, examples = TRUE, run_dont_run = FALSE, #>   seed = 1014, lazy = FALSE, ...>), envir = base::quote(<environment>), quote = base::quote( #>   TRUE)) #> \t -> <function(..., crayon_enabled, crayon_colors, pkgdown_internet) { #>   options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, #>     pkgdown.internet = pkgdown_internet) #>   pkgdown::build_site(...) #> }>(pkg = base::quote(<pkgdown>), examples = base::quote(TRUE), run_dont_run = base::quote( #>   FALSE), seed = base::quote(1014), lazy = base::quote(FALSE), override = base::quote( #>   <list: >), install = base::quote(FALSE), preview = base::quote(FALSE), #> new_process = base::quote(FALSE), devel = base::quote(FALSE), crayon_enabled = base::quote( #>   TRUE), crayon_colors = base::quote(256L), pkgdown_internet = base::quote(TRUE)) #> \t -> pkgdown::build_site(...) #> \t -> build_site_local(pkg = pkg, examples = examples, run_dont_run = run_dont_run, #>   seed = seed, lazy = lazy, override = override, preview = preview, devel = devel) #> \t -> build_reference(pkg, lazy = lazy, examples = examples, run_dont_run = run_dont_run, #>   seed = seed, override = override, preview = FALSE, devel = devel) #> \t -> purrr::map(topics, build_reference_topic, pkg = pkg, lazy = lazy, examples_env = examples_env, #>   run_dont_run = run_dont_run) #> \t -> .f(.x[[i]], ...) #> \t -> withCallingHandlers(data_reference_topic(topic, pkg, examples_env = examples_env, #>   run_dont_run = run_dont_run), error = function(err) { #>   msg <- c(paste0(\"Failed to parse Rd in \", topic$file_in), i = err$message) #>   abort(msg, parent = err) #> }) #> \t -> data_reference_topic(topic, pkg, examples_env = examples_env, run_dont_run = run_dont_run) #> \t -> run_examples(tags$tag_examples[[1]], env = if (is.null(examples_env) #> ) NULL else new.env(parent = examples_env), topic = tools::file_path_sans_ext( #>   topic$file_in), run_dont_run = run_dont_run) #> \t -> highlight_examples(code, topic, env = env) #> \t -> downlit::evaluate_and_highlight(code, fig_save = fig_save_topic, env = child_env( #>   env), output_handler = evaluate::new_output_handler(value = pkgdown_print)) #> \t -> evaluate::evaluate(code, child_env(env), new_device = TRUE, output_handler = output_handler) #> \t -> evaluate_call(expr, parsed$src[[i]], envir = envir, enclos = enclos, debug = debug, #> last = i == length(out), use_try = stop_on_error != 2L, keep_warning = keep_warning, #> keep_message = keep_message, output_handler = output_handler, include_timing = include_timing) #> \t -> handle(pv <- withCallingHandlers(withVisible(value_fun(ev$value, ev$visible)), #> warning = wHandler, error = eHandler, message = mHandler)) #> \t -> try(f, silent = TRUE) #> \t -> tryCatch(expr, error = function(e) { #>   call <- conditionCall(e) #>   if (!is.null(call)) { #>     if (identical(call[[1L]], quote(doTryCatch))) call <- sys.call(-4L) #>     dcall <- deparse(call, nlines = 1L) #>     prefix <- paste(\"Error in\", dcall, \": \") #>     LONG <- 75L #>     sm <- strsplit(conditionMessage(e), \"\\n\")[[1L]] #>     w <- 14L + nchar(dcall, type = \"w\") + nchar(sm[1L], type = \"w\") #>     if (is.na(w)) w <- 14L + nchar(dcall, type = \"b\") + nchar(sm[1L], type = \"b\") #>     if (w > LONG) prefix <- paste0(prefix, \"\\n  \") #>   } else prefix <- \"Error : \" #>   msg <- paste0(prefix, conditionMessage(e), \"\\n\") #>   .Internal(seterrmessage(msg[1L])) #>   if (!silent && isTRUE(getOption(\"show.error.messages\"))) { #>     cat(msg, file = outFile) #>     .Internal(printDeferredWarnings()) #>   } #>   invisible(structure(msg, class = \"try-error\", condition = e)) #> }) #> \t -> tryCatchList(expr, classes, parentenv, handlers) #> \t -> tryCatchOne(expr, names, parentenv, handlers[[1L]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> withCallingHandlers(withVisible(value_fun(ev$value, ev$visible)), warning = wHandler, #> error = eHandler, message = mHandler) #> \t -> withVisible(value_fun(ev$value, ev$visible)) #> \t -> value_fun(ev$value, ev$visible) #> \t -> pkgdown_print.default(ev$value, ev$visible) #> \t -> print(x) -> print.default(x) #> \t -> <stndrdGn>(<tnlIntrv>) #> \t -> <stndrdGn>(<tnlIntrv>) #> \t -> print(ifelse(is.na(object), \"NA\", as.character(object)), quote = FALSE) #> \t -> ifelse(is.na(object), \"NA\", as.character(object)) #> \t -> as.character(object) #> \t -> as.character(object) #> \t -> .local(x, ...) #> \t -> kern(x) -> pitchArgCheck(c(args, x = x, complex = complex, Key = Key, directed = directed, #>   ... = ...), \"kern\") #> \t -> .names(args) #> \t -> c(args, x = x, complex = complex, Key = Key, directed = directed, ... = ...) #> \t -> c(args, x = x, complex = complex, Key = Key, directed = directed, ... = ...) #> \t -> FUN(X[[i]], ...) #> \t #> Error: You can't concatinate a tonalInterval struct object with objects of classes try-error. # = octave  M3 %/% M2  #> [1] 2 # = 2  ###  cMajor <- sort(tint( , -1:5)) #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used eMajor <- cMajor + M3 eMajor + 2L  #> tonalInterval[ , ] #> Error in as(y, outclass) :  #>   no method or default for coercing “list” to “tonalInterval” #> humdrumR error in: #> \ttryCatch(withCallingHandlers({ #>   NULL #>   saveRDS(do.call(do.call, c(readRDS( #>     \"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), list(envir = .GlobalEnv, #>     quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\") #>   flush(stdout()) #>   flush(stderr()) #>   NULL #>   invisible() #> }, error = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, interrupt = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, callr_message = function(e) { #>   try(signalCondition(e)) #> }), error = function(e) { #>   NULL #>   try(stop(e)) #> }, interrupt = function(e) { #>   NULL #>   e #> }) #> \t -> tryCatchList(expr, classes, parentenv, handlers) #> \t -> tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), names[nh], #> parentenv, handlers[[nh]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> tryCatchList(expr, names[-nh], parentenv, handlers[-nh]) #> \t -> tryCatchOne(expr, names, parentenv, handlers[[1L]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> withCallingHandlers({ #>   NULL #>   saveRDS(do.call(do.call, c(readRDS( #>     \"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), list(envir = .GlobalEnv, #>     quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\") #>   flush(stdout()) #>   flush(stderr()) #>   NULL #>   invisible() #> }, error = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, interrupt = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, callr_message = function(e) { #>   try(signalCondition(e)) #> }) #> \t -> saveRDS(do.call(do.call, c(readRDS( #>   \"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), list(envir = .GlobalEnv, #>   quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\") #> \t -> do.call(do.call, c(readRDS(\"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), #> list(envir = .GlobalEnv, quote = TRUE)), envir = .GlobalEnv, quote = TRUE) #> \t -> <function(what, args, quote = FALSE, envir = parent.frame()) { #>   if (!is.list(args)) stop(\"second argument must be a list\") #>   if (quote) args <- lapply(args, enquote) #>   .Internal(do.call(what, args, envir)) #> }>(base::quote(<function(..., crayon_enabled, crayon_colors, pkgdown_internet) { #>   options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, #>     pkgdown.internet = pkgdown_internet) #>   pkgdown::build_site(...) #> }>), base::quote(<list: pkg = <pkgdown>, examples = TRUE, run_dont_run = FALSE, #>   seed = 1014, lazy = FALSE, ...>), envir = base::quote(<environment>), quote = base::quote( #>   TRUE)) #> \t -> <function(..., crayon_enabled, crayon_colors, pkgdown_internet) { #>   options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, #>     pkgdown.internet = pkgdown_internet) #>   pkgdown::build_site(...) #> }>(pkg = base::quote(<pkgdown>), examples = base::quote(TRUE), run_dont_run = base::quote( #>   FALSE), seed = base::quote(1014), lazy = base::quote(FALSE), override = base::quote( #>   <list: >), install = base::quote(FALSE), preview = base::quote(FALSE), #> new_process = base::quote(FALSE), devel = base::quote(FALSE), crayon_enabled = base::quote( #>   TRUE), crayon_colors = base::quote(256L), pkgdown_internet = base::quote(TRUE)) #> \t -> pkgdown::build_site(...) #> \t -> build_site_local(pkg = pkg, examples = examples, run_dont_run = run_dont_run, #>   seed = seed, lazy = lazy, override = override, preview = preview, devel = devel) #> \t -> build_reference(pkg, lazy = lazy, examples = examples, run_dont_run = run_dont_run, #>   seed = seed, override = override, preview = FALSE, devel = devel) #> \t -> purrr::map(topics, build_reference_topic, pkg = pkg, lazy = lazy, examples_env = examples_env, #>   run_dont_run = run_dont_run) #> \t -> .f(.x[[i]], ...) #> \t -> withCallingHandlers(data_reference_topic(topic, pkg, examples_env = examples_env, #>   run_dont_run = run_dont_run), error = function(err) { #>   msg <- c(paste0(\"Failed to parse Rd in \", topic$file_in), i = err$message) #>   abort(msg, parent = err) #> }) #> \t -> data_reference_topic(topic, pkg, examples_env = examples_env, run_dont_run = run_dont_run) #> \t -> run_examples(tags$tag_examples[[1]], env = if (is.null(examples_env) #> ) NULL else new.env(parent = examples_env), topic = tools::file_path_sans_ext( #>   topic$file_in), run_dont_run = run_dont_run) #> \t -> highlight_examples(code, topic, env = env) #> \t -> downlit::evaluate_and_highlight(code, fig_save = fig_save_topic, env = child_env( #>   env), output_handler = evaluate::new_output_handler(value = pkgdown_print)) #> \t -> evaluate::evaluate(code, child_env(env), new_device = TRUE, output_handler = output_handler) #> \t -> evaluate_call(expr, parsed$src[[i]], envir = envir, enclos = enclos, debug = debug, #> last = i == length(out), use_try = stop_on_error != 2L, keep_warning = keep_warning, #> keep_message = keep_message, output_handler = output_handler, include_timing = include_timing) #> \t -> handle(pv <- withCallingHandlers(withVisible(value_fun(ev$value, ev$visible)), #> warning = wHandler, error = eHandler, message = mHandler)) #> \t -> try(f, silent = TRUE) #> \t -> tryCatch(expr, error = function(e) { #>   call <- conditionCall(e) #>   if (!is.null(call)) { #>     if (identical(call[[1L]], quote(doTryCatch))) call <- sys.call(-4L) #>     dcall <- deparse(call, nlines = 1L) #>     prefix <- paste(\"Error in\", dcall, \": \") #>     LONG <- 75L #>     sm <- strsplit(conditionMessage(e), \"\\n\")[[1L]] #>     w <- 14L + nchar(dcall, type = \"w\") + nchar(sm[1L], type = \"w\") #>     if (is.na(w)) w <- 14L + nchar(dcall, type = \"b\") + nchar(sm[1L], type = \"b\") #>     if (w > LONG) prefix <- paste0(prefix, \"\\n  \") #>   } else prefix <- \"Error : \" #>   msg <- paste0(prefix, conditionMessage(e), \"\\n\") #>   .Internal(seterrmessage(msg[1L])) #>   if (!silent && isTRUE(getOption(\"show.error.messages\"))) { #>     cat(msg, file = outFile) #>     .Internal(printDeferredWarnings()) #>   } #>   invisible(structure(msg, class = \"try-error\", condition = e)) #> }) #> \t -> tryCatchList(expr, classes, parentenv, handlers) #> \t -> tryCatchOne(expr, names, parentenv, handlers[[1L]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> withCallingHandlers(withVisible(value_fun(ev$value, ev$visible)), warning = wHandler, #> error = eHandler, message = mHandler) #> \t -> withVisible(value_fun(ev$value, ev$visible)) #> \t -> value_fun(ev$value, ev$visible) #> \t -> pkgdown_print.default(ev$value, ev$visible) #> \t -> print(x) -> print.default(x) #> \t -> <stndrdGn>(<tnlIntrv>) #> \t -> <stndrdGn>(<tnlIntrv>) #> \t -> print(ifelse(is.na(object), \"NA\", as.character(object)), quote = FALSE) #> \t -> ifelse(is.na(object), \"NA\", as.character(object)) #> \t -> as.character(object) #> \t -> as.character(object) #> \t -> .local(x, ...) #> \t -> kern(x) -> pitchArgCheck(c(args, x = x, complex = complex, Key = Key, directed = directed, #>   ... = ...), \"kern\") #> \t -> .names(args) #> \t -> c(args, x = x, complex = complex, Key = Key, directed = directed, ... = ...) #> \t -> c(args, x = x, complex = complex, Key = Key, directed = directed, ... = ...) #> \t -> FUN(X[[i]], ...) #> \t #> Error: You can't concatinate a tonalInterval struct object with objects of classes try-error. # f# g# a# b cc# dd# ee#  eMajor[4:5] - octave  #> tonalInterval[ , ] #> Error in as(y, outclass) :  #>   no method or default for coercing “list” to “tonalInterval” #> humdrumR error in: #> \ttryCatch(withCallingHandlers({ #>   NULL #>   saveRDS(do.call(do.call, c(readRDS( #>     \"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), list(envir = .GlobalEnv, #>     quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\") #>   flush(stdout()) #>   flush(stderr()) #>   NULL #>   invisible() #> }, error = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, interrupt = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, callr_message = function(e) { #>   try(signalCondition(e)) #> }), error = function(e) { #>   NULL #>   try(stop(e)) #> }, interrupt = function(e) { #>   NULL #>   e #> }) #> \t -> tryCatchList(expr, classes, parentenv, handlers) #> \t -> tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), names[nh], #> parentenv, handlers[[nh]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> tryCatchList(expr, names[-nh], parentenv, handlers[-nh]) #> \t -> tryCatchOne(expr, names, parentenv, handlers[[1L]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> withCallingHandlers({ #>   NULL #>   saveRDS(do.call(do.call, c(readRDS( #>     \"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), list(envir = .GlobalEnv, #>     quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\") #>   flush(stdout()) #>   flush(stderr()) #>   NULL #>   invisible() #> }, error = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, interrupt = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, callr_message = function(e) { #>   try(signalCondition(e)) #> }) #> \t -> saveRDS(do.call(do.call, c(readRDS( #>   \"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), list(envir = .GlobalEnv, #>   quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\") #> \t -> do.call(do.call, c(readRDS(\"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), #> list(envir = .GlobalEnv, quote = TRUE)), envir = .GlobalEnv, quote = TRUE) #> \t -> <function(what, args, quote = FALSE, envir = parent.frame()) { #>   if (!is.list(args)) stop(\"second argument must be a list\") #>   if (quote) args <- lapply(args, enquote) #>   .Internal(do.call(what, args, envir)) #> }>(base::quote(<function(..., crayon_enabled, crayon_colors, pkgdown_internet) { #>   options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, #>     pkgdown.internet = pkgdown_internet) #>   pkgdown::build_site(...) #> }>), base::quote(<list: pkg = <pkgdown>, examples = TRUE, run_dont_run = FALSE, #>   seed = 1014, lazy = FALSE, ...>), envir = base::quote(<environment>), quote = base::quote( #>   TRUE)) #> \t -> <function(..., crayon_enabled, crayon_colors, pkgdown_internet) { #>   options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, #>     pkgdown.internet = pkgdown_internet) #>   pkgdown::build_site(...) #> }>(pkg = base::quote(<pkgdown>), examples = base::quote(TRUE), run_dont_run = base::quote( #>   FALSE), seed = base::quote(1014), lazy = base::quote(FALSE), override = base::quote( #>   <list: >), install = base::quote(FALSE), preview = base::quote(FALSE), #> new_process = base::quote(FALSE), devel = base::quote(FALSE), crayon_enabled = base::quote( #>   TRUE), crayon_colors = base::quote(256L), pkgdown_internet = base::quote(TRUE)) #> \t -> pkgdown::build_site(...) #> \t -> build_site_local(pkg = pkg, examples = examples, run_dont_run = run_dont_run, #>   seed = seed, lazy = lazy, override = override, preview = preview, devel = devel) #> \t -> build_reference(pkg, lazy = lazy, examples = examples, run_dont_run = run_dont_run, #>   seed = seed, override = override, preview = FALSE, devel = devel) #> \t -> purrr::map(topics, build_reference_topic, pkg = pkg, lazy = lazy, examples_env = examples_env, #>   run_dont_run = run_dont_run) #> \t -> .f(.x[[i]], ...) #> \t -> withCallingHandlers(data_reference_topic(topic, pkg, examples_env = examples_env, #>   run_dont_run = run_dont_run), error = function(err) { #>   msg <- c(paste0(\"Failed to parse Rd in \", topic$file_in), i = err$message) #>   abort(msg, parent = err) #> }) #> \t -> data_reference_topic(topic, pkg, examples_env = examples_env, run_dont_run = run_dont_run) #> \t -> run_examples(tags$tag_examples[[1]], env = if (is.null(examples_env) #> ) NULL else new.env(parent = examples_env), topic = tools::file_path_sans_ext( #>   topic$file_in), run_dont_run = run_dont_run) #> \t -> highlight_examples(code, topic, env = env) #> \t -> downlit::evaluate_and_highlight(code, fig_save = fig_save_topic, env = child_env( #>   env), output_handler = evaluate::new_output_handler(value = pkgdown_print)) #> \t -> evaluate::evaluate(code, child_env(env), new_device = TRUE, output_handler = output_handler) #> \t -> evaluate_call(expr, parsed$src[[i]], envir = envir, enclos = enclos, debug = debug, #> last = i == length(out), use_try = stop_on_error != 2L, keep_warning = keep_warning, #> keep_message = keep_message, output_handler = output_handler, include_timing = include_timing) #> \t -> handle(pv <- withCallingHandlers(withVisible(value_fun(ev$value, ev$visible)), #> warning = wHandler, error = eHandler, message = mHandler)) #> \t -> try(f, silent = TRUE) #> \t -> tryCatch(expr, error = function(e) { #>   call <- conditionCall(e) #>   if (!is.null(call)) { #>     if (identical(call[[1L]], quote(doTryCatch))) call <- sys.call(-4L) #>     dcall <- deparse(call, nlines = 1L) #>     prefix <- paste(\"Error in\", dcall, \": \") #>     LONG <- 75L #>     sm <- strsplit(conditionMessage(e), \"\\n\")[[1L]] #>     w <- 14L + nchar(dcall, type = \"w\") + nchar(sm[1L], type = \"w\") #>     if (is.na(w)) w <- 14L + nchar(dcall, type = \"b\") + nchar(sm[1L], type = \"b\") #>     if (w > LONG) prefix <- paste0(prefix, \"\\n  \") #>   } else prefix <- \"Error : \" #>   msg <- paste0(prefix, conditionMessage(e), \"\\n\") #>   .Internal(seterrmessage(msg[1L])) #>   if (!silent && isTRUE(getOption(\"show.error.messages\"))) { #>     cat(msg, file = outFile) #>     .Internal(printDeferredWarnings()) #>   } #>   invisible(structure(msg, class = \"try-error\", condition = e)) #> }) #> \t -> tryCatchList(expr, classes, parentenv, handlers) #> \t -> tryCatchOne(expr, names, parentenv, handlers[[1L]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> withCallingHandlers(withVisible(value_fun(ev$value, ev$visible)), warning = wHandler, #> error = eHandler, message = mHandler) #> \t -> withVisible(value_fun(ev$value, ev$visible)) #> \t -> value_fun(ev$value, ev$visible) #> \t -> pkgdown_print.default(ev$value, ev$visible) #> \t -> print(x) -> print.default(x) #> \t -> <stndrdGn>(<tnlIntrv>) #> \t -> <stndrdGn>(<tnlIntrv>) #> \t -> print(ifelse(is.na(object), \"NA\", as.character(object)), quote = FALSE) #> \t -> ifelse(is.na(object), \"NA\", as.character(object)) #> \t -> as.character(object) #> \t -> as.character(object) #> \t -> .local(x, ...) #> \t -> kern(x) -> pitchArgCheck(c(args, x = x, complex = complex, Key = Key, directed = directed, #>   ... = ...), \"kern\") #> \t -> .names(args) #> \t -> c(args, x = x, complex = complex, Key = Key, directed = directed, ... = ...) #> \t -> c(args, x = x, complex = complex, Key = Key, directed = directed, ... = ...) #> \t -> FUN(X[[i]], ...) #> \t #> Error: You can't concatinate a tonalInterval struct object with objects of classes try-error. # = A B  \"4.ee\" + P5  #> Error in as(y, outclass) :  #>   no method or default for coercing “list” to “tonalInterval” #> humdrumR error in: #> \ttryCatch(withCallingHandlers({ #>   NULL #>   saveRDS(do.call(do.call, c(readRDS( #>     \"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), list(envir = .GlobalEnv, #>     quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\") #>   flush(stdout()) #>   flush(stderr()) #>   NULL #>   invisible() #> }, error = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, interrupt = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, callr_message = function(e) { #>   try(signalCondition(e)) #> }), error = function(e) { #>   NULL #>   try(stop(e)) #> }, interrupt = function(e) { #>   NULL #>   e #> }) #> \t -> tryCatchList(expr, classes, parentenv, handlers) #> \t -> tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), names[nh], #> parentenv, handlers[[nh]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> tryCatchList(expr, names[-nh], parentenv, handlers[-nh]) #> \t -> tryCatchOne(expr, names, parentenv, handlers[[1L]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> withCallingHandlers({ #>   NULL #>   saveRDS(do.call(do.call, c(readRDS( #>     \"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), list(envir = .GlobalEnv, #>     quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\") #>   flush(stdout()) #>   flush(stderr()) #>   NULL #>   invisible() #> }, error = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, interrupt = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, callr_message = function(e) { #>   try(signalCondition(e)) #> }) #> \t -> saveRDS(do.call(do.call, c(readRDS( #>   \"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), list(envir = .GlobalEnv, #>   quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\") #> \t -> do.call(do.call, c(readRDS(\"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), #> list(envir = .GlobalEnv, quote = TRUE)), envir = .GlobalEnv, quote = TRUE) #> \t -> <function(what, args, quote = FALSE, envir = parent.frame()) { #>   if (!is.list(args)) stop(\"second argument must be a list\") #>   if (quote) args <- lapply(args, enquote) #>   .Internal(do.call(what, args, envir)) #> }>(base::quote(<function(..., crayon_enabled, crayon_colors, pkgdown_internet) { #>   options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, #>     pkgdown.internet = pkgdown_internet) #>   pkgdown::build_site(...) #> }>), base::quote(<list: pkg = <pkgdown>, examples = TRUE, run_dont_run = FALSE, #>   seed = 1014, lazy = FALSE, ...>), envir = base::quote(<environment>), quote = base::quote( #>   TRUE)) #> \t -> <function(..., crayon_enabled, crayon_colors, pkgdown_internet) { #>   options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, #>     pkgdown.internet = pkgdown_internet) #>   pkgdown::build_site(...) #> }>(pkg = base::quote(<pkgdown>), examples = base::quote(TRUE), run_dont_run = base::quote( #>   FALSE), seed = base::quote(1014), lazy = base::quote(FALSE), override = base::quote( #>   <list: >), install = base::quote(FALSE), preview = base::quote(FALSE), #> new_process = base::quote(FALSE), devel = base::quote(FALSE), crayon_enabled = base::quote( #>   TRUE), crayon_colors = base::quote(256L), pkgdown_internet = base::quote(TRUE)) #> \t -> pkgdown::build_site(...) #> \t -> build_site_local(pkg = pkg, examples = examples, run_dont_run = run_dont_run, #>   seed = seed, lazy = lazy, override = override, preview = preview, devel = devel) #> \t -> build_reference(pkg, lazy = lazy, examples = examples, run_dont_run = run_dont_run, #>   seed = seed, override = override, preview = FALSE, devel = devel) #> \t -> purrr::map(topics, build_reference_topic, pkg = pkg, lazy = lazy, examples_env = examples_env, #>   run_dont_run = run_dont_run) #> \t -> .f(.x[[i]], ...) #> \t -> withCallingHandlers(data_reference_topic(topic, pkg, examples_env = examples_env, #>   run_dont_run = run_dont_run), error = function(err) { #>   msg <- c(paste0(\"Failed to parse Rd in \", topic$file_in), i = err$message) #>   abort(msg, parent = err) #> }) #> \t -> data_reference_topic(topic, pkg, examples_env = examples_env, run_dont_run = run_dont_run) #> \t -> run_examples(tags$tag_examples[[1]], env = if (is.null(examples_env) #> ) NULL else new.env(parent = examples_env), topic = tools::file_path_sans_ext( #>   topic$file_in), run_dont_run = run_dont_run) #> \t -> highlight_examples(code, topic, env = env) #> \t -> downlit::evaluate_and_highlight(code, fig_save = fig_save_topic, env = child_env( #>   env), output_handler = evaluate::new_output_handler(value = pkgdown_print)) #> \t -> evaluate::evaluate(code, child_env(env), new_device = TRUE, output_handler = output_handler) #> \t -> evaluate_call(expr, parsed$src[[i]], envir = envir, enclos = enclos, debug = debug, #> last = i == length(out), use_try = stop_on_error != 2L, keep_warning = keep_warning, #> keep_message = keep_message, output_handler = output_handler, include_timing = include_timing) #> \t -> timing_fn(handle(ev <- withCallingHandlers(withVisible(eval(expr, envir, enclos)), #> warning = wHandler, error = eHandler, message = mHandler))) #> \t -> handle(ev <- withCallingHandlers(withVisible(eval(expr, envir, enclos)), #> warning = wHandler, error = eHandler, message = mHandler)) #> \t -> try(f, silent = TRUE) #> \t -> tryCatch(expr, error = function(e) { #>   call <- conditionCall(e) #>   if (!is.null(call)) { #>     if (identical(call[[1L]], quote(doTryCatch))) call <- sys.call(-4L) #>     dcall <- deparse(call, nlines = 1L) #>     prefix <- paste(\"Error in\", dcall, \": \") #>     LONG <- 75L #>     sm <- strsplit(conditionMessage(e), \"\\n\")[[1L]] #>     w <- 14L + nchar(dcall, type = \"w\") + nchar(sm[1L], type = \"w\") #>     if (is.na(w)) w <- 14L + nchar(dcall, type = \"b\") + nchar(sm[1L], type = \"b\") #>     if (w > LONG) prefix <- paste0(prefix, \"\\n  \") #>   } else prefix <- \"Error : \" #>   msg <- paste0(prefix, conditionMessage(e), \"\\n\") #>   .Internal(seterrmessage(msg[1L])) #>   if (!silent && isTRUE(getOption(\"show.error.messages\"))) { #>     cat(msg, file = outFile) #>     .Internal(printDeferredWarnings()) #>   } #>   invisible(structure(msg, class = \"try-error\", condition = e)) #> }) #> \t -> tryCatchList(expr, classes, parentenv, handlers) #> \t -> tryCatchOne(expr, names, parentenv, handlers[[1L]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> withCallingHandlers(withVisible(eval(expr, envir, enclos)), warning = wHandler, #> error = eHandler, message = mHandler) #> \t -> withVisible(eval(expr, envir, enclos)) #> \t -> eval(expr, envir, enclos) #> \t -> eval(expr, envir, enclos) #> \t -> \"4.ee\" + P5 -> \"4.ee\" + P5 -> rePlace(reParse(e3, dispatch, c(\"kern\", \"pitch\", \"solfa\", \"interval\", \"degree\")), #> dispatch) #> \t -> reParse(e3, dispatch, c(\"kern\", \"pitch\", \"solfa\", \"interval\", \"degree\")) #> \t -> unlist(Map(function(res, excl) { #>   reParser <- match.fun(if (excl %in% reParsers) excl else reParsers[1]) #>   reParser(res, inPlace = FALSE) #> }, result, exclusives)) #> \t -> Map(function(res, excl) { #>   reParser <- match.fun(if (excl %in% reParsers) excl else reParsers[1]) #>   reParser(res, inPlace = FALSE) #> }, result, exclusives) #> \t -> mapply(FUN = f, ..., SIMPLIFY = FALSE) #> \t -> <function(res, excl) { #>   reParser <- match.fun(if (excl %in% reParsers) excl else reParsers[1]) #>   reParser(res, inPlace = FALSE) #> }>(dots[[1L]][[1L]], dots[[2L]][[1L]]) #> \t -> reParser(res, inPlace = FALSE) #> \t -> pitchArgCheck(c(args, x = x, complex = complex, Key = Key, directed = directed, #>   ... = ...), \"kern\") #> \t -> .names(args) #> \t -> c(args, x = x, complex = complex, Key = Key, directed = directed, ... = ...) #> \t -> c(args, x = x, complex = complex, Key = Key, directed = directed, ... = ...) #> \t -> FUN(X[[i]], ...) #> \t #> Error: You can't concatinate a tonalInterval struct object with objects of classes try-error. # = \"4.bb\""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalIntervalS4.html","id":null,"dir":"Reference","previous_headings":"","what":"Representation of tonal pitch information — tonalIntervalS4","title":"Representation of tonal pitch information — tonalIntervalS4","text":"tonalInterval core tonal pitch representation humdrumR. tonalInterval abstract representation tonal pitch, can translated /standard \"concrete\" pitch representations: solfege, scientific pitch, semitones, frequencies, scale degrees, intervals, etc. part, users need interact tonalIntervals directly---rather, tonalIntervals work behind scene numerous humdrumR pitch functions. See pitchRepresentations tonalTransformations documentation details usage functionality Tonality humdrumR vignette detailed explanation theory specifics tonalIntervals.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalIntervalS4.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Representation of tonal pitch information — tonalIntervalS4","text":"","code":"tint(   octave,   LO5th = 0L,   cent = numeric(length(octave)),   partition = FALSE,   Key = NULL,   octave.round = floor )  is.tonalInterval(x)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalIntervalS4.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Representation of tonal pitch information — tonalIntervalS4","text":"tonalInterval S4 subclass humdrumR's virtual class struct, inherits lot useful \"vector-like\" behaviors/functionality. constructor function tint can used create tonalIntervals directly. three arguments corespond three slots: octave, LO5th (Fifth), cent. inputs coerced match length. , octave argument can left blank, case appropriate octave automatically computed place interval octave . default, .character method, thus (via struct) show method, tonalIntervals call kern(). Thus, return tonalInterval command line (call print one one) see kern pitch representation printed.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalIntervalS4.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Representation of tonal pitch information — tonalIntervalS4","text":"Octave integers representing octave offset. Fifth integers representing \"line--fifths\" value. Cent numeric values representing cents (1200th octave).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalIntervalS4.html","id":"arithmetic","dir":"Reference","previous_headings":"","what":"Arithmetic","title":"Representation of tonal pitch information — tonalIntervalS4","text":"Technically, tonalIntervals examples algebraic modules integers. means certain arithmetic operations defined tonalIntervals can called using standard arithmetic operators (+, -, etc.): Addition: tonalIntervals can added together, acting exactly expect (.e., \\(M3 + m3 = P5\\)). Subtraction: tonalIntervals can subtracted just added. Also, can negated single - operator (like -M3). Multiplication: tonalIntervals can multiplied together. However, scalar (integer) multiplication defined: thus, tonalIntervals can multiplied integers create new tonalIntervals: e.g., \\(M2 * 3L = A4\\). Division: natural inverse scale multiplication, Euclidean division defined tonalIntervals---.e., division /whole (integer) pieces, often leftover \"remainders\" (modulo). R, Euclidean division achieved %/% operator---/---, associated %% used remainder/modulo. Two tonalIntervals can divided produced integer; Conversely, tonalInterval can divided integer produce tonalInterval. Take note way humdrumR defines Euclidean division based tonal space---.e., line--fifths---frequency atonal-semitone space. example, augmented-fourth divided major-second 3L, diminished-fifth divided major-second 3L---d5 %/% M2 equals -3L remainder P8 (plus octave)! division algorithm works applying standard Euclidean division @Fifth slot (line--fifths tonal space), shifting @Octave value remainder match appropriate octave. definition useful properties specificinterval %% A1 = genericinterval interval %% d2 = enharmonicinterval. Since basic data types can parsed tonalInterval (see ), humdrumR attempt automatically coerce data tonalIntervals asked perform arithmetic. means arithmetic can applied one two arguments tonalInterval coercable atomic. instance, M3 + 2L interpret 2L two semitones add major-second major-third! clever dispatch system even ignore character strings recognized (see examples)! useful combined \"Predifined Intervals\" (like M3), described .","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalIntervalS4.html","id":"relational-operators","dir":"Reference","previous_headings":"","what":"Relational Operators","title":"Representation of tonal pitch information — tonalIntervalS4","text":"tonalIntervals can compared using standard relational operations---==, !=, >, >=, etc. Two tonalIntervals equal (according ==) slots (Octave, Fifth, Cent) exactly identical. Thus, enharmonic notes (like C# Db) equal. contrast, ordinal comparisons (e.g., >, <=) tonalIntervals based semitone (equal temperament) size, enharmonicity irrelevant. Thus, m3 >= A2 A2 >= m3 TRUE, even though m3 == A2 .","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalIntervalS4.html","id":"predefined-intervals-","dir":"Reference","previous_headings":"","what":"Predefined Intervals:","title":"Representation of tonal pitch information — tonalIntervalS4","text":"humdrumR automatically exports bunch tonalIntervals, named musical interval representation. Every generic interval 1 15 combined every interval quality dd (doubly diminished), d (diminished), m (minor), M (major), (augumented) AA (doubly augmented). Thus, loading humdrumR, can type things like M3 + M3 get A5. addition, variables unison (= P1 = tint(0, 0)),  pythagorean.comma (= d2 = tint(-19,12)), octave (tint(1, 0)) exported well.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalIntervalS4.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Representation of tonal pitch information — tonalIntervalS4","text":"","code":"M3 <- tint(   , 4L)  M2 <- tint(   , 2L) M9 <- tint(-1L, 2L)  M9 - M2  #> tonalInterval[ , ] #> [1] ccc # = octave M9 - 2L #> tonalInterval[ , ] #> [1] ccc # = octave  M3 %/% M2  #> [1] 2 # = 2  ###  cMajor <- sort(tint( , -1:5)) #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used #> Warning: the condition has length > 1 and only the first element will be used eMajor <- cMajor + M3 eMajor + 2L  #> tonalInterval[ , ] #> [1] f#  g#  a#  b   cc# dd# ee# # f# g# a# b cc# dd# ee#  eMajor[4:5] - octave  #> Error in as(e2, class(e1)): no method or default for coercing “function” to “tonalInterval” # = A B  \"4.ee\" + P5  #> [1] \"4.bb\" # = \"4.bb\""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalIntervalparts.html","id":null,"dir":"Reference","previous_headings":"","what":"Tonal interval partitions — tonalIntervalparts","title":"Tonal interval partitions — tonalIntervalparts","text":"Tonal interval partitions","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalTransformations.html","id":null,"dir":"Reference","previous_headings":"","what":"Tonal Transformations — tonalTransformations","title":"Tonal Transformations — tonalTransformations","text":"Various transformations pitch information Invert transpose tonal intervals.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonalTransformations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tonal Transformations — tonalTransformations","text":"","code":"tonalTransform(   x,   direction = TRUE,   delta = FALSE,   sigma = Exclusive %allin% c(\"mint\"),   generic = FALSE,   simple = FALSE,   roundContour = floor,   enharmonic = FALSE,   Key = NULL,   Exclusive = NULL,   ... )  invert(tint, around, Key, ...) invert(tint, around, Key, ...)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonh.html","id":null,"dir":"Reference","previous_headings":"","what":"German-style pitch notation. — tonh","title":"German-style pitch notation. — tonh","text":"Based common German system notating pitches, encoded humdrum **Tonh interpretation.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonh.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"German-style pitch notation. — tonh","text":"","code":"tonh(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonh.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"German-style pitch notation. — tonh","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). generic (logical, length == 1) generic = TRUE \"specific\" pitch information discarded. tonal representations, means accidentals/qualities equivalent information printed. atonal representations, generic pitch returned. alternative, can specify specific alternative (opposite) generic argument: generic == !specific. simple (logical, length == 1) simple = TRUE \"complex\" pitch information discarded. means octave information discarded, resulting output confined within default octave. absolute pitch representations, octave middle C. relative pitch representations, octave unison. (special octave.round argument can used modify behavior). transposeArgs (list) transposeArgs can list arguments passed special call transpose. convenient syntactic sugar, instead writing transposeArgs = list(= x, b = y, etc.), can write transpose(= x, b = y, etc.). parseArgs (list) parseArgs can list arguments passed pitch parser. convenient syntactic sugar, instead writing parseArgs = list(= x, b = y, etc.), can write parse(= x, b = y, etc.). inPlace (logical, length == 1) argument effect input (x argument) character strings, extral, non-pitch information strings \"beside\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ). S S = TRUE, E-flat (Ees) written just \"S\", -flat (Aes) written \"\".","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/tonh.html","id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"German-style pitch notation. — tonh","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/transpose.html","id":null,"dir":"Reference","previous_headings":"","what":"Transpose pitches and keys — transpose","title":"Transpose pitches and keys — transpose","text":"function transposes pitches keys various intervals target keys. Inside box, inputs transpositions take place tonalIntervals diatonicSets, numeric character string representation pitches can transposed well. function incorporated directly tonalTransform, thence, pitch translation functions, probably call directly often.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/transpose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transpose pitches and keys — transpose","text":"","code":"transpose(x, by, Key, to, real, relative, ...)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/transpose.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transpose pitches and keys — transpose","text":"x input pitch(es) transpose. tonalInterval something intepretable tonalInterval. tonalInterval something intepretable tonalInterval. input x transposed interval. Key diatonicSet something intepretable diatonicSet. tonal /transpositions, \"\" key. value NULL, defaults C major. diatonicSet something intepretable diatonicSet. input x transposed key. real logical. TRUE (default), transposition real. FALSE, transposition tonal. relative logical. TRUE transposition relative. FALSE (default), transposition parallel.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/transpose.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Transpose pitches and keys — transpose","text":"two distinct types transposition (real tonal). also two different approaches specifying transpositions: \"\" \"\". \"\" transpositions can also either parallel relative.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/transpose.html","id":"types-of-transposition","dir":"Reference","previous_headings":"","what":"Types of Transposition","title":"Transpose pitches and keys — transpose","text":"two different types transposition: real transposition tonal transposition. real transposition, inputs transposed specific interval. example, pitches {C D E F G} transposed major second {C D E F# G}. tonal transposition, inputs transposed generic intervals, within key. example, sequence {C D E F G}, key C major, translated generic second {D E F G }. choose real tonal transposition, use real argument: real = TRUE real transposition, real = FALSE tonal transposition.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/transpose.html","id":"alterations","dir":"Reference","previous_headings":"","what":"Alterations","title":"Transpose pitches and keys — transpose","text":"Tonal transposition complicated presence alterations input pitches. instance, given pitches {C F# G D# E}`` key C major, tonally transposed second, within C major? one obvious, correct answer answer, can easily identified. algorithm implemented humdrumR` follows: Alterations/accidentals input identified. (case, F# D#). generic pitches transposed within key, resulting {D G E F}. Alterations input added output unless resulting pitches interpreted comma call tintPartion, given enharmonic wrap value (default 12). example, adding first accidental results {G#} comma. However, second accidental results {E#} comma away natural {F}. Thus, accidental added output, resulting {E}, {E#}. resulting output {D G# E F}. size enharmonicWrap effectively determines extreme accidentals allowed. default value, 12, assures output notes enharmonically equivalent notes key. illustrate, sequence {C F# G D# E, B- - G C# D, B D- C} transposed tonally within C major seven possible generic intervals, enharmonicWrap = 12:","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/transpose.html","id":"specifying-transpositions","dir":"Reference","previous_headings":"","what":"Specifying Transpositions","title":"Transpose pitches and keys — transpose","text":"two approaches specifying transpositions, arguments. argument must interval, input translated interval. interval specific real = FALSE, input treated generic interval, tranposition takes place within key indicated Key argument. argument translates input desired key. example, input key E major want transposed G major, say = '*E:'. real = TRUE, input simply translated root key, exact intervals. real = FALSE, input translated root new key, intervals changed match new key well. either case, result depends input's key , indicated standard Key argument. Key arguments like \"\" key. Key = NULL, input key interpreted C major. Consider input notes {D B C # B, D C# D E D} key G major. specify = e:, real = TRUE, output {B G# F## G#, B # B C# B}. (Notice even though key minor, output still clearly E major). specify = e:, real = FALSE, output instead {B G F# G, B # B C B}. Building previous example, consider input key matters well. use input notes ({D B C # B, D C# D E D}) input Key C major, : specify = e:, real = TRUE, output {F# D# E C## D#, F# E# F# G# F#}. specify = e:, real = FALSE, output instead {F# D E C# D, F# E F# G F#}. specified, transposition applied first, followed transposition. real = FALSE, transposition happens within key, Key key.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/transpose.html","id":"relative-vs-parallel","dir":"Reference","previous_headings":"","what":"Relative vs Parallel","title":"Transpose pitches and keys — transpose","text":"transposing , diferent approaches determining relationship \"\" key (Key argument) \"\" key (argument). think \"parallel\" relationships keys, match roots keys regardless modes. instance, C major C minor parallel keys. instead think \"relative\" relationships keys, match modes keys, roots. instance, C major minor relative keys. similar distinction \"la-based minor\" solfege (relative) vs \"fixed-\" solfege (parallel). transposing using argument, relative = FALSE input key (Key argument) transposed match root argument. example, input key G minor `` key C major, output transposed G minor. However, relative = TRUEthe input key transposed match mode thetokey: G minor input C majortowould translated minor, parallel minor thetokey. theKey(key) andto` (key) arguments mode, parallel relative transpositions .","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/transpose.html","id":"special-operators-","dir":"Reference","previous_headings":"","what":"Special Operators +-","title":"Transpose pitches and keys — transpose","text":"note, real transposition interval can achieved concisely using + - operators, long least one side operators actual tonalInterval object. humdrumR preassigns common tonalIntervals objects global environment. Thus, can type commands like \"c#\" + M2 get d#, c(\"C4\", \"E4\", \"C5\") - m6 get \"E3\" \"G#3\" \"E4\".","code":""},{"path":[]},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/with-in-Humdrum.html","id":null,"dir":"Reference","previous_headings":"","what":"with(in)Humdrum — with-in-Humdrum","title":"with(in)Humdrum — with-in-Humdrum","text":"Apply arbitrary expressions fields within humdrumR data.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/with-in-Humdrum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"with(in)Humdrum — with-in-Humdrum","text":"Reference Getting started humdrumR Humdrum Syntax Rhythm Pitch Intervals HumdrumR Coders Diatonic Tertian Sets humdrumR Overview humdrumR Pitch Tonality humdrumR Reading writing data humdrumR Rhythm Meter humdrumR Validating Humdrum Data  Apply arbitrary expressions fields within humdrumR data. humdrumR humdrumR data object. ... arguments can fed ()Humdrum formulae (except expressions, replaced FUN argument!). However, rather writinging formula format Keyword ~ Expression, humApply arguments written normal R arguments: Keyword = Expression. Unnamed arguments ignored. #' @param within logical. TRUE (default), withinHumdrum used apply function---meaning output reconstituted new field humdrumR object. within == FALSE, withHumdrum used instead, results function's output returned inprocessed. drop argument concetually similar drop argument R matrices data.frames. drop = TRUE, output withHumdrum simplified much possible (trying return \"raw\" vector, list, table, etc. within ). drop = FALSE, result always data.table. default value (drop = TRUE) usually want intuitive, complex code, can helpful set drop = FALSE output consistent. withinHumdrum inHumdrum, new humdrumR data object. withHumdrum, whatever value returned expression. functions primary means working humdrumR data. (analogous base functions within applied data.frames.) Specifically allow evaluate arbitrary expressions involving fields humdrumR data object. also includes number special evaluation options: Evaluate expression matching parts data. Evaluate expression separately subsets data. Evaluate expression across windows data (e.g., ngrams, rolling windows). Evaluate expression produces plot, particular plotting parameters set using par. difference withHumdrum withinHumdrum analogous difference within. withHumdrum evaluates expression(s) simply returns result evaluation. withinHumdrum evaluates expression(s) (attempts) insert results back humdrumR object, generating new fields called PipeX (see details). inHumdrum simply short hand withinHumdrum.","code":"withinHumdrum(humdrumR, ...)  withHumdrum(humdrumR, ..., drop = TRUE)  <<<<<<< HEAD inHumdrum(humdrumR, ...)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/with-in-Humdrum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"with(in)Humdrum — with-in-Humdrum","text":"humdrumR humdrumR data object. ... Additional formulas/functions, lists formulas/functions. simply appended formulae argument.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/with-in-Humdrum.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"with(in)Humdrum — with-in-Humdrum","text":"withinHumdrum inHumdrum, new humdrumR data object. withHumdrum, whatever value returned expression.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/with-in-Humdrum.html","id":"overview","dir":"Reference","previous_headings":"","what":"Overview","title":"with(in)Humdrum — with-in-Humdrum","text":"FUN function apply Active field(s) humdrumR object. doplot Boolean. TRUE FUN argument treated doplot expression ()Humdrum, result ignored (plotting side-effects purposes).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/with-in-Humdrum.html","id":"formulae","dir":"Reference","previous_headings":"","what":"Formulae","title":"with(in)Humdrum — with-in-Humdrum","text":"Every formula formulae argument treated Keyword ~ Expression(s) pairing. Multiple expressions can input using multiple ~ operators: (leftmost expression treated keyword.) leftmost expression (.e., ~ Expression), Keyword defaults \".\" keyword expression must single, simple name/symbol, following standard R rules (.e., \".foobar\" acceptable \"3 + foobar\" ). Legal keywords, meanings : expression evaluated within humdrumR data object (see \"Expression evaluation\"). doplot expression evaluated within humdrumR data object ignoring result expression (see \"Expression evaluation\" \"Plotting\". expression used break data groups, expression(s) evaluated separately group (see \"Partitioning\"). expression indicating subset data evaluate expression (see \"Partitioning\"). ngrams positive number n. expression evaluated across overlapping length-n windows. recordtypes string vector characters drawn c(\"D\", \"d\", \"\", \"L\", \"M\",\"G\"). characters correspond types humdrum records: Data, null data, Interpretations, Measures, Local comments, Global comments respectively. expression evaluated data drawn specified record types (defaults \"D\"). pre expression evaluate evaluating expression(s). Useful, instance, taking logs opening graphing window. pre expression evaluated global environment. post expression evaluate evaluating expression(s). Always evaluated global environment.","code":"Keyword ~ Expression1 [~ Expression2 ~ ... ~ ExpressionN]"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/with-in-Humdrum.html","id":"expression-evaluation","dir":"Reference","previous_headings":"","what":"Expression evaluation","title":"with(in)Humdrum — with-in-Humdrum","text":"right-hand side formula formulae argument keyword doplot (keyword specified) evaluated within humdrumR data object. expression can, thus, refer field humdrumR object (Record, Token, File, etc.). can also include . anywhere expression, interpreted humdrumR object's current Active expression. multiple expressions provided, evaluated one time, result piped next. , non-, formulae (like ~ ngrams~) reused expression evaluated.","code":"humdata <- readHumdrum('directorywithdata/*.krn') # read some data  withinHumdrum(humdata, ~getPitch(Token)) # The most basic pattern withinHumdrum(humdata, ~getPitch(.)) # Same as previous (unless \\code{Active} field has been changed))  withinHumdrum(humdata, ~solfa(getPitch(Token), key = Key))  # Assumes that the Key field was parsed during the call to \\code{\\link{readHumdrum}}  withinHumdrum(humdata, ~getSemits(Token) - mean(getSemits(Token)))"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/with-in-Humdrum.html","id":"partitioning","dir":"Reference","previous_headings":"","what":"Partitioning","title":"with(in)Humdrum — with-in-Humdrum","text":"expression used break data subsets, expression(s) evaluated separately within subset. works similarly argument data.tables, INDEX argument tapply, INDICES argument . expression must evaluate, within humdrumR data object, vector (list vectors equal length) categories group data . commonly, expression(s) simply field(s) data: instance, apply function table Token field separately file humdrumR data. However, can also use complex expressions like evaluate expression two groups, one either spine number three less record number even, another group opposite true. expression evaluates list grouping vectors, expressions evaulated across every combination categories vectors. Thus, apply table Token across spine file. syntactic sugar, expression two parts, parts except (leftmost) keyword part combined list (.e., ~ File ~ Spine becomes ~ list(File, Spine)). Thus previous example can also written: expression used identify subset data evaluate expression(s) subset. expressions must evaluated, within humdrumR data object, single logical vector. expression(s) evaluated logical vector TRUE. Wherever expression evaluates FALSE, original humdrumR data kept unchanged. multiple partitioning formulae (.e, ) expressions evaluated recursively, order left right. Thus specify standard deviation semits field calculated file, semits field greater mean semits value within file. Contrast call: wherein standard deviation semits , , calculated file, time wherever semits field greater mean value across data.","code":"withinHumdrum(humdata,                        do ~ table(Token),                        by ~ File) withinHumdrum(humdata,                        do ~ table(Token),                         by ~ Spine > 3 | Record %% 2 == 0 withinHumdrum(humdata,                         do ~ table(Token),                        by ~ list(File, Spine)) withinHumdrum(humdata,                         do ~ table(Token),                        by ~ File ~ Spine) withinHumdrum(humdata,                        do ~ sd(semits),                        by ~ File,                         where ~ semits > mean(semits)) withinHumdrum(humdata,                        do ~ sd(semits)                        where ~ semits > mean(semits),                         by ~ File)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/with-in-Humdrum.html","id":"plotting","dir":"Reference","previous_headings":"","what":"Plotting","title":"with(in)Humdrum — with-in-Humdrum","text":"doplot keyword behaves exactly like keyword, except result evaluation ignored. useful plotting well side-effects (like writing file). doplot used withHumdrum, function simply returns NULL (executing doplot expression doplot used withinHumdrum (inHumdrum), function simply returns unaltered humdrumR argument. withinHumdrum also allows specify plotting options line, without make separate call par. par argument can specified Keyword ~ Expression pair formulae argument. instance, call doplot expression expression creates four groups, R create four plots---see last one! Normally, need call par(mfcol = c(2,2)) calling plotting function. However, withinHumdrum can soecific mfcol = c(2,2) right formulae formula: best part withinHumdrum reset par previous state withinHumdrum done.","code":"withinHumdrum(humdata,                       doplot ~ fooplot(.),                       by ~ list(Two, byTwo),                       mfcol ~ c(2, 2))"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/with-in-Humdrum.html","id":"tandem-interpretations","dir":"Reference","previous_headings":"","what":"Tandem interpretations","title":"with(in)Humdrum — with-in-Humdrum","text":"function readHumdrum automatically parses tandem interpretations (recognizes) fields resulting humdrumR data. instance, data '*clefF4' show Clef field. However, users might read humdrum data custom tandem interpretations built humdrumR. humdrumR includes function getTandem help us extract arbitrary tandem intrpretation data. Luckily, withinHumdrum knows syntactic sugar makes easy anywhere expressions, simply putting named object beginning symbol *. course, R normally allow names begin symbols like *, can force placing grave symbols around name `*name`. withinHumdrum expression, withinHumdrum treat name regular expression substitute call getTandem(Tandem, 'regular expression') expression. means can something like myFunction called first argument Token field, second argument tandem interpretations match 'mytandempattern' (extracted Tandem field).  Developed Nathaniel Condit-Schultz.  Site built pkgdown 2.0.2.","code":"withinHumdrum(humdata,                         do ~ myFunction(Token, `*mytandempattern`))"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/with-in-Humdrum.html","id":"splatting","dir":"Reference","previous_headings":"","what":"Splatting","title":"with(in)Humdrum — with-in-Humdrum","text":"(\"Splatting\" refers feeding function list/vector arguments.) Sometimes want divide data pieces (l\\'partition option), rather applying expression piece, want feed separate pieces separate arguments function. withinHumdrum can use syntactic sugar just , using @ symbol format myFunction(TargetExpr@GroupingExpr). make call four spines withinHumdrum intepret expression:","code":"withinHumdrum(humdata,           do ~ myFunction(Token@Spine)) withinHumdrum(humData,          do ~ myFunction(Token[Spine == 1], # first argument when Spine == 1                          Token[Spine == 2], # second argument when Spine == 2                          Token[Spine == 3], # etc.                          Token[Spine == 4]))"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/with-in-Humdrum.html","id":"argument-interpolation","dir":"Reference","previous_headings":"","what":"Argument interpolation","title":"with(in)Humdrum — with-in-Humdrum","text":"named arguments withinHumdrum interpolated expressions. useful already created list formulas like, like make small changes function call within expressions, without starting scratch. Examples:","code":"mycommand <- c(do ~ mean(., na.rm = TRUE), by ~ Spine ~ File) withinHumdrum(humdata,               mycommand,               na.rm = FALSE) # mycommand is executed with na.rm changed to FALSE"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/with-in-Humdrum.html","id":"piping","dir":"Reference","previous_headings":"","what":"Piping","title":"with(in)Humdrum — with-in-Humdrum","text":"calls withinHumdrum, result expression insterted back humdrum table. results put new field(s) labeled Pipe1, PipeX, ..., PipeN. results expression shorter rows humdrum table, object, humdrum table shrunk fit .  Developed Nathaniel Condit-Schultz.  Site built pkgdown 2.0.2.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/with-in-Humdrum.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"with(in)Humdrum — with-in-Humdrum","text":"","code":"humdata <- readHumdrum('directorywithdata/*.krn') #> Finding and reading files... #> \tREpath-pattern 'directorywithdata/*.krn' matches 0 text files in 0 directory. #> Zero files read from disk.  #> No files to validate.  withinHumdrum(humdata, ~nchar(.)) # counts characters in each data token. #> Error: In the call withinHumdrum(humdrumR = _), the argument humdrumR must be a humdrumR object. withinHumdrum(humdata, ~table(.), by ~ Spine) # Tabulates data tokens in each Spine. #> Error: In the call withinHumdrum(humdrumR = _), the argument humdrumR must be a humdrumR object."},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/with-in-humdrum.html","id":null,"dir":"Reference","previous_headings":"","what":"with(in)Humdrum — with-in-Humdrum","title":"with(in)Humdrum — with-in-Humdrum","text":"Apply arbitrary expressions fields within humdrumR data.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/with-in-humdrum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"with(in)Humdrum — with-in-Humdrum","text":"Reference Getting started humdrumR Humdrum Syntax Rhythm Pitch Intervals HumdrumR Coders Diatonic Tertian Sets humdrumR Overview humdrumR Pitch Tonality humdrumR Reading writing data humdrumR Rhythm Meter humdrumR Validating Humdrum Data  Apply arbitrary expressions fields within humdrumR data. humdrumR humdrumR data object. ... arguments can fed ()Humdrum formulae (except expressions, replaced FUN argument!). However, rather writinging formula format Keyword ~ Expression, humApply arguments written normal R arguments: Keyword = Expression. Unnamed arguments ignored. #' @param within logical. TRUE (default), withinHumdrum used apply function---meaning output reconstituted new field humdrumR object. within == FALSE, withHumdrum used instead, results function's output returned inprocessed. drop argument concetually similar drop argument R matrices data.frames. drop = TRUE, output withHumdrum simplified much possible (trying return \"raw\" vector, list, table, etc. within ). drop = FALSE, result always data.table. default value (drop = TRUE) usually want intuitive, complex code, can helpful set drop = FALSE output consistent. withinHumdrum inHumdrum, new humdrumR data object. withHumdrum, whatever value returned expression. functions primary means working humdrumR data. (analogous base functions within applied data.frames.) Specifically allow evaluate arbitrary expressions involving fields humdrumR data object. also includes number special evaluation options: Evaluate expression matching parts data. Evaluate expression separately subsets data. Evaluate expression across windows data (e.g., ngrams, rolling windows). Evaluate expression produces plot, particular plotting parameters set using par. difference withHumdrum withinHumdrum analogous difference within. withHumdrum evaluates expression(s) simply returns result evaluation. withinHumdrum evaluates expression(s) (attempts) insert results back humdrumR object, generating new fields called PipeX (see details). inHumdrum simply short hand withinHumdrum.","code":"withinHumdrum(humdrumR, ...)  withHumdrum(humdrumR, ..., drop = TRUE)  <<<<<<< HEAD inHumdrum(humdrumR, ...)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/with-in-humdrum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"with(in)Humdrum — with-in-Humdrum","text":"humdrumR humdrumR data object. ... Additional formulas/functions, lists formulas/functions. simply appended formulae argument.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/with-in-humdrum.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"with(in)Humdrum — with-in-Humdrum","text":"withinHumdrum inHumdrum, new humdrumR data object. withHumdrum, whatever value returned expression.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/with-in-humdrum.html","id":"overview","dir":"Reference","previous_headings":"","what":"Overview","title":"with(in)Humdrum — with-in-Humdrum","text":"FUN function apply Active field(s) humdrumR object. doplot Boolean. TRUE FUN argument treated doplot expression ()Humdrum, result ignored (plotting side-effects purposes).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/with-in-humdrum.html","id":"formulae","dir":"Reference","previous_headings":"","what":"Formulae","title":"with(in)Humdrum — with-in-Humdrum","text":"Every formula formulae argument treated Keyword ~ Expression(s) pairing. Multiple expressions can input using multiple ~ operators: (leftmost expression treated keyword.) leftmost expression (.e., ~ Expression), Keyword defaults \".\" keyword expression must single, simple name/symbol, following standard R rules (.e., \".foobar\" acceptable \"3 + foobar\" ). Legal keywords, meanings : expression evaluated within humdrumR data object (see \"Expression evaluation\"). doplot expression evaluated within humdrumR data object ignoring result expression (see \"Expression evaluation\" \"Plotting\". expression used break data groups, expression(s) evaluated separately group (see \"Partitioning\"). expression indicating subset data evaluate expression (see \"Partitioning\"). ngrams positive number n. expression evaluated across overlapping length-n windows. recordtypes string vector characters drawn c(\"D\", \"d\", \"\", \"L\", \"M\",\"G\"). characters correspond types humdrum records: Data, null data, Interpretations, Measures, Local comments, Global comments respectively. expression evaluated data drawn specified record types (defaults \"D\"). pre expression evaluate evaluating expression(s). Useful, instance, taking logs opening graphing window. pre expression evaluated global environment. post expression evaluate evaluating expression(s). Always evaluated global environment.","code":"Keyword ~ Expression1 [~ Expression2 ~ ... ~ ExpressionN]"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/with-in-humdrum.html","id":"expression-evaluation","dir":"Reference","previous_headings":"","what":"Expression evaluation","title":"with(in)Humdrum — with-in-Humdrum","text":"right-hand side formula formulae argument keyword doplot (keyword specified) evaluated within humdrumR data object. expression can, thus, refer field humdrumR object (Record, Token, File, etc.). can also include . anywhere expression, interpreted humdrumR object's current Active expression. multiple expressions provided, evaluated one time, result piped next. , non-, formulae (like ~ ngrams~) reused expression evaluated.","code":"humdata <- readHumdrum('directorywithdata/*.krn') # read some data  withinHumdrum(humdata, ~getPitch(Token)) # The most basic pattern withinHumdrum(humdata, ~getPitch(.)) # Same as previous (unless \\code{Active} field has been changed))  withinHumdrum(humdata, ~solfa(getPitch(Token), key = Key))  # Assumes that the Key field was parsed during the call to \\code{\\link{readHumdrum}}  withinHumdrum(humdata, ~getSemits(Token) - mean(getSemits(Token)))"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/with-in-humdrum.html","id":"partitioning","dir":"Reference","previous_headings":"","what":"Partitioning","title":"with(in)Humdrum — with-in-Humdrum","text":"expression used break data subsets, expression(s) evaluated separately within subset. works similarly argument data.tables, INDEX argument tapply, INDICES argument . expression must evaluate, within humdrumR data object, vector (list vectors equal length) categories group data . commonly, expression(s) simply field(s) data: instance, apply function table Token field separately file humdrumR data. However, can also use complex expressions like evaluate expression two groups, one either spine number three less record number even, another group opposite true. expression evaluates list grouping vectors, expressions evaulated across every combination categories vectors. Thus, apply table Token across spine file. syntactic sugar, expression two parts, parts except (leftmost) keyword part combined list (.e., ~ File ~ Spine becomes ~ list(File, Spine)). Thus previous example can also written: expression used identify subset data evaluate expression(s) subset. expressions must evaluated, within humdrumR data object, single logical vector. expression(s) evaluated logical vector TRUE. Wherever expression evaluates FALSE, original humdrumR data kept unchanged. multiple partitioning formulae (.e, ) expressions evaluated recursively, order left right. Thus specify standard deviation semits field calculated file, semits field greater mean semits value within file. Contrast call: wherein standard deviation semits , , calculated file, time wherever semits field greater mean value across data.","code":"withinHumdrum(humdata,                        do ~ table(Token),                        by ~ File) withinHumdrum(humdata,                        do ~ table(Token),                         by ~ Spine > 3 | Record %% 2 == 0 withinHumdrum(humdata,                         do ~ table(Token),                        by ~ list(File, Spine)) withinHumdrum(humdata,                         do ~ table(Token),                        by ~ File ~ Spine) withinHumdrum(humdata,                        do ~ sd(semits),                        by ~ File,                         where ~ semits > mean(semits)) withinHumdrum(humdata,                        do ~ sd(semits)                        where ~ semits > mean(semits),                         by ~ File)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/with-in-humdrum.html","id":"plotting","dir":"Reference","previous_headings":"","what":"Plotting","title":"with(in)Humdrum — with-in-Humdrum","text":"doplot keyword behaves exactly like keyword, except result evaluation ignored. useful plotting well side-effects (like writing file). doplot used withHumdrum, function simply returns NULL (executing doplot expression doplot used withinHumdrum (inHumdrum), function simply returns unaltered humdrumR argument. withinHumdrum also allows specify plotting options line, without make separate call par. par argument can specified Keyword ~ Expression pair formulae argument. instance, call doplot expression expression creates four groups, R create four plots---see last one! Normally, need call par(mfcol = c(2,2)) calling plotting function. However, withinHumdrum can soecific mfcol = c(2,2) right formulae formula: best part withinHumdrum reset par previous state withinHumdrum done.","code":"withinHumdrum(humdata,                       doplot ~ fooplot(.),                       by ~ list(Two, byTwo),                       mfcol ~ c(2, 2))"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/with-in-humdrum.html","id":"tandem-interpretations","dir":"Reference","previous_headings":"","what":"Tandem interpretations","title":"with(in)Humdrum — with-in-Humdrum","text":"function readHumdrum automatically parses tandem interpretations (recognizes) fields resulting humdrumR data. instance, data '*clefF4' show Clef field. However, users might read humdrum data custom tandem interpretations built humdrumR. humdrumR includes function getTandem help us extract arbitrary tandem intrpretation data. Luckily, withinHumdrum knows syntactic sugar makes easy anywhere expressions, simply putting named object beginning symbol *. course, R normally allow names begin symbols like *, can force placing grave symbols around name `*name`. withinHumdrum expression, withinHumdrum treat name regular expression substitute call getTandem(Tandem, 'regular expression') expression. means can something like myFunction called first argument Token field, second argument tandem interpretations match 'mytandempattern' (extracted Tandem field).  Developed Nathaniel Condit-Schultz.  Site built pkgdown 2.0.2.","code":"withinHumdrum(humdata,                         do ~ myFunction(Token, `*mytandempattern`))"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/with-in-humdrum.html","id":"splatting","dir":"Reference","previous_headings":"","what":"Splatting","title":"with(in)Humdrum — with-in-Humdrum","text":"(\"Splatting\" refers feeding function list/vector arguments.) Sometimes want divide data pieces (l\\'partition option), rather applying expression piece, want feed separate pieces separate arguments function. withinHumdrum can use syntactic sugar just , using @ symbol format myFunction(TargetExpr@GroupingExpr). make call four spines withinHumdrum intepret expression:","code":"withinHumdrum(humdata,           do ~ myFunction(Token@Spine)) withinHumdrum(humData,          do ~ myFunction(Token[Spine == 1], # first argument when Spine == 1                          Token[Spine == 2], # second argument when Spine == 2                          Token[Spine == 3], # etc.                          Token[Spine == 4]))"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/with-in-humdrum.html","id":"argument-interpolation","dir":"Reference","previous_headings":"","what":"Argument interpolation","title":"with(in)Humdrum — with-in-Humdrum","text":"named arguments withinHumdrum interpolated expressions. useful already created list formulas like, like make small changes function call within expressions, without starting scratch. Examples:","code":"mycommand <- c(do ~ mean(., na.rm = TRUE), by ~ Spine ~ File) withinHumdrum(humdata,               mycommand,               na.rm = FALSE) # mycommand is executed with na.rm changed to FALSE"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/with-in-humdrum.html","id":"piping","dir":"Reference","previous_headings":"","what":"Piping","title":"with(in)Humdrum — with-in-Humdrum","text":"calls withinHumdrum, result expression insterted back humdrum table. results put new field(s) labeled Pipe1, PipeX, ..., PipeN. results expression shorter rows humdrum table, object, humdrum table shrunk fit .  Developed Nathaniel Condit-Schultz.  Site built pkgdown 2.0.2.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/with-in-humdrum.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"with(in)Humdrum — with-in-Humdrum","text":"","code":"humdata <- readHumdrum('directorywithdata/*.krn') #> Finding and reading files... #> \tREpath-pattern 'directorywithdata/*.krn' matches 0 text files in 0 directory. #> Zero files read from disk.  #> No files to validate.  withinHumdrum(humdata, ~nchar(.)) # counts characters in each data token. #> Error: In the call withinHumdrum(humdrumR = _), the argument humdrumR must be a humdrumR object. withinHumdrum(humdata, ~table(.), by ~ Spine) # Tabulates data tokens in each Spine. #> Error: In the call withinHumdrum(humdrumR = _), the argument humdrumR must be a humdrumR object."},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/withinHumdrum.html","id":null,"dir":"Reference","previous_headings":"","what":"with(in)Humdrum — withinHumdrum","title":"with(in)Humdrum — withinHumdrum","text":"Apply arbitrary expressions fields within [S4class][humdrumRclass] data.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/withinHumdrum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"with(in)Humdrum — withinHumdrum","text":"","code":"withinHumdrum(humdrumR, ...)  withHumdrum(humdrumR, ..., drop = TRUE)  inHumdrum(humdrumR, ...)  humApply(humdrumR, FUN, ..., within = TRUE, doplot = FALSE)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/withinHumdrum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"with(in)Humdrum — withinHumdrum","text":"humdrumR humdrumRclass data object. ... arguments can fed [humdrumR:--Humdrum][()Humdrum] formulae (except expressions, replaced FUN argument!). However, rather writinging formula format Keyword ~ Expression, humApply arguments written normal R arguments: Keyword = Expression. Unnamed arguments ignored. #' @param within logical. TRUE (default), [humdrumR:--Humdrum][withinHumdrum] used apply function---meaning output reconstituted new field humdrumR object. within == FALSE, [humdrumR:--Humdrum][withHumdrum] used instead, results function's output returned inprocessed. drop argument concetually similar drop argument R matrices data.frames. drop = TRUE, output withHumdrum simplified much possible (trying return \"raw\" vector, list, table, etc. within ). drop = FALSE, result always data.table. default value (drop = TRUE) usually want intuitive, complex code, can helpful set drop = FALSE output consistent. FUN function apply humdrumR:humdrumRfield(s) thehumdrumR` object. doplot Boolean. TRUE FUN argument treated doplot expression [humdrumR:--Humdrum][()Humdrum], result ignored (plotting side-effects purposes).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/withinHumdrum.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"with(in)Humdrum — withinHumdrum","text":"withinHumdrum inHumdrum, new humdrumR data object. withHumdrum, whatever value returned expression.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/withinHumdrum.html","id":"overview","dir":"Reference","previous_headings":"","what":"Overview","title":"with(in)Humdrum — withinHumdrum","text":"functions primary means working humdrumR data. (analogous base functions [base][] [base][within] applied [base:data.frame][data.frames].) Specifically allow evaluate arbitrary expressions involving fields humdrumR data object. also includes number special evaluation options: Evaluate expression matching parts data. Evaluate expression separately subsets data. Evaluate expression across windows data (e.g., ngrams, rolling windows). Evaluate expression produces plot, particular plotting parameters set using [graphics][par]. difference withHumdrum withinHumdrum analogous difference [base][] [base][within]. withHumdrum evaluates expression(s) simply returns result evaluation. withinHumdrum evaluates expression(s) (attempts) insert results back humdrumR object, generating new fields called PipeX (see details). inHumdrum simply short hand withinHumdrum.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/withinHumdrum.html","id":"formulae","dir":"Reference","previous_headings":"","what":"Formulae","title":"with(in)Humdrum — withinHumdrum","text":"Every formula formulae argument treated Keyword ~ Expression(s) pairing. Multiple expressions can input using multiple ~ operators: Keyword ~ Expression1 [~ Expression2 ~ ... ~ ExpressionN] (leftmost expression treated keyword.) leftmost expression (.e., ~ Expression), Keyword defaults \".\" keyword expression must single, simple name/symbol, following standard R rules (.e., \".foobar\" acceptable \"3 + foobar\" ). Legal keywords, meanings : expression evaluated within humdrumR data object (see \"Expression evaluation\"). doplot expression evaluated within humdrumR data object ignoring result expression (see \"Expression evaluation\" \"Plotting\". expression used break data groups, expression(s) evaluated separately group (see \"Partitioning\"). expression indicating subset data evaluate expression (see \"Partitioning\"). ngrams positive number n. expression evaluated across overlapping length-n windows. recordtypes string vector characters drawn c(\"D\", \"d\", \"\", \"L\", \"M\",\"G\"). characters correspond types humdrum records: Data, null data, Interpretations, Measures, Local comments, Global comments respectively. expression evaluated data drawn specified record types (defaults \"D\"). pre expression evaluate evaluating expression(s). Useful, instance, taking logs opening graphing window. pre expression evaluated global environment. post expression evaluate evaluating expression(s). Always evaluated global environment.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/withinHumdrum.html","id":"expression-evaluation","dir":"Reference","previous_headings":"","what":"Expression evaluation","title":"with(in)Humdrum — withinHumdrum","text":"right-hand side formula formulae argument keyword doplot (keyword specified) evaluated within humdrumR data object. expression can, thus, refer field humdrumR object (Record, Token, File, etc.). can also include . anywhere expression, interpreted humdrumR object's current [dest=humdrumR][Active] expression. multiple expressions provided, evaluated one time, result piped next. , non-, formulae (like ~ ngrams~) reused expression evaluated.","code":"humdata <- readHumdrum('directorywithdata/*.krn') # read some data  withinHumdrum(humdata, ~getPitch(Token)) # The most basic pattern withinHumdrum(humdata, ~getPitch(.)) # Same as previous (unless `Active` field has been changed))  withinHumdrum(humdata, ~solfa(getPitch(Token), key = Key))  # Assumes that the Key field was parsed during the call to `[readHumdrum][readHumdrum]`  withinHumdrum(humdata, ~getSemits(Token) - mean(getSemits(Token)))"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/withinHumdrum.html","id":"partitioning","dir":"Reference","previous_headings":"","what":"Partitioning","title":"with(in)Humdrum — withinHumdrum","text":"expression used break data subsets, expression(s) evaluated separately within subset. works similarly argument [data.table][data.table]s, INDEX argument [base][tapply], INDICES argument [base][]. expression must evaluate, within humdrumR data object, vector (list vectors equal length) categories group data . commonly, expression(s) simply field(s) data: instance, apply function [base][table] Token field separately file humdrumR data. However, can also use complex expressions like evaluate expression two groups, one either spine number three less record number even, another group opposite true. expression evaluates list grouping vectors, expressions evaulated across every combination categories vectors. Thus, withinHumdrum(humdata, ~ table(Token), ~ list(File, Spine)) apply table Token across spine file. syntactic sugar, expression two parts, parts except (leftmost) keyword part combined list (.e., ~ File ~ Spine becomes ~ list(File, Spine)}. Thus previous example can also written: withinHumdrum(humdata, ~ table(Token), ~ File ~ Spine) expression used identify subset data evaluate expression(s) subset. expressions must evaluated, within humdrumR data object, single logical vector. expression(s) evaluated logical vector TRUE. Wherever expression evaluates FALSE, original humdrumR data kept unchanged. multiple partitioning formulae (.e, ) expressions evaluated recursively, order left right. Thus specify withinHumdrum(humdata, ~ sd(semits), ~ File, ~ semits > mean(semits)) standard deviation semits field calculated file, semits field greater mean semits value within file. Contrast call: withinHumdrum(humdata, ~ sd(semits) ~ semits > mean(semits), ~ File) wherein standard deviation semits , , calculated file, time wherever semits field greater mean value across data.","code":"withinHumdrum(humdata,          do ~ table(Token),          by ~ File) withinHumdrum(humdata,          do ~ table(Token),           by ~ Spine > 3 | Record \\%\\% 2 == 0)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/withinHumdrum.html","id":"plotting","dir":"Reference","previous_headings":"","what":"Plotting","title":"with(in)Humdrum — withinHumdrum","text":"doplot keyword behaves exactly like keyword, except result evaluation ignored. useful plotting well side-effects (like writing file). doplot used withHumdrum, function simply returns NULL (executing doplot expression doplot used withinHumdrum (inHumdrum), function simply returns unaltered humdrumR argument. withinHumdrum also allows specify plotting options line, without make separate call [graphics][par]. [graphics][par] argument can specified Keyword ~ Expression pair formulae argument. instance, call doplot expression expression creates four groups, R create four plots---see last one! Normally, need call par(mfcol = c(2,2)) calling plotting function. However, withinHumdrum can soecific mfcol = c(2,2) right formulae formula: withinHumdrum(humdata, doplot ~ fooplot(.), ~ list(Two, byTwo), mfcol ~ c(2, 2)) best part withinHumdrum reset par previous state withinHumdrum done.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/withinHumdrum.html","id":"tandem-interpretations","dir":"Reference","previous_headings":"","what":"Tandem interpretations","title":"with(in)Humdrum — withinHumdrum","text":"function [readHumdrum][readHumdrum] automatically parses tandem interpretations (recognizes) fields resulting [humdrumR][humdrumRclass] data. instance, data '*clefF4' show Clef field. However, users might read humdrum data custom tandem interpretations built humdrumR. humdrumR includes function [getTandem][getTandem] help us extract arbitrary tandem intrpretation data. Luckily, withinHumdrum knows syntactic sugar makes easy anywhere expressions, simply putting named object beginning symbol *. course, R normally allow names begin symbols like *, can force placing grave symbols around name *name. withinHumdrum expression, withinHumdrum treat name regular expression substitute call getTandem(Tandem, 'regular expression') expression. means can something like withinHumdrum(humdata, ~ myFunction(Token, *mytandempattern)) myFunction called first argument Token field, second argument tandem interpretations match 'mytandempattern' (extracted Tandem field).","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/withinHumdrum.html","id":"splatting","dir":"Reference","previous_headings":"","what":"Splatting","title":"with(in)Humdrum — withinHumdrum","text":"(\"Splatting\" refers feeding function list/vector arguments.) Sometimes want divide data pieces (l\\'partition option), rather applying expression piece, want feed separate pieces separate arguments function. withinHumdrum can use syntactic sugar just , using @ symbol format myFunction(TargetExpr@GroupingExpr). make call withinHumdrum(humdata, ~ myFunction(Token@Spine)) four spines withinHumdrum intepret expression: withinHumdrum(humData, ~ myFunction(TokenSpine == 1, # first argument Spine == 1 TokenSpine == 2, # second argument Spine == 2 TokenSpine == 3, # etc. TokenSpine == 4))","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/withinHumdrum.html","id":"argument-interpolation","dir":"Reference","previous_headings":"","what":"Argument interpolation","title":"with(in)Humdrum — withinHumdrum","text":"named arguments withinHumdrum [humdrumR:interpolateArguments][interpolated] expressions. useful already created list formulas like, like make small changes function call within expressions, without starting scratch. Examples:","code":"mycommand <- c(do ~ mean(., na.rm = TRUE), by ~ Spine ~ File) withinHumdrum(humdata,               mycommand,               na.rm = FALSE) # mycommand is executed with na.rm changed to FALSE"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/withinHumdrum.html","id":"piping","dir":"Reference","previous_headings":"","what":"Piping","title":"with(in)Humdrum — withinHumdrum","text":"calls withinHumdrum, result expression insterted back [humtable][humdrum table]. results put new field(s) labeled Pipe1, PipeX, ..., PipeN. results expression shorter rows humtable, object, humdrum table shrunk fit .","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/withinHumdrum.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"with(in)Humdrum — withinHumdrum","text":"","code":"humdata <- readHumdrum('directorywithdata/*.krn') #> Finding and reading files... #> \tREpath-pattern 'directorywithdata/*.krn' matches 0 text files in 0 directories. #> Zero files read from disk. #> No files to validate.  withinHumdrum(humdata, ~nchar(.)) # counts characters in each data token. #> humdrumR error in: #> \ttryCatch(withCallingHandlers({ #>   NULL #>   saveRDS(do.call(do.call, c(readRDS( #>     \"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), list(envir = .GlobalEnv, #>     quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\") #>   flush(stdout()) #>   flush(stderr()) #>   NULL #>   invisible() #> }, error = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, interrupt = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, callr_message = function(e) { #>   try(signalCondition(e)) #> }), error = function(e) { #>   NULL #>   try(stop(e)) #> }, interrupt = function(e) { #>   NULL #>   e #> }) #> \t -> tryCatchList(expr, classes, parentenv, handlers) #> \t -> tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), names[nh], #> parentenv, handlers[[nh]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> tryCatchList(expr, names[-nh], parentenv, handlers[-nh]) #> \t -> tryCatchOne(expr, names, parentenv, handlers[[1L]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> withCallingHandlers({ #>   NULL #>   saveRDS(do.call(do.call, c(readRDS( #>     \"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), list(envir = .GlobalEnv, #>     quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\") #>   flush(stdout()) #>   flush(stderr()) #>   NULL #>   invisible() #> }, error = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, interrupt = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, callr_message = function(e) { #>   try(signalCondition(e)) #> }) #> \t -> saveRDS(do.call(do.call, c(readRDS( #>   \"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), list(envir = .GlobalEnv, #>   quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\") #> \t -> do.call(do.call, c(readRDS(\"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), #> list(envir = .GlobalEnv, quote = TRUE)), envir = .GlobalEnv, quote = TRUE) #> \t -> <function(what, args, quote = FALSE, envir = parent.frame()) { #>   if (!is.list(args)) stop(\"second argument must be a list\") #>   if (quote) args <- lapply(args, enquote) #>   .Internal(do.call(what, args, envir)) #> }>(base::quote(<function(..., crayon_enabled, crayon_colors, pkgdown_internet) { #>   options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, #>     pkgdown.internet = pkgdown_internet) #>   pkgdown::build_site(...) #> }>), base::quote(<list: pkg = <pkgdown>, examples = TRUE, run_dont_run = FALSE, #>   seed = 1014, lazy = FALSE, ...>), envir = base::quote(<environment>), quote = base::quote( #>   TRUE)) #> \t -> <function(..., crayon_enabled, crayon_colors, pkgdown_internet) { #>   options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, #>     pkgdown.internet = pkgdown_internet) #>   pkgdown::build_site(...) #> }>(pkg = base::quote(<pkgdown>), examples = base::quote(TRUE), run_dont_run = base::quote( #>   FALSE), seed = base::quote(1014), lazy = base::quote(FALSE), override = base::quote( #>   <list: >), install = base::quote(FALSE), preview = base::quote(FALSE), #> new_process = base::quote(FALSE), devel = base::quote(FALSE), crayon_enabled = base::quote( #>   TRUE), crayon_colors = base::quote(256L), pkgdown_internet = base::quote(TRUE)) #> \t -> pkgdown::build_site(...) #> \t -> build_site_local(pkg = pkg, examples = examples, run_dont_run = run_dont_run, #>   seed = seed, lazy = lazy, override = override, preview = preview, devel = devel) #> \t -> build_reference(pkg, lazy = lazy, examples = examples, run_dont_run = run_dont_run, #>   seed = seed, override = override, preview = FALSE, devel = devel) #> \t -> purrr::map(topics, build_reference_topic, pkg = pkg, lazy = lazy, examples_env = examples_env, #>   run_dont_run = run_dont_run) #> \t -> .f(.x[[i]], ...) #> \t -> withCallingHandlers(data_reference_topic(topic, pkg, examples_env = examples_env, #>   run_dont_run = run_dont_run), error = function(err) { #>   msg <- c(paste0(\"Failed to parse Rd in \", topic$file_in), i = err$message) #>   abort(msg, parent = err) #> }) #> \t -> data_reference_topic(topic, pkg, examples_env = examples_env, run_dont_run = run_dont_run) #> \t -> run_examples(tags$tag_examples[[1]], env = if (is.null(examples_env) #> ) NULL else new.env(parent = examples_env), topic = tools::file_path_sans_ext( #>   topic$file_in), run_dont_run = run_dont_run) #> \t -> highlight_examples(code, topic, env = env) #> \t -> downlit::evaluate_and_highlight(code, fig_save = fig_save_topic, env = child_env( #>   env), output_handler = evaluate::new_output_handler(value = pkgdown_print)) #> \t -> evaluate::evaluate(code, child_env(env), new_device = TRUE, output_handler = output_handler) #> \t -> evaluate_call(expr, parsed$src[[i]], envir = envir, enclos = enclos, debug = debug, #> last = i == length(out), use_try = stop_on_error != 2L, keep_warning = keep_warning, #> keep_message = keep_message, output_handler = output_handler, include_timing = include_timing) #> \t -> timing_fn(handle(ev <- withCallingHandlers(withVisible(eval(expr, envir, enclos)), #> warning = wHandler, error = eHandler, message = mHandler))) #> \t -> handle(ev <- withCallingHandlers(withVisible(eval(expr, envir, enclos)), #> warning = wHandler, error = eHandler, message = mHandler)) #> \t -> try(f, silent = TRUE) #> \t -> tryCatch(expr, error = function(e) { #>   call <- conditionCall(e) #>   if (!is.null(call)) { #>     if (identical(call[[1L]], quote(doTryCatch))) call <- sys.call(-4L) #>     dcall <- deparse(call, nlines = 1L) #>     prefix <- paste(\"Error in\", dcall, \": \") #>     LONG <- 75L #>     sm <- strsplit(conditionMessage(e), \"\\n\")[[1L]] #>     w <- 14L + nchar(dcall, type = \"w\") + nchar(sm[1L], type = \"w\") #>     if (is.na(w)) w <- 14L + nchar(dcall, type = \"b\") + nchar(sm[1L], type = \"b\") #>     if (w > LONG) prefix <- paste0(prefix, \"\\n  \") #>   } else prefix <- \"Error : \" #>   msg <- paste0(prefix, conditionMessage(e), \"\\n\") #>   .Internal(seterrmessage(msg[1L])) #>   if (!silent && isTRUE(getOption(\"show.error.messages\"))) { #>     cat(msg, file = outFile) #>     .Internal(printDeferredWarnings()) #>   } #>   invisible(structure(msg, class = \"try-error\", condition = e)) #> }) #> \t -> tryCatchList(expr, classes, parentenv, handlers) #> \t -> tryCatchOne(expr, names, parentenv, handlers[[1L]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> withCallingHandlers(withVisible(eval(expr, envir, enclos)), warning = wHandler, #> error = eHandler, message = mHandler) #> \t -> withVisible(eval(expr, envir, enclos)) #> \t -> eval(expr, envir, enclos) #> \t -> eval(expr, envir, enclos) #> \t -> withinHumdrum(humdata, ~ nchar(.)) #> \t #> Error: In the call withinHumdrum(humdrumR = _), the argument humdrumR must be a humdrumR object. withinHumdrum(humdata, ~table(.), by ~ Spine) # Tabulates data tokens in each Spine. #> humdrumR error in: #> \ttryCatch(withCallingHandlers({ #>   NULL #>   saveRDS(do.call(do.call, c(readRDS( #>     \"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), list(envir = .GlobalEnv, #>     quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\") #>   flush(stdout()) #>   flush(stderr()) #>   NULL #>   invisible() #> }, error = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, interrupt = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, callr_message = function(e) { #>   try(signalCondition(e)) #> }), error = function(e) { #>   NULL #>   try(stop(e)) #> }, interrupt = function(e) { #>   NULL #>   e #> }) #> \t -> tryCatchList(expr, classes, parentenv, handlers) #> \t -> tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), names[nh], #> parentenv, handlers[[nh]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> tryCatchList(expr, names[-nh], parentenv, handlers[-nh]) #> \t -> tryCatchOne(expr, names, parentenv, handlers[[1L]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> withCallingHandlers({ #>   NULL #>   saveRDS(do.call(do.call, c(readRDS( #>     \"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), list(envir = .GlobalEnv, #>     quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\") #>   flush(stdout()) #>   flush(stderr()) #>   NULL #>   invisible() #> }, error = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, interrupt = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\", \".error\")) #>   } #> }, callr_message = function(e) { #>   try(signalCondition(e)) #> }) #> \t -> saveRDS(do.call(do.call, c(readRDS( #>   \"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), list(envir = .GlobalEnv, #>   quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmp269hj3/callr-res-1ddbcf4fb31a\") #> \t -> do.call(do.call, c(readRDS(\"/home/nat/.tmp/Rtmp269hj3/callr-fun-1ddbc363cbbbb\"), #> list(envir = .GlobalEnv, quote = TRUE)), envir = .GlobalEnv, quote = TRUE) #> \t -> <function(what, args, quote = FALSE, envir = parent.frame()) { #>   if (!is.list(args)) stop(\"second argument must be a list\") #>   if (quote) args <- lapply(args, enquote) #>   .Internal(do.call(what, args, envir)) #> }>(base::quote(<function(..., crayon_enabled, crayon_colors, pkgdown_internet) { #>   options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, #>     pkgdown.internet = pkgdown_internet) #>   pkgdown::build_site(...) #> }>), base::quote(<list: pkg = <pkgdown>, examples = TRUE, run_dont_run = FALSE, #>   seed = 1014, lazy = FALSE, ...>), envir = base::quote(<environment>), quote = base::quote( #>   TRUE)) #> \t -> <function(..., crayon_enabled, crayon_colors, pkgdown_internet) { #>   options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, #>     pkgdown.internet = pkgdown_internet) #>   pkgdown::build_site(...) #> }>(pkg = base::quote(<pkgdown>), examples = base::quote(TRUE), run_dont_run = base::quote( #>   FALSE), seed = base::quote(1014), lazy = base::quote(FALSE), override = base::quote( #>   <list: >), install = base::quote(FALSE), preview = base::quote(FALSE), #> new_process = base::quote(FALSE), devel = base::quote(FALSE), crayon_enabled = base::quote( #>   TRUE), crayon_colors = base::quote(256L), pkgdown_internet = base::quote(TRUE)) #> \t -> pkgdown::build_site(...) #> \t -> build_site_local(pkg = pkg, examples = examples, run_dont_run = run_dont_run, #>   seed = seed, lazy = lazy, override = override, preview = preview, devel = devel) #> \t -> build_reference(pkg, lazy = lazy, examples = examples, run_dont_run = run_dont_run, #>   seed = seed, override = override, preview = FALSE, devel = devel) #> \t -> purrr::map(topics, build_reference_topic, pkg = pkg, lazy = lazy, examples_env = examples_env, #>   run_dont_run = run_dont_run) #> \t -> .f(.x[[i]], ...) #> \t -> withCallingHandlers(data_reference_topic(topic, pkg, examples_env = examples_env, #>   run_dont_run = run_dont_run), error = function(err) { #>   msg <- c(paste0(\"Failed to parse Rd in \", topic$file_in), i = err$message) #>   abort(msg, parent = err) #> }) #> \t -> data_reference_topic(topic, pkg, examples_env = examples_env, run_dont_run = run_dont_run) #> \t -> run_examples(tags$tag_examples[[1]], env = if (is.null(examples_env) #> ) NULL else new.env(parent = examples_env), topic = tools::file_path_sans_ext( #>   topic$file_in), run_dont_run = run_dont_run) #> \t -> highlight_examples(code, topic, env = env) #> \t -> downlit::evaluate_and_highlight(code, fig_save = fig_save_topic, env = child_env( #>   env), output_handler = evaluate::new_output_handler(value = pkgdown_print)) #> \t -> evaluate::evaluate(code, child_env(env), new_device = TRUE, output_handler = output_handler) #> \t -> evaluate_call(expr, parsed$src[[i]], envir = envir, enclos = enclos, debug = debug, #> last = i == length(out), use_try = stop_on_error != 2L, keep_warning = keep_warning, #> keep_message = keep_message, output_handler = output_handler, include_timing = include_timing) #> \t -> timing_fn(handle(ev <- withCallingHandlers(withVisible(eval(expr, envir, enclos)), #> warning = wHandler, error = eHandler, message = mHandler))) #> \t -> handle(ev <- withCallingHandlers(withVisible(eval(expr, envir, enclos)), #> warning = wHandler, error = eHandler, message = mHandler)) #> \t -> try(f, silent = TRUE) #> \t -> tryCatch(expr, error = function(e) { #>   call <- conditionCall(e) #>   if (!is.null(call)) { #>     if (identical(call[[1L]], quote(doTryCatch))) call <- sys.call(-4L) #>     dcall <- deparse(call, nlines = 1L) #>     prefix <- paste(\"Error in\", dcall, \": \") #>     LONG <- 75L #>     sm <- strsplit(conditionMessage(e), \"\\n\")[[1L]] #>     w <- 14L + nchar(dcall, type = \"w\") + nchar(sm[1L], type = \"w\") #>     if (is.na(w)) w <- 14L + nchar(dcall, type = \"b\") + nchar(sm[1L], type = \"b\") #>     if (w > LONG) prefix <- paste0(prefix, \"\\n  \") #>   } else prefix <- \"Error : \" #>   msg <- paste0(prefix, conditionMessage(e), \"\\n\") #>   .Internal(seterrmessage(msg[1L])) #>   if (!silent && isTRUE(getOption(\"show.error.messages\"))) { #>     cat(msg, file = outFile) #>     .Internal(printDeferredWarnings()) #>   } #>   invisible(structure(msg, class = \"try-error\", condition = e)) #> }) #> \t -> tryCatchList(expr, classes, parentenv, handlers) #> \t -> tryCatchOne(expr, names, parentenv, handlers[[1L]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> withCallingHandlers(withVisible(eval(expr, envir, enclos)), warning = wHandler, #> error = eHandler, message = mHandler) #> \t -> withVisible(eval(expr, envir, enclos)) #> \t -> eval(expr, envir, enclos) #> \t -> eval(expr, envir, enclos) #> \t -> withinHumdrum(humdata, ~ table(.), by ~ Spine) #> \t #> Error: In the call withinHumdrum(humdrumR = _), the argument humdrumR must be a humdrumR object."},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/wort.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract words from syllables — wort","title":"Extract words from syllables — wort","text":"Transform humdrumR's syllabic form lyrics complete words, row contain either one word null data token.","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/wort.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract words from syllables — wort","text":"","code":"wort(silbe, nullTokens = TRUE, keepSilbe = FALSE, indices = FALSE)"},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/wort.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract words from syllables — wort","text":"nullTokens Boolean expression determines whether null tokens replace empty spaces syllables moved combine others make word. Default TRUE keepSilbe Boolean expression determines whether user wants save silbe format output case needed back translation later uses. Default FALSE indices Boolean expression determines whether linguistics version word printed. Default FALSE. data data transformed (character vector)","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/wort.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract words from syllables — wort","text":"transformed data","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/writeHumdrum.html","id":null,"dir":"Reference","previous_headings":"","what":"Write humdrumR data to humdrum files. — writeHumdrum","title":"Write humdrumR data to humdrum files. — writeHumdrum","text":"----------NEEDS DOCUMENTATION------------","code":""},{"path":"https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/reference/writeHumdrum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write humdrumR data to humdrum files. — writeHumdrum","text":"","code":"writeHumdrum(   humdrumR,   fieldname = NULL,   affix = \"_humdrumR\",   prefix = \"\",   rename = NULL,   extension = NULL,   directory = NULL,   EMD = paste0(\"Edited in humdrumR \", packageVersion(\"humdrumR\"), \" on \", Sys.date()),   overwrite = FALSE,   verbose = TRUE )"}]
