[{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Filtering.html","id":"indexing","dir":"Articles","previous_headings":"","what":"Indexing","title":"Filtering humdrum data","text":"simplest, common, way filter data indexing, common approach programming selecting subsets data. R, use square brackets, [], index various data objects, including basic atomic vectors, data.tables, lists. example, using brackets can extract subsets vector: Watch ! R actually two different ways indexing: can use single pair matches brackets ([ ]) double pair ([[ ]]). want primer two types indexing used normal R objects, check R primer—really don’t need getting humdrum\\(_{\\mathbb{R}}\\), might want eventually. can use single-bracket [] double-bracket [[]] commands index humdrum\\(_{\\mathbb{R}}\\) data objects. single-brackets used index whole pieces data. double-brackets used index “within” pieces data. Either type bracket can accept either numeric character vectors index .","code":"myname <- c('N', 'A', 'T', ' ', 'C', 'O', 'N', 'D', 'I', 'T')  myname[1:3] >    [1] \"N\" \"A\" \"T\"  myname[5:10] >    [1] \"C\" \"O\" \"N\" \"D\" \"I\" \"T\"  myname[c(1, 5)] >    [1] \"N\" \"C\""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Filtering.html","id":"single-bracket-indexing","dir":"Articles","previous_headings":"Indexing","what":"Single-bracket indexing","title":"Filtering humdrum data","text":"single-brackets used index whole pieces data. dataset 19 files, want look files, ’d use single-brackets [].","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Filtering.html","id":"numeric-indices-for-single-brackets","dir":"Articles","previous_headings":"Indexing > Single-bracket indexing","what":"Numeric indices (for single-brackets)","title":"Filtering humdrum data","text":"give numeric value single-bracket index command, number select ith file dataset. example, want look fifth chorale, can call: can also give command vector numbers: might want use R sequence command, :, select range numbers:","code":"chorales[5] >    ############################ vvv chor005.krn vvv ############################ >        1:  !!!COM: Bach, Johann Sebastian >        2:  !!!CDT: 1685/02/21/-1750/07/28/ >        3:  !!!OTL@@DE: An Wasserfl&uuml;ssen Babylon >        4:  !!!SCT: BWV 267 >        5:  !!!PC#: 5 >        6:  !!!AGN: chorale >        7:          **kern        **kern        **kern        **kern >        8:          *ICvox        *ICvox        *ICvox        *ICvox >        9:          *Ibass       *Itenor        *Ialto       *Isoprn >       10:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >       11:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >       12:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >       13:             *>A           *>A           *>A           *>A >       14:         *clefF4      *clefGv2       *clefG2       *clefG2 >       15:          *k[f#]        *k[f#]        *k[f#]        *k[f#] >       16:             *G:           *G:           *G:           *G: >       17:           *M4/4         *M4/4         *M4/4         *M4/4 >       18:         *met(c)       *met(c)       *met(c)       *met(c) >       19:          *MM100        *MM100        *MM100        *MM100 >       20:              4G            4B            4g           4dd >       21:              =1            =1            =1            =1 >       22:              4C           8cL            4g           4ee >       23:               .           8BJ             .             . >       24:              4D            4A           4f#          8ddL >       25:               .             .             .          8ccJ >       26:              4E            4e            4g           8bL >       27:               .             .             .          8ccJ >       28:            8F#L           8AL           4f#           4dd >       29:             8GJ           8BJ             .             . >       30:              =2            =2            =2            =2 >       31:              4A           8cL           8eL          8ccL >       32:               .           8eJ           8gJ           8bJ >       33:              4D            4d           8gL           4cc >       34:               .             .          8f#J             . >       35:             4G;           4d;           4g;           4b; >       36:             4F#            4d            4a            4a >       37:              =3            =3            =3            =3 >       38:             8GL            4d            4g            4b >       39:            8F#J             .             .             . >       40:              4E           8GL            4g           4cc >       41:               .           8AJ             .             . >       42:             4BB           8BL            4g           4dd >       43:               .           8GJ             .             . >       44:              4C            4e            4g          8ccL >       45:               .             .             .           8bJ >       46:              =4            =4            =4            =4 >       47:              2D           8AL            4g           8aL >       48:               .           8BJ             .           8gJ >       49:               .            4c           4f#            4a >       50:            4GG;           4B;           4d;           4g; >       51:            =:|!          =:|!          =:|!          =:|! >       52:             *>B           *>B           *>B           *>B >       53:              4G            4B            4d            4g >       54:              =5            =5            =5            =5 >       55:             4F#            4A           8dL            4a >       56:               .             .           8eJ             . >       57:             8EL            4d           4f#            4b >       58:             8DJ             .             .             . >       59:              4E            4G            4e          8ccL >       60:               .             .             .           8bJ >       61:             4F#            4A           8eL            4a >       62:               .             .           8dJ             . >       63:              =6            =6            =6            =6 >       64:              4G           8AL            4d            4b >       65:               .           8GJ             .             . >       66:              4D           8GL            4c            4a >       67:               .          8F#J             .             . >       68:            4GG;           4G;           4B;           4g; >       69:              4C            4G            4e           8gL >       70:               .             .             .           8aJ >       71:              =7            =7            =7            =7 >       72:             8GL            4G            4d            4b >       73:             8FJ             .             .             . >       74:             8EL            4G            4e           4cc >       75:             8DJ             .             .             . >       76:             8CL            4G            4f           4dd >       77:            8BBJ             .             .             . >       78:             8CL            4G           8eL           4ee >       79:             8DJ             .          8f#J             . >       80:              =8            =8            =8            =8 >       81:              4E           8GL           8gL            4b >       82:               .          16AL          8f#J             . >       83:               .         16BJJ             .             . >       84:             4AA            4A           8gL          4cc# >       85:               .             .           8aJ             . >       86:             4D;           4A;          4f#;          4dd; >       87:             8GL            4G            4d           8bL >       88:             8AJ             .             .          8ccJ >       89:              =9            =9            =9            =9 >       90:              4B           8GL            4g           4dd >       91:               .           8dJ             .             . >       92:              4c           8cL            4g           4ee >       93:               .           8BJ             .             . >       94:             4F#            4A            4a          8ddL >       95:               .             .             .          8ccJ >       96:             4G#            4e            4b            4b >       97:             =10           =10           =10           =10 >       98:              4A            2e           8bL           2cc >       99:               .             .          8g#J             . >      100:             4AA             .            4a             . >      101:             4E;           4e;          4g#;           4b; >      102:            4GG#           8eL            4b           4ee >      103:               .           8dJ             .             . >      104:             =11           =11           =11           =11 >      105:            8AAL           8cL            4a           4ee >      106:            8BBJ           8BJ             .             . >      107:             8CL           [4A           8eL           4ee >      108:            8AAJ             .           8cJ             . >      109:              4F          8AL]           8dL            4a >      110:               .          8G#J           8eJ             . >      111:             8EL           8AL            4f           4dd >      112:             8DJ           8BJ             .             . >      113:             =12           =12           =12           =12 >      114:              4E           8G#            4e           4cc >      115:               .            4A             .             . >      116:             4EE             .            4d            4b >      117:               .           8G#             .             . >      118:            4AA;           4A;           4c;           4a; >      119:             4AA           8EL            4a           4cc >      120:               .         8F#XJ             .             . >      121:             =13           =13           =13           =13 >      122:            8BBL          4GnX           8dL            4b >      123:            8C#J             .           8eJ             . >      124:              2D           8dL            4f            4a >      125:               .           8cJ             .             . >      126:               .           4B-           8eL            4g >      127:               .             .           8dJ             . >      128:             4C#            4A           [4e           8aL >      129:               .             .             .           8gJ >      130:             =14           =14           =14           =14 >      131:              4D            4A          8eL]            4f >      132:               .             .           8dJ             . >      133:             4AA            4G           8dL            4e >      134:               .             .          8c#J             . >      135:             4D;         4F#X;           4d;           4d; >      136:             4BB           4F#           8dL            4d >      137:               .             .           8cJ             . >      138:             =15           =15           =15           =15 >      139:              4E            4G           8BL            4g >      140:               .             .           8AJ             . >      141:              4D            4d           8GL            4a >      142:               .             .          8F#J             . >      143:             8GL            4d            4G           4.b >      144:            8F#J             .             .             . >      145:              4E            4e            4g             . >      146:               .             .             .           8cc >      147:             =16           =16           =16           =16 >      148:            8BBL            2d           4f#           4dd >      149:            8AAJ             .             .             . >      150:             4GG             .            4g          8ccL >      151:               .             .             .           8bJ >      152:             8CL           8eL            4g            4a >      153:            8BBJ           8dJ             .             . >      154:             4AA            4c           [4g           8bL >      155:               .             .             .          8ccJ >      156:             =17           =17           =17           =17 >      157:             8DL           8dL           4g]            2a >      158:             8CJ           8eJ             .             . >      159:              4D           8dL           4f#             . >      160:               .           8cJ             .             . >      161:            4GG;           4B;           4d;           4g; >      162:              ==            ==            ==            == >      163:              *-            *-            *-            *- >      164:  !!!hum2abc: -Q '' >      165:  !!!title: @{PC#}. @{OTL@@DE} >      166:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian *** >      167:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&*** >      168:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371*** >      169:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.*** >      170:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >      171:  !!!EED:  Craig Stuart Sapp >      172:  !!!EEV:  2009/05/22 >    ############################ ^^^ chor005.krn ^^^ ############################ >                         (***four global comments truncated due to screen size***) >        Data fields:  >               *Token :: character chorales[c(1,3,5)] >    ############################ vvv chor001.krn vvv ############################# >         1:  !!!COM: Bach, Johann Sebastian >         2:  !!!CDT: 1685/02/21/-1750/07/28/ >         3:  !!!OTL@@DE: Aus meines Herzens Grunde >         4:  !!!OTL@EN:      From the Depths of My Heart >         5:  !!!SCT: BWV 269 >         6:  !!!PC#: 1 >         7:  !!!AGN: chorale >         8:          **kern        **kern        **kern        **kern >         9:          *ICvox        *ICvox        *ICvox        *ICvox >        10:          *Ibass       *Itenor        *Ialto       *Isoprn >        11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >        12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >        13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >        14:             *>A           *>A           *>A           *>A >        15:         *clefF4      *clefGv2       *clefG2       *clefG2 >        16:          *k[f#]        *k[f#]        *k[f#]        *k[f#] >        17:             *G:           *G:           *G:           *G: >        18:             *F:             *             *             * >        19:           *M3/4         *M3/4         *M3/4         *M3/4 >        20:          *MM100        *MM100        *MM100        *MM100 >        21:             4GG            4B            4d            4g >        22:              =1            =1            =1            =1 >        23:              4G            4B            4d            2g >        24:              4E           8cL            4e             . >        25:               .           8BJ             .             . >        26:             4F#            4A            4d           4dd >        27:              =2            =2            =2            =2 >        28:              4G            4G            2d           4.b >        29:              4D           4F#             .             . >        30:               .             .             .            8a >        31:              4E            4G            4B            4g >        32:              =3            =3            =3            =3 >        33:              4C           8cL           8eL           4.g >        34:               .           8BJ            8d             . >        35:            8BBL            4c            8e             . >        36:            8AAJ             .          8f#J            8a >        37:             4GG            4d            4g            4b >        38:              =4            =4            =4            =4 >        39:             2D;           2d;          2f#;           2a; >        40:             4GG            4d            4g            4b >    41-134:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################ ^^^ chor001.krn ^^^ ############################# >     >           (1 more files...) >     >    ############################ vvv chor005.krn vvv ############################# >     1-132:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >       133:             4AA            4G           8dL            4e >       134:               .             .          8c#J             . >       135:             4D;         4F#X;           4d;           4d; >       136:             4BB           4F#           8dL            4d >       137:               .             .           8cJ             . >       138:             =15           =15           =15           =15 >       139:              4E            4G           8BL            4g >       140:               .             .           8AJ             . >       141:              4D            4d           8GL            4a >       142:               .             .          8F#J             . >       143:             8GL            4d            4G           4.b >       144:            8F#J             .             .             . >       145:              4E            4e            4g             . >       146:               .             .             .           8cc >       147:             =16           =16           =16           =16 >       148:            8BBL            2d           4f#           4dd >       149:            8AAJ             .             .             . >       150:             4GG             .            4g          8ccL >       151:               .             .             .           8bJ >       152:             8CL           8eL            4g            4a >       153:            8BBJ           8dJ             .             . >       154:             4AA            4c           [4g           8bL >       155:               .             .             .          8ccJ >       156:             =17           =17           =17           =17 >       157:             8DL           8dL           4g]            2a >       158:             8CJ           8eJ             .             . >       159:              4D           8dL           4f#             . >       160:               .           8cJ             .             . >       161:            4GG;           4B;           4d;           4g; >       162:              ==            ==            ==            == >       163:              *-            *-            *-            *- >       164:  !!!hum2abc: -Q '' >       165:  !!!title: @{PC#}. @{OTL@@DE} >       166:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian *** >       167:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&*** >       168:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371*** >       169:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.*** >       170:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >       171:  !!!EED:  Craig Stuart Sapp >       172:  !!!EEV:  2009/05/22 >    ############################ ^^^ chor005.krn ^^^ ############################# >                          (***four global comments truncated due to screen size***) >     >       humdrumR corpus of three files. >        Data fields:  >               *Token :: character chorales[6:10] >     >           (3 more files...) >     >    ############################# vvv chor010.krn vvv ############################# >      1-60::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >        61:             4AA            4c            4f            4a >        62:            4BB-            4d            4f            4g >        63:              4C          8.cL            4e            4g >        64:               .        16B-Jk             .             . >        65:              =8            =8            =8            =8 >        66:           2.FF;          2.A;          2.c;          2.f; >        67:              ==            ==            ==            == >        68:              *-            *-            *-            *- >        69:  !!!hum2abc: -Q '' >        70:  !!!title: @{PC#}. @{OTL@@DE} >        71:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** >        72:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** >        73:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** >        74:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** >        75:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >        76:  !!!EED:  Craig Stuart Sapp >        77:  !!!EEV:  2009/05/22 >    ############################# ^^^ chor010.krn ^^^ ############################# >    ############################# vvv chor006.krn vvv ############################# >         1:  !!!COM: Bach, Johann Sebastian >         2:  !!!CDT: 1685/02/21/-1750/07/28/ >         3:  !!!OTL@@DE: Aus tiefer Not schrei ich zu dir >         4:  !!!SCT: BWV 38/6 >         5:  !!!PC#: 10 >         6:  !!!AGN: chorale >         7:          **kern        **kern        **kern        **kern >         8:          *ICvox        *ICvox        *ICvox        *ICvox >         9:          *Ibass       *Itenor        *Ialto       *Isoprn >        10:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >        11:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >        12:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >        13:             *>A           *>A           *>A           *>A >        14:         *clefF4      *clefGv2       *clefG2       *clefG2 >        15:            *k[]          *k[]          *k[]          *k[] >        16:             *a:           *a:           *a:           *a: >        17:           *M4/4         *M4/4         *M4/4         *M4/4 >        18:         *met(c)       *met(c)       *met(c)       *met(c) >        19:          *MM100        *MM100        *MM100        *MM100 >        20:             =1-           =1-           =1-           =1- >        21:              2D           2G#            2e            2b >        22:              4C            4A            4e            4e >        23:             4BB            4d           4g#            4b >        24:              =2            =2            =2            =2 >        25:             4AA            4e            4a           4cc >        26:             4BB            4d         8gnXL           8bL >        27:               .             .          8f#J           8aJ >        28:             8CL           8eL            4e            4g >        29:            8BBJ           8dJ             .             . >        30:             4AA            4c           4f#            4a >        31:              =3            =3            =3            =3 >        32:             2E;           2B;          2g#;           2b; >        33:              2E            2e           2g#            2b >        34:              =4            =4            =4            =4 >        35:              4A            4e            4a           4cc >        36:             8GL            4f            4b           4dd >        37:             8FJ             .             .             . >        38:              4E            4g           4cc          8ccL >        39:               .             .             .           8bJ >        40:              4F            4c            4f            4a >    41-100::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################# ^^^ chor006.krn ^^^ ############################# >                           (***four global comments truncated due to screen size***) >     >       humdrumR corpus of five files. >        Data fields:  >               *Token :: character"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Filtering.html","id":"character-indices-for-single-brackets","dir":"Articles","previous_headings":"Indexing > Single-bracket indexing","what":"Character indices (for single-brackets)","title":"Filtering humdrum data","text":"supply humdrum\\(_{\\mathbb{R}}\\) object single-bracket index character string, Humdrum\\(_{\\mathbb{R}}\\) treat string regular expression return files contain match expression data token—even one. example, might interested files use flat notes. Since **kern represents flats “-”, can simply write: Look , five ten chorales contain least one flat. chorales zero flats. Notice still get whole files returned us!","code":"chorales['-'] >    ############################# vvv chor003.krn vvv ############################# >         1:  !!!COM: Bach, Johann Sebastian >         2:  !!!CDT: 1685/02/21/-1750/07/28/ >         3:  !!!OTL@@DE: Ach Gott, vom Himmel sieh darein >         4:  !!!OTL@EN: Oh God, look down from Heaven >         5:  !!!OPR: Cantata BWV 153: Schau, lieber Gott, wie meine Feind >         6:  !!!SCT: BWV 153/1 >         7:  !!!PC#: 3 >         8:  !!!AGN: chorale >         9:          **kern        **kern        **kern        **kern >        10:          *ICvox        *ICvox        *ICvox        *ICvox >        11:          *Ibass       *Itenor        *Ialto       *Isoprn >        12:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >        13:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >        14:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >        15:             *>A           *>A           *>A           *>A >        16:         *clefF4      *clefGv2       *clefG2       *clefG2 >        17:          *k[f#]        *k[f#]        *k[f#]        *k[f#] >        18:             *a:           *a:           *a:           *a: >        19:         !dorian       !dorian       !dorian       !dorian >        20:           *M4/4         *M4/4         *M4/4         *M4/4 >        21:         *met(c)       *met(c)       *met(c)       *met(c) >        22:          *MM100        *MM100        *MM100        *MM100 >        23:              4E            4e           4g#            4b >        24:              =1            =1            =1            =1 >        25:              4A            4e            4a           4cc >        26:              4B            4d           4g#            4b >        27:              4c            4e            4a            4a >        28:             8BL           8dL          8g#L           4ee >        29:             8AJ           8cJ           8aJ             . >        30:              =2            =2            =2            =2 >        31:             4G#            4B            4b          8eeL >        32:               .             .             .          8ddJ >        33:              4A           8cL           8eL           4cc >        34:               .           8dJ          8f#J             . >        35:             4E;           4e;          4g#;           4b; >        36:             4BB            4f           4g#           4dd >        37:              =3            =3            =3            =3 >        38:             8CL            4e            4a           4cc >        39:             8DJ             .             .             . >        40:              4E           8eL           4g#            4b >    41-110::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################# ^^^ chor003.krn ^^^ ############################# >     >           (3 more files...) >     >    ############################# vvv chor010.krn vvv ############################# >      1-60::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >        61:            2AA;           2c;           2e;           2a; >        62:              2A            2e            2a           2cc >        63:              =9            =9            =9            =9 >        64:              4E            4e            4g            4b >        65:             8DL            4e            4g           4cc >        66:             8CJ             .             .             . >        67:             4BB            4d           8gL           4dd >        68:               .             .           8fJ             . >        69:              4C            4c            4e            4g >        70:             =10           =10           =10           =10 >        71:              4D           8F#            4d            4b >        72:               .            4G             .             . >        73:              4D             .            4c            4a >        74:               .           8F#             .             . >        75:            2GG;           2G;           2B;           2g; >        76:             =11           =11           =11           =11 >        77:              2C            2G            2e            2g >        78:             4AA            4A            4e           4cc >        79:              4E           4G#           8eL            4b >        80:               .             .           8dJ             . >        81:             =12           =12           =12           =12 >        82:              4F            4A            4c            4a >        83:              4C            4G            4c            4e >        84:            4BB-            4G           [2d            4g >        85:             4AA            4A             .            4f >        86:             =13           =13           =13           =13 >        87:            4GG#            4B           4d]           1e; >        88:             4AA            4A            4c             . >        89:            2EE;         2G#X;           2B;             . >        90:              ==            ==            ==            == >        91:              *-            *-            *-            *- >        92:  !!!hum2abc: -Q '' >        93:  !!!title: @{PC#}. @{OTL@@DE} >        94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** >        95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** >        96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** >        97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** >        98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >        99:  !!!EED:  Craig Stuart Sapp >       100:  !!!EEV:  2009/05/22 >    ############################# ^^^ chor010.krn ^^^ ############################# >                           (***four global comments truncated due to screen size***) >     >       humdrumR corpus of five files. >        Data fields:  >               *Token :: character"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Filtering.html","id":"double-bracket-indexing","dir":"Articles","previous_headings":"Indexing","what":"Double-bracket indexing","title":"Filtering humdrum data","text":"double-brackets used index within pieces data. Specifically, want work certain spines records within pieces. double-brackets apply filters separately file dataset. double-bracket indexing, can provide two separate arguments, either individually together: first argument index records within file. j second argument, index spines within file. want use j (spine) argument , put comma , indicate skipping . also good practice clear put comma , actually needed. Basically, commands look like : chorales[[, ]] (records) chorales[[  , j]] (spines) chorales[[, j]] (records spines)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Filtering.html","id":"numeric-indices-for-double-brackets","dir":"Articles","previous_headings":"Indexing > Double-bracket indexing","what":"Numeric indices (for double-brackets)","title":"Filtering humdrum data","text":"Numeric values j can given double-bracket humdrum\\(_{\\mathbb{R}}\\) index commands. , number simply matched record numbers file. example, extract first fifty records file : j, number matched spines file (left right). wanted second spine file, ’d write: give indices larger number records spines file, file dropped. example, call get three files back, seven files don’t records 150! (Notice humdrum\\(_{\\mathbb{R}}\\) won’t remove Exclusive interpretation spine spine closing (*-) records…since break humdrum syntax.)","code":"chorales[[1:50, ]] >    ###################### vvv chor001.krn vvv ###################### >         1:  !!!COM: Bach, Johann Sebastian >         2:  !!!CDT: 1685/02/21/-1750/07/28/ >         3:  !!!OTL@@DE: Aus meines Herzens Grunde >         4:  !!!OTL@EN:      From the Depths of My Heart >         5:  !!!SCT: BWV 269 >         6:  !!!PC#: 1 >         7:  !!!AGN: chorale >         8:          **kern        **kern        **kern        **kern >         9:          *ICvox        *ICvox        *ICvox        *ICvox >        10:          *Ibass       *Itenor        *Ialto       *Isoprn >        11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >        12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >        13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >        14:             *>A           *>A           *>A           *>A >        15:         *clefF4      *clefGv2       *clefG2       *clefG2 >        16:          *k[f#]        *k[f#]        *k[f#]        *k[f#] >        17:             *G:           *G:           *G:           *G: >        18:             *F:             *             *             * >        19:           *M3/4         *M3/4         *M3/4         *M3/4 >        20:          *MM100        *MM100        *MM100        *MM100 >        21:             4GG            4B            4d            4g >        22:              =1            =1            =1            =1 >        23:              4G            4B            4d            2g >        24:              4E           8cL            4e             . >        25:               .           8BJ             .             . >        26:             4F#            4A            4d           4dd >        27:              =2            =2            =2            =2 >        28:              4G            4G            2d           4.b >        29:              4D           4F#             .             . >        30:               .             .             .            8a >        31:              4E            4G            4B            4g >        32:              =3            =3            =3            =3 >        33:              4C           8cL           8eL           4.g >        34:               .           8BJ            8d             . >        35:            8BBL            4c            8e             . >        36:            8AAJ             .          8f#J            8a >        37:             4GG            4d            4g            4b >        38:              =4            =4            =4            =4 >        39:             2D;           2d;          2f#;           2a; >        40:             4GG            4d            4g            4b >    41-125::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ###################### ^^^ chor001.krn ^^^ ###################### >     >           (8 more files...) >     >    ###################### vvv chor010.krn vvv ###################### >      1-11::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >        12:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >        13:             *>A           *>A           *>A           *>A >        14:         *clefF4      *clefGv2       *clefG2       *clefG2 >        15:            *k[]          *k[]          *k[]          *k[] >        16:             *a:           *a:           *a:           *a: >        17:           *M4/4         *M4/4         *M4/4         *M4/4 >        18:         *met(c)       *met(c)       *met(c)       *met(c) >        19:          *MM100        *MM100        *MM100        *MM100 >        20:             =1-           =1-           =1-           =1- >        21:              2D           2G#            2e            2b >        22:              4C            4A            4e            4e >        23:             4BB            4d           4g#            4b >        24:              =2            =2            =2            =2 >        25:             4AA            4e            4a           4cc >        26:             4BB            4d         8gnXL           8bL >        27:               .             .          8f#J           8aJ >        28:             8CL           8eL            4e            4g >        29:            8BBJ           8dJ             .             . >        30:             4AA            4c           4f#            4a >        31:              =3            =3            =3            =3 >        32:             2E;           2B;          2g#;           2b; >        33:              2E            2e           2g#            2b >        34:              =4            =4            =4            =4 >        35:              4A            4e            4a           4cc >        36:             8GL            4f            4b           4dd >        37:             8FJ             .             .             . >        38:              4E            4g           4cc          8ccL >        39:               .             .             .           8bJ >        40:              4F            4c            4f            4a >        41:              =5            =5            =5            =5 >        42:              4C           8cL            4e            4g >        43:               .           8BJ             .             . >        44:              4D            4A           8dL            4f >        45:               .             .           8cJ             . >        46:             2E;          2G#;           2B;           2e; >        47:           =6:|!         =6:|!         =6:|!         =6:|! >        48:             *>B           *>B           *>B           *>B >        49:              2c            2A            2e            2a >        50:              4B            4B            4d          4gnX >        91:              *-            *-            *-            *- >    ###################### ^^^ chor010.krn ^^^ ###################### >     >       humdrumR corpus of ten files. >        Data fields:  >               *Token :: character chorales[[ , 2]] >    ############################# vvv chor001.krn vvv ############################# >         1:  !!!COM: Bach, Johann Sebastian >         2:  !!!CDT: 1685/02/21/-1750/07/28/ >         3:  !!!OTL@@DE: Aus meines Herzens Grunde >         4:  !!!OTL@EN:      From the Depths of My Heart >         5:  !!!SCT: BWV 269 >         6:  !!!PC#: 1 >         7:  !!!AGN: chorale >         8:          **kern >         9:          *ICvox >        10:         *Itenor >        11:        *I\"Tenor >        12:       *>[A,A,B] >        13:    *>norep[A,B] >        14:             *>A >        15:        *clefGv2 >        16:          *k[f#] >        17:             *G: >        18:               * >        19:           *M3/4 >        20:          *MM100 >        21:              4B >        22:              =1 >        23:              4B >        24:             8cL >        25:             8BJ >        26:              4A >        27:              =2 >        28:              4G >        29:             4F# >        30:               . >        31:              4G >        32:              =3 >        33:             8cL >        34:             8BJ >        35:              4c >        36:               . >        37:              4d >        38:              =4 >        39:             2d; >        40:              4d >    41-134::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################# ^^^ chor001.krn ^^^ ############################# >     >           (8 more files...) >     >    ############################# vvv chor010.krn vvv ############################# >      1-60::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >        61:             2c; >        62:              2e >        63:              =9 >        64:              4e >        65:              4e >        66:               . >        67:              4d >        68:               . >        69:              4c >        70:             =10 >        71:             8F# >        72:              4G >        73:               . >        74:             8F# >        75:             2G; >        76:             =11 >        77:              2G >        78:              4A >        79:             4G# >        80:               . >        81:             =12 >        82:              4A >        83:              4G >        84:              4G >        85:              4A >        86:             =13 >        87:              4B >        88:              4A >        89:           2G#X; >        90:              == >        91:              *- >        92:  !!!hum2abc: -Q '' >        93:  !!!title: @{PC#}. @{OTL@@DE} >        94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** >        95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** >        96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** >        97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** >        98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >        99:  !!!EED:  Craig Stuart Sapp >       100:  !!!EEV:  2009/05/22 >    ############################# ^^^ chor010.krn ^^^ ############################# >                           (***four global comments truncated due to screen size***) >     >       humdrumR corpus of ten files. >        Data fields:  >               *Token :: character chorales[[150:200, ]] >    ############################ vvv chor005.krn vvv ############################ >        7:    **kern  **kern  **kern  **kern >      150:       4GG       .      4g    8ccL >      151:         .       .       .     8bJ >      152:       8CL     8eL      4g      4a >      153:      8BBJ     8dJ       .       . >      154:       4AA      4c     [4g     8bL >      155:         .       .       .    8ccJ >      156:       =17     =17     =17     =17 >      157:       8DL     8dL     4g]      2a >      158:       8CJ     8eJ       .       . >      159:        4D     8dL     4f#       . >      160:         .     8cJ       .       . >      161:      4GG;     4B;     4d;     4g; >      162:        ==      ==      ==      == >      163:        *-      *-      *-      *- >      164:  !!!hum2abc: -Q '' >      165:  !!!title: @{PC#}. @{OTL@@DE} >      166:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian *** >      167:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&*** >      168:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371*** >      169:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.*** >      170:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >      171:  !!!EED:  Craig Stuart Sapp >      172:  !!!EEV:  2009/05/22 >         :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################ ^^^ chor005.krn ^^^ ############################ >     >           (1 more files...) >     >    ############################ vvv chor008.krn vvv ############################ >         :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >        7:    **kern  **kern  **kern  **kern >      150:        8F      4f    8a-L     4cc >      151:       8GJ       .    8b-J       . >      152:      8A-L      4c     4cc     4ff >      153:        8G       .       .       . >      154:       8A-      4F    8b-L     4ff >      155:      8B-J       .    8a-J       . >      156:       =20     =20     =20     =20 >      157:        4c      4c      4g     4ee >      158:        4C      4c      4g     4ee >      159:        4F      4c      4a     4ff >      160:       4F;     4c;     4a;    4ff; >      161:        ==      ==      ==      == >      162:        *-      *-      *-      *- >      163:  !!!hum2abc: -Q '' >      164:  !!!title: @{PC#}. @{OTL@@DE} >      165:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian *** >      166:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&*** >      167:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371*** >      168:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.*** >      169:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >      170:  !!!EED:  Craig Stuart Sapp >      171:  !!!EEV:  2009/05/22 >    ############################ ^^^ chor008.krn ^^^ ############################ >                        (***eight global comments truncated due to screen size***) >     >       humdrumR corpus of three files. >        Data fields:  >               *Token :: character"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Filtering.html","id":"character-indices-for-double-brackets","dir":"Articles","previous_headings":"Indexing > Double-bracket indexing","what":"Character indices (for double-brackets)","title":"Filtering humdrum data","text":"Character string values j can also given double-bracket humdrum\\(_{\\mathbb{R}}\\) index commands. Humdrum\\(_{\\mathbb{R}}\\) treat string regular expression return records () spines (j) match expression data token—even one. example, let’s () say interesting studying flats. Since **kern represents flats “-”, can find records contain flat calling: single-bracket search flats (previous section) get five files back, five chorales contain flats . However, now see records don’t contain flat completely stripped away, leaving (handful) records least one flat. thing j (spines) looks like get one spine five files. single spines simply ever spine file contained flat. couple things notice! first file, now spine 1 old spine 2, can tell instrument interpretation *Itenor. However, look last five files see *Ibass—new spine 1 actually original spine 1 file. wait, ’s ! dig look files returned us (aren’t shown default), see now third file actually flats four spines, four spines still ! cases may find renumbering spines per file basis confusing, want keep track original spine numbers. Fortunately, option might helpful, learn : try specifying removeEmpty = FALSE:","code":"chorales[['-', ]] >    ############################ vvv chor003.krn vvv ############################ >          1:  !!!COM: Bach, Johann Sebastian >          2:  !!!CDT: 1685/02/21/-1750/07/28/ >          3:  !!!OTL@@DE: Ach Gott, vom Himmel sieh darein >          4:  !!!OTL@EN: Oh God, look down from Heaven >          5:  !!!OPR: Cantata BWV 153: Schau, lieber Gott, wie meine Feind >          6:  !!!SCT: BWV 153/1 >          7:  !!!PC#: 3 >          8:  !!!AGN: chorale >          9:          **kern        **kern        **kern        **kern >         10:          *ICvox        *ICvox        *ICvox        *ICvox >         11:          *Ibass       *Itenor        *Ialto       *Isoprn >         12:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >         13:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >         14:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >         15:             *>A           *>A           *>A           *>A >         16:         *clefF4      *clefGv2       *clefG2       *clefG2 >         17:          *k[f#]        *k[f#]        *k[f#]        *k[f#] >         18:             *a:           *a:           *a:           *a: >         19:         !dorian       !dorian       !dorian       !dorian >         20:           *M4/4         *M4/4         *M4/4         *M4/4 >         21:         *met(c)       *met(c)       *met(c)       *met(c) >         22:          *MM100        *MM100        *MM100        *MM100 >      23-53:        =====1-4      =====1-4      =====1-4      =====1-4 >         54:             *>B           *>B           *>B           *>B >      55-91:        =====5-9      =====5-9      =====5-9      =====5-9 >         92:             8DL           4B-            4g           4ee >         93:               .             .             .             . >         94:             =10           =10           =10           =10 >         95:               .             .             .             . >         96:               .             .             .             . >         97:               .             .             .             . >         98:               .             .             .             . >         99:              ==            ==            ==            == >        100:              *-            *-            *-            *- >        101:  !!!hum2abc: -Q '' >        102:  !!!title: @{PC#}. @{OTL@@DE} >        103:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastia*** >        104:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und *** >        105:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 3*** >        106:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., *** >    107-110:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################ ^^^ chor003.krn ^^^ ############################ >     >           (3 more files...) >     >    ############################ vvv chor010.krn vvv ############################ >       1-26:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >         27:               .             .             .             . >         28:               .             .             .             . >         29:               .             .             .             . >         30:               .             .             .             . >         31:              =3            =3            =3            =3 >         32:               .             .             .             . >         33:               .             .             .             . >         34:              =4            =4            =4            =4 >         35:               .             .             .             . >         36:               .             .             .             . >         37:               .             .             .             . >         38:               .             .             .             . >         39:               .             .             .             . >         40:               .             .             .             . >         41:              =5            =5            =5            =5 >         42:               .             .             .             . >         43:               .             .             .             . >         44:               .             .             .             . >         45:               .             .             .             . >         46:               .             .             .             . >         47:           =6:|!         =6:|!         =6:|!         =6:|! >         48:             *>B           *>B           *>B           *>B >      49-83:      ======7-12    ======7-12    ======7-12    ======7-12 >         84:            4BB-            4G           [2d            4g >         85:               .             .             .             . >         86:             =13           =13           =13           =13 >         87:               .             .             .             . >         88:               .             .             .             . >         89:               .             .             .             . >         90:              ==            ==            ==            == >         91:              *-            *-            *-            *- >         92:  !!!hum2abc: -Q '' >         93:  !!!title: @{PC#}. @{OTL@@DE} >         94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastia*** >         95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und *** >         96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 3*** >         97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., *** >         98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >         99:  !!!EED:  Craig Stuart Sapp >        100:  !!!EEV:  2009/05/22 >    ############################ ^^^ chor010.krn ^^^ ############################ >                         (***nine global comments truncated due to screen size***) >     >       humdrumR corpus of five files. >        Data fields:  >               *Token :: character chorales[[ , '-']] >    ############################# vvv chor003.krn vvv ############################# >         1:  !!!COM: Bach, Johann Sebastian >         2:  !!!CDT: 1685/02/21/-1750/07/28/ >         3:  !!!OTL@@DE: Ach Gott, vom Himmel sieh darein >         4:  !!!OTL@EN: Oh God, look down from Heaven >         5:  !!!OPR: Cantata BWV 153: Schau, lieber Gott, wie meine Feind >         6:  !!!SCT: BWV 153/1 >         7:  !!!PC#: 3 >         8:  !!!AGN: chorale >         9:          **kern >        10:          *ICvox >        11:         *Itenor >        12:        *I\"Tenor >        13:       *>[A,A,B] >        14:    *>norep[A,B] >        15:             *>A >        16:        *clefGv2 >        17:          *k[f#] >        18:             *a: >        19:         !dorian >        20:           *M4/4 >        21:         *met(c) >        22:          *MM100 >        23:              4e >        24:              =1 >        25:              4e >        26:              4d >        27:              4e >        28:             8dL >        29:             8cJ >        30:              =2 >        31:              4B >        32:               . >        33:             8cL >        34:             8dJ >        35:             4e; >        36:              4f >        37:              =3 >        38:              4e >        39:               . >        40:             8eL >    41-110::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################# ^^^ chor003.krn ^^^ ############################# >     >           (3 more files...) >     >    ############################# vvv chor010.krn vvv ############################# >      1-60::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >        61:            2AA; >        62:              2A >        63:              =9 >        64:              4E >        65:             8DL >        66:             8CJ >        67:             4BB >        68:               . >        69:              4C >        70:             =10 >        71:              4D >        72:               . >        73:              4D >        74:               . >        75:            2GG; >        76:             =11 >        77:              2C >        78:             4AA >        79:              4E >        80:               . >        81:             =12 >        82:              4F >        83:              4C >        84:            4BB- >        85:             4AA >        86:             =13 >        87:            4GG# >        88:             4AA >        89:            2EE; >        90:              == >        91:              *- >        92:  !!!hum2abc: -Q '' >        93:  !!!title: @{PC#}. @{OTL@@DE} >        94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** >        95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** >        96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** >        97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** >        98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >        99:  !!!EED:  Craig Stuart Sapp >       100:  !!!EEV:  2009/05/22 >    ############################# ^^^ chor010.krn ^^^ ############################# >                           (***four global comments truncated due to screen size***) >     >       humdrumR corpus of five files. >        Data fields:  >               *Token :: character chorales[[ , '-']][5] >    ############################ vvv chor010.krn vvv ############################ >       1:  !!!COM: Bach, Johann Sebastian >       2:  !!!CDT: 1685/02/21/-1750/07/28/ >       3:  !!!OTL@@DE: Aus tiefer Not schrei ich zu dir >       4:  !!!SCT: BWV 38/6 >       5:  !!!PC#: 10 >       6:  !!!AGN: chorale >       7:          **kern >       8:          *ICvox >       9:          *Ibass >      10:         *I\"Bass >      11:       *>[A,A,B] >      12:    *>norep[A,B] >      13:             *>A >      14:         *clefF4 >      15:            *k[] >      16:             *a: >      17:           *M4/4 >      18:         *met(c) >      19:          *MM100 >      20:             =1- >      21:              2D >      22:              4C >      23:             4BB >      24:              =2 >      25:             4AA >      26:             4BB >      27:               . >      28:             8CL >      29:            8BBJ >      30:             4AA >      31:              =3 >      32:             2E; >      33:              2E >      34:              =4 >      35:              4A >      36:             8GL >      37:             8FJ >      38:              4E >      39:               . >      40:              4F >      41:              =5 >      42:              4C >      43:               . >      44:              4D >      45:               . >      46:             2E; >      47:           =6:|! >      48:             *>B >      49:              2c >      50:              4B >      51:              4A >      52:               . >      53:              =7 >      54:              4G >      55:           8FnXL >      56:             8EJ >      57:              4D >      58:               . >      59:              4E >      60:              =8 >      61:            2AA; >      62:              2A >      63:              =9 >      64:              4E >      65:             8DL >      66:             8CJ >      67:             4BB >      68:               . >      69:              4C >      70:             =10 >      71:              4D >      72:               . >      73:              4D >      74:               . >      75:            2GG; >      76:             =11 >      77:              2C >      78:             4AA >      79:              4E >      80:               . >      81:             =12 >      82:              4F >      83:              4C >      84:            4BB- >      85:             4AA >      86:             =13 >      87:            4GG# >      88:             4AA >      89:            2EE; >      90:              == >      91:              *- >      92:  !!!hum2abc: -Q '' >      93:  !!!title: @{PC#}. @{OTL@@DE} >      94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** >      95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** >      96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** >      97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** >      98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >      99:  !!!EED:  Craig Stuart Sapp >     100:  !!!EEV:  2009/05/22 >    ############################ ^^^ chor010.krn ^^^ ############################ >                         (***four global comments truncated due to screen size***) >        Data fields:  >               *Token :: character chorales[[ , '-']][3] >    ############################ vvv chor006.krn vvv ############################ >       1:  !!!COM: Bach, Johann Sebastian >       2:  !!!CDT: 1685/02/21/-1750/07/28/ >       3:  !!!OTL@@DE: Christus, der ist mein Leben >       4:  !!!SCT: BWV 281 >       5:  !!!PC#: 6 >       6:  !!!AGN: chorale >       7:     **kern    **kern   **kern      **kern >       8:     *ICvox    *ICvox   *ICvox      *ICvox >       9:     *Ibass   *Itenor   *Ialto     *Isoprn >      10:    *I\"Bass  *I\"Tenor  *I\"Alto  *I\"Soprano >      11:    *clefF4  *clefGv2  *clefG2     *clefG2 >      12:     *k[b-]    *k[b-]   *k[b-]      *k[b-] >      13:        *F:       *F:      *F:         *F: >      14:      *M4/4     *M4/4    *M4/4       *M4/4 >      15:    *met(c)   *met(c)  *met(c)     *met(c) >      16:     *MM100    *MM100   *MM100      *MM100 >      17:        4FF        4A       4c          4f >      18:         =1        =1       =1          =1 >      19:         4F        4c       4f          4a >      20:         4E        4c       4g          4g >      21:        4E-        4c       4f          4a >      22:         4D        4d       4f         4b- >      23:         =2        =2       =2          =2 >      24:        8CL        4G      8eL         2cc >      25:         8D         .       8f           . >      26:         8E        4c       8g           . >      27:        8CJ         .      8eJ           . >      28:        4F;       4c;      4f;         4a; >      29:       4BB-       4B-       4f         4dd >      30:         =3        =3       =3          =3 >      31:        4AA        4c      4.f         4cc >      32:        4GG       8dL        .         4b- >      33:          .      8B-J       8e           . >      34:       8FFL        4c      4.f          4a >      35:       8AAJ         .        .           . >      36:         4C        4c        .          4g >      37:          .         .       8e           . >      38:         =4        =4       =4          =4 >      39:       2FF;       2c;      2f;         2a; >      40:         4r       4ry      4ry          4r >      41:         4A        4f      [4a         4cc >      42:         =5        =5       =5          =5 >      43:        4BB        4f     8aL]         4dd >      44:          .         .     [8gJ           . >      45:         4C       [4e     8gL]         4ee >      46:          .         .   16ccLL           . >      47:          .         .  16b-XJJ           . >      48:        8DL      8eL]       4a         4ff >      49:        8FJ       8dJ        .           . >      50:        8AL       [4c       4a         4ee >      51:        8GJ         .        .           . >      52:         =6        =6       =6          =6 >      53:        8FL       4c]       4a         2dd >      54:        8DJ         .        .           . >      55:         4G        4B       4g           . >      56:        4C;       4e;      4g;        4cc; >      57:        4FF        4c      [4f          4a >      58:         =7        =7       =7          =7 >      59:        4GG      4B-X     8fL]         4b- >      60:          .         .      8eJ           . >      61:        4AA        4c       4f          4a >      62:       4BB-        4d       4f          4g >      63:         4C      8.cL       4e          4g >      64:          .    16B-Jk        .           . >      65:         =8        =8       =8          =8 >      66:      2.FF;      2.A;     2.c;        2.f; >      67:         ==        ==       ==          == >      68:         *-        *-       *-          *- >      69:  !!!hum2abc: -Q '' >      70:  !!!title: @{PC#}. @{OTL@@DE} >      71:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** >      72:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** >      73:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** >      74:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** >      75:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >      76:  !!!EED:  Craig Stuart Sapp >      77:  !!!EEV:  2009/05/22 >    ############################ ^^^ chor006.krn ^^^ ############################ >                         (***four global comments truncated due to screen size***) >        Data fields:  >               *Token :: character chorales[[ , '-', removeEmpty = FALSE]] >    ############################# vvv chor003.krn vvv ############################# >         1:  !!!COM: Bach, Johann Sebastian >         2:  !!!CDT: 1685/02/21/-1750/07/28/ >         3:  !!!OTL@@DE: Ach Gott, vom Himmel sieh darein >         4:  !!!OTL@EN: Oh God, look down from Heaven >         5:  !!!OPR: Cantata BWV 153: Schau, lieber Gott, wie meine Feind >         6:  !!!SCT: BWV 153/1 >         7:  !!!PC#: 3 >         8:  !!!AGN: chorale >         9:          **kern        **kern        **kern        **kern >        10:          *ICvox        *ICvox        *ICvox        *ICvox >        11:          *Ibass       *Itenor        *Ialto       *Isoprn >        12:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >        13:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >        14:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >        15:             *>A           *>A           *>A           *>A >        16:         *clefF4      *clefGv2       *clefG2       *clefG2 >        17:          *k[f#]        *k[f#]        *k[f#]        *k[f#] >        18:             *a:           *a:           *a:           *a: >        19:         !dorian       !dorian       !dorian       !dorian >        20:           *M4/4         *M4/4         *M4/4         *M4/4 >        21:         *met(c)       *met(c)       *met(c)       *met(c) >        22:          *MM100        *MM100        *MM100        *MM100 >        23:               .            4e             .             . >        24:              =1            =1            =1            =1 >        25:               .            4e             .             . >        26:               .            4d             .             . >        27:               .            4e             .             . >        28:               .           8dL             .             . >        29:               .           8cJ             .             . >        30:              =2            =2            =2            =2 >        31:               .            4B             .             . >        32:               .             .             .             . >        33:               .           8cL             .             . >        34:               .           8dJ             .             . >        35:               .           4e;             .             . >        36:               .            4f             .             . >        37:              =3            =3            =3            =3 >        38:               .            4e             .             . >        39:               .             .             .             . >        40:               .           8eL             .             . >    41-110::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################# ^^^ chor003.krn ^^^ ############################# >     >           (3 more files...) >     >    ############################# vvv chor010.krn vvv ############################# >      1-60::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >        61:            2AA;             .             .             . >        62:              2A             .             .             . >        63:              =9            =9            =9            =9 >        64:              4E             .             .             . >        65:             8DL             .             .             . >        66:             8CJ             .             .             . >        67:             4BB             .             .             . >        68:               .             .             .             . >        69:              4C             .             .             . >        70:             =10           =10           =10           =10 >        71:              4D             .             .             . >        72:               .             .             .             . >        73:              4D             .             .             . >        74:               .             .             .             . >        75:            2GG;             .             .             . >        76:             =11           =11           =11           =11 >        77:              2C             .             .             . >        78:             4AA             .             .             . >        79:              4E             .             .             . >        80:               .             .             .             . >        81:             =12           =12           =12           =12 >        82:              4F             .             .             . >        83:              4C             .             .             . >        84:            4BB-             .             .             . >        85:             4AA             .             .             . >        86:             =13           =13           =13           =13 >        87:            4GG#             .             .             . >        88:             4AA             .             .             . >        89:            2EE;             .             .             . >        90:              ==            ==            ==            == >        91:              *-            *-            *-            *- >        92:  !!!hum2abc: -Q '' >        93:  !!!title: @{PC#}. @{OTL@@DE} >        94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** >        95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** >        96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** >        97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** >        98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >        99:  !!!EED:  Craig Stuart Sapp >       100:  !!!EEV:  2009/05/22 >    ############################# ^^^ chor010.krn ^^^ ############################# >                           (***four global comments truncated due to screen size***) >     >       humdrumR corpus of five files. >        Data fields:  >               *Token :: character"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Filtering.html","id":"negative-numeric-indices","dir":"Articles","previous_headings":"Indexing","what":"Negative numeric indices","title":"Filtering humdrum data","text":"nifty feature R supply negative numbers indexer, R remove numbers. works humdrum\\(_{\\mathbb{R}}\\) , want files except first file, write: want spines except fourth spine, write want remove first 20 records file: (, humdrum\\(_{\\mathbb{R}}\\) won’t remove Exclusive interpretation spine spine closing (*-) records…since break humdrum syntax.)","code":"chorales[-1] >     >           (7 more files...) >     >    ############################ vvv chor010.krn vvv ############################# >      1-60:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >        61:               .             .         8g#XJ           8bJ >        62:            8C#L            4e            4a          4cc# >        63:             8DJ             .             .             . >        64:             4E;           4e;          4g#;           4b; >        65:             4C#            4e           4a#          4cc# >        66:              =7            =7            =7            =7 >        67:             4BB           8f#           8bL           4dd >        68:               .            4B           8aJ             . >        69:             4C#             .            4g          4cc# >        70:               .           8A#             .             . >        71:             8DL            4B          8f#L            4b >        72:             8GJ             .           8eJ             . >        73:             4F#           4c#           4f#           4a# >        74:              =8            =8            =8            =8 >        75:           2.BB;          2.d;         2.f#;          2.b; >        76:             4C#           4G#           8eL            4e >        77:               .             .           8dJ             . >        78:              =9            =9            =9            =9 >        79:             4F#            4A           4c#            4a >        80:             8EL          8G#L            4d            4b >        81:             8DJ          8F#J             .             . >        82:             4C#           8EL            4e          4cc# >        83:               .           8eJ             .             . >        84:             4BB            4d          8f#L           4dd >        85:               .             .          8g#J             . >        86:             =10           =10           =10           =10 >        87:            8AAL          8c#L            2a           4ee >        88:             8BB            8d             .             . >        89:             8C#            8e             .          8ddL >        90:             8DJ          8f#J             .         8cc#J >        91:             4E;          4g#;           4e;           4b; >        92:             4BB           4f#            4b           4dd >        93:             =11           =11           =11           =11 >        94:            8F#L          8f#L           8aL          4cc# >        95:            8G#J           8eJ          8g#J             . >        96:              4A           8dL           4f#            4b >        97:               .          8c#J             .             . >        98:            8G#L            4B            4e          4.ee >        99:             8EJ             .             .             . >       100:             [4A          8c#L          8f#L             . >       101:               .           8dJ          8g#J           8dd >       102:             =12           =12           =12           =12 >       103:            8AL]           4.e            2a         8cc#L >       104:            8G#J             .             .            8b >       105:             4F#             .             .            8a >       106:               .            8d             .           8bJ >       107:             8EL          8c#L            4a          4cc# >       108:             8DJ          8f#J             .             . >       109:              4E           8BL           4g#            4b >       110:               .          16eL             .             . >       111:               .         16dJJ             .             . >       112:             =13           =13           =13           =13 >       113:           2.AA;         2.c#;          2.e;          2.a; >       114:              ==            ==            ==            == >       115:              *-            *-            *-            *- >       116:  !!!hum2abc: -Q '' >       117:  !!!title: @{PC#}. @{OTL@@DE} >       118:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian *** >       119:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&*** >       120:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371*** >       121:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.*** >       122:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >       123:  !!!EED:  Craig Stuart Sapp >       124:  !!!EEV:  2009/05/22 >    ############################ ^^^ chor010.krn ^^^ ############################# >    ############################ vvv chor002.krn vvv ############################# >         1:  !!!COM: Bach, Johann Sebastian >         2:  !!!CDT: 1685/02/21/-1750/07/28/ >         3:  !!!OTL@@DE: Aus tiefer Not schrei ich zu dir >         4:  !!!SCT: BWV 38/6 >         5:  !!!PC#: 10 >         6:  !!!AGN: chorale >         7:          **kern        **kern        **kern        **kern >         8:          *ICvox        *ICvox        *ICvox        *ICvox >         9:          *Ibass       *Itenor        *Ialto       *Isoprn >        10:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >        11:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >        12:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >        13:             *>A           *>A           *>A           *>A >        14:         *clefF4      *clefGv2       *clefG2       *clefG2 >        15:            *k[]          *k[]          *k[]          *k[] >        16:             *a:           *a:           *a:           *a: >        17:           *M4/4         *M4/4         *M4/4         *M4/4 >        18:         *met(c)       *met(c)       *met(c)       *met(c) >        19:          *MM100        *MM100        *MM100        *MM100 >        20:             =1-           =1-           =1-           =1- >        21:              2D           2G#            2e            2b >        22:              4C            4A            4e            4e >        23:             4BB            4d           4g#            4b >        24:              =2            =2            =2            =2 >        25:             4AA            4e            4a           4cc >        26:             4BB            4d         8gnXL           8bL >        27:               .             .          8f#J           8aJ >        28:             8CL           8eL            4e            4g >        29:            8BBJ           8dJ             .             . >        30:             4AA            4c           4f#            4a >        31:              =3            =3            =3            =3 >        32:             2E;           2B;          2g#;           2b; >        33:              2E            2e           2g#            2b >        34:              =4            =4            =4            =4 >        35:              4A            4e            4a           4cc >        36:             8GL            4f            4b           4dd >        37:             8FJ             .             .             . >        38:              4E            4g           4cc          8ccL >        39:               .             .             .           8bJ >        40:              4F            4c            4f            4a >    41-100:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################ ^^^ chor002.krn ^^^ ############################# >                          (***four global comments truncated due to screen size***) >     >       humdrumR corpus of nine files. >        Data fields:  >               *Token :: character chorales[[ , -4]] >    ############################# vvv chor001.krn vvv ############################# >         1:  !!!COM: Bach, Johann Sebastian >         2:  !!!CDT: 1685/02/21/-1750/07/28/ >         3:  !!!OTL@@DE: Aus meines Herzens Grunde >         4:  !!!OTL@EN:      From the Depths of My Heart >         5:  !!!SCT: BWV 269 >         6:  !!!PC#: 1 >         7:  !!!AGN: chorale >         8:          **kern        **kern        **kern >         9:          *ICvox        *ICvox        *ICvox >        10:          *Ibass       *Itenor        *Ialto >        11:         *I\"Bass      *I\"Tenor       *I\"Alto >        12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >        13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >        14:             *>A           *>A           *>A >        15:         *clefF4      *clefGv2       *clefG2 >        16:          *k[f#]        *k[f#]        *k[f#] >        17:             *G:           *G:           *G: >        18:             *F:             *             * >        19:           *M3/4         *M3/4         *M3/4 >        20:          *MM100        *MM100        *MM100 >        21:             4GG            4B            4d >        22:              =1            =1            =1 >        23:              4G            4B            4d >        24:              4E           8cL            4e >        25:               .           8BJ             . >        26:             4F#            4A            4d >        27:              =2            =2            =2 >        28:              4G            4G            2d >        29:              4D           4F#             . >        30:               .             .             . >        31:              4E            4G            4B >        32:              =3            =3            =3 >        33:              4C           8cL           8eL >        34:               .           8BJ            8d >        35:            8BBL            4c            8e >        36:            8AAJ             .          8f#J >        37:             4GG            4d            4g >        38:              =4            =4            =4 >        39:             2D;           2d;          2f#; >        40:             4GG            4d            4g >    41-134::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################# ^^^ chor001.krn ^^^ ############################# >     >           (8 more files...) >     >    ############################# vvv chor010.krn vvv ############################# >      1-60::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >        61:            2AA;           2c;           2e; >        62:              2A            2e            2a >        63:              =9            =9            =9 >        64:              4E            4e            4g >        65:             8DL            4e            4g >        66:             8CJ             .             . >        67:             4BB            4d           8gL >        68:               .             .           8fJ >        69:              4C            4c            4e >        70:             =10           =10           =10 >        71:              4D           8F#            4d >        72:               .            4G             . >        73:              4D             .            4c >        74:               .           8F#             . >        75:            2GG;           2G;           2B; >        76:             =11           =11           =11 >        77:              2C            2G            2e >        78:             4AA            4A            4e >        79:              4E           4G#           8eL >        80:               .             .           8dJ >        81:             =12           =12           =12 >        82:              4F            4A            4c >        83:              4C            4G            4c >        84:            4BB-            4G           [2d >        85:             4AA            4A             . >        86:             =13           =13           =13 >        87:            4GG#            4B           4d] >        88:             4AA            4A            4c >        89:            2EE;         2G#X;           2B; >        90:              ==            ==            == >        91:              *-            *-            *- >        92:  !!!hum2abc: -Q '' >        93:  !!!title: @{PC#}. @{OTL@@DE} >        94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** >        95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** >        96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** >        97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** >        98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >        99:  !!!EED:  Craig Stuart Sapp >       100:  !!!EEV:  2009/05/22 >    ############################# ^^^ chor010.krn ^^^ ############################# >                           (***four global comments truncated due to screen size***) >     >       humdrumR corpus of ten files. >        Data fields:  >               *Token :: character chorales[[-1:-20, ]] >    ############################# vvv chor001.krn vvv ############################# >         8:    **kern  **kern  **kern  **kern >        21:       4GG      4B      4d      4g >        22:        =1      =1      =1      =1 >        23:        4G      4B      4d      2g >        24:        4E     8cL      4e       . >        25:         .     8BJ       .       . >        26:       4F#      4A      4d     4dd >        27:        =2      =2      =2      =2 >        28:        4G      4G      2d     4.b >        29:        4D     4F#       .       . >        30:         .       .       .      8a >        31:        4E      4G      4B      4g >        32:        =3      =3      =3      =3 >        33:        4C     8cL     8eL     4.g >        34:         .     8BJ      8d       . >        35:      8BBL      4c      8e       . >        36:      8AAJ       .    8f#J      8a >        37:       4GG      4d      4g      4b >        38:        =4      =4      =4      =4 >        39:       2D;     2d;    2f#;     2a; >        40:       4GG      4d      4g      4b >        41:        =5      =5      =5      =5 >        42:      4FF#      4A      4d     2dd >        43:       4GG      4B      4e       . >        44:       4AA      4c     4f#     4cc >        45:        =6      =6      =6      =6 >        46:       4BB      4d      2g      4b >        47:        4C      4e       .      2a >        48:        4D     8dL     4f#       . >        49:         .     8cJ       .       . >        50:        =7      =7      =7      =7 >        51:      2GG;     2B;     2d;     2g; >        52:      =:|!    =:|!    =:|!    =:|! >        53:       *>B     *>B     *>B     *>B >        54:       4GG      4d     [4g      4b >        55:        =8      =8      =8      =8 >        56:       4GG      4d    8gL]      4b >        57:         .       .    8f#J       . >        58:       4AA      4c     8eL     4cc >        59:         .       .    8f#J       . >    60-134::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################# ^^^ chor001.krn ^^^ ############################# >     >           (8 more files...) >     >    ############################# vvv chor010.krn vvv ############################# >      7-60::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >        61:      2AA;     2c;     2e;     2a; >        62:        2A      2e      2a     2cc >        63:        =9      =9      =9      =9 >        64:        4E      4e      4g      4b >        65:       8DL      4e      4g     4cc >        66:       8CJ       .       .       . >        67:       4BB      4d     8gL     4dd >        68:         .       .     8fJ       . >        69:        4C      4c      4e      4g >        70:       =10     =10     =10     =10 >        71:        4D     8F#      4d      4b >        72:         .      4G       .       . >        73:        4D       .      4c      4a >        74:         .     8F#       .       . >        75:      2GG;     2G;     2B;     2g; >        76:       =11     =11     =11     =11 >        77:        2C      2G      2e      2g >        78:       4AA      4A      4e     4cc >        79:        4E     4G#     8eL      4b >        80:         .       .     8dJ       . >        81:       =12     =12     =12     =12 >        82:        4F      4A      4c      4a >        83:        4C      4G      4c      4e >        84:      4BB-      4G     [2d      4g >        85:       4AA      4A       .      4f >        86:       =13     =13     =13     =13 >        87:      4GG#      4B     4d]     1e; >        88:       4AA      4A      4c       . >        89:      2EE;   2G#X;     2B;       . >        90:        ==      ==      ==      == >        91:        *-      *-      *-      *- >        92:  !!!hum2abc: -Q '' >        93:  !!!title: @{PC#}. @{OTL@@DE} >        94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** >        95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** >        96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** >        97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** >        98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >        99:  !!!EED:  Craig Stuart Sapp >       100:  !!!EEV:  2009/05/22 >    ############################# ^^^ chor010.krn ^^^ ############################# >                           (***four global comments truncated due to screen size***) >     >       humdrumR corpus of ten files. >        Data fields:  >               *Token :: character"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Filtering.html","id":"general-filtering","dir":"Articles","previous_headings":"","what":"General Filtering","title":"Filtering humdrum data","text":"indexing commands (previous sections) get far. want precise filtering, use subset method humdrum\\(_{\\mathbb{R}}\\) data. subset.humdrumR works exactly like within.humdrumR. However, expression(s) give must evaluate logical vector (TRUE FALSE) length input. (get error otherwise.) subset.humdrumR take logical result filter data matches FALSE. can reproduce functionality [] [[]] indexing operators (previous section) using subset: , now can filter based arbitrary criteria want. example, extract tokens odd numbered spines odd numbered records even numbered spines even numbered records. ’ll use Rs modulo command %% separate even odd numbers (odd %% 2 == 1, even %% 2 == 0). ever want ? Probably . However, returning flats, study, lets grab flat notes: Woh, ’re seeing couple B flats files! , know lot flats fourth file (losing files flats):","code":"subset(chorales, Spine == 1) >    ############################# vvv chor001.krn vvv ############################# >         1:  !!!COM: Bach, Johann Sebastian >         2:  !!!CDT: 1685/02/21/-1750/07/28/ >         3:  !!!OTL@@DE: Aus meines Herzens Grunde >         4:  !!!OTL@EN:      From the Depths of My Heart >         5:  !!!SCT: BWV 269 >         6:  !!!PC#: 1 >         7:  !!!AGN: chorale >         8:          **kern        **kern        **kern        **kern >         9:          *ICvox        *ICvox        *ICvox        *ICvox >        10:          *Ibass       *Itenor        *Ialto       *Isoprn >        11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >        12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >        13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >        14:             *>A           *>A           *>A           *>A >        15:         *clefF4      *clefGv2       *clefG2       *clefG2 >        16:          *k[f#]        *k[f#]        *k[f#]        *k[f#] >        17:             *G:           *G:           *G:           *G: >        18:             *F:             *             *             * >        19:           *M3/4         *M3/4         *M3/4         *M3/4 >        20:          *MM100        *MM100        *MM100        *MM100 >        21:             4GG             .             .             . >        22:              =1            =1            =1            =1 >        23:              4G             .             .             . >        24:              4E             .             .             . >        25:               .             .             .             . >        26:             4F#             .             .             . >        27:              =2            =2            =2            =2 >        28:              4G             .             .             . >        29:              4D             .             .             . >        30:               .             .             .             . >        31:              4E             .             .             . >        32:              =3            =3            =3            =3 >        33:              4C             .             .             . >        34:               .             .             .             . >        35:            8BBL             .             .             . >        36:            8AAJ             .             .             . >        37:             4GG             .             .             . >        38:              =4            =4            =4            =4 >        39:             2D;             .             .             . >        40:             4GG             .             .             . >    41-134::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################# ^^^ chor001.krn ^^^ ############################# >     >           (8 more files...) >     >    ############################# vvv chor010.krn vvv ############################# >      1-60::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >        61:            2AA;             .             .             . >        62:              2A             .             .             . >        63:              =9            =9            =9            =9 >        64:              4E             .             .             . >        65:             8DL             .             .             . >        66:             8CJ             .             .             . >        67:             4BB             .             .             . >        68:               .             .             .             . >        69:              4C             .             .             . >        70:             =10           =10           =10           =10 >        71:              4D             .             .             . >        72:               .             .             .             . >        73:              4D             .             .             . >        74:               .             .             .             . >        75:            2GG;             .             .             . >        76:             =11           =11           =11           =11 >        77:              2C             .             .             . >        78:             4AA             .             .             . >        79:              4E             .             .             . >        80:               .             .             .             . >        81:             =12           =12           =12           =12 >        82:              4F             .             .             . >        83:              4C             .             .             . >        84:            4BB-             .             .             . >        85:             4AA             .             .             . >        86:             =13           =13           =13           =13 >        87:            4GG#             .             .             . >        88:             4AA             .             .             . >        89:            2EE;             .             .             . >        90:              ==            ==            ==            == >        91:              *-            *-            *-            *- >        92:  !!!hum2abc: -Q '' >        93:  !!!title: @{PC#}. @{OTL@@DE} >        94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** >        95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** >        96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** >        97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** >        98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >        99:  !!!EED:  Craig Stuart Sapp >       100:  !!!EEV:  2009/05/22 >    ############################# ^^^ chor010.krn ^^^ ############################# >                           (***four global comments truncated due to screen size***) >     >       humdrumR corpus of ten files. >        Data fields:  >               *Token :: character subset(chorales, (Record %% 2 == 0) == (Spine %% 2 == 0) ) >    ############################# vvv chor001.krn vvv ############################# >         1:  !!!COM: Bach, Johann Sebastian >         2:  !!!CDT: 1685/02/21/-1750/07/28/ >         3:  !!!OTL@@DE: Aus meines Herzens Grunde >         4:  !!!OTL@EN:      From the Depths of My Heart >         5:  !!!SCT: BWV 269 >         6:  !!!PC#: 1 >         7:  !!!AGN: chorale >         8:          **kern        **kern        **kern        **kern >         9:          *ICvox        *ICvox        *ICvox        *ICvox >        10:          *Ibass       *Itenor        *Ialto       *Isoprn >        11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >        12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >        13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >        14:             *>A           *>A           *>A           *>A >        15:         *clefF4      *clefGv2       *clefG2       *clefG2 >        16:          *k[f#]        *k[f#]        *k[f#]        *k[f#] >        17:             *G:           *G:           *G:           *G: >        18:             *F:             *             *             * >        19:           *M3/4         *M3/4         *M3/4         *M3/4 >        20:          *MM100        *MM100        *MM100        *MM100 >        21:             4GG             .            4d             . >        22:              =1            =1            =1            =1 >        23:              4G             .            4d             . >        24:               .           8cL             .             . >        25:               .             .             .             . >        26:               .            4A             .           4dd >        27:              =2            =2            =2            =2 >        28:               .            4G             .           4.b >        29:              4D             .             .             . >        30:               .             .             .            8a >        31:              4E             .            4B             . >        32:              =3            =3            =3            =3 >        33:              4C             .           8eL             . >        34:               .           8BJ             .             . >        35:            8BBL             .            8e             . >        36:               .             .             .            8a >        37:             4GG             .            4g             . >        38:              =4            =4            =4            =4 >        39:             2D;             .          2f#;             . >        40:               .            4d             .            4b >    41-134::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################# ^^^ chor001.krn ^^^ ############################# >     >           (8 more files...) >     >    ############################# vvv chor010.krn vvv ############################# >      1-60::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >        61:            2AA;             .           2e;             . >        62:               .            2e             .           2cc >        63:              =9            =9            =9            =9 >        64:               .            4e             .            4b >        65:             8DL             .            4g             . >        66:               .             .             .             . >        67:             4BB             .           8gL             . >        68:               .             .             .             . >        69:              4C             .            4e             . >        70:             =10           =10           =10           =10 >        71:              4D             .            4d             . >        72:               .            4G             .             . >        73:              4D             .            4c             . >        74:               .           8F#             .             . >        75:            2GG;             .           2B;             . >        76:             =11           =11           =11           =11 >        77:              2C             .            2e             . >        78:               .            4A             .           4cc >        79:              4E             .           8eL             . >        80:               .             .             .             . >        81:             =12           =12           =12           =12 >        82:               .            4A             .            4a >        83:              4C             .            4c             . >        84:               .            4G             .            4g >        85:             4AA             .             .             . >        86:             =13           =13           =13           =13 >        87:            4GG#             .           4d]             . >        88:               .            4A             .             . >        89:            2EE;             .           2B;             . >        90:              ==            ==            ==            == >        91:              *-            *-            *-            *- >        92:  !!!hum2abc: -Q '' >        93:  !!!title: @{PC#}. @{OTL@@DE} >        94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** >        95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** >        96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** >        97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** >        98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >        99:  !!!EED:  Craig Stuart Sapp >       100:  !!!EEV:  2009/05/22 >    ############################# ^^^ chor010.krn ^^^ ############################# >                           (***four global comments truncated due to screen size***) >     >       humdrumR corpus of ten files. >        Data fields:  >               *Token :: character subset(chorales, Token %~% '-') >    ############################ vvv chor003.krn vvv ############################ >          1:  !!!COM: Bach, Johann Sebastian >          2:  !!!CDT: 1685/02/21/-1750/07/28/ >          3:  !!!OTL@@DE: Ach Gott, vom Himmel sieh darein >          4:  !!!OTL@EN: Oh God, look down from Heaven >          5:  !!!OPR: Cantata BWV 153: Schau, lieber Gott, wie meine Feind >          6:  !!!SCT: BWV 153/1 >          7:  !!!PC#: 3 >          8:  !!!AGN: chorale >          9:          **kern        **kern        **kern        **kern >         10:          *ICvox        *ICvox        *ICvox        *ICvox >         11:          *Ibass       *Itenor        *Ialto       *Isoprn >         12:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >         13:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >         14:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >         15:             *>A           *>A           *>A           *>A >         16:         *clefF4      *clefGv2       *clefG2       *clefG2 >         17:          *k[f#]        *k[f#]        *k[f#]        *k[f#] >         18:             *a:           *a:           *a:           *a: >         19:         !dorian       !dorian       !dorian       !dorian >         20:           *M4/4         *M4/4         *M4/4         *M4/4 >         21:         *met(c)       *met(c)       *met(c)       *met(c) >         22:          *MM100        *MM100        *MM100        *MM100 >      23-53:        =====1-4      =====1-4      =====1-4      =====1-4 >         54:             *>B           *>B           *>B           *>B >      55-91:        =====5-9      =====5-9      =====5-9      =====5-9 >         92:               .           4B-             .             . >         93:               .             .             .             . >         94:             =10           =10           =10           =10 >         95:               .             .             .             . >         96:               .             .             .             . >         97:               .             .             .             . >         98:               .             .             .             . >         99:              ==            ==            ==            == >        100:              *-            *-            *-            *- >        101:  !!!hum2abc: -Q '' >        102:  !!!title: @{PC#}. @{OTL@@DE} >        103:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastia*** >        104:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und *** >        105:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 3*** >        106:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., *** >    107-110:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################ ^^^ chor003.krn ^^^ ############################ >     >           (3 more files...) >     >    ############################ vvv chor010.krn vvv ############################ >       1-26:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >         27:               .             .             .             . >         28:               .             .             .             . >         29:               .             .             .             . >         30:               .             .             .             . >         31:              =3            =3            =3            =3 >         32:               .             .             .             . >         33:               .             .             .             . >         34:              =4            =4            =4            =4 >         35:               .             .             .             . >         36:               .             .             .             . >         37:               .             .             .             . >         38:               .             .             .             . >         39:               .             .             .             . >         40:               .             .             .             . >         41:              =5            =5            =5            =5 >         42:               .             .             .             . >         43:               .             .             .             . >         44:               .             .             .             . >         45:               .             .             .             . >         46:               .             .             .             . >         47:           =6:|!         =6:|!         =6:|!         =6:|! >         48:             *>B           *>B           *>B           *>B >      49-83:      ======7-12    ======7-12    ======7-12    ======7-12 >         84:            4BB-             .             .             . >         85:               .             .             .             . >         86:             =13           =13           =13           =13 >         87:               .             .             .             . >         88:               .             .             .             . >         89:               .             .             .             . >         90:              ==            ==            ==            == >         91:              *-            *-            *-            *- >         92:  !!!hum2abc: -Q '' >         93:  !!!title: @{PC#}. @{OTL@@DE} >         94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastia*** >         95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und *** >         96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 3*** >         97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., *** >         98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >         99:  !!!EED:  Craig Stuart Sapp >        100:  !!!EEV:  2009/05/22 >    ############################ ^^^ chor010.krn ^^^ ############################ >                         (***nine global comments truncated due to screen size***) >     >       humdrumR corpus of five files. >        Data fields:  >               *Token :: character subset(chorales, Token %~% '-')[4] >    ############################ vvv chor008.krn vvv ############################ >        1:  !!!COM: Bach, Johann Sebastian >        2:  !!!CDT: 1685/02/21/-1750/07/28/ >        3:  !!!OTL@@DE: Freuet euch, ihr Christen alle >        4:  !!!SCT: BWV 40/8 >        5:  !!!PC#: 8 >        6:  !!!AGN: chorale >        7:        **kern      **kern      **kern      **kern >        8:        *ICvox      *ICvox      *ICvox      *ICvox >        9:        *Ibass     *Itenor      *Ialto     *Isoprn >       10:       *I\"Bass    *I\"Tenor     *I\"Alto  *I\"Soprano >       11:       *clefF4    *clefGv2     *clefG2     *clefG2 >       12:    *k[b-e-a-]  *k[b-e-a-]  *k[b-e-a-]  *k[b-e-a-] >       13:        *f:dor      *f:dor      *f:dor      *f:dor >       14:         *M4/4       *M4/4       *M4/4       *M4/4 >       15:       *met(c)     *met(c)     *met(c)     *met(c) >       16:        *MM100      *MM100      *MM100      *MM100 >       17:           =1-         =1-         =1-         =1- >       18:             .         4A-           .           . >       19:           4E-           .           .           . >       20:           4D-         4B-           .         4b- >       21:             .           .           .           . >       22:             .           .           .         4a- >       23:            =2          =2          =2          =2 >       24:          4BB-         4d-           .           . >       25:             .           .           .           . >       26:             .           .           .           . >       27:             .        8B-J           .           . >       28:             .         4A-           .           . >       29:             .        4A-;           .           . >       30:            =3          =3          =3          =3 >       31:             .           .           .        4.a- >       32:          8E-L           .           .           . >       33:          8D-J         8B-           .         8b- >       34:             .         4e-         4a-           . >       35:         8BB-J           .           .           . >       36:          4AA-         4e-         4a-           . >       37:            =4          =4          =4          =4 >       38:           4D-           .        8a-L        4.b- >       39:             .           .           .           . >       40:           4E-        8e-L           .           . >       41:             .       8d-XJ           .         8a- >       42:         2AA-;           .        2e-;        2a-; >       43:            =5          =5          =5          =5 >       44:           4D-         4d-           .         4a- >       45:             .         4d-           .         4b- >       46:         8BB-J           .           .           . >       47:             .           .           .         4b- >       48:           4D-           .           .         4a- >       49:             .        8A-J           .           . >       50:            =6          =6          =6          =6 >       51:          4BB-         4d-           .           . >       52:             .           .           .           . >       53:             .        8B-J           .           . >       54:             .        2A-;           .           . >       55:            =7          =7          =7          =7 >       56:             .           .           .           . >       57:             .        8B-J           .           . >       58:             .           .           .           . >       59:             .           .           .           . >       60:         8BB-L         4B-           .        4dd- >       61:             .           .           .           . >       62:           8D-         4B-           .        4dd- >       63:         8BB-J           .           .           . >       64:            =8          =8          =8          =8 >       65:          8E-L         4B-           .         4b- >       66:             .           .       8a-XJ           . >       67:             .         4e-        8b-L         4b- >       68:          8E-J           .           .           . >       69:           4A-         4e-         4a-           . >       70:          4A-;        4e-;        4a-;           . >       71:            =9          =9          =9          =9 >       72:          8D-L         4d-           .         4a- >       73:           8E-           .           .           . >       74:             .         4d-           .         4a- >       75:          8D-J           .           .           . >       76:         8BB-L           .         4b-        4dd- >       77:             .           .           .           . >       78:           8D-           .         4b-        4dd- >       79:         8BB-J           .           .           . >       80:           =10         =10         =10         =10 >       81:          8E-L         4g-         4b-           . >       82:             .           .           .           . >       83:             .           .           .           . >       84:             .        8e-J           .           . >       85:         2BB-;        2d-;           .        2b-; >       86:           =11         =11         =11         =11 >       87:           4B-           .           .           . >       88:           4A-           .           .        4a-X >       89:             .         4B-           .         4b- >       90:             .           .           .           . >       91:             .           .           .         4a- >       92:           =12         =12         =12         =12 >       93:          4BB-         4d-           .           . >       94:             .           .           .           . >       95:             .        8B-J           .           . >       96:             .        2A-;           .           . >       97:           =13         =13         =13         =13 >       98:             .           .         4a-           . >       99:             .           .           .           . >      100:          8AA-           .         4a-           . >      101:         8BB-J           .           .           . >      102:             .           .           .       4ee-X >      103:             .           .           .           . >      104:           8E-           .           .        4ee- >      105:             .           .           .           . >      106:           =14         =14         =14         =14 >      107:             .           .           .           . >      108:             .           .        8a-J           . >      109:             .           .           .           . >      110:             .           .           .           . >      111:             .           .           .           . >      112:             .           .           .           . >      113:           =15         =15         =15         =15 >      114:             .           .           .           . >      115:           8E-           .           .           . >      116:           8D-           .           .           . >      117:             .           .           .           . >      118:          4BB-         4B-           .        4dd- >      119:             .           .           .           . >      120:             .         4E-         4a-           . >      121:          8D-J           .           .           . >      122:           =16         =16         =16         =16 >      123:           4E-        4.e-        8a-L        4.b- >      124:             .           .           .           . >      125:           4E-           .           .           . >      126:             .         8d-           .         8a- >      127:          4AA-           .         4e-         4a- >      128:         4AA-;           .        4e-;        4a-; >      129:           =17         =17         =17         =17 >      130:          8D-L         4d-           .         4a- >      131:           8E-           .           .           . >      132:           8D-         4d-           .         4a- >      133:             .           .           .           . >      134:         8BB-L           .         4b-        4dd- >      135:             .           .           .           . >      136:           8D-           .         4b-        4dd- >      137:         8BB-J           .           .           . >      138:           =18         =18         =18         =18 >      139:          8E-L         4e-           .         4b- >      140:             .           .           .           . >      141:           8E-         4e-           .         4b- >      142:          8D-J           .           .           . >      143:             .           .           .        4ee- >      144:           8D-           .           .           . >      145:           8E-           .           .        4ee- >      146:             .           .           .           . >      147:           =19         =19         =19         =19 >      148:             .           .        8a-L           . >      149:             .           .           .           . >      150:             .           .        8a-L           . >      151:             .           .        8b-J           . >      152:          8A-L           .           .           . >      153:             .           .           .           . >      154:           8A-           .        8b-L           . >      155:          8B-J           .        8a-J           . >      156:           =20         =20         =20         =20 >      157:             .           .           .           . >      158:             .           .           .           . >      159:             .           .           .           . >      160:             .           .           .           . >      161:            ==          ==          ==          == >      162:            *-          *-          *-          *- >      163:  !!!hum2abc: -Q '' >      164:  !!!title: @{PC#}. @{OTL@@DE} >      165:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian *** >      166:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&*** >      167:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371*** >      168:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.*** >      169:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >      170:  !!!EED:  Craig Stuart Sapp >      171:  !!!EEV:  2009/05/22 >    ############################ ^^^ chor008.krn ^^^ ############################ >                         (***four global comments truncated due to screen size***) >        Data fields:  >               *Token :: character"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Filtering.html","id":"subseting-by-group","dir":"Articles","previous_headings":"General Filtering","what":"Subseting by Group","title":"Filtering humdrum data","text":"Since subset.humdrumR makes use [within.humdrumR], can use within.humdrumR’s special options, including group . can useful way get context searches. example, let’s say want find flats , want see whole bar music contains flat. can grouping Bar field (File field). ’ll want say “within bar, flats, return TRUE whole bar, else return FALSE whole bar.” can use function get match, fill option copy result whole bar. enough context ? Maybe group bars even-odd pairs:","code":"subset(chorales, fill = any(Token %~% '-'), by = list(File, Bar)) >    ############################ vvv chor003.krn vvv ############################ >          1:  !!!COM: Bach, Johann Sebastian >          2:  !!!CDT: 1685/02/21/-1750/07/28/ >          3:  !!!OTL@@DE: Ach Gott, vom Himmel sieh darein >          4:  !!!OTL@EN: Oh God, look down from Heaven >          5:  !!!OPR: Cantata BWV 153: Schau, lieber Gott, wie meine Feind >          6:  !!!SCT: BWV 153/1 >          7:  !!!PC#: 3 >          8:  !!!AGN: chorale >          9:          **kern        **kern        **kern        **kern >         10:          *ICvox        *ICvox        *ICvox        *ICvox >         11:          *Ibass       *Itenor        *Ialto       *Isoprn >         12:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >         13:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >         14:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >         15:             *>A           *>A           *>A           *>A >         16:         *clefF4      *clefGv2       *clefG2       *clefG2 >         17:          *k[f#]        *k[f#]        *k[f#]        *k[f#] >         18:             *a:           *a:           *a:           *a: >         19:         !dorian       !dorian       !dorian       !dorian >         20:           *M4/4         *M4/4         *M4/4         *M4/4 >         21:         *met(c)       *met(c)       *met(c)       *met(c) >         22:          *MM100        *MM100        *MM100        *MM100 >      23-53:        =====1-4      =====1-4      =====1-4      =====1-4 >         54:             *>B           *>B           *>B           *>B >      55-86:        =====5-9      =====5-9      =====5-9      =====5-9 >         87:             4G#            4B            4e           4ee >         88:             8AL            4A            4e           4cc >         89:             8GJ             .             .             . >         90:             8FL            4A            4f           4dd >         91:             8EJ             .             .             . >         92:             8DL           4B-            4g           4ee >         93:            8C#J             .             .             . >         94:             =10           =10           =10           =10 >         95:               .             .             .             . >         96:               .             .             .             . >         97:               .             .             .             . >         98:               .             .             .             . >         99:              ==            ==            ==            == >        100:              *-            *-            *-            *- >        101:  !!!hum2abc: -Q '' >    102-110:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################ ^^^ chor003.krn ^^^ ############################ >     >           (3 more files...) >     >    ############################ vvv chor010.krn vvv ############################ >       1-28:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >         29:               .             .             .             . >         30:               .             .             .             . >         31:              =3            =3            =3            =3 >         32:               .             .             .             . >         33:               .             .             .             . >         34:              =4            =4            =4            =4 >         35:               .             .             .             . >         36:               .             .             .             . >         37:               .             .             .             . >         38:               .             .             .             . >         39:               .             .             .             . >         40:               .             .             .             . >         41:              =5            =5            =5            =5 >         42:               .             .             .             . >         43:               .             .             .             . >         44:               .             .             .             . >         45:               .             .             .             . >         46:               .             .             .             . >         47:           =6:|!         =6:|!         =6:|!         =6:|! >         48:             *>B           *>B           *>B           *>B >      49-81:      ======7-12    ======7-12    ======7-12    ======7-12 >         82:              4F            4A            4c            4a >         83:              4C            4G            4c            4e >         84:            4BB-            4G           [2d            4g >         85:             4AA            4A             .            4f >         86:             =13           =13           =13           =13 >         87:               .             .             .             . >         88:               .             .             .             . >         89:               .             .             .             . >         90:              ==            ==            ==            == >         91:              *-            *-            *-            *- >         92:  !!!hum2abc: -Q '' >         93:  !!!title: @{PC#}. @{OTL@@DE} >         94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastia*** >         95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und *** >         96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 3*** >         97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., *** >         98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >         99:  !!!EED:  Craig Stuart Sapp >        100:  !!!EEV:  2009/05/22 >    ############################ ^^^ chor010.krn ^^^ ############################ >                         (***five global comments truncated due to screen size***) >     >       humdrumR corpus of five files. >        Data fields:  >               *Token :: character subset(chorales, fill = any(Token %~% '-'), by = list(File, floor(Bar  / 2))) >    ############################ vvv chor003.krn vvv ############################ >          1:  !!!COM: Bach, Johann Sebastian >          2:  !!!CDT: 1685/02/21/-1750/07/28/ >          3:  !!!OTL@@DE: Ach Gott, vom Himmel sieh darein >          4:  !!!OTL@EN: Oh God, look down from Heaven >          5:  !!!OPR: Cantata BWV 153: Schau, lieber Gott, wie meine Feind >          6:  !!!SCT: BWV 153/1 >          7:  !!!PC#: 3 >          8:  !!!AGN: chorale >          9:          **kern        **kern        **kern        **kern >         10:          *ICvox        *ICvox        *ICvox        *ICvox >         11:          *Ibass       *Itenor        *Ialto       *Isoprn >         12:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >         13:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >         14:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >         15:             *>A           *>A           *>A           *>A >         16:         *clefF4      *clefGv2       *clefG2       *clefG2 >         17:          *k[f#]        *k[f#]        *k[f#]        *k[f#] >         18:             *a:           *a:           *a:           *a: >         19:         !dorian       !dorian       !dorian       !dorian >         20:           *M4/4         *M4/4         *M4/4         *M4/4 >         21:         *met(c)       *met(c)       *met(c)       *met(c) >         22:          *MM100        *MM100        *MM100        *MM100 >      23-53:        =====1-4      =====1-4      =====1-4      =====1-4 >         54:             *>B           *>B           *>B           *>B >      55-86:        =====5-9      =====5-9      =====5-9      =====5-9 >         87:             4G#            4B            4e           4ee >         88:             8AL            4A            4e           4cc >         89:             8GJ             .             .             . >         90:             8FL            4A            4f           4dd >         91:             8EJ             .             .             . >         92:             8DL           4B-            4g           4ee >         93:            8C#J             .             .             . >         94:             =10           =10           =10           =10 >         95:              4D           8AL         8f#XL           4dd >         96:               .           8EJ          8g#J             . >         97:             4D#          4F#X            4a           4cc >         98:             4E;          4G#;           4e;           4b; >         99:              ==            ==            ==            == >        100:              *-            *-            *-            *- >        101:  !!!hum2abc: -Q '' >    102-110:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################ ^^^ chor003.krn ^^^ ############################ >     >           (3 more files...) >     >    ############################ vvv chor010.krn vvv ############################ >       1-28:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >         29:               .             .             .             . >         30:               .             .             .             . >         31:              =3            =3            =3            =3 >         32:               .             .             .             . >         33:               .             .             .             . >         34:              =4            =4            =4            =4 >         35:               .             .             .             . >         36:               .             .             .             . >         37:               .             .             .             . >         38:               .             .             .             . >         39:               .             .             .             . >         40:               .             .             .             . >         41:              =5            =5            =5            =5 >         42:               .             .             .             . >         43:               .             .             .             . >         44:               .             .             .             . >         45:               .             .             .             . >         46:               .             .             .             . >         47:           =6:|!         =6:|!         =6:|!         =6:|! >         48:             *>B           *>B           *>B           *>B >      49-81:      ======7-12    ======7-12    ======7-12    ======7-12 >         82:              4F            4A            4c            4a >         83:              4C            4G            4c            4e >         84:            4BB-            4G           [2d            4g >         85:             4AA            4A             .            4f >         86:             =13           =13           =13           =13 >         87:            4GG#            4B           4d]           1e; >         88:             4AA            4A            4c             . >         89:            2EE;         2G#X;           2B;             . >         90:              ==            ==            ==            == >         91:              *-            *-            *-            *- >         92:  !!!hum2abc: -Q '' >         93:  !!!title: @{PC#}. @{OTL@@DE} >         94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastia*** >         95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und *** >         96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 3*** >         97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., *** >         98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >         99:  !!!EED:  Craig Stuart Sapp >        100:  !!!EEV:  2009/05/22 >    ############################ ^^^ chor010.krn ^^^ ############################ >                         (***five global comments truncated due to screen size***) >     >       humdrumR corpus of five files. >        Data fields:  >               *Token :: character"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Filtering.html","id":"removing-vs-filtering","dir":"Articles","previous_headings":"General Filtering","what":"Removing vs Filtering","title":"Filtering humdrum data","text":"probably noticed , unlike indexing commands [] [[]], subset doesn’t seem actually remove data filter . say still four spines, spines 2–4 just emptied. correct. subset actually mark filtered data Filter field humdrum table. Humdrum\\(_{\\mathbb{R}}\\) ignores data automatically. ? several reasons: clear example [[ , j]] indexing flats (): simply removed spines flats hard tell spine result. Many filters break humdrum syntax data simply removed. removed tokens don’t contain flats, result humdrum data holes . possible undo filters, using clearFilter command. (Try .) ’ve done filtering subset, want get rid empty parts data, can using commands removeEmptyFiles, removeEmptySpines, removeEmptyRecords, removeEmptyStops, removeEmptyPaths. using commands, make sure 1) explicitly want remove 2) humdrum syntax broken, whole records/spines/paths/files removed. spines example: records:","code":"subset(chorales, Spine == 1) >    ############################# vvv chor001.krn vvv ############################# >         1:  !!!COM: Bach, Johann Sebastian >         2:  !!!CDT: 1685/02/21/-1750/07/28/ >         3:  !!!OTL@@DE: Aus meines Herzens Grunde >         4:  !!!OTL@EN:      From the Depths of My Heart >         5:  !!!SCT: BWV 269 >         6:  !!!PC#: 1 >         7:  !!!AGN: chorale >         8:          **kern        **kern        **kern        **kern >         9:          *ICvox        *ICvox        *ICvox        *ICvox >        10:          *Ibass       *Itenor        *Ialto       *Isoprn >        11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >        12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >        13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >        14:             *>A           *>A           *>A           *>A >        15:         *clefF4      *clefGv2       *clefG2       *clefG2 >        16:          *k[f#]        *k[f#]        *k[f#]        *k[f#] >        17:             *G:           *G:           *G:           *G: >        18:             *F:             *             *             * >        19:           *M3/4         *M3/4         *M3/4         *M3/4 >        20:          *MM100        *MM100        *MM100        *MM100 >        21:             4GG             .             .             . >        22:              =1            =1            =1            =1 >        23:              4G             .             .             . >        24:              4E             .             .             . >        25:               .             .             .             . >        26:             4F#             .             .             . >        27:              =2            =2            =2            =2 >        28:              4G             .             .             . >        29:              4D             .             .             . >        30:               .             .             .             . >        31:              4E             .             .             . >        32:              =3            =3            =3            =3 >        33:              4C             .             .             . >        34:               .             .             .             . >        35:            8BBL             .             .             . >        36:            8AAJ             .             .             . >        37:             4GG             .             .             . >        38:              =4            =4            =4            =4 >        39:             2D;             .             .             . >        40:             4GG             .             .             . >    41-134::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################# ^^^ chor001.krn ^^^ ############################# >     >           (8 more files...) >     >    ############################# vvv chor010.krn vvv ############################# >      1-60::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >        61:            2AA;             .             .             . >        62:              2A             .             .             . >        63:              =9            =9            =9            =9 >        64:              4E             .             .             . >        65:             8DL             .             .             . >        66:             8CJ             .             .             . >        67:             4BB             .             .             . >        68:               .             .             .             . >        69:              4C             .             .             . >        70:             =10           =10           =10           =10 >        71:              4D             .             .             . >        72:               .             .             .             . >        73:              4D             .             .             . >        74:               .             .             .             . >        75:            2GG;             .             .             . >        76:             =11           =11           =11           =11 >        77:              2C             .             .             . >        78:             4AA             .             .             . >        79:              4E             .             .             . >        80:               .             .             .             . >        81:             =12           =12           =12           =12 >        82:              4F             .             .             . >        83:              4C             .             .             . >        84:            4BB-             .             .             . >        85:             4AA             .             .             . >        86:             =13           =13           =13           =13 >        87:            4GG#             .             .             . >        88:             4AA             .             .             . >        89:            2EE;             .             .             . >        90:              ==            ==            ==            == >        91:              *-            *-            *-            *- >        92:  !!!hum2abc: -Q '' >        93:  !!!title: @{PC#}. @{OTL@@DE} >        94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** >        95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** >        96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** >        97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** >        98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >        99:  !!!EED:  Craig Stuart Sapp >       100:  !!!EEV:  2009/05/22 >    ############################# ^^^ chor010.krn ^^^ ############################# >                           (***four global comments truncated due to screen size***) >     >       humdrumR corpus of ten files. >        Data fields:  >               *Token :: character subset(chorales, Spine == 1) |> removeEmptySpines() >    ############################# vvv chor001.krn vvv ############################# >         1:  !!!COM: Bach, Johann Sebastian >         2:  !!!CDT: 1685/02/21/-1750/07/28/ >         3:  !!!OTL@@DE: Aus meines Herzens Grunde >         4:  !!!OTL@EN:      From the Depths of My Heart >         5:  !!!SCT: BWV 269 >         6:  !!!PC#: 1 >         7:  !!!AGN: chorale >         8:          **kern >         9:          *ICvox >        10:          *Ibass >        11:         *I\"Bass >        12:       *>[A,A,B] >        13:    *>norep[A,B] >        14:             *>A >        15:         *clefF4 >        16:          *k[f#] >        17:             *G: >        18:             *F: >        19:           *M3/4 >        20:          *MM100 >        21:             4GG >        22:              =1 >        23:              4G >        24:              4E >        25:               . >        26:             4F# >        27:              =2 >        28:              4G >        29:              4D >        30:               . >        31:              4E >        32:              =3 >        33:              4C >        34:               . >        35:            8BBL >        36:            8AAJ >        37:             4GG >        38:              =4 >        39:             2D; >        40:             4GG >    41-134::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################# ^^^ chor001.krn ^^^ ############################# >     >           (8 more files...) >     >    ############################# vvv chor010.krn vvv ############################# >      1-60::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >        61:            2AA; >        62:              2A >        63:              =9 >        64:              4E >        65:             8DL >        66:             8CJ >        67:             4BB >        68:               . >        69:              4C >        70:             =10 >        71:              4D >        72:               . >        73:              4D >        74:               . >        75:            2GG; >        76:             =11 >        77:              2C >        78:             4AA >        79:              4E >        80:               . >        81:             =12 >        82:              4F >        83:              4C >        84:            4BB- >        85:             4AA >        86:             =13 >        87:            4GG# >        88:             4AA >        89:            2EE; >        90:              == >        91:              *- >        92:  !!!hum2abc: -Q '' >        93:  !!!title: @{PC#}. @{OTL@@DE} >        94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** >        95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** >        96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** >        97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** >        98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >        99:  !!!EED:  Craig Stuart Sapp >       100:  !!!EEV:  2009/05/22 >    ############################# ^^^ chor010.krn ^^^ ############################# >                           (***four global comments truncated due to screen size***) >     >       humdrumR corpus of ten files. >        Data fields:  >               *Token :: character subset(chorales, Record %% 2 == 0) |> removeEmptyRecords() >    ############################# vvv chor001.krn vvv ############################# >         1:  !!!COM: Bach, Johann Sebastian >         2:  !!!CDT: 1685/02/21/-1750/07/28/ >         3:  !!!OTL@@DE: Aus meines Herzens Grunde >         4:  !!!OTL@EN:      From the Depths of My Heart >         5:  !!!SCT: BWV 269 >         6:  !!!PC#: 1 >         7:  !!!AGN: chorale >         8:          **kern        **kern        **kern        **kern >         9:          *ICvox        *ICvox        *ICvox        *ICvox >        10:          *Ibass       *Itenor        *Ialto       *Isoprn >        11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >        12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >        13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >        14:             *>A           *>A           *>A           *>A >        15:         *clefF4      *clefGv2       *clefG2       *clefG2 >        16:          *k[f#]        *k[f#]        *k[f#]        *k[f#] >        17:             *G:           *G:           *G:           *G: >        18:             *F:             *             *             * >        19:           *M3/4         *M3/4         *M3/4         *M3/4 >        20:          *MM100        *MM100        *MM100        *MM100 >        22:              =1            =1            =1            =1 >        24:              4E           8cL            4e             . >        26:             4F#            4A            4d           4dd >        27:              =2            =2            =2            =2 >        28:              4G            4G            2d           4.b >        30:               .             .             .            8a >        32:              =3            =3            =3            =3 >        34:               .           8BJ            8d             . >        36:            8AAJ             .          8f#J            8a >        38:              =4            =4            =4            =4 >        40:             4GG            4d            4g            4b >        41:              =5            =5            =5            =5 >        42:            4FF#            4A            4d           2dd >        44:             4AA            4c           4f#           4cc >        45:              =6            =6            =6            =6 >        46:             4BB            4d            2g            4b >        48:              4D           8dL           4f#             . >        50:              =7            =7            =7            =7 >        52:            =:|!          =:|!          =:|!          =:|! >        53:             *>B           *>B           *>B           *>B >    54-134::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################# ^^^ chor001.krn ^^^ ############################# >     >           (8 more files...) >     >    ############################# vvv chor010.krn vvv ############################# >      1-40::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >        41:              =5            =5            =5            =5 >        42:              4C           8cL            4e            4g >        44:              4D            4A           8dL            4f >        46:             2E;          2G#;           2B;           2e; >        47:           =6:|!         =6:|!         =6:|!         =6:|! >        48:             *>B           *>B           *>B           *>B >        50:              4B            4B            4d          4gnX >        52:               .             .          8f#J             . >        53:              =7            =7            =7            =7 >        54:              4G            4d            4g            4b >        56:             8EJ           8eJ             .             . >        58:               .             .           8aJ          8ccJ >        60:              =8            =8            =8            =8 >        62:              2A            2e            2a           2cc >        63:              =9            =9            =9            =9 >        64:              4E            4e            4g            4b >        66:             8CJ             .             .             . >        68:               .             .           8fJ             . >        70:             =10           =10           =10           =10 >        72:               .            4G             .             . >        74:               .           8F#             .             . >        76:             =11           =11           =11           =11 >        78:             4AA            4A            4e           4cc >        80:               .             .           8dJ             . >        81:             =12           =12           =12           =12 >        82:              4F            4A            4c            4a >        84:            4BB-            4G           [2d            4g >        86:             =13           =13           =13           =13 >        88:             4AA            4A            4c             . >        90:              ==            ==            ==            == >        91:              *-            *-            *-            *- >        92:  !!!hum2abc: -Q '' >        93:  !!!title: @{PC#}. @{OTL@@DE} >        94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** >        95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** >        96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** >        97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** >        98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >        99:  !!!EED:  Craig Stuart Sapp >       100:  !!!EEV:  2009/05/22 >    ############################# ^^^ chor010.krn ^^^ ############################# >                           (***four global comments truncated due to screen size***) >     >       humdrumR corpus of ten files. >        Data fields:  >               *Token :: character"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/GettingStarted.html","id":"quick-start","dir":"Articles","previous_headings":"","what":"Quick Start","title":"Getting started with humdrumR","text":"Let’s just dive right ! First, make sure humdrum\\(_{\\mathbb{R}}\\) installed: install humdrumR. Open R session load humdrum\\(_{\\mathbb{R}}\\) library using command library(humdrumR)—now ready rock! Humdrum\\(_{\\mathbb{R}}\\) comes packaged small number humdrum data files just play around . files stored directory computer installed humdrum\\(_{\\mathbb{R}}\\), subfolder called “HumdrumData”. can move R session folder using R’s “set working directory command”: setwd(humdrumRroot). ’re humdrumR directory, can use base R dir function see humdrum data available . looks like five folders humdrum data available . Using dir , can look inside one: let’s start ‘BachChorales’ folder. ten files folder, named “chor001.krn”, “chor002.krn”, etc. simple plain humdrum text files, using **kern interpretation represent ten chorales J.S. Bach. Take minute find files computer’s finder/explorer open simple text editor. One core philosophies humdrum\\(_{\\mathbb{R}}\\) maintain direct, transparent relationship symbolic data—always take time look data! can also within Rstudio’s “Files” pane—fact, Rstudio make things extra easy can (within Files pane) click “” > “Go Working Directory” quickly find files.","code":"library(humdrumR)  setwd(humdrumRroot)  dir('HumdrumData') >    [1] \"BachChorales\"        \"BeethovenVariations\" \"MozartVariations\"    >    [4] \"RapFlow\"             \"RollingStoneCorpus\" dir('HumdrumData/BachChorales') >     [1] \"chor001.krn\" \"chor002.krn\" \"chor003.krn\" \"chor004.krn\" \"chor005.krn\" >     [6] \"chor006.krn\" \"chor007.krn\" \"chor008.krn\" \"chor009.krn\" \"chor010.krn\""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/GettingStarted.html","id":"reading-humdrum-data","dir":"Articles","previous_headings":"Quick Start","what":"Reading humdrum data","title":"Getting started with humdrumR","text":"Now ’ve found humdrum data look , let’s read humdrum\\(_{\\mathbb{R}}\\). can using humdrum\\(_{\\mathbb{R}}\\)’s readHumdrum command. Try : command two things: readHumdrum function read “chor001.krn” file R create humdrum\\(_{\\mathbb{R}}\\) data object . new object saved variable called chor1. (name ‘chor1’ just name chose—welcome give different name want.) ’ve created chor1 object (whatever chose call ), can take quick look just typing name command line pressing enter: (R, enter something command line, R “prints” read.) print-see shows name file, contents file, stuff “Data fields” learn soon. Cool! Still, looking single humdrum file really exciting. whole point using computers working large amounts data. Luckily, humdrum\\(_{\\mathbb{R}}\\) makes easy. Check next command: Notice ’ve changed instead writing 'chor001.krn', wrote 'chor0'. feed string 'chor0' readHumdrum, won’t just look file called “chor0”; read file folder whose name contains substring “chor0”—case ten files! Try printing new chorales object see different. Wow! ’ve now got “humdrumR corpus ten files”—’s nothing: readHumdrum work just well reading hundreds thousands files! Notice print humdrum\\(_{\\mathbb{R}}\\) object, humdrum\\(_{\\mathbb{R}}\\) shows beginning first file end last file, well telling many files total. readHumdrum number cool options can read detail humdrumR read/write tutorial.","code":"readHumdrum('HumdrumData/BachChorales/chor001.krn') -> chor1 chor1 >    ############################ vvv chor001.krn vvv ############################ >        1:  !!!COM: Bach, Johann Sebastian >        2:  !!!CDT: 1685/02/21/-1750/07/28/ >        3:  !!!OTL@@DE: Aus meines Herzens Grunde >        4:  !!!OTL@EN:      From the Depths of My Heart >        5:  !!!SCT: BWV 269 >        6:  !!!PC#: 1 >        7:  !!!AGN: chorale >        8:          **kern        **kern        **kern        **kern >        9:          *ICvox        *ICvox        *ICvox        *ICvox >       10:          *Ibass       *Itenor        *Ialto       *Isoprn >       11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >       12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >       13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >       14:             *>A           *>A           *>A           *>A >       15:         *clefF4      *clefGv2       *clefG2       *clefG2 >       16:          *k[f#]        *k[f#]        *k[f#]        *k[f#] >       17:             *G:           *G:           *G:           *G: >       18:             *F:             *             *             * >       19:           *M3/4         *M3/4         *M3/4         *M3/4 >       20:          *MM100        *MM100        *MM100        *MM100 >       21:             4GG            4B            4d            4g >       22:              =1            =1            =1            =1 >       23:              4G            4B            4d            2g >       24:              4E           8cL            4e             . >       25:               .           8BJ             .             . >       26:             4F#            4A            4d           4dd >       27:              =2            =2            =2            =2 >       28:              4G            4G            2d           4.b >       29:              4D           4F#             .             . >       30:               .             .             .            8a >       31:              4E            4G            4B            4g >       32:              =3            =3            =3            =3 >       33:              4C           8cL           8eL           4.g >       34:               .           8BJ            8d             . >       35:            8BBL            4c            8e             . >       36:            8AAJ             .          8f#J            8a >       37:             4GG            4d            4g            4b >       38:              =4            =4            =4            =4 >       39:             2D;           2d;          2f#;           2a; >       40:             4GG            4d            4g            4b >       41:              =5            =5            =5            =5 >       42:            4FF#            4A            4d           2dd >       43:             4GG            4B            4e             . >       44:             4AA            4c           4f#           4cc >       45:              =6            =6            =6            =6 >       46:             4BB            4d            2g            4b >       47:              4C            4e             .            2a >       48:              4D           8dL           4f#             . >       49:               .           8cJ             .             . >       50:              =7            =7            =7            =7 >       51:            2GG;           2B;           2d;           2g; >       52:            =:|!          =:|!          =:|!          =:|! >       53:             *>B           *>B           *>B           *>B >       54:             4GG            4d           [4g            4b >       55:              =8            =8            =8            =8 >       56:             4GG            4d          8gL]            4b >       57:               .             .          8f#J             . >       58:             4AA            4c           8eL           4cc >       59:               .             .          8f#J             . >       60:             4BB           8BL           [4g           4dd >       61:               .           8AJ             .             . >       62:              =9            =9            =9            =9 >       63:            4.BB           8BL          8gL]          4.dd >       64:               .           8cJ           8aJ             . >       65:               .            4d           8gL             . >       66:             8AA             .          8f#J           8cc >       67:             4GG            4d            4g            4b >       68:             =10           =10           =10           =10 >       69:             2D;           2d;          2f#;           2a; >       70:             [4E            4B            4e            4g >       71:             =11           =11           =11           =11 >       72:             4E]            4G            4e            2b >       73:              4D            4B          8f#L             . >       74:               .             .           8gJ             . >       75:              4C            4e            4a           4cc >       76:             =12           =12           =12           =12 >       77:            4.BB            2d            4a           2dd >       78:               .             .           4.g             . >       79:              8C             .             .             . >       80:              4D            4d             .           4cc >       81:               .             .           8f#             . >       82:             =13           =13           =13           =13 >       83:            8GGL           2.d            2g           2.b >       84:            8AAJ             .             .             . >       85:             4BB             .             .             . >       86:             4GG             .            4f             . >       87:             =14           =14           =14           =14 >       88:             2C;           2c;           2e;           2g; >       89:             4GG            4d            4g            4b >       90:             =15           =15           =15           =15 >       91:            4FF#           8dL           4.a           2dd >       92:               .           8cJ             .             . >       93:             4GG            4B             .             . >       94:               .             .            8g             . >       95:             4AA            4c           4f#           4cc >       96:             =16           =16           =16           =16 >       97:             4BB            2d            2g            2b >       98:             4GG             .             .             . >       99:              4D           8dL          [4f#            4a >      100:               .           8cJ             .             . >      101:             =17           =17           =17           =17 >      102:             8EL            4B         8f#L]           4.g >      103:              8D             .           8eJ             . >      104:              8C            4c           8eL             . >      105:             8BB             .          8f#J            8a >      106:             8AA            4d            4g            4b >      107:            8GGJ             .             .             . >      108:             =18           =18           =18           =18 >      109:             2D;           2d;          2f#;           2a; >      110:             [4G            4d            4g            4b >      111:             =19           =19           =19           =19 >      112:             4G]            2d            2a           2dd >      113:             4F#             .             .             . >      114:             [4E            4e           8gL           4cc >      115:               .             .          8f#J             . >      116:             =20           =20           =20           =20 >      117:            8EL]            2e            2g            4b >      118:             8DJ             .             .             . >      119:              4C             .             .            2a >      120:              4D           8dL           4f#             . >      121:               .           8cJ             .             . >      122:             =21           =21           =21           =21 >      123:           2.GG;          2.B;          2.d;          2.g; >      124:              ==            ==            ==            == >      125:              *-            *-            *-            *- >      126:  !!!hum2abc: -Q '' >      127:  !!!title: @{PC#}. @{OTL@@DE} >      128:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian *** >      129:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&*** >      130:  !!!YOR3: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371*** >      131:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.*** >      132:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >      133:  !!!EED:  Craig Stuart Sapp >      134:  !!!EEV:  2009/05/22 >    ############################ ^^^ chor001.krn ^^^ ############################ >                         (***four global comments truncated due to screen size***) >        Data fields:  >               *Token :: character readHumdrum('HumdrumData/BachChorales/chor0') -> chorales chorales >    ############################# vvv chor001.krn vvv ############################# >         1:  !!!COM: Bach, Johann Sebastian >         2:  !!!CDT: 1685/02/21/-1750/07/28/ >         3:  !!!OTL@@DE: Aus meines Herzens Grunde >         4:  !!!OTL@EN:      From the Depths of My Heart >         5:  !!!SCT: BWV 269 >         6:  !!!PC#: 1 >         7:  !!!AGN: chorale >         8:          **kern        **kern        **kern        **kern >         9:          *ICvox        *ICvox        *ICvox        *ICvox >        10:          *Ibass       *Itenor        *Ialto       *Isoprn >        11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >        12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >        13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >        14:             *>A           *>A           *>A           *>A >        15:         *clefF4      *clefGv2       *clefG2       *clefG2 >        16:          *k[f#]        *k[f#]        *k[f#]        *k[f#] >        17:             *G:           *G:           *G:           *G: >        18:             *F:             *             *             * >        19:           *M3/4         *M3/4         *M3/4         *M3/4 >        20:          *MM100        *MM100        *MM100        *MM100 >        21:             4GG            4B            4d            4g >        22:              =1            =1            =1            =1 >        23:              4G            4B            4d            2g >        24:              4E           8cL            4e             . >        25:               .           8BJ             .             . >        26:             4F#            4A            4d           4dd >        27:              =2            =2            =2            =2 >        28:              4G            4G            2d           4.b >        29:              4D           4F#             .             . >        30:               .             .             .            8a >        31:              4E            4G            4B            4g >        32:              =3            =3            =3            =3 >        33:              4C           8cL           8eL           4.g >        34:               .           8BJ            8d             . >        35:            8BBL            4c            8e             . >        36:            8AAJ             .          8f#J            8a >        37:             4GG            4d            4g            4b >        38:              =4            =4            =4            =4 >        39:             2D;           2d;          2f#;           2a; >        40:             4GG            4d            4g            4b >    41-134::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################# ^^^ chor001.krn ^^^ ############################# >     >           (8 more files...) >     >    ############################# vvv chor010.krn vvv ############################# >      1-60::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >        61:            2AA;           2c;           2e;           2a; >        62:              2A            2e            2a           2cc >        63:              =9            =9            =9            =9 >        64:              4E            4e            4g            4b >        65:             8DL            4e            4g           4cc >        66:             8CJ             .             .             . >        67:             4BB            4d           8gL           4dd >        68:               .             .           8fJ             . >        69:              4C            4c            4e            4g >        70:             =10           =10           =10           =10 >        71:              4D           8F#            4d            4b >        72:               .            4G             .             . >        73:              4D             .            4c            4a >        74:               .           8F#             .             . >        75:            2GG;           2G;           2B;           2g; >        76:             =11           =11           =11           =11 >        77:              2C            2G            2e            2g >        78:             4AA            4A            4e           4cc >        79:              4E           4G#           8eL            4b >        80:               .             .           8dJ             . >        81:             =12           =12           =12           =12 >        82:              4F            4A            4c            4a >        83:              4C            4G            4c            4e >        84:            4BB-            4G           [2d            4g >        85:             4AA            4A             .            4f >        86:             =13           =13           =13           =13 >        87:            4GG#            4B           4d]           1e; >        88:             4AA            4A            4c             . >        89:            2EE;         2G#X;           2B;             . >        90:              ==            ==            ==            == >        91:              *-            *-            *-            *- >        92:  !!!hum2abc: -Q '' >        93:  !!!title: @{PC#}. @{OTL@@DE} >        94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** >        95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** >        96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** >        97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** >        98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >        99:  !!!EED:  Craig Stuart Sapp >       100:  !!!EEV:  2009/05/22 >    ############################# ^^^ chor010.krn ^^^ ############################# >                           (***four global comments truncated due to screen size***) >     >       humdrumR corpus of ten files. >        Data fields:  >               *Token :: character"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/GettingStarted.html","id":"the-data-model","dir":"Articles","previous_headings":"","what":"The Data Model","title":"Getting started with humdrumR","text":"really make use humdrum\\(_{\\mathbb{R}}\\), need understand bit humdrum data represented humdrum\\(_{\\mathbb{R}}\\) package: humdrum\\(_{\\mathbb{R}}\\) “data model.” essential thing understand maps humdrum data syntax R data.table.  fully understand , start least basic understanding humdrum syntax! Read syntax humdrum.org check vignette topic.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/GettingStarted.html","id":"data-frames","dir":"Articles","previous_headings":"The Data Model","what":"data.frames","title":"Getting started with humdrumR","text":"Data.frames essential R. data.frame simply two-dimensional table named columns. column either vector list values, length. Humdrum\\(_{\\mathbb{R}}\\) makes use popular extension base-R data.frames, data.table. humdrum\\(_{\\mathbb{R}}\\), every single, individual token collection humdrum-syntax text files given row data.frame. example, consider simple, humdrum-syntax file: file contains nineteen individual tokens. illustrate, ’ll print file, token bracketed < >: happens humdrum\\(_{\\mathbb{R}}\\) reads file? (file bundled humdrum\\(_{\\mathbb{R}}\\) \"humdrumRroot/examples\" directory.) see thing saw earlier, reading real humdrum data \"HumdrumData\" folder. ’s hood? see , can use getHumtab function extract underlying humdrum table: Look , data.table nineteen rows! One row every token. case, humdrum data table (“humtable”) twenty-three columns! columns : humdrum\\(_{\\mathbb{R}}\\), refer columns fields. learn fields humdrum\\(_{\\mathbb{R}}\\) object, better call fields command directly original humdrum\\(_{\\mathbb{R}}\\) object: see twenty-three fields (humtable columns), divided five types fields: Data fields Structure fields Interpretation fields Form fields Reference fields (good place read details columns means humdrum table documentation can get calling ?humTable.) Let’s go back Bach chorales dataset loaded earlier (saved chorales): chorales corpus 43 fields!—fields example1, additional ones. additional fields interpretation reference records didn’t appear toy example1.","code":">     !!!OTL: Example 1 >     **kern                        **kern                         >     *M4/4                         *M4/4                          >     *C:                           *C:                            >     =                             =                              >     2G                            4g                             >     .                             4f                             >     2C                            2e                             >     ==                            ==                             >     *-                            *- >    NULL >    <!!!OTL: Example 1> >    <**kern>                      <**kern>                       >    <*M4/4>                       <*M4/4>                        >    <*C:>                         <*C:>                          >    <=>                           <=>                            >    <2G>                          <4g>                           >    <.>                           <4f>                           >    <2C>                          <2e>                           >    <==>                          <==>                           >    <*->                          <*-> example1 <- readHumdrum('examples/BasicExample.krn')  example1 >     vvv BasicExample.krn vvv  >       1:  !!!OTL: Example 1 >       2:    **kern  **kern >       3:     *M4/4   *M4/4 >       4:       *C:     *C: >       5:         =       = >       6:        2G      4g >       7:         .      4f >       8:        2C      2e >       9:        ==      == >      10:        *-      *- >     ^^^ BasicExample.krn ^^^  >        Data fields:  >               *Token :: character humtab <- getHumtab(example1)  humtab >                    Token Record Type Spine Path Stop Exclusive  Tandem Bar >     1: !!!OTL: Example 1      1    G    NA   NA   NA      <NA>    <NA>  NA >     2:            **kern      2    I     1    0    1      kern           0 >     3:             *M4/4      3    I     1    0    1      kern    M4/4   0 >     4:               *C:      4    I     1    0    1      kern C:,M4/4   0 >     5:                 =      5    M     1    0    1      kern C:,M4/4   1 >     6:                2G      6    D     1    0    1      kern C:,M4/4   1 >     7:                 .      7    d     1    0    1      kern C:,M4/4   1 >     8:                2C      8    D     1    0    1      kern C:,M4/4   1 >     9:                ==      9    M     1    0    1      kern C:,M4/4   2 >    10:                *-     10    I     1    0    1      kern C:,M4/4   2 >    11:            **kern      2    I     2    0    1      kern           0 >    12:             *M4/4      3    I     2    0    1      kern    M4/4   0 >    13:               *C:      4    I     2    0    1      kern C:,M4/4   0 >    14:                 =      5    M     2    0    1      kern C:,M4/4   1 >    15:                4g      6    D     2    0    1      kern C:,M4/4   1 >    16:                4f      7    D     2    0    1      kern C:,M4/4   1 >    17:                2e      8    D     2    0    1      kern C:,M4/4   1 >    18:                ==      9    M     2    0    1      kern C:,M4/4   2 >    19:                *-     10    I     2    0    1      kern C:,M4/4   2 >        DoubleBar BarLabel NData       OTL Piece                  Filepath File >     1:        NA     <NA>    NA Example 1     1 examples/BasicExample.krn    1 >     2:         0     <NA>    NA Example 1     1 examples/BasicExample.krn    1 >     3:         0     <NA>    NA Example 1     1 examples/BasicExample.krn    1 >     4:         0     <NA>    NA Example 1     1 examples/BasicExample.krn    1 >     5:         0             NA Example 1     1 examples/BasicExample.krn    1 >     6:         0              1 Example 1     1 examples/BasicExample.krn    1 >     7:         0              2 Example 1     1 examples/BasicExample.krn    1 >     8:         0              3 Example 1     1 examples/BasicExample.krn    1 >     9:         1        =    NA Example 1     1 examples/BasicExample.krn    1 >    10:         1        =    NA Example 1     1 examples/BasicExample.krn    1 >    11:         0     <NA>    NA Example 1     1 examples/BasicExample.krn    1 >    12:         0     <NA>    NA Example 1     1 examples/BasicExample.krn    1 >    13:         0     <NA>    NA Example 1     1 examples/BasicExample.krn    1 >    14:         0             NA Example 1     1 examples/BasicExample.krn    1 >    15:         0              1 Example 1     1 examples/BasicExample.krn    1 >    16:         0              2 Example 1     1 examples/BasicExample.krn    1 >    17:         0              3 Example 1     1 examples/BasicExample.krn    1 >    18:         1        =    NA Example 1     1 examples/BasicExample.krn    1 >    19:         1        =    NA Example 1     1 examples/BasicExample.krn    1 >        Label         Filename  Null Filter Global  Key TimeSignature >     1:    _1 BasicExample.krn FALSE  FALSE   TRUE <NA>          <NA> >     2:    _1 BasicExample.krn FALSE  FALSE  FALSE <NA>          <NA> >     3:    _1 BasicExample.krn FALSE  FALSE  FALSE <NA>          M4/4 >     4:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4 >     5:    _1 BasicExample.krn  TRUE  FALSE  FALSE   C:          M4/4 >     6:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4 >     7:    _1 BasicExample.krn  TRUE  FALSE  FALSE   C:          M4/4 >     8:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4 >     9:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4 >    10:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4 >    11:    _1 BasicExample.krn FALSE  FALSE  FALSE <NA>          <NA> >    12:    _1 BasicExample.krn FALSE  FALSE  FALSE <NA>          M4/4 >    13:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4 >    14:    _1 BasicExample.krn  TRUE  FALSE  FALSE   C:          M4/4 >    15:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4 >    16:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4 >    17:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4 >    18:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4 >    19:    _1 BasicExample.krn FALSE  FALSE  FALSE   C:          M4/4 colnames(humtab) >     [1] \"Token\"         \"Record\"        \"Type\"          \"Spine\"         >     [5] \"Path\"          \"Stop\"          \"Exclusive\"     \"Tandem\"        >     [9] \"Bar\"           \"DoubleBar\"     \"BarLabel\"      \"NData\"         >    [13] \"OTL\"           \"Piece\"         \"Filepath\"      \"File\"          >    [17] \"Label\"         \"Filename\"      \"Null\"          \"Filter\"        >    [21] \"Global\"        \"Key\"           \"TimeSignature\" fields(example1) >                 Name     Class           Type >     1:         Token character           Data >     2:      Filename character      Structure >     3:      Filepath character      Structure >     4:          File   integer      Structure >     5:         Label character      Structure >     6:         Piece   integer      Structure >     7:         Spine   integer      Structure >     8:          Path   integer      Structure >     9:          Stop   integer      Structure >    10:        Record   integer      Structure >    11:         NData   integer      Structure >    12:        Global   logical      Structure >    13:          Null   logical      Structure >    14:        Filter   logical      Structure >    15:          Type character      Structure >    16:     Exclusive character Interpretation >    17:        Tandem character Interpretation >    18:           Key character Interpretation >    19: TimeSignature character Interpretation >    20:           Bar   integer         Formal >    21:     DoubleBar   integer         Formal >    22:      BarLabel character         Formal >    23:           OTL character      Reference >                 Name     Class           Type fields(chorales) >                   Name     Class           Type >     1:           Token character           Data >     2:        Filename character      Structure >     3:        Filepath character      Structure >     4:            File   integer      Structure >     5:           Label character      Structure >     6:           Piece   integer      Structure >     7:           Spine   integer      Structure >     8:            Path   integer      Structure >     9:            Stop   integer      Structure >    10:          Record   integer      Structure >    11:           NData   integer      Structure >    12:          Global   logical      Structure >    13:            Null   logical      Structure >    14:          Filter   logical      Structure >    15:            Type character      Structure >    16:       Exclusive character Interpretation >    17:          Tandem character Interpretation >    18:             Key character Interpretation >    19:    KeySignature character Interpretation >    20:            Clef character Interpretation >    21:   TimeSignature character Interpretation >    22:     Mensuration character Interpretation >    23:             BPM character Interpretation >    24:      Instrument character Interpretation >    25: InstrumentClass character Interpretation >    26:          Formal character         Formal >    27:             Bar   integer         Formal >    28:       DoubleBar   integer         Formal >    29:        BarLabel character         Formal >    30:             COM character      Reference >    31:             CDT character      Reference >    32:         OTL@@DE character      Reference >    33:          OTL@EN character      Reference >    34:             SCT character      Reference >    35:             PC# character      Reference >    36:             AGN character      Reference >    37:         hum2abc character      Reference >    38:           title character      Reference >    39:             YOR character      Reference >    40:             SMS character      Reference >    41:             EED character      Reference >    42:             EEV character      Reference >    43:             OPR character      Reference >                   Name     Class           Type"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/GettingStarted.html","id":"main-fields","dir":"Articles","previous_headings":"The Data Model > data.frames","what":"Main Fields","title":"Getting started with humdrumR","text":"important fields always present humdrum\\(_{\\mathbb{R}}\\) humtable 1) Token field contains original character tokens read humdrum data; 2) “Structural” fields tell us original humdrum data token came . “Structural” fields allow humdrum\\(_{\\mathbb{R}}\\) (re)construct original humdrum data—translating humdrum-table (data.table) plain-text humdrum syntax. can inspect field humdrum\\(_{\\mathbb{R}}\\) data using $ operator: Just call humdrum\\(_{\\mathbb{R}}\\) data object $ name field. Using , can see content structural fields ! important Spine, Record, (Record) Type, File(name) fields. “record types” : \"G\": global comment (including reference records) \"L\": local comment \"\": interpretation \"M\": measure (.e., barlines) \"D\": (non-null) data token \"d\": null data token (\".\")","code":"example1$Spine >     vvv BasicExample.krn vvv  >       1:  !!!OTL: Example 1 >       2:    1  2 >       3:    1  2 >       4:    1  2 >       5:    1  2 >       6:    1  2 >       7:    1  2 >       8:    1  2 >       9:    1  2 >      10:    1  2 >     ^^^ BasicExample.krn ^^^  >        Data fields:  >                Token :: character  # example1$Record  example1$Type >     vvv BasicExample.krn vvv  >       1:    G    >       2:    I  I >       3:    I  I >       4:    I  I >       5:    M  M >       6:    D  D >       7:    D  D >       8:    D  D >       9:    M  M >      10:    I  I >     ^^^ BasicExample.krn ^^^  >        Data fields:  >                Token :: character  example1$Filename >    ######## vvv BasicExample.krn vvv ######### >       1:    BasicExample.krn                   >       2:    BasicExample.krn  BasicExample.krn >       3:    BasicExample.krn  BasicExample.krn >       4:    BasicExample.krn  BasicExample.krn >       5:    BasicExample.krn  BasicExample.krn >       6:    BasicExample.krn  BasicExample.krn >       7:    BasicExample.krn  BasicExample.krn >       8:    BasicExample.krn  BasicExample.krn >       9:    BasicExample.krn  BasicExample.krn >      10:    BasicExample.krn  BasicExample.krn >    ######## ^^^ BasicExample.krn ^^^ ######### >        Data fields:  >                Token :: character"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/GettingStarted.html","id":"stops","dir":"Articles","previous_headings":"The Data Model > data.frames","what":"Stops","title":"Getting started with humdrumR","text":"humdrum syntax, multiple tokens can placed “place” (.e., record, spine) simply separating spaces. (commonly used represent chords **kern data.) humdrum\\(_{\\mathbb{R}}\\), call “Stops”—always, every humdrum token, including stops, get row humdrum\\(_{\\mathbb{R}}\\) humtable. Thus, need Stop field tell us stop token came ! much data, /tokens simply Stop == 1 (first position), one tokens record/spine, numbered ascending one: Let’s look example make sense ! file chords second spine: individual note tokens separated spaces. Let’s inspect humtable: can see note chords gets row, numbered 1, 2, 3 Stop field!","code":"stops <- readHumdrum('examples/Stops.krn')  stops >    ##### vvv Stops.krn vvv ##### >       1:  !!!OTL: \"Stop\" example >       2:    **kern    **kern >       3:     *M4/4     *M4/4 >       4:       *C:       *C: >       5:        =-        =- >       6:        2G  4g cc ee >       7:         .   4f b dd >       8:       2C;   2e; cc; >       9:         =         = >      10:        *-        *- >    ##### ^^^ Stops.krn ^^^ ##### >        Data fields:  >               *Token :: character getHumtab(stops) >                         Token Record Type Spine Path Stop Exclusive  Tandem Bar >     1: !!!OTL: \"Stop\" example      1    G    NA   NA   NA      <NA>    <NA>  NA >     2:                 **kern      2    I     1    0    1      kern           0 >     3:                  *M4/4      3    I     1    0    1      kern    M4/4   0 >     4:                    *C:      4    I     1    0    1      kern C:,M4/4   0 >     5:                     =-      5    M     1    0    1      kern C:,M4/4   1 >     6:                     2G      6    D     1    0    1      kern C:,M4/4   1 >     7:                      .      7    d     1    0    1      kern C:,M4/4   1 >     8:                    2C;      8    D     1    0    1      kern C:,M4/4   1 >     9:                      =      9    M     1    0    1      kern C:,M4/4   2 >    10:                     *-     10    I     1    0    1      kern C:,M4/4   2 >    11:                 **kern      2    I     2    0    1      kern           0 >    12:                  *M4/4      3    I     2    0    1      kern    M4/4   0 >    13:                    *C:      4    I     2    0    1      kern C:,M4/4   0 >    14:                     =-      5    M     2    0    1      kern C:,M4/4   1 >    15:                     4g      6    D     2    0    1      kern C:,M4/4   1 >    16:                     cc      6    D     2    0    2      kern C:,M4/4   1 >    17:                     ee      6    D     2    0    3      kern C:,M4/4   1 >    18:                     4f      7    D     2    0    1      kern C:,M4/4   1 >    19:                      b      7    D     2    0    2      kern C:,M4/4   1 >    20:                     dd      7    D     2    0    3      kern C:,M4/4   1 >    21:                    2e;      8    D     2    0    1      kern C:,M4/4   1 >    22:                    cc;      8    D     2    0    2      kern C:,M4/4   1 >    23:                      =      9    M     2    0    1      kern C:,M4/4   2 >    24:                     *-     10    I     2    0    1      kern C:,M4/4   2 >                         Token Record Type Spine Path Stop Exclusive  Tandem Bar >        DoubleBar BarLabel NData            OTL Piece           Filepath File Label >     1:        NA     <NA>    NA \"Stop\" example     1 examples/Stops.krn    1    _1 >     2:         0     <NA>    NA \"Stop\" example     1 examples/Stops.krn    1    _1 >     3:         0     <NA>    NA \"Stop\" example     1 examples/Stops.krn    1    _1 >     4:         0     <NA>    NA \"Stop\" example     1 examples/Stops.krn    1    _1 >     5:         0        -    NA \"Stop\" example     1 examples/Stops.krn    1    _1 >     6:         0        -     1 \"Stop\" example     1 examples/Stops.krn    1    _1 >     7:         0        -     2 \"Stop\" example     1 examples/Stops.krn    1    _1 >     8:         0        -     3 \"Stop\" example     1 examples/Stops.krn    1    _1 >     9:         0             NA \"Stop\" example     1 examples/Stops.krn    1    _1 >    10:         0             NA \"Stop\" example     1 examples/Stops.krn    1    _1 >    11:         0     <NA>    NA \"Stop\" example     1 examples/Stops.krn    1    _1 >    12:         0     <NA>    NA \"Stop\" example     1 examples/Stops.krn    1    _1 >    13:         0     <NA>    NA \"Stop\" example     1 examples/Stops.krn    1    _1 >    14:         0        -    NA \"Stop\" example     1 examples/Stops.krn    1    _1 >    15:         0        -     1 \"Stop\" example     1 examples/Stops.krn    1    _1 >    16:         0        -     1 \"Stop\" example     1 examples/Stops.krn    1    _1 >    17:         0        -     1 \"Stop\" example     1 examples/Stops.krn    1    _1 >    18:         0        -     2 \"Stop\" example     1 examples/Stops.krn    1    _1 >    19:         0        -     2 \"Stop\" example     1 examples/Stops.krn    1    _1 >    20:         0        -     2 \"Stop\" example     1 examples/Stops.krn    1    _1 >    21:         0        -     3 \"Stop\" example     1 examples/Stops.krn    1    _1 >    22:         0        -     3 \"Stop\" example     1 examples/Stops.krn    1    _1 >    23:         0             NA \"Stop\" example     1 examples/Stops.krn    1    _1 >    24:         0             NA \"Stop\" example     1 examples/Stops.krn    1    _1 >        DoubleBar BarLabel NData            OTL Piece           Filepath File Label >         Filename  Null Filter Global  Key TimeSignature >     1: Stops.krn FALSE  FALSE   TRUE <NA>          <NA> >     2: Stops.krn FALSE  FALSE  FALSE <NA>          <NA> >     3: Stops.krn FALSE  FALSE  FALSE <NA>          M4/4 >     4: Stops.krn FALSE  FALSE  FALSE   C:          M4/4 >     5: Stops.krn FALSE  FALSE  FALSE   C:          M4/4 >     6: Stops.krn FALSE  FALSE  FALSE   C:          M4/4 >     7: Stops.krn  TRUE  FALSE  FALSE   C:          M4/4 >     8: Stops.krn FALSE  FALSE  FALSE   C:          M4/4 >     9: Stops.krn  TRUE  FALSE  FALSE   C:          M4/4 >    10: Stops.krn FALSE  FALSE  FALSE   C:          M4/4 >    11: Stops.krn FALSE  FALSE  FALSE <NA>          <NA> >    12: Stops.krn FALSE  FALSE  FALSE <NA>          M4/4 >    13: Stops.krn FALSE  FALSE  FALSE   C:          M4/4 >    14: Stops.krn FALSE  FALSE  FALSE   C:          M4/4 >    15: Stops.krn FALSE  FALSE  FALSE   C:          M4/4 >    16: Stops.krn FALSE  FALSE  FALSE   C:          M4/4 >    17: Stops.krn FALSE  FALSE  FALSE   C:          M4/4 >    18: Stops.krn FALSE  FALSE  FALSE   C:          M4/4 >    19: Stops.krn FALSE  FALSE  FALSE   C:          M4/4 >    20: Stops.krn FALSE  FALSE  FALSE   C:          M4/4 >    21: Stops.krn FALSE  FALSE  FALSE   C:          M4/4 >    22: Stops.krn FALSE  FALSE  FALSE   C:          M4/4 >    23: Stops.krn  TRUE  FALSE  FALSE   C:          M4/4 >    24: Stops.krn FALSE  FALSE  FALSE   C:          M4/4 >         Filename  Null Filter Global  Key TimeSignature"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/GettingStarted.html","id":"paths","dir":"Articles","previous_headings":"The Data Model > data.frames","what":"Paths","title":"Getting started with humdrumR","text":"humdrum data contains “spine paths”—places single spine splits two. humdrum\\(_{\\mathbb{R}}\\) treats spine paths “subspines” main spine split , one numbered Path field. starting path (leftmost) numbered path 0—datasets spine paths, Path field zeros. paths numbered higher integers. Let’s look simple example: complex example: Notice humdrum\\(_{\\mathbb{R}}\\) prints paths way readable reading humdrum syntax directly: paths “shifted” columns align. option function .matrix.humdrumR().","code":"paths1 <- readHumdrum('examples/Paths.krn')  paths1 >    ###### vvv Paths.krn vvv ###### >       1:  !!!OTL: \"Path\" example >       2:    **kern     **kern      >       3:     *M4/4      *M4/4      >       4:       *C:        *C:      >       5:        =-         =-      >       6:        4C    4cc 4ee      >       7:        4D     4b 4dd      >       8:        4E     2a 2cc      >       9:        4F          .      >      10:         =          =      >      11:         *         *^      >      12:        1G         8g  4cc >      13:         .         8a    . >      14:         .         8g   4a >      15:         .        8f#    . >      16:         .         4g   2b >      17:         .         4f    . >      18:         *         *v   *v >      19:         =          =      >      20:        1C  1e 1g 1cc      >      21:        ==         ==      >      22:        *-         *-      >    ###### ^^^ Paths.krn ^^^ ###### >        Data fields:  >               *Token :: character  paths1$Path >    ##### vvv Paths.krn vvv ##### >       1:  !!!OTL: \"Path\" example >       2:    0      0    >       3:    0      0    >       4:    0      0    >       5:    0      0    >       6:    0    0 0    >       7:    0    0 0    >       8:    0    0 0    >       9:    0      0    >      10:    0      0    >      11:    0      0    >      12:    0      0  1 >      13:    0      0  1 >      14:    0      0  1 >      15:    0      0  1 >      16:    0      0  1 >      17:    0      0  1 >      18:    0      0  1 >      19:    0      0    >      20:    0  0 0 0    >      21:    0      0    >      22:    0      0    >    ##### ^^^ Paths.krn ^^^ ##### >        Data fields:  >                Token :: character  getHumtab(paths1) >                         Token Record Type Spine Path Stop Exclusive  Tandem Bar >     1: !!!OTL: \"Path\" example      1    G    NA   NA   NA      <NA>    <NA>  NA >     2:                 **kern      2    I     1    0    1      kern           0 >     3:                  *M4/4      3    I     1    0    1      kern    M4/4   0 >     4:                    *C:      4    I     1    0    1      kern C:,M4/4   0 >     5:                     =-      5    M     1    0    1      kern C:,M4/4   1 >     6:                     4C      6    D     1    0    1      kern C:,M4/4   1 >     7:                     4D      7    D     1    0    1      kern C:,M4/4   1 >     8:                     4E      8    D     1    0    1      kern C:,M4/4   1 >     9:                     4F      9    D     1    0    1      kern C:,M4/4   1 >    10:                      =     10    M     1    0    1      kern C:,M4/4   2 >    11:                      *     11    I     1    0    1      kern C:,M4/4   2 >    12:                     1G     12    D     1    0    1      kern C:,M4/4   2 >    13:                      .     13    d     1    0    1      kern C:,M4/4   2 >    14:                      .     14    d     1    0    1      kern C:,M4/4   2 >    15:                      .     15    d     1    0    1      kern C:,M4/4   2 >    16:                      .     16    d     1    0    1      kern C:,M4/4   2 >    17:                      .     17    d     1    0    1      kern C:,M4/4   2 >    18:                      *     18    I     1    0    1      kern C:,M4/4   2 >    19:                      =     19    M     1    0    1      kern C:,M4/4   3 >    20:                     1C     20    D     1    0    1      kern C:,M4/4   3 >    21:                     ==     21    M     1    0    1      kern C:,M4/4   4 >    22:                     *-     22    I     1    0    1      kern C:,M4/4   4 >    23:                 **kern      2    I     2    0    1      kern           0 >    24:                  *M4/4      3    I     2    0    1      kern    M4/4   0 >    25:                    *C:      4    I     2    0    1      kern C:,M4/4   0 >    26:                     =-      5    M     2    0    1      kern C:,M4/4   1 >    27:                    4cc      6    D     2    0    1      kern C:,M4/4   1 >    28:                    4ee      6    D     2    0    2      kern C:,M4/4   1 >    29:                     4b      7    D     2    0    1      kern C:,M4/4   1 >    30:                    4dd      7    D     2    0    2      kern C:,M4/4   1 >    31:                     2a      8    D     2    0    1      kern C:,M4/4   1 >    32:                    2cc      8    D     2    0    2      kern C:,M4/4   1 >    33:                      .      9    d     2    0    1      kern C:,M4/4   1 >    34:                      =     10    M     2    0    1      kern C:,M4/4   2 >    35:                     *^     11    I     2    0    1      kern C:,M4/4   2 >    36:                     8g     12    D     2    0    1      kern C:,M4/4   2 >    37:                     8a     13    D     2    0    1      kern C:,M4/4   2 >    38:                     8g     14    D     2    0    1      kern C:,M4/4   2 >    39:                    8f#     15    D     2    0    1      kern C:,M4/4   2 >    40:                     4g     16    D     2    0    1      kern C:,M4/4   2 >    41:                     4f     17    D     2    0    1      kern C:,M4/4   2 >    42:                     *v     18    I     2    0    1      kern C:,M4/4   2 >    43:                      =     19    M     2    0    1      kern C:,M4/4   3 >    44:                     1e     20    D     2    0    1      kern C:,M4/4   3 >    45:                     1g     20    D     2    0    2      kern C:,M4/4   3 >    46:                    1cc     20    D     2    0    3      kern C:,M4/4   3 >    47:                     ==     21    M     2    0    1      kern C:,M4/4   4 >    48:                     *-     22    I     2    0    1      kern C:,M4/4   4 >    49:                    4cc     12    D     2    1    1      kern C:,M4/4   2 >    50:                      .     13    d     2    1    1      kern C:,M4/4   2 >    51:                     4a     14    D     2    1    1      kern C:,M4/4   2 >    52:                      .     15    d     2    1    1      kern C:,M4/4   2 >    53:                     2b     16    D     2    1    1      kern C:,M4/4   2 >    54:                      .     17    d     2    1    1      kern C:,M4/4   2 >    55:                     *v     18    I     2    1    1      kern C:,M4/4   2 >                         Token Record Type Spine Path Stop Exclusive  Tandem Bar >        DoubleBar BarLabel NData            OTL Piece           Filepath File Label >     1:        NA     <NA>    NA \"Path\" example     1 examples/Paths.krn    1    _1 >     2:         0     <NA>    NA \"Path\" example     1 examples/Paths.krn    1    _1 >     3:         0     <NA>    NA \"Path\" example     1 examples/Paths.krn    1    _1 >     4:         0     <NA>    NA \"Path\" example     1 examples/Paths.krn    1    _1 >     5:         0        -    NA \"Path\" example     1 examples/Paths.krn    1    _1 >     6:         0        -     5 \"Path\" example     1 examples/Paths.krn    1    _1 >     7:         0        -     6 \"Path\" example     1 examples/Paths.krn    1    _1 >     8:         0        -     7 \"Path\" example     1 examples/Paths.krn    1    _1 >     9:         0        -     8 \"Path\" example     1 examples/Paths.krn    1    _1 >    10:         0             NA \"Path\" example     1 examples/Paths.krn    1    _1 >    11:         0             NA \"Path\" example     1 examples/Paths.krn    1    _1 >    12:         0             11 \"Path\" example     1 examples/Paths.krn    1    _1 >    13:         0             12 \"Path\" example     1 examples/Paths.krn    1    _1 >    14:         0             13 \"Path\" example     1 examples/Paths.krn    1    _1 >    15:         0             14 \"Path\" example     1 examples/Paths.krn    1    _1 >    16:         0             15 \"Path\" example     1 examples/Paths.krn    1    _1 >    17:         0             16 \"Path\" example     1 examples/Paths.krn    1    _1 >    18:         0             NA \"Path\" example     1 examples/Paths.krn    1    _1 >    19:         0             NA \"Path\" example     1 examples/Paths.krn    1    _1 >    20:         0             18 \"Path\" example     1 examples/Paths.krn    1    _1 >    21:         1        =    NA \"Path\" example     1 examples/Paths.krn    1    _1 >    22:         1        =    NA \"Path\" example     1 examples/Paths.krn    1    _1 >    23:         0     <NA>    NA \"Path\" example     1 examples/Paths.krn    1    _1 >    24:         0     <NA>    NA \"Path\" example     1 examples/Paths.krn    1    _1 >    25:         0     <NA>    NA \"Path\" example     1 examples/Paths.krn    1    _1 >    26:         0        -    NA \"Path\" example     1 examples/Paths.krn    1    _1 >    27:         0        -     5 \"Path\" example     1 examples/Paths.krn    1    _1 >    28:         0        -     5 \"Path\" example     1 examples/Paths.krn    1    _1 >    29:         0        -     6 \"Path\" example     1 examples/Paths.krn    1    _1 >    30:         0        -     6 \"Path\" example     1 examples/Paths.krn    1    _1 >    31:         0        -     7 \"Path\" example     1 examples/Paths.krn    1    _1 >    32:         0        -     7 \"Path\" example     1 examples/Paths.krn    1    _1 >    33:         0        -     8 \"Path\" example     1 examples/Paths.krn    1    _1 >    34:         0             NA \"Path\" example     1 examples/Paths.krn    1    _1 >    35:         0             NA \"Path\" example     1 examples/Paths.krn    1    _1 >    36:         0             11 \"Path\" example     1 examples/Paths.krn    1    _1 >    37:         0             12 \"Path\" example     1 examples/Paths.krn    1    _1 >    38:         0             13 \"Path\" example     1 examples/Paths.krn    1    _1 >    39:         0             14 \"Path\" example     1 examples/Paths.krn    1    _1 >    40:         0             15 \"Path\" example     1 examples/Paths.krn    1    _1 >    41:         0             16 \"Path\" example     1 examples/Paths.krn    1    _1 >    42:         0             NA \"Path\" example     1 examples/Paths.krn    1    _1 >    43:         0             NA \"Path\" example     1 examples/Paths.krn    1    _1 >    44:         0             18 \"Path\" example     1 examples/Paths.krn    1    _1 >    45:         0             18 \"Path\" example     1 examples/Paths.krn    1    _1 >    46:         0             18 \"Path\" example     1 examples/Paths.krn    1    _1 >    47:         1        =    NA \"Path\" example     1 examples/Paths.krn    1    _1 >    48:         1        =    NA \"Path\" example     1 examples/Paths.krn    1    _1 >    49:         0             11 \"Path\" example     1 examples/Paths.krn    1    _1 >    50:         0             12 \"Path\" example     1 examples/Paths.krn    1    _1 >    51:         0             13 \"Path\" example     1 examples/Paths.krn    1    _1 >    52:         0             14 \"Path\" example     1 examples/Paths.krn    1    _1 >    53:         0             15 \"Path\" example     1 examples/Paths.krn    1    _1 >    54:         0             16 \"Path\" example     1 examples/Paths.krn    1    _1 >    55:         0             NA \"Path\" example     1 examples/Paths.krn    1    _1 >        DoubleBar BarLabel NData            OTL Piece           Filepath File Label >         Filename  Null Filter Global  Key TimeSignature >     1: Paths.krn  TRUE  FALSE   TRUE <NA>          <NA> >     2: Paths.krn FALSE  FALSE  FALSE <NA>          <NA> >     3: Paths.krn FALSE  FALSE  FALSE <NA>          M4/4 >     4: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >     5: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >     6: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >     7: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >     8: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >     9: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    10: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    11: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    12: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    13: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    14: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    15: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    16: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    17: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    18: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    19: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    20: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    21: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    22: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    23: Paths.krn FALSE  FALSE  FALSE <NA>          <NA> >    24: Paths.krn FALSE  FALSE  FALSE <NA>          M4/4 >    25: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    26: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    27: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    28: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    29: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    30: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    31: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    32: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    33: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    34: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    35: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    36: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    37: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    38: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    39: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    40: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    41: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    42: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    43: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    44: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    45: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    46: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    47: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    48: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    49: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    50: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    51: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    52: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    53: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    54: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >    55: Paths.krn FALSE  FALSE  FALSE   C:          M4/4 >         Filename  Null Filter Global  Key TimeSignature paths2 <- readHumdrum('examples/Paths2.krn')  paths2 >    ######## vvv Paths2.krn vvv ######### >       1:  !!!OTL: complex \"Path\" example >       2:    **path             >       3:         a             >       4:        *^             >       5:         b       c     >       6:         d       e     >       7:        *^       *     >       8:         f   g   h     >       9:         i   j   k     >      10:        *v  *v   *     >      11:         l       m     >      12:         n       o     >      13:         *      *^     >      14:         p       q   r >      15:         s       t   u >      16:         *      *v  *v >      17:         v       w     >      18:         x       y     >      19:        *v      *v     >      20:         z             >      21:        *-             >    ######## ^^^ Paths2.krn ^^^ ######### >        Data fields:  >               *Token :: character  paths2$Path >    ######## vvv Paths2.krn vvv ######### >       1:  !!!OTL: complex \"Path\" example >       2:    0          >       3:    0          >       4:    0          >       5:    0     2    >       6:    0     2    >       7:    0     2    >       8:    0  1  2    >       9:    0  1  2    >      10:    0  1  2    >      11:    0     2    >      12:    0     2    >      13:    0     2    >      14:    0     2  3 >      15:    0     2  3 >      16:    0     2  3 >      17:    0     2    >      18:    0     2    >      19:    0     2    >      20:    0          >      21:    0          >    ######## ^^^ Paths2.krn ^^^ ######### >        Data fields:  >                Token :: character  getHumtab(paths2) >                                 Token Record Type Spine Path Stop Exclusive Tandem >     1: !!!OTL: complex \"Path\" example      1    G    NA   NA   NA      <NA>   <NA> >     2:                         **path      2    I     1    0    1      path        >     3:                              a      3    D     1    0    1      path        >     4:                             *^      4    I     1    0    1      path        >     5:                              b      5    D     1    0    1      path        >     6:                              d      6    D     1    0    1      path        >     7:                             *^      7    I     1    0    1      path        >     8:                              f      8    D     1    0    1      path        >     9:                              i      9    D     1    0    1      path        >    10:                             *v     10    I     1    0    1      path        >    11:                              l     11    D     1    0    1      path        >    12:                              n     12    D     1    0    1      path        >    13:                              *     13    I     1    0    1      path        >    14:                              p     14    D     1    0    1      path        >    15:                              s     15    D     1    0    1      path        >    16:                              *     16    I     1    0    1      path        >    17:                              v     17    D     1    0    1      path        >    18:                              x     18    D     1    0    1      path        >    19:                             *v     19    I     1    0    1      path        >    20:                              z     20    D     1    0    1      path        >    21:                             *-     21    I     1    0    1      path        >    22:                              g      8    D     1    1    1      path        >    23:                              j      9    D     1    1    1      path        >    24:                             *v     10    I     1    1    1      path        >    25:                              c      5    D     1    2    1      path        >    26:                              e      6    D     1    2    1      path        >    27:                              *      7    I     1    2    1      path        >    28:                              h      8    D     1    2    1      path        >    29:                              k      9    D     1    2    1      path        >    30:                              *     10    I     1    2    1      path        >    31:                              m     11    D     1    2    1      path        >    32:                              o     12    D     1    2    1      path        >    33:                             *^     13    I     1    2    1      path        >    34:                              q     14    D     1    2    1      path        >    35:                              t     15    D     1    2    1      path        >    36:                             *v     16    I     1    2    1      path        >    37:                              w     17    D     1    2    1      path        >    38:                              y     18    D     1    2    1      path        >    39:                             *v     19    I     1    2    1      path        >    40:                              r     14    D     1    3    1      path        >    41:                              u     15    D     1    3    1      path        >    42:                             *v     16    I     1    3    1      path        >                                 Token Record Type Spine Path Stop Exclusive Tandem >        Bar DoubleBar BarLabel NData                    OTL Piece >     1:  NA        NA     <NA>    NA complex \"Path\" example     1 >     2:   0         0     <NA>    NA complex \"Path\" example     1 >     3:   0         0     <NA>     2 complex \"Path\" example     1 >     4:   0         0     <NA>    NA complex \"Path\" example     1 >     5:   0         0     <NA>     4 complex \"Path\" example     1 >     6:   0         0     <NA>     5 complex \"Path\" example     1 >     7:   0         0     <NA>    NA complex \"Path\" example     1 >     8:   0         0     <NA>     7 complex \"Path\" example     1 >     9:   0         0     <NA>     8 complex \"Path\" example     1 >    10:   0         0     <NA>    NA complex \"Path\" example     1 >    11:   0         0     <NA>    10 complex \"Path\" example     1 >    12:   0         0     <NA>    11 complex \"Path\" example     1 >    13:   0         0     <NA>    NA complex \"Path\" example     1 >    14:   0         0     <NA>    13 complex \"Path\" example     1 >    15:   0         0     <NA>    14 complex \"Path\" example     1 >    16:   0         0     <NA>    NA complex \"Path\" example     1 >    17:   0         0     <NA>    16 complex \"Path\" example     1 >    18:   0         0     <NA>    17 complex \"Path\" example     1 >    19:   0         0     <NA>    NA complex \"Path\" example     1 >    20:   0         0     <NA>    19 complex \"Path\" example     1 >    21:   0         0     <NA>    NA complex \"Path\" example     1 >    22:   0         0     <NA>     7 complex \"Path\" example     1 >    23:   0         0     <NA>     8 complex \"Path\" example     1 >    24:   0         0     <NA>    NA complex \"Path\" example     1 >    25:   0         0     <NA>     4 complex \"Path\" example     1 >    26:   0         0     <NA>     5 complex \"Path\" example     1 >    27:   0         0     <NA>    NA complex \"Path\" example     1 >    28:   0         0     <NA>     7 complex \"Path\" example     1 >    29:   0         0     <NA>     8 complex \"Path\" example     1 >    30:   0         0     <NA>    NA complex \"Path\" example     1 >    31:   0         0     <NA>    10 complex \"Path\" example     1 >    32:   0         0     <NA>    11 complex \"Path\" example     1 >    33:   0         0     <NA>    NA complex \"Path\" example     1 >    34:   0         0     <NA>    13 complex \"Path\" example     1 >    35:   0         0     <NA>    14 complex \"Path\" example     1 >    36:   0         0     <NA>    NA complex \"Path\" example     1 >    37:   0         0     <NA>    16 complex \"Path\" example     1 >    38:   0         0     <NA>    17 complex \"Path\" example     1 >    39:   0         0     <NA>    NA complex \"Path\" example     1 >    40:   0         0     <NA>    13 complex \"Path\" example     1 >    41:   0         0     <NA>    14 complex \"Path\" example     1 >    42:   0         0     <NA>    NA complex \"Path\" example     1 >        Bar DoubleBar BarLabel NData                    OTL Piece >                   Filepath File Label   Filename  Null Filter Global >     1: examples/Paths2.krn    1    _1 Paths2.krn  TRUE  FALSE   TRUE >     2: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >     3: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >     4: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >     5: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >     6: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >     7: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >     8: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >     9: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    10: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    11: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    12: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    13: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    14: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    15: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    16: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    17: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    18: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    19: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    20: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    21: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    22: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    23: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    24: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    25: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    26: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    27: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    28: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    29: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    30: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    31: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    32: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    33: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    34: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    35: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    36: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    37: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    38: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    39: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    40: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    41: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >    42: examples/Paths2.krn    1    _1 Paths2.krn FALSE  FALSE  FALSE >                   Filepath File Label   Filename  Null Filter Global"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/GettingStarted.html","id":"doing-stuff","dir":"Articles","previous_headings":"","what":"Doing Stuff!","title":"Getting started with humdrumR","text":"Ok, ’ve now seen read inspect humdrum\\(_{\\mathbb{R}}\\) data. ’ve also got idea humdrum data looks like surface: humdrum table. can ? create humdrum\\(_{\\mathbb{R}}\\) corpus object, using readHumdrum, object encapsulates humdrum-table (data.table) object, data really stored. ’ve already seen can extract humdrum table directly using getHumtab—already R pro, might just want extract table work directly. However, humdrum\\(_{\\mathbb{R}}\\) object give us convenient ways working table. example, ’ve already seen print humdrum\\(_{\\mathbb{R}}\\) objects, print humdrum syntax, easier read complex humdrum table! humdrum\\(_{\\mathbb{R}}\\) ! main thing humdrum\\(_{\\mathbb{R}}\\) allow us work fields humdrum-tables way convenient powerful. First, create special R “expressions” refer humdrum-table’s fields. instance, can write things like: Spine + File nchar(Token) paste0(Token, Record) However, can tell humdrum\\(_{\\mathbb{R}}\\) evaluate expressions using fields humdrum tables. simplest way using within() function, takes humdrum\\(_{\\mathbb{R}}\\) object expression right side. expression evaluated, result put back place humdrum data! ’ll also notice printout, new Data field, called Result1—default name humdrum\\(_{\\mathbb{R}}\\) assigns new fields create. want, can pick names using <- within within call. instance, lets use humdrum\\(_{\\mathbb{R}}\\)’s semits function (see humdrum pitch vignette) calculate semitone value pitch chorales: worked! Lets , save result new field, call Semits—course, give name want, just let called Result1 want! now new Data field humdrum table, called Semits. Meanwhile, original Token field still , safely unchanged! Just like , can use $ operator look fields: Whats , can use Semits field just like field:","code":"within(chorales, Spine + File) >    ############################# vvv chor001.krn vvv ############################# >         1:  !!!COM: Bach, Johann Sebastian >         2:  !!!CDT: 1685/02/21/-1750/07/28/ >         3:  !!!OTL@@DE: Aus meines Herzens Grunde >         4:  !!!OTL@EN:      From the Depths of My Heart >         5:  !!!SCT: BWV 269 >         6:  !!!PC#: 1 >         7:  !!!AGN: chorale >         8:          **kern        **kern        **kern        **kern >         9:          *ICvox        *ICvox        *ICvox        *ICvox >        10:          *Ibass       *Itenor        *Ialto       *Isoprn >        11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >        12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >        13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >        14:             *>A           *>A           *>A           *>A >        15:         *clefF4      *clefGv2       *clefG2       *clefG2 >        16:          *k[f#]        *k[f#]        *k[f#]        *k[f#] >        17:             *G:           *G:           *G:           *G: >        18:             *F:             *             *             * >        19:           *M3/4         *M3/4         *M3/4         *M3/4 >        20:          *MM100        *MM100        *MM100        *MM100 >        21:               2             3             4             5 >        22:              =1            =1            =1            =1 >        23:               2             3             4             5 >        24:               2             3             4             . >        25:               .             3             .             . >        26:               2             3             4             5 >        27:              =2            =2            =2            =2 >        28:               2             3             4             5 >        29:               2             3             .             . >        30:               .             .             .             5 >        31:               2             3             4             5 >        32:              =3            =3            =3            =3 >        33:               2             3             4             5 >        34:               .             3             4             . >        35:               2             3             4             . >        36:               2             .             4             5 >        37:               2             3             4             5 >        38:              =4            =4            =4            =4 >        39:               2             3             4             5 >        40:               2             3             4             5 >    41-134::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################# ^^^ chor001.krn ^^^ ############################# >     >           (8 more files...) >     >    ############################# vvv chor010.krn vvv ############################# >      1-60::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >        61:              11            12            13            14 >        62:              11            12            13            14 >        63:              =9            =9            =9            =9 >        64:              11            12            13            14 >        65:              11            12            13            14 >        66:              11             .             .             . >        67:              11            12            13            14 >        68:               .             .            13             . >        69:              11            12            13            14 >        70:             =10           =10           =10           =10 >        71:              11            12            13            14 >        72:               .            12             .             . >        73:              11             .            13            14 >        74:               .            12             .             . >        75:              11            12            13            14 >        76:             =11           =11           =11           =11 >        77:              11            12            13            14 >        78:              11            12            13            14 >        79:              11            12            13            14 >        80:               .             .            13             . >        81:             =12           =12           =12           =12 >        82:              11            12            13            14 >        83:              11            12            13            14 >        84:              11            12            13            14 >        85:              11            12             .            14 >        86:             =13           =13           =13           =13 >        87:              11            12            13            14 >        88:              11            12            13             . >        89:              11            12            13             . >        90:              ==            ==            ==            == >        91:              *-            *-            *-            *- >        92:  !!!hum2abc: -Q '' >        93:  !!!title: @{PC#}. @{OTL@@DE} >        94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** >        95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** >        96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** >        97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** >        98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >        99:  !!!EED:  Craig Stuart Sapp >       100:  !!!EEV:  2009/05/22 >    ############################# ^^^ chor010.krn ^^^ ############################# >                           (***four global comments truncated due to screen size***) >     >       humdrumR corpus of ten files. >        Data fields:  >                Token   :: character >               *Result1 :: integer  within(chorales,  nchar(Token)) >    ############################# vvv chor001.krn vvv ############################# >         1:  !!!COM: Bach, Johann Sebastian >         2:  !!!CDT: 1685/02/21/-1750/07/28/ >         3:  !!!OTL@@DE: Aus meines Herzens Grunde >         4:  !!!OTL@EN:      From the Depths of My Heart >         5:  !!!SCT: BWV 269 >         6:  !!!PC#: 1 >         7:  !!!AGN: chorale >         8:          **kern        **kern        **kern        **kern >         9:          *ICvox        *ICvox        *ICvox        *ICvox >        10:          *Ibass       *Itenor        *Ialto       *Isoprn >        11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >        12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >        13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >        14:             *>A           *>A           *>A           *>A >        15:         *clefF4      *clefGv2       *clefG2       *clefG2 >        16:          *k[f#]        *k[f#]        *k[f#]        *k[f#] >        17:             *G:           *G:           *G:           *G: >        18:             *F:             *             *             * >        19:           *M3/4         *M3/4         *M3/4         *M3/4 >        20:          *MM100        *MM100        *MM100        *MM100 >        21:               3             2             2             2 >        22:              =1            =1            =1            =1 >        23:               2             2             2             2 >        24:               2             3             2             . >        25:               .             3             .             . >        26:               3             2             2             3 >        27:              =2            =2            =2            =2 >        28:               2             2             2             3 >        29:               2             3             .             . >        30:               .             .             .             2 >        31:               2             2             2             2 >        32:              =3            =3            =3            =3 >        33:               2             3             3             3 >        34:               .             3             2             . >        35:               4             2             2             . >        36:               4             .             4             2 >        37:               3             2             2             2 >        38:              =4            =4            =4            =4 >        39:               3             3             4             3 >        40:               3             2             2             2 >    41-134::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################# ^^^ chor001.krn ^^^ ############################# >     >           (8 more files...) >     >    ############################# vvv chor010.krn vvv ############################# >      1-60::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >        61:               4             3             3             3 >        62:               2             2             2             3 >        63:              =9            =9            =9            =9 >        64:               2             2             2             2 >        65:               3             2             2             3 >        66:               3             .             .             . >        67:               3             2             3             3 >        68:               .             .             3             . >        69:               2             2             2             2 >        70:             =10           =10           =10           =10 >        71:               2             3             2             2 >        72:               .             2             .             . >        73:               2             .             2             2 >        74:               .             3             .             . >        75:               4             3             3             3 >        76:             =11           =11           =11           =11 >        77:               2             2             2             2 >        78:               3             2             2             3 >        79:               2             3             3             2 >        80:               .             .             3             . >        81:             =12           =12           =12           =12 >        82:               2             2             2             2 >        83:               2             2             2             2 >        84:               4             2             3             2 >        85:               3             2             .             2 >        86:             =13           =13           =13           =13 >        87:               4             2             3             3 >        88:               3             2             2             . >        89:               4             5             3             . >        90:              ==            ==            ==            == >        91:              *-            *-            *-            *- >        92:  !!!hum2abc: -Q '' >        93:  !!!title: @{PC#}. @{OTL@@DE} >        94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** >        95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** >        96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** >        97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** >        98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >        99:  !!!EED:  Craig Stuart Sapp >       100:  !!!EEV:  2009/05/22 >    ############################# ^^^ chor010.krn ^^^ ############################# >                           (***four global comments truncated due to screen size***) >     >       humdrumR corpus of ten files. >        Data fields:  >                Token   :: character >               *Result1 :: integer  within(chorales,  paste0(Token, Record)) >    ############################# vvv chor001.krn vvv ############################# >         1:  !!!COM: Bach, Johann Sebastian >         2:  !!!CDT: 1685/02/21/-1750/07/28/ >         3:  !!!OTL@@DE: Aus meines Herzens Grunde >         4:  !!!OTL@EN:      From the Depths of My Heart >         5:  !!!SCT: BWV 269 >         6:  !!!PC#: 1 >         7:  !!!AGN: chorale >         8:          **kern        **kern        **kern        **kern >         9:          *ICvox        *ICvox        *ICvox        *ICvox >        10:          *Ibass       *Itenor        *Ialto       *Isoprn >        11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >        12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >        13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >        14:             *>A           *>A           *>A           *>A >        15:         *clefF4      *clefGv2       *clefG2       *clefG2 >        16:          *k[f#]        *k[f#]        *k[f#]        *k[f#] >        17:             *G:           *G:           *G:           *G: >        18:             *F:             *             *             * >        19:           *M3/4         *M3/4         *M3/4         *M3/4 >        20:          *MM100        *MM100        *MM100        *MM100 >        21:           4GG21          4B21          4d21          4g21 >        22:              =1            =1            =1            =1 >        23:            4G23          4B23          4d23          2g23 >        24:            4E24         8cL24          4e24             . >        25:               .         8BJ25             .             . >        26:           4F#26          4A26          4d26         4dd26 >        27:              =2            =2            =2            =2 >        28:            4G28          4G28          2d28         4.b28 >        29:            4D29         4F#29             .             . >        30:               .             .             .          8a30 >        31:            4E31          4G31          4B31          4g31 >        32:              =3            =3            =3            =3 >        33:            4C33         8cL33         8eL33         4.g33 >        34:               .         8BJ34          8d34             . >        35:          8BBL35          4c35          8e35             . >        36:          8AAJ36             .        8f#J36          8a36 >        37:           4GG37          4d37          4g37          4b37 >        38:              =4            =4            =4            =4 >        39:           2D;39         2d;39        2f#;39         2a;39 >        40:           4GG40          4d40          4g40          4b40 >    41-134::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################# ^^^ chor001.krn ^^^ ############################# >     >           (8 more files...) >     >    ############################# vvv chor010.krn vvv ############################# >      1-60::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >        61:          2AA;61         2c;61         2e;61         2a;61 >        62:            2A62          2e62          2a62         2cc62 >        63:              =9            =9            =9            =9 >        64:            4E64          4e64          4g64          4b64 >        65:           8DL65          4e65          4g65         4cc65 >        66:           8CJ66             .             .             . >        67:           4BB67          4d67         8gL67         4dd67 >        68:               .             .         8fJ68             . >        69:            4C69          4c69          4e69          4g69 >        70:             =10           =10           =10           =10 >        71:            4D71         8F#71          4d71          4b71 >        72:               .          4G72             .             . >        73:            4D73             .          4c73          4a73 >        74:               .         8F#74             .             . >        75:          2GG;75         2G;75         2B;75         2g;75 >        76:             =11           =11           =11           =11 >        77:            2C77          2G77          2e77          2g77 >        78:           4AA78          4A78          4e78         4cc78 >        79:            4E79         4G#79         8eL79          4b79 >        80:               .             .         8dJ80             . >        81:             =12           =12           =12           =12 >        82:            4F82          4A82          4c82          4a82 >        83:            4C83          4G83          4c83          4e83 >        84:          4BB-84          4G84         [2d84          4g84 >        85:           4AA85          4A85             .          4f85 >        86:             =13           =13           =13           =13 >        87:          4GG#87          4B87         4d]87         1e;87 >        88:           4AA88          4A88          4c88             . >        89:          2EE;89       2G#X;89         2B;89             . >        90:              ==            ==            ==            == >        91:              *-            *-            *-            *- >        92:  !!!hum2abc: -Q '' >        93:  !!!title: @{PC#}. @{OTL@@DE} >        94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** >        95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** >        96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** >        97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** >        98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >        99:  !!!EED:  Craig Stuart Sapp >       100:  !!!EEV:  2009/05/22 >    ############################# ^^^ chor010.krn ^^^ ############################# >                           (***four global comments truncated due to screen size***) >     >       humdrumR corpus of ten files. >        Data fields:  >                Token   :: character >               *Result1 :: character within(chorales, semits(Token)) >    ############################# vvv chor001.krn vvv ############################# >         1:  !!!COM: Bach, Johann Sebastian >         2:  !!!CDT: 1685/02/21/-1750/07/28/ >         3:  !!!OTL@@DE: Aus meines Herzens Grunde >         4:  !!!OTL@EN:      From the Depths of My Heart >         5:  !!!SCT: BWV 269 >         6:  !!!PC#: 1 >         7:  !!!AGN: chorale >         8:          **kern        **kern        **kern        **kern >         9:          *ICvox        *ICvox        *ICvox        *ICvox >        10:          *Ibass       *Itenor        *Ialto       *Isoprn >        11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >        12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >        13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >        14:             *>A           *>A           *>A           *>A >        15:         *clefF4      *clefGv2       *clefG2       *clefG2 >        16:          *k[f#]        *k[f#]        *k[f#]        *k[f#] >        17:             *G:           *G:           *G:           *G: >        18:             *F:             *             *             * >        19:           *M3/4         *M3/4         *M3/4         *M3/4 >        20:          *MM100        *MM100        *MM100        *MM100 >        21:             -17            -1             2             7 >        22:              =1            =1            =1            =1 >        23:              -5            -1             2             7 >        24:              -8             0             4             . >        25:               .            -1             .             . >        26:              -6            -3             2            14 >        27:              =2            =2            =2            =2 >        28:              -5            -5             2            11 >        29:             -10            -6             .             . >        30:               .             .             .             9 >        31:              -8            -5            -1             7 >        32:              =3            =3            =3            =3 >        33:             -12             0             4             7 >        34:               .            -1             2             . >        35:             -13             0             4             . >        36:             -15             .             6             9 >        37:             -17             2             7            11 >        38:              =4            =4            =4            =4 >        39:             -10             2             6             9 >        40:             -17             2             7            11 >    41-134::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################# ^^^ chor001.krn ^^^ ############################# >     >           (8 more files...) >     >    ############################# vvv chor010.krn vvv ############################# >      1-60::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >        61:             -15             0             4             9 >        62:              -3             4             9            12 >        63:              =9            =9            =9            =9 >        64:              -8             4             7            11 >        65:             -10             4             7            12 >        66:             -12             .             .             . >        67:             -13             2             7            14 >        68:               .             .             5             . >        69:             -12             0             4             7 >        70:             =10           =10           =10           =10 >        71:             -10            -6             2            11 >        72:               .            -5             .             . >        73:             -10             .             0             9 >        74:               .            -6             .             . >        75:             -17            -5            -1             7 >        76:             =11           =11           =11           =11 >        77:             -12            -5             4             7 >        78:             -15            -3             4            12 >        79:              -8            -4             4            11 >        80:               .             .             2             . >        81:             =12           =12           =12           =12 >        82:              -7            -3             0             9 >        83:             -12            -5             0             4 >        84:             -14            -5             2             7 >        85:             -15            -3             .             5 >        86:             =13           =13           =13           =13 >        87:             -16            -1             2             4 >        88:             -15            -3             0             . >        89:             -20            -4            -1             . >        90:              ==            ==            ==            == >        91:              *-            *-            *-            *- >        92:  !!!hum2abc: -Q '' >        93:  !!!title: @{PC#}. @{OTL@@DE} >        94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** >        95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** >        96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** >        97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** >        98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >        99:  !!!EED:  Craig Stuart Sapp >       100:  !!!EEV:  2009/05/22 >    ############################# ^^^ chor010.krn ^^^ ############################# >                           (***four global comments truncated due to screen size***) >     >       humdrumR corpus of ten files. >        Data fields:  >                Token   :: character >               *Result1 :: integer within(chorales, semits(Token) -> Semits) -> chorales chorales$Token >    ############################# vvv chor001.krn vvv ############################# >         1:  !!!COM: Bach, Johann Sebastian >         2:  !!!CDT: 1685/02/21/-1750/07/28/ >         3:  !!!OTL@@DE: Aus meines Herzens Grunde >         4:  !!!OTL@EN:      From the Depths of My Heart >         5:  !!!SCT: BWV 269 >         6:  !!!PC#: 1 >         7:  !!!AGN: chorale >         8:          **kern        **kern        **kern        **kern >         9:          *ICvox        *ICvox        *ICvox        *ICvox >        10:          *Ibass       *Itenor        *Ialto       *Isoprn >        11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >        12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >        13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >        14:             *>A           *>A           *>A           *>A >        15:         *clefF4      *clefGv2       *clefG2       *clefG2 >        16:          *k[f#]        *k[f#]        *k[f#]        *k[f#] >        17:             *G:           *G:           *G:           *G: >        18:             *F:             *             *             * >        19:           *M3/4         *M3/4         *M3/4         *M3/4 >        20:          *MM100        *MM100        *MM100        *MM100 >        21:             4GG            4B            4d            4g >        22:              =1            =1            =1            =1 >        23:              4G            4B            4d            2g >        24:              4E           8cL            4e             . >        25:               .           8BJ             .             . >        26:             4F#            4A            4d           4dd >        27:              =2            =2            =2            =2 >        28:              4G            4G            2d           4.b >        29:              4D           4F#             .             . >        30:               .             .             .            8a >        31:              4E            4G            4B            4g >        32:              =3            =3            =3            =3 >        33:              4C           8cL           8eL           4.g >        34:               .           8BJ            8d             . >        35:            8BBL            4c            8e             . >        36:            8AAJ             .          8f#J            8a >        37:             4GG            4d            4g            4b >        38:              =4            =4            =4            =4 >        39:             2D;           2d;          2f#;           2a; >        40:             4GG            4d            4g            4b >    41-134::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################# ^^^ chor001.krn ^^^ ############################# >     >           (8 more files...) >     >    ############################# vvv chor010.krn vvv ############################# >      1-60::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >        61:            2AA;           2c;           2e;           2a; >        62:              2A            2e            2a           2cc >        63:              =9            =9            =9            =9 >        64:              4E            4e            4g            4b >        65:             8DL            4e            4g           4cc >        66:             8CJ             .             .             . >        67:             4BB            4d           8gL           4dd >        68:               .             .           8fJ             . >        69:              4C            4c            4e            4g >        70:             =10           =10           =10           =10 >        71:              4D           8F#            4d            4b >        72:               .            4G             .             . >        73:              4D             .            4c            4a >        74:               .           8F#             .             . >        75:            2GG;           2G;           2B;           2g; >        76:             =11           =11           =11           =11 >        77:              2C            2G            2e            2g >        78:             4AA            4A            4e           4cc >        79:              4E           4G#           8eL            4b >        80:               .             .           8dJ             . >        81:             =12           =12           =12           =12 >        82:              4F            4A            4c            4a >        83:              4C            4G            4c            4e >        84:            4BB-            4G           [2d            4g >        85:             4AA            4A             .            4f >        86:             =13           =13           =13           =13 >        87:            4GG#            4B           4d]           1e; >        88:             4AA            4A            4c             . >        89:            2EE;         2G#X;           2B;             . >        90:              ==            ==            ==            == >        91:              *-            *-            *-            *- >        92:  !!!hum2abc: -Q '' >        93:  !!!title: @{PC#}. @{OTL@@DE} >        94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** >        95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** >        96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** >        97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** >        98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >        99:  !!!EED:  Craig Stuart Sapp >       100:  !!!EEV:  2009/05/22 >    ############################# ^^^ chor010.krn ^^^ ############################# >                           (***four global comments truncated due to screen size***) >     >       humdrumR corpus of ten files. >        Data fields:  >               *Token  :: character >                Semits :: integer  chorales$Semits >    ############################# vvv chor001.krn vvv ############################# >         1:  !!!COM: Bach, Johann Sebastian >         2:  !!!CDT: 1685/02/21/-1750/07/28/ >         3:  !!!OTL@@DE: Aus meines Herzens Grunde >         4:  !!!OTL@EN:      From the Depths of My Heart >         5:  !!!SCT: BWV 269 >         6:  !!!PC#: 1 >         7:  !!!AGN: chorale >         8:          **kern        **kern        **kern        **kern >         9:          *ICvox        *ICvox        *ICvox        *ICvox >        10:          *Ibass       *Itenor        *Ialto       *Isoprn >        11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >        12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >        13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >        14:             *>A           *>A           *>A           *>A >        15:         *clefF4      *clefGv2       *clefG2       *clefG2 >        16:          *k[f#]        *k[f#]        *k[f#]        *k[f#] >        17:             *G:           *G:           *G:           *G: >        18:             *F:             *             *             * >        19:           *M3/4         *M3/4         *M3/4         *M3/4 >        20:          *MM100        *MM100        *MM100        *MM100 >        21:             -17            -1             2             7 >        22:              =1            =1            =1            =1 >        23:              -5            -1             2             7 >        24:              -8             0             4             . >        25:               .            -1             .             . >        26:              -6            -3             2            14 >        27:              =2            =2            =2            =2 >        28:              -5            -5             2            11 >        29:             -10            -6             .             . >        30:               .             .             .             9 >        31:              -8            -5            -1             7 >        32:              =3            =3            =3            =3 >        33:             -12             0             4             7 >        34:               .            -1             2             . >        35:             -13             0             4             . >        36:             -15             .             6             9 >        37:             -17             2             7            11 >        38:              =4            =4            =4            =4 >        39:             -10             2             6             9 >        40:             -17             2             7            11 >    41-134::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################# ^^^ chor001.krn ^^^ ############################# >     >           (8 more files...) >     >    ############################# vvv chor010.krn vvv ############################# >      1-60::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >        61:             -15             0             4             9 >        62:              -3             4             9            12 >        63:              =9            =9            =9            =9 >        64:              -8             4             7            11 >        65:             -10             4             7            12 >        66:             -12             .             .             . >        67:             -13             2             7            14 >        68:               .             .             5             . >        69:             -12             0             4             7 >        70:             =10           =10           =10           =10 >        71:             -10            -6             2            11 >        72:               .            -5             .             . >        73:             -10             .             0             9 >        74:               .            -6             .             . >        75:             -17            -5            -1             7 >        76:             =11           =11           =11           =11 >        77:             -12            -5             4             7 >        78:             -15            -3             4            12 >        79:              -8            -4             4            11 >        80:               .             .             2             . >        81:             =12           =12           =12           =12 >        82:              -7            -3             0             9 >        83:             -12            -5             0             4 >        84:             -14            -5             2             7 >        85:             -15            -3             .             5 >        86:             =13           =13           =13           =13 >        87:             -16            -1             2             4 >        88:             -15            -3             0             . >        89:             -20            -4            -1             . >        90:              ==            ==            ==            == >        91:              *-            *-            *-            *- >        92:  !!!hum2abc: -Q '' >        93:  !!!title: @{PC#}. @{OTL@@DE} >        94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** >        95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** >        96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** >        97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** >        98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >        99:  !!!EED:  Craig Stuart Sapp >       100:  !!!EEV:  2009/05/22 >    ############################# ^^^ chor010.krn ^^^ ############################# >                           (***four global comments truncated due to screen size***) >     >       humdrumR corpus of ten files. >        Data fields:  >                Token  :: character >               *Semits :: integer within(chorales, paste0(Token, ' = ', Semits)) >    ############################# vvv chor001.krn vvv ############################# >         1:  !!!COM: Bach, Johann Sebastian >         2:  !!!CDT: 1685/02/21/-1750/07/28/ >         3:  !!!OTL@@DE: Aus meines Herzens Grunde >         4:  !!!OTL@EN:      From the Depths of My Heart >         5:  !!!SCT: BWV 269 >         6:  !!!PC#: 1 >         7:  !!!AGN: chorale >         8:          **kern        **kern        **kern        **kern >         9:          *ICvox        *ICvox        *ICvox        *ICvox >        10:          *Ibass       *Itenor        *Ialto       *Isoprn >        11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >        12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >        13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >        14:             *>A           *>A           *>A           *>A >        15:         *clefF4      *clefGv2       *clefG2       *clefG2 >        16:          *k[f#]        *k[f#]        *k[f#]        *k[f#] >        17:             *G:           *G:           *G:           *G: >        18:             *F:             *             *             * >        19:           *M3/4         *M3/4         *M3/4         *M3/4 >        20:          *MM100        *MM100        *MM100        *MM100 >        21:       4GG = -17       4B = -1        4d = 2        4g = 7 >        22:              =1            =1            =1            =1 >        23:         4G = -5       4B = -1        4d = 2        2g = 7 >        24:         4E = -8       8cL = 0        4e = 4             . >        25:               .      8BJ = -1             .             . >        26:        4F# = -6       4A = -3        4d = 2      4dd = 14 >        27:              =2            =2            =2            =2 >        28:         4G = -5       4G = -5        2d = 2      4.b = 11 >        29:        4D = -10      4F# = -6             .             . >        30:               .             .             .        8a = 9 >        31:         4E = -8       4G = -5       4B = -1        4g = 7 >        32:              =3            =3            =3            =3 >        33:        4C = -12       8cL = 0       8eL = 4       4.g = 7 >        34:               .      8BJ = -1        8d = 2             . >        35:      8BBL = -13        4c = 0        8e = 4             . >        36:      8AAJ = -15             .      8f#J = 6        8a = 9 >        37:       4GG = -17        4d = 2        4g = 7       4b = 11 >        38:              =4            =4            =4            =4 >        39:       2D; = -10       2d; = 2      2f#; = 6       2a; = 9 >        40:       4GG = -17        4d = 2        4g = 7       4b = 11 >    41-134::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################# ^^^ chor001.krn ^^^ ############################# >     >           (8 more files...) >     >    ############################# vvv chor010.krn vvv ############################# >      1-60::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >        61:      2AA; = -15       2c; = 0       2e; = 4       2a; = 9 >        62:         2A = -3        2e = 4        2a = 9      2cc = 12 >        63:              =9            =9            =9            =9 >        64:         4E = -8        4e = 4        4g = 7       4b = 11 >        65:       8DL = -10        4e = 4        4g = 7      4cc = 12 >        66:       8CJ = -12             .             .             . >        67:       4BB = -13        4d = 2       8gL = 7      4dd = 14 >        68:               .             .       8fJ = 5             . >        69:        4C = -12        4c = 0        4e = 4        4g = 7 >        70:             =10           =10           =10           =10 >        71:        4D = -10      8F# = -6        4d = 2       4b = 11 >        72:               .       4G = -5             .             . >        73:        4D = -10             .        4c = 0        4a = 9 >        74:               .      8F# = -6             .             . >        75:      2GG; = -17      2G; = -5      2B; = -1       2g; = 7 >        76:             =11           =11           =11           =11 >        77:        2C = -12       2G = -5        2e = 4        2g = 7 >        78:       4AA = -15       4A = -3        4e = 4      4cc = 12 >        79:         4E = -8      4G# = -4       8eL = 4       4b = 11 >        80:               .             .       8dJ = 2             . >        81:             =12           =12           =12           =12 >        82:         4F = -7       4A = -3        4c = 0        4a = 9 >        83:        4C = -12       4G = -5        4c = 0        4e = 4 >        84:      4BB- = -14       4G = -5       [2d = 2        4g = 7 >        85:       4AA = -15       4A = -3             .        4f = 5 >        86:             =13           =13           =13           =13 >        87:      4GG# = -16       4B = -1       4d] = 2       1e; = 4 >        88:       4AA = -15       4A = -3        4c = 0             . >        89:      2EE; = -20    2G#X; = -4      2B; = -1             . >        90:              ==            ==            ==            == >        91:              *-            *-            *-            *- >        92:  !!!hum2abc: -Q '' >        93:  !!!title: @{PC#}. @{OTL@@DE} >        94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** >        95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** >        96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** >        97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** >        98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >        99:  !!!EED:  Craig Stuart Sapp >       100:  !!!EEV:  2009/05/22 >    ############################# ^^^ chor010.krn ^^^ ############################# >                           (***four global comments truncated due to screen size***) >     >       humdrumR corpus of ten files. >        Data fields:  >                Token   :: character >                Semits  :: integer >               *Result1 :: character"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/GettingStarted.html","id":"counting-stuff","dir":"Articles","previous_headings":"Doing Stuff!","what":"Counting stuff","title":"Getting started with humdrumR","text":"basic step computational musicology …counting things! R fantastic, simple function tabulating (counting) elements vectors: function table(). Using , can easily count happens data: get count every unique data token dataset. ’s little messy. Let’s use humdrum\\(_{\\mathbb{R}}\\)’s kern() function extract just simple pitch information, tabulate instead: Much easier read…plot even better. R good basic function called barplot():  Remember Semits field made earlier? Maybe ’d like see histogram values—let’s use R’s hist() function:","code":"with(chorales, table(Token)) >    Token >        [2d     [2e     [4a     [4A     [4B     [4c     [4d     [4e     [4E     [4f  >          1       1       1       2       1       1       1       2       2       1  >       [4f#     [4g     [4G    [8cJ    [8CJ    [8gJ    16AL  16B-Jk 16b-XJJ  16BBJJ  >          1       4       2       1       1       1       1       1       1       1  >      16BJJ   16C#L  16c#LL   16ccL  16ccLL  16d#JJ  16ddJJ   16dJJ   16EJJ    16eL  >          1       1       1       1       1       1       1       2       1       2  >      16F#L     1e;    2.a;    2.A;   2.AA;     2.b    2.b;    2.B;   2.BB;    2.c;  >          1       1       1       1       1       1       1       1       1       1  >       2.C#   2.c#;     2.d    2.d;     2.e    2.e;    2.ee    2.f;   2.f#;   2.FF;  >          1       1       1       2       1       1       1       1       1       1  >       2.g;   2.GG;      2a      2A    2a-;    2A-;     2a;     2A;   2AA-;    2AA;  >          1       1      17      10       1       2       9       2       1       4  >         2b      2B    2b-;     2b;     2B;     2BB   2BB-;    2BB;      2c      2C  >         10       2       1       3       8       2       1       1       1       1  >        2c;     2C;     2c#    2c#;     2cc    2cc#   2cc#;      2d      2D    2d-;  >          6       1       5       3       3       3       1       6       5       1  >        2d;     2D;     2d#     2D#    2d#;     2dd    2DnX      2e      2E    2e-;  >          6       5       1       1       1       8       1      13       4       1  >        2e;     2E;     2E#    2EE;     2f;     2f#     2F#    2f#;    2F#;    2FF;  >          9       5       1       1       4      10       4       5       1       3  >      2FF#;      2g      2G     2g;     2G;     2g#     2G#    2g#;    2G#;   2G#X;  >          1       7       1       3       1       4       1       1       4       1  >       2GG;     4.a    4.a-     4.b     4.B    4.b-    4.BB     4.c   4.cc#     4.d  >          2       2       1       2       3       2       2       1       1       1  >       4.dd     4.e    4.e-    4.ee     4.f    4.f#     4.g      4a      4A     4a-  >          1       1       1       1       3       1       5      90      58      15  >        4A-    4a-;    4A-;    4a-X     4a;     4A;     4a#     4A#     4AA    4AA-  >          4       2       2       1       8       3       4       2      20       2  >      4AA-;    4AA;    4AA#    4anX      4b      4B     4b-     4B-    4B-X     4b;  >          1       5       1       1      81      56      16      10       1       9  >        4B;     4B]     4BB    4BB-    4BB;      4c      4C     4c;     4C;     4c]  >          9       1      25       7       3      49      23       8       2       1  >        4c#     4C#    4c#;    4C#;     4cc    4cc;    4cc#   4ccnX    4CnX      4d  >         27      19       2       1      48       3      28       1       1      53  >         4D     4d-     4D-     4d;     4D;     4d]     4d#     4D#    4d#;     4dd  >         30       9       4       8       4       1       9       8       3      29  >        4DD    4dd-    4dd;    4dd#    4dnX    4DnX      4e      4E     4e-     4E-  >          1       7       2       3       2       1     103      43       7       6  >       4e-;     4e;     4E;     4e]     4E]     4e#     4E#    4e#;    4E#X     4ee  >          2      14       7       1       1       3       2       1       1      20  >        4EE    4ee-   4ee-X    4ee;    4EE;    4enX    4EnX      4f      4F     4f;  >          2       3       1       1       2       1       1      50      12       2  >        4F;     4f#     4F#    4f#;    4F#;    4F#X   4F#X;     4ff     4FF    4ff;  >          2      47      30       4       2       1       1       6       3       1  >       4FF;    4ff#    4FF#      4g      4G     4g-     4g;     4G;     4g]     4G]  >          1       1       2      66      33       1       8       3       2       1  >        4g#     4G#    4g#;    4G#;    4G#X   4G#X;     4gg     4GG    4GG;    4GG#  >         34      21       5       3       1       1       1      15       5       2  >       4gnX    4GnX    8.cL      8a      8A     8a-     8A-    8a-J    8A-J    8a-L  >          1       1       1       5       5       2       1       2       1       4  >       8A-L   8a-XJ     8A#    8a#J    8A#J     8AA    8AA-    8AAJ    8AAL     8aJ  >          1       1       2       1       1       3       1       7       4      15  >        8AJ     8aL     8AL    8aL]    8AL]   8AnXL      8b     8b-     8B-    8b-J  >         17      10      12       1       2       1       2       1       1       1  >       8B-J    8b-L     8BB   8BB-J   8BB-L    8BBJ    8BBL     8bJ     8BJ     8bL  >          6       2       3       6       3       6       4      11      15      14  >        8BL      8c      8C     8C#    8c#J    8C#J    8c#L    8C#L   8c#XJ     8cc  >         18       1       5       2       3       2       5       4       1       2  >      8cc#J   8cc#L    8ccJ    8ccL     8cJ     8CJ     8cL     8CL    8cL]    8CL]  >          2       2       7       7      15       8      14      14       1       1  >      8cnXJ      8d      8D     8d-     8D-    8D-J    8D-L   8d-XJ    8d#J    8D#J  >          1       5       3       1       6       4       2       1       5       1  >       8d#L    8D#L     8dd   8dd#J    8ddJ    8ddL     8dJ     8DJ     8dL     8DL  >          1       2       1       1       2       4      19      15      24       6  >       8dL]    8dnJ      8e      8E     8E-    8e-J    8E-J    8e-L    8E-L    8EEJ  >          1       1       6       2       6       1       1       1       4       1  >       8eeL    8EEL     8eJ     8EJ     8eL     8EL    8eL]    8EL]      8f      8F  >          2       1      20       7      35      15       2       1       3       4  >        8f#     8F#    8f#J    8F#J    8f#L    8F#L   8f#L]   8F#XJ   8f#XL   8FF#J  >          2       3      26      14      12       7       1       1       1       2  >       8FFL     8fJ     8FJ     8fL     8FL    8fL]   8FnXL      8g      8G     8g#  >          2       4       5       5       6       1       1       3       4       4  >        8G#    8g#J    8G#J    8g#L    8G#L   8g#XJ     8GG    8GGJ    8GGL     8gJ  >          4       7       7       5       3       1       2       2       2      14  >        8GJ     8gL     8GL    8gL]    8GL]   8gnXL   8GnXL  >          8      14      17       3       1       2       1 with(chorales, kern(Token, simple = TRUE) |> table()) >     >      a  a-  a#   b  b-   c  c#   d  d-  d#   e  e-  e#   f  f#   g  g-  g#  >    318  45  11 297  60 232 115 253  35  37 334  34   8 121 182 237   1 109 with(chorales, kern(Token, simple = TRUE) |> table() |> barplot()) with(chorales, hist(Semits))"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/GettingStarted.html","id":"what-next","dir":"Articles","previous_headings":"","what":"What next?","title":"Getting started with humdrumR","text":"’ve gotten started, much learn! keep learning check articles humdrumR webpage. want continue along path ’ve started , next articles check probably Getting know data, Filtering humdrum data, Working humdrum data. Since musicological analysis involves pitch rhythm, ’ll probably want learn relevant ideas Pitch tonality Rhythm meter articles. humdrum data working complex—e.g., including multiple different exclusive interpretations, spine paths, multi-stops—’ll probably find need check Shaping humdrum data article, give tools deal complex humdrum data sets.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/HumdrumSyntax.html","id":"structure-vs-content","dir":"Articles","previous_headings":"","what":"Structure vs Content","title":"The humdrum syntax","text":"humdrum syntax lays simple structure encoding data, says nothing content. information encoded, information represented flexible. flexibility, structure humdrum data—humdrum syntax—always , makes easy work ! fill content humdrum files, define “interpretations. Interpretations schemes represent information characters. sounds complicated/scary, can simple! instance, wanted encode drum beats humdrum invent simple scheme encoding drum beats : Kick drum = “K” Snare drum = “S” Hi-Hat = “H” treat newline text file sixteenth-note tick (read humdrum “timebase” ) start encoding. thing need make conform humdrum syntax name : call overarching interpretations like “exclusive interpretations”, prefixed **. call **drums ’d ready create humdrum data!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/HumdrumSyntax.html","id":"syntax","dir":"Articles","previous_headings":"","what":"Syntax","title":"The humdrum syntax","text":"humdrum syntax , first glance, nothing simple, tab-delineated spread sheet. (“tab-delineated” just means columns spreadsheet separated TABs.) basic idea, extra features learn! Let’s take look basic humdrum file:  file can broken different types information like :  file two columns data, separated tabs. However, special terminology use: “columns” humdrum file called spines. line, row, file called record.  twenty records two spines file. character-string, located spine/record position, called token. Examples tokens file include *M4/4, 4A, =1, !Suspension.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/HumdrumSyntax.html","id":"global-vs-local","dir":"Articles","previous_headings":"Syntax","what":"Global vs Local","title":"The humdrum syntax","text":"’ll notice two records file (1 10) don’t seem two columns. Indeed, called “global” records—don’t belong particular column, whole row/file. image illustrates two spines file don’t include records 1 10:  real data :","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/HumdrumSyntax.html","id":"time","dir":"Articles","previous_headings":"Syntax","what":"Time","title":"The humdrum syntax","text":"one fundamental assumption regarding humdrum syntax encodes information: travel downward file (top bottom) encoding information order occurs time. true data records—interpretation comment records associated moment time first data record occurs . Information appears record (within one spine, different spines) assumed happen time.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/HumdrumSyntax.html","id":"record-types","dir":"Articles","previous_headings":"Syntax","what":"Record Types","title":"The humdrum syntax","text":"humdrum syntax recognizes four broad types records, five sub-types: Exclusive (**) Tandem (*) Reference (!!!) Global (!!) Local (!) Barlines (=) Data know type record ’re dealing looking first character token. tokens single record must type—can’t interpretation token comment token line. result, can refer type token, type whole record, tokens within record always type.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/HumdrumSyntax.html","id":"interpretations","dir":"Articles","previous_headings":"Syntax > Record Types","what":"Interpretations","title":"The humdrum syntax","text":"token starts *, interpretation token. Two stars ** indicates exclusive interpretation. Every spine must start exclusive interpretation, can one. exclusive interpretation spine tells us type information encoded spine, whole spine. instance, **drums interpretation invented exclusive interpretation. examples ’re using , exclusive interpretation spines **kern, widely used humdrum interpretation, used encode music notation. Note humdrum file can different exclusive interpretations spine—don’t , example. read various humdrum interpretations defined, check humdrum.org.  token starts one *, called tandem interpretation. Tandem interpretations tell us specific, localized information interpret data. can different, overlapping tandem interpretations within spine. example, *C:, *Ibass, *M4/4, *M3/4, tandem interpretations. *C: used **kern indicate key C major. *Ibass indicates instrument associated spine (bass voice). *M4/4 *M3/4 indicate 4/4 3/4 meter respectively. last case brings something important tandem interpretations: tandem interpretation applied subsequent data points, unless cancelled replaced another tandem interpretation type. Thus, humdrum file indicates 4/4 time starting record 5, switches 3/4 time record 13. However, *M4/4 record 4 doesn’t replace *C: record 3, different types tandem interpretations. One special token *- token. token indicates spine ends. *- missing end—one every spine—invalid humdrum file!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/HumdrumSyntax.html","id":"comments","dir":"Articles","previous_headings":"Syntax > Record Types","what":"Comments","title":"The humdrum syntax","text":"token begins !, comment token. Comments used freely include comments data. global comments (!!) associated spine—apply whole file point appear—local comments (!) specific particular spine. example, !! Ritardando global comment, !Suspension local comment, specific second spine.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/HumdrumSyntax.html","id":"reference-records","dir":"Articles","previous_headings":"Syntax > Record Types > Comments","what":"Reference Records","title":"The humdrum syntax","text":"one final type comment: reference records. Reference records global comments placed beginning end file. Reference records encode global metadata entire file: things like composed piece title piece . Reference records specific “reference codes,” usually three digits, come !!!, followed colon, whatever content record . instance, code !!!OTL: refers original title piece. Learn various standard humdrum reference records .","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Intervals.html","id":"intervals","dir":"Articles","previous_headings":"","what":"Intervals","title":"Rhythm and Pitch Intervals","text":"pitch time perceived relatively: relationship two points. Thus represent , conceptually, interval—difference. case pitch, interval two frequencies (abstractly, “tonal” interval circle--fifths). case rhythm, interval two time points—two onsets, onset offset. humdrumR, abstract intervals represented tonalInterval rhythmInterval objects, respectively. concretize abstract intervals, must establish relative . reference? actually multiple, useful ways can represent information. Since intervals relative, always implicit reference—origin, zero. tonalIntervals origin unison interval. rhythmIntervals origin zero. tonalIntervals rhythmIntervals constitute constitute algebraic module integers (module \\(\\mathbb{Z}\\)), appropriate arithmetic operations fully defined humdrumR. Since intervals can added/subtracted, interval can thought combination (addition) intervals. humdrumR, often “partition” interval combination useful sub-intervals.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Intervals.html","id":"serial-and-fixed-reference","dir":"Articles","previous_headings":"Intervals","what":"Serial and Fixed Reference","title":"Rhythm and Pitch Intervals","text":"Vectors humdrumR intervals can represented two fundamental ways: serial reference representation fixed reference representation. illustrate, use two examples, one rhythmic, one pitched: major scale “tag-line” rhythm 3+3+3+3+2+2","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Intervals.html","id":"fixed-reference","dir":"Articles","previous_headings":"Intervals > Serial and Fixed Reference","what":"Fixed reference","title":"Rhythm and Pitch Intervals","text":"fixed-reference representation, intervals interpreted relative fixed point (implicitly 0). Fixed-reference representations major scale (using semitones) tag-line rhythm follows: Note representation quite commonly used musicians, various forms, pitch. contrast, fixed-reference representations commonly used musicians rhythm. However, used contexts, essentially represent “time beginning” piece: Thus, timestamps/timelines DAWs “offsets” music21 examples fixed-reference representations time.","code":"referenceMajor   <- c(0, 2, 4, 5, 7, 9, 11, 12)  referenceTagline <- c(0, 3, 6, 9, 12, 14, 16)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Intervals.html","id":"serial-reference","dir":"Articles","previous_headings":"Intervals > Serial and Fixed Reference","what":"Serial reference","title":"Rhythm and Pitch Intervals","text":"alternative representation serial-reference representation, interval measured relative previous one. Thus, data point represents local change (\\(\\Delta\\)) parameter. lossless (explained ) first element serial data vector measured relative implicit reference (0). Serial representations tag-line major scale follows: representations also fairly intuitive musicians—representing “melodic intervals”—music notation sequencers represent pitch. contrast, serial-reference representation rhythm normative: traditional music notation note values serial-reference representation.","code":"serialMajor   <- c(0, 2, 2, 1, 2, 2, 2, 1)  serialTagline <- c(0, 3, 3, 3, 3, 2, 2)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Intervals.html","id":"transformations-interval-calculus","dir":"Articles","previous_headings":"Intervals > Serial and Fixed Reference","what":"Transformations (“Interval Calculus”)","title":"Rhythm and Pitch Intervals","text":"Since addition defined intervals fixed-reference serial-reference representations can translated . serial-reference representation can calculated pairwise differences elements fixed-reference data, first reference element appended beginning. Conversely, fixed-reference representation can calculated cumulative sum serial-reference data. Thus: humdrumR, refer two transformations delta (\\(\\Delta\\)) sigma (\\(\\Sigma\\)), differences sums respecticely. humdrumR, note relationship fixed- serial-reference representations analogous relationship function derivative. fixed-reference representation represents sequence independent values function (serial) index position. serial-reference representation represents sequence differences adjacent elements index—much fixed representation changes index. (Since first element serial-reference representation relative fixed (implicit) reference, normal one--many relationship derivatives functions removed, lossless one--one relationship maintained.) two transformations thus inverses : \\(x = sigma(delta(x))\\) \\(x = delta(sigma(x))\\). Derivative/Integral relationship Major Scale Derivative/Integral relationship Tagline Rhythm","code":"identical(cumsum(serialMajor), referenceMajor) ## [1] TRUE identical(cumsum(serialTagline), referenceTagline) ## [1] TRUE identical(c(referenceMajor[1], diff(referenceMajor)), serialMajor) ## [1] TRUE identical(c(referenceTagline[1], diff(referenceTagline)), serialTagline) ## [1] TRUE library(humdrumR) ## Loading required package: rlang ##  ## Attaching package: 'humdrumR' ## The following objects are masked from 'package:stats': ##  ##     lag, sigma, step ## The following object is masked from 'package:methods': ##  ##     signature identical(referenceMajor, sigma(delta(referenceMajor))) ## [1] TRUE identical(referenceMajor, delta(sigma(referenceMajor))) ## [1] FALSE"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Intervals.html","id":"dynamic-reference","dir":"Articles","previous_headings":"Intervals","what":"Dynamic Reference","title":"Rhythm and Pitch Intervals","text":"Since intervals additive, another possibilty use one vector intervals reference point second vector intervals. allows us create dynamic reference points. examples Figured Bass: bass voice texture encoded (serial/reference reprsentation) voices represented relative bass voice. Chord Tones: abstract “root” chord progression represented one vector, vectors representing “chord tones” (root, 3rd, 5th, 7th, etc.) relative chord root. Scale degrees: tonic key used dynamic reference, notes calculated relative tonic. Figured Bass Calculating dynamic reference intervals lossless complete information reference intervals maintained. instance, keep track serial fixed intervals bass voice. , keep track local key (usually using fixed interval “C”).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/KeysAndChord.html","id":"diatonic-sets","dir":"Articles","previous_headings":"","what":"Diatonic Sets","title":"Diatonic and tertian sets in humdrumR","text":"mentioned Pitch Tonality vignette, normative diatonic key consists set seven consecutive pitch chroma Line Fifths. diatonic set can ordered either line--fifths position: “scale-order,” corresponds steps \\(+2\\) (\\(-5\\)) modulo 7.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/KeysAndChord.html","id":"tertian-sets","dir":"Articles","previous_headings":"","what":"Tertian Sets","title":"Diatonic and tertian sets in humdrumR","text":"set seven notes diatonic key can reimagined chord—set notes played time. Specifically, full seven-note diatonic chord referred 13th chord. However, chords used tonal music subsets full diatonic set, particular three-note triads. viewing diatonic set chord, traditionally order set sequence ascending thirds, corresponding intervals \\(+4\\) line--fifths, modulo 7. tertian steps usually wrapped octave, resulting steps 9, 11, 13, instead 2, 4, 6. \\(2^7=\\) 128 possible subsets can formed full diatonic set. , seven possibilities built consecutive tertian steps theoretically privileged : .e., \\(\\{\\{1\\}, \\{1,3\\}, \\{1,3,5\\}, \\{1,3,5,7\\}, \\{1,3,5,7,9\\}, \\{1,3,5,7,9,11\\}, \\{1,3,5,7,9,11,13\\}\\}\\). possible sets fairly commonplace Western theory well: \\(\\{1,5, 11\\}\\) (“sus4”), \\(\\{1,3,5,9\\}\\) (“add9”), \\(\\{1,3,5,13\\}\\) (“add6”), etc.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/KeysAndChord.html","id":"concrete-representations","dir":"Articles","previous_headings":"Tertian Sets","what":"Concrete Representations","title":"Diatonic and tertian sets in humdrumR","text":"numerous ways tertian sets notes traditionally notated annotated character strings. Unfortunately, systems always rigorously consistent logical, convenient shorthands common chords lead ambiguity, /practices rooted traditional practices little relevance. Humdrum\\(_{\\mathbb{R}}\\) aims provide general approach make reading/writing chord annotations many forms possible. chord representation consists set least one following elements: root note. bass note. subset tertian steps present. Qualities chord steps, relative implicit explicit key. Traditional chord notation symbols often conflate merge various elements various ways, numerous common shorthands. particular, common diatonic triads—abstractly different combinations qualities 3rd 5th—represented various shorthands.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/KeysAndChord.html","id":"section","dir":"Articles","previous_headings":"","what":"Diatonic and tertian sets in humdrumR","title":"Diatonic and tertian sets in humdrumR","text":"Chord symbols tonal chroma practice often used indicate bass note part ostensible chord. instance, C7/Ab. consist form, unique symbol appended indicate one four unique triad types: major, minor, diminished, augmented. However, cases, major assumed default, can ommitted. cases, either major minor symbol ommited, case root symbol used indicate major minor. (cases, case root symbol also matched diminished (lower) augmented (major) symbols).) Roman numerals 7ths 753 7, 653 65, 643 43, 642 42 2 9ths 9753: 1111100 7653: 1111001 6543: 1110011 6432: 1100111 7642: 1001111 11ths 11","code":"753:     1111000 653:     1110001 643:     1100011 642:     1000111"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Overview.html","id":"what-is-humdrum_mathbbr","dir":"Articles","previous_headings":"","what":"What is humdrum\\(_{\\mathbb{R}}\\)?","title":"Overview of humdrumR","text":"Humdrum\\(_{\\mathbb{R}}\\) R package—“library” preexisting code [R programming language](https://en.wikipedia.org/wiki/R_(programming_language). Humdrum\\(_{\\mathbb{R}}\\) code provides tools visualization, manipulation, analysis humdrum data. Note: name package pronounced hum-drum-ARRRRR, last syllable emphasized pirate fashion. name always typeset \\(h\\mu m_{\\mathbb{R}}^{\\Delta r \\mu m}\\). Failure pronounce typeset \\(h\\mu m_{\\mathbb{R}}^{\\Delta r \\mu m}\\) correctly void warranty.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Overview.html","id":"what-is-humdrum","dir":"Articles","previous_headings":"What is humdrum\\(_{\\mathbb{R}}\\)?","what":"What is humdrum?","title":"Overview of humdrumR","text":"Humdrum system computational musicology developed David Huron. Humdrum “universe” includes two parts: data format called humdrum syntax musicological software system called humdrum toolkit, humdrum\\(_{\\mathbb{R}}\\) meant modernized replacement original humdrum toolkit, leveraging power R give us unprecedented power manipulate analyze humdrum data using concise, expressive syntax. humdrum\\(_{\\mathbb{R}}\\) mainly used manipulate analyze data encoded humdrum syntax /humdrum interpretations like “**kern”. humdrum syntax incredibly flexible, powerful, scheme encoding musical data. Tens thousands musical scores (musical data) encoded humdrum syntax, many available online repositories KernScores. humdrum syntax vignette gives detailed introduction data format.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Overview.html","id":"what-is-r","dir":"Articles","previous_headings":"What is humdrum\\(_{\\mathbb{R}}\\)?","what":"What is R?","title":"Overview of humdrumR","text":"R programming language, designed ground statistical computing data analysis. R many features make ideal data analysis, particularly research analysis background programming. R primer introduces core concepts R programming.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Overview.html","id":"what-can-humdrum_mathbbr-do","dir":"Articles","previous_headings":"","what":"What can humdrum\\(_{\\mathbb{R}}\\) do?","title":"Overview of humdrumR","text":"Humdrum\\(_{\\mathbb{R}}\\) provides number tools working humdrum data generally, musicological analysis. package seven main components:","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Overview.html","id":"representing-humdrum-in-r","dir":"Articles","previous_headings":"What can humdrum\\(_{\\mathbb{R}}\\) do?","what":"Representing humdrum in R","title":"Overview of humdrumR","text":"represent humdrum data R, humdrum\\(_{\\mathbb{R}}\\) defines special data type—humdrumR class—call “humdrumR objects” throughout documentation. important part humdrumR object “humdrum table” contains. can read humdrum-syntax data represented getting started humdrumR vignette.  details, read humdrumR class humdrum table; humdrum\\(_{\\mathbb{R}}\\) installed loaded, can read directly R session typing ?humdrumR-class ?humTable.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Overview.html","id":"reading-and-writing-humdrum-data","dir":"Articles","previous_headings":"What can humdrum\\(_{\\mathbb{R}}\\) do?","what":"Reading and writing humdrum data","title":"Overview of humdrumR","text":"create humdrumR data objects, humdrum\\(_{\\mathbb{R}}\\) includes humdrum data parser, finds humdrum data local machine, reads R, creates humdrumR object data. Reading writing data vignette best place learm works. can get details readHumdrum() writeHumdrum() documentation; humdrum\\(_{\\mathbb{R}}\\) installed loaded, can read directly R session typing ?readHumdrum ?writeHumdrum.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Overview.html","id":"shaping-humdrum-data","dir":"Articles","previous_headings":"What can humdrum\\(_{\\mathbb{R}}\\) do?","what":"Shaping humdrum data","title":"Overview of humdrumR","text":"’ve imported humdrum data R, next step often organize prepare data. ’ll often want pick specific subsets data, rearrange data representations easier work . Humdrum\\(_{\\mathbb{R}}\\) gives us number powerful tools “shaping data”: Shaping humdrum data Filtering humdrum data vignettes best places learn processes. can find details subsetting data subset.humdrumR() indexHumdrum documentation; humdrum\\(_{\\mathbb{R}}\\) installed loaded, can read directly R session typing ?subset.humdrumR ?indexHumdrum.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Overview.html","id":"working-with-humdrum-data","dir":"Articles","previous_headings":"What can humdrum\\(_{\\mathbb{R}}\\) do?","what":"Working with humdrum data","title":"Overview of humdrumR","text":"Humdrum\\(_{\\mathbb{R}}\\) makes easy manipulate, modify, analyze humdrum data. Working humdrum data vignette gives overview functionality. can find details withinHumdrum documentation; humdrum\\(_{\\mathbb{R}}\\) installed loaded, can read directly R session typing ?withinHumdrum.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Overview.html","id":"pitch","dir":"Articles","previous_headings":"What can humdrum\\(_{\\mathbb{R}}\\) do?","what":"Pitch","title":"Overview of humdrumR","text":"Humdrum\\(_{\\mathbb{R}}\\) defines tools manipulating numerous representations pitch tonality, including diatonic keys tertian harmonies. Pitch tonality vignette explains work pitch data humdrum\\(_{\\mathbb{R}}\\). can find details humdrumPitch documentation; humdrum\\(_{\\mathbb{R}}\\) installed loaded, can read directly R session typing ?humdrumPitch.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Overview.html","id":"rhythm","dir":"Articles","previous_headings":"What can humdrum\\(_{\\mathbb{R}}\\) do?","what":"Rhythm","title":"Overview of humdrumR","text":"Humdrum\\(_{\\mathbb{R}}\\) defines tools manipulating numerous representations rhythm, timing, meter. Rhythm meter vignette explains work rhythmic information humdrum\\(_{\\mathbb{R}}\\). can find details humdrumRhythm documentation; humdrum\\(_{\\mathbb{R}}\\) installed loaded, can read directly R session typing ?humdrumRhythm.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Overview.html","id":"development","dir":"Articles","previous_headings":"What can humdrum\\(_{\\mathbb{R}}\\) do?","what":"Development","title":"Overview of humdrumR","text":"facilitate development new functions work humdrum tokens—simple character strings packed information—, humdrum\\(_{\\mathbb{R}}\\) provides several useful development tools, including struct data type useful API call regular-expression dispatch system, makes easy dispatch different methods based matches regular expressions.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/PitchAndTonality.html","id":"pitches-and-intervals","dir":"Articles","previous_headings":"","what":"Pitches and Intervals","title":"Pitch and tonality in humdrumR","text":"Humdrum\\(_{\\mathbb{R}}\\) defines suite pitch functions, like kern, solfa, interval, semits. functions work essentially way: take input argument output pitch information particular format. example, Notice functions recognize pitch part input tokens, ignoring non-pitch (rhythm) information. want keep non-pitch part tokens, use inPlace argument: complete list basic pitch functions : kern pitch lilypond helmholtz tonh (German-style notation) interval solfa (relative-solfege) solfg (French-style fixed-solfege) degree (absolute scale degrees) deg (melodic scale degrees) bhatk (hindustani swara) step accidental quality octave semits midi cents pc (pitch classes) freq global documentation pitch functions can seen calling ?pitchFunctions. can also call documentation individual function, like ?kern.","code":"input <- c('4.c', '8d', '4e', '2.g')  kern(input) >    [1] \"c\" \"d\" \"e\" \"g\" interval(input) >    [1] \"P1\"  \"+M2\" \"+M3\" \"+P5\" semits(input) >    [1] 0 2 4 7 solfa(input) >    [1] \"do\" \"re\" \"mi\" \"so\" input <- c('4.c', '8d', '4e', '2.g')  kern(input, inPlace = TRUE) >    [1] \"4.c\" \"8d\"  \"4e\"  \"2.g\" interval(input, inPlace = TRUE) >    [1] \"4.P1\"  \"8+M2\"  \"4+M3\"  \"2.+P5\" semits(input, inPlace = TRUE) >    [1] \"4.0\" \"82\"  \"44\"  \"2.7\" solfa(input, inPlace = TRUE) >    [1] \"4.do\" \"8re\"  \"4mi\"  \"2.so\""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/PitchAndTonality.html","id":"generic-and-simple-pitch","dir":"Articles","previous_headings":"Pitch arguments","what":"Generic and Simple pitch","title":"Pitch and tonality in humdrumR","text":"pitch functions accept logical (TRUE/FALSE) generic simple arguments.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/PitchAndTonality.html","id":"simple-vs-compound","dir":"Articles","previous_headings":"Pitch arguments > Generic and Simple pitch","what":"Simple vs Compound","title":"Pitch and tonality in humdrumR","text":"default, pitch functions complete full pitch information, including octave information (“compound intervals”). However, specify simple = TRUE, octave information discarded, leaving simple part pitch information. (can alternately specify compound = FALSE).","code":"input <- c('c', 'dd#', 'G', 'GG', 'GGG-')  rbind(kern(input, simple = FALSE), kern(input, simple = TRUE)) >         [,1] [,2]  [,3] [,4] [,5]   >    [1,] \"c\"  \"dd#\" \"G\"  \"GG\" \"GGG-\" >    [2,] \"c\"  \"d#\"  \"g\"  \"g\"  \"g-\" rbind(interval(input, simple = FALSE), interval(input, simple = TRUE)) >         [,1] [,2]  [,3]  [,4]   [,5]   >    [1,] \"P1\" \"+A9\" \"-P4\" \"-P11\" \"-A18\" >    [2,] \"P1\" \"+A2\" \"-P4\" \"-P4\"  \"-A4\" rbind(semits(input, compound = TRUE), semits(input, compound = FALSE)) >         [,1] [,2] [,3] [,4] [,5] >    [1,]    0   15   -5  -17  -30 >    [2,]    0    3    7    7    6 rbind(solfa(input, compound = TRUE), solfa(input, compound = FALSE)) >         [,1] [,2]  [,3]  [,4]   [,5]    >    [1,] \"do\" \"^ri\" \"vso\" \"vvso\" \"vvvse\" >    [2,] \"do\" \"ri\"  \"so\"  \"so\"   \"se\""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/PitchAndTonality.html","id":"generic-vs-specific","dir":"Articles","previous_headings":"Pitch arguments","what":"Generic vs Specific","title":"Pitch and tonality in humdrumR","text":"default, pitch functions complete full pitch information, including specific tonal information. “Specific” pitch information usually specified accidentals quality labels. specify generic = TRUE (specific = FALSE), accidentals qualities printed. case pitch representations without excplicit accidentals/qualities (like solfege), generic version pitch printed.","code":"input <- c('c', 'd#', 'e', 'f#', 'g')  rbind(kern(input, generic = FALSE), kern(input, generic = TRUE)) >         [,1] [,2] [,3] [,4] [,5] >    [1,] \"c\"  \"d#\" \"e\"  \"f#\" \"g\"  >    [2,] \"c\"  \"d\"  \"e\"  \"f\"  \"g\" rbind(interval(input, generic = FALSE), interval(input, generic = TRUE)) >         [,1] [,2]  [,3]  [,4]  [,5]  >    [1,] \"P1\" \"+A2\" \"+M3\" \"+A4\" \"+P5\" >    [2,] \"1\"  \"+2\"  \"+3\"  \"+4\"  \"+5\" rbind(semits(input, specific = TRUE), semits(input, specific = FALSE)) >         [,1] [,2] [,3] [,4] [,5] >    [1,]    0    3    4    6    7 >    [2,]    0    2    4    5    7 rbind(solfa(input, specific = TRUE), solfa(input, specific = FALSE)) >         [,1] [,2] [,3] [,4] [,5] >    [1,] \"do\" \"ri\" \"mi\" \"fi\" \"so\" >    [2,] \"do\" \"re\" \"mi\" \"fa\" \"so\""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html","id":"basic-commands","dir":"Articles","previous_headings":"","what":"Basic Commands","title":"An R primer for humdrumR users","text":"R code made “expressions” like 2 + 2, sqrt(2), (x - mean(x))^2. can see, can create intuitive arithmetic expressions, like 5 / 2 3 * 3. However, common elements R expressions “calls” functions. “function” R pre-built bit code something. functions take one input arguments, “return” kind output. example, function sqrt() takes number input argument, “returns” square root number. “call” function, write function’s name, followed parentheses (()). input arguments function must go inside parentheses, separated commas one. examples common functions “called” zero input arguments: Different functions different arguments recognize, specific names. example, function log() takes two arguments, called x base. functions can take number arguments, name. can learn function, including arguments accepts, typing ?functionName command line; example, ?sqrt ?mean. see argument called ..., tells function can take number arguments. can explicitly “name” function arguments want putting argname = argument calls: example, say log(10, base = 2). Named arguments useful creating data, like vectors data.frames (see ).","code":"sqrt(2) >    [1] 1.414214  sqrt(9) >    [1] 3 abs(-3) >    [1] 3  mean(1:5) >    [1] 3  max(1, 5) # two arguments >    [1] 5  c(1, 2, 3) # three arguments >    [1] 1 2 3  Sys.time() # no arguments! >    [1] \"2022-10-13 11:44:34 EDT\""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html","id":"pipes","dir":"Articles","previous_headings":"Basic Commands","what":"Pipes","title":"An R primer for humdrumR users","text":"Complex expressions might involve large number function calls, can get tiresome read (write). example, something like calls four functions! expression like bit tricky read, can really easy make mistake put wrong number parentheses. alternative, R gives us option calling functions “pipe.” way works use “pipe” command |>, takes input left “pipes” function call right. example, can rewrite previous command : Much better! make things even cleaner, R understand spread expressions across multiple lines, putting new line |>, function argument:","code":"log(round(sqrt(mean(x^2)), base = 2) x^2 |> mean() |> sqrt() |> round() |> log(base = 2) x^2 |>   mean() |>   sqrt() |>   round() |>   log(base = 2)    max(sqrt(2),     log(2),     exp(2),     pi / 2)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html","id":"variables","dir":"Articles","previous_headings":"Basic Commands","what":"Variables","title":"An R primer for humdrumR users","text":"coding R, ’ll often want “save” data objects can reuse . “assigning” something (often result function) “variable”. done using assignment operators, either <- ->. variable name can combination upper lowercase letters. Let’s calculate square-root two save variable: can reuse value many times want: can also assign left right, using ->. useful combination pipes: Note variable names can also include _, ., numeric digits, long aren’t beginning name. example, X1 my_name valid names—2X.","code":"tworoot <- sqrt(2) tworoot^2 >    [1] 2  tworoot * 2 >    [1] 2.828427  c(tworoot, tworoot) >    [1] 1.414214 1.414214 tworoot |> exp() |> round() -> newvalue"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html","id":"basic-data-structures","dir":"Articles","previous_headings":"","what":"Basic Data Structures","title":"An R primer for humdrumR users","text":"R, two fundamental data structures used time: “atomic” vectors data.frames","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html","id":"vectors","dir":"Articles","previous_headings":"Basic Data Structures","what":"Vectors","title":"An R primer for humdrumR users","text":"R, basic units—atoms, —information called “atomic” vectors. three basic atomic data types: Examples: 3, 4.2, -13, 254.30 Examples: \"note\", \"\", \", dear, female dear\" Examples: TRUE, FALSE might wondering, calling basic atoms “vectors”? Well, R, basic atomic data types always considered collection ordered values. ordered collections called vectors. simple examples , vector single value, just looks like one value—single values like often called “scalars”. However, R doesn’t really distinguish scalars (single values) vectors (multiple values)—everything always vector. (Still, sometimes refer length-1 vectors scalars.) make vector scratch R, use c(), : example, ’ve created five vectors. numeric vector length 3. character vector length four (composers). logical vector length 2. ’s right, c(32.3) 32.3 thing—vector length 1. Notice vectors can’t mix--match different data types; makes sense cause vector single type thing. means commands like c(3, \"\") actually create character vector, 3 forced character (\"3\").","code":"c(1, 2, 3) >    [1] 1 2 3  c(\"Bach\", \"Mozart\", \"Beethoven\", \"Brahms\") >    [1] \"Bach\"      \"Mozart\"    \"Beethoven\" \"Brahms\"  c(TRUE, FALSE) >    [1]  TRUE FALSE  c(32.3) >    [1] 32.3  32.3 >    [1] 32.3"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html","id":"vectorization","dir":"Articles","previous_headings":"Basic Data Structures > Vectors","what":"Vectorization","title":"An R primer for humdrumR users","text":"everything vector time useful, allows us think use collections data single thing. give , say, ten thousand numbers, don’t worry manipulating ten thousand things: rather, just work one thing: vector, happens length 10,000. R, call vectorization—generally, R humdrum\\(_{\\mathbb{R}}\\) constantly taking advantage vectorization make lives super easy! example vectorization, watch : created two numeric vectors: first eight numbers Fibonacci sequence single number 2 multiplied together! Notice entire Fibonacci vector multiplied two! don’t worry multiplying number vector, done us. two ideal circumstances working vectors. length. One vector length 1, isn’t. first case, work multiple vectors length, value vector “lined” values vector. , example, add two vectors together, “lined ” pair numbers added: second case, one vectors length-1 (“scalar”). case, scalar value paired value longer vector (Fibonacci example ). happens vectors longer one, length? Well, R generally attempt “recycle” shorter vector—means repeat — necessary match length longer vector. shorter vector evenly divides longer vector, generally won’t problem: division perfect, R still “recycle” shorter vector, ’ll get warning: see warning message R us? “longer object length multiple shorter object length” ’s R telling us ’ve got obvious mismatch lengths vectors. Generally, best work vectors length /scalar values (length-1 vectors), can avoid worrying exactly R “recycling” values. brings us …","code":"c(1, 1, 2, 3, 5, 8, 13, 21) * 2 >    [1]  2  2  4  6 10 16 26 42 c(1, 2, 3) + c(5, 4, 3) >    [1] 6 6 6   paste(c('a', 'b', 'c'), c(1, 2, 3)) >    [1] \"a 1\" \"b 2\" \"c 3\" c(1, 2, 3) + 5 >    [1] 6 7 8   paste(c('a', 'b', 'c'), 1) >    [1] \"a 1\" \"b 1\" \"c 1\" c(1, 2, 3, 4) * c(2, 3) >    [1]  2  6  6 12 c(1, 2, 3, 4) * c(2, 3, 4) >    Warning in c(1, 2, 3, 4) * c(2, 3, 4): longer object length is not a multiple of >    shorter object length >    [1]  2  6 12  8"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html","id":"data-frames","dir":"Articles","previous_headings":"Basic Data Structures","what":"Data frames","title":"An R primer for humdrumR users","text":"Data frames heart soul R. data.frame simply collection vectors length—ideal vectorized operations! vectors data.frame arranged columns two dimension table. Let’s make data frame, feeding vectors [data.frame()] function: Notice columns/vectors can different type, problem. Also notice, column name; can inspect names using colnames() function. change : Finally, ’s also possible assign column name want creating data frame: Remember, vectors data.frame must length. tried make data.frame vectors don’t match length, ’ll get error “arguments imply differing number rows.” one exception can call data.frame scalar single values, automatically recycled match length vectors.","code":"X <- c(\"C\", \"D\", \"E\", \"F\", \"G\", \"A\", \"B\", \"C\") Y <- c(0, 2, 4, 5, 7, 9, 11, 12) Z <- c(\"P1\", \"M2\", \"M3\", \"P4\", \"P5\", \"M6\", \"M7\", \"P8\")  df <- data.frame(X, Y, Z)  df >      X  Y  Z >    1 C  0 P1 >    2 D  2 M2 >    3 E  4 M3 >    4 F  5 P4 >    5 G  7 P5 >    6 A  9 M6 >    7 B 11 M7 >    8 C 12 P8 colnames(df) >    [1] \"X\" \"Y\" \"Z\" colnames(df) <- c('Letters', \"Semitones\", \"Intervals\") df >      Letters Semitones Intervals >    1       C         0        P1 >    2       D         2        M2 >    3       E         4        M3 >    4       F         5        P4 >    5       G         7        P5 >    6       A         9        M6 >    7       B        11        M7 >    8       C        12        P8 data.frame(Letters = X, Semitones = Y, Intervals = Z) >      Letters Semitones Intervals >    1       C         0        P1 >    2       D         2        M2 >    3       E         4        M3 >    4       F         5        P4 >    5       G         7        P5 >    6       A         9        M6 >    7       B        11        M7 >    8       C        12        P8"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html","id":"with-and-within-you","dir":"Articles","previous_headings":"Basic Data Structures > Data frames","what":"With and Within You","title":"An R primer for humdrumR users","text":"often want access columns/vectors held data frame. can several ways. One approach $ operator, combined name column want. example, can get Letters column data frame made using df$Letters. Often, ’ll want write code uses bunch different columns data.frame—fact, main thing time R! avoid writing df$ , can use () function. () allows us drop “inside” data.frame, R commands can “see” columns variables:","code":"with(df,      paste(Intervals, Semitones, sep = ' = ')) >    [1] \"P1 = 0\"  \"M2 = 2\"  \"M3 = 4\"  \"P4 = 5\"  \"P5 = 7\"  \"M6 = 9\"  \"M7 = 11\" >    [8] \"P8 = 12\""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html","id":"missing-data","dir":"Articles","previous_headings":"Basic Data Structures","what":"Missing Data","title":"An R primer for humdrumR users","text":"Sometimes ’ll encounter data points irrelevant, meaningless, “applicable.”","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html","id":"common-functions","dir":"Articles","previous_headings":"","what":"Common Functions","title":"An R primer for humdrumR users","text":"getwd() — Get R’s current working directory. setwd() — Set R’s working directory. summary() — Summarize contents R object.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html","id":"vector-functions","dir":"Articles","previous_headings":"Common Functions","what":"Vector functions","title":"An R primer for humdrumR users","text":"set decreasing = TRUE decreasing order. rev() — Reverse order vector. unique() — Returns unique values vector. x %% y — elements vector x appear vector y?","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html","id":"string-functions","dir":"Articles","previous_headings":"Common Functions","what":"String functions","title":"An R primer for humdrumR users","text":"paste() — Paste together multiple character strings.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html","id":"arithmetic","dir":"Articles","previous_headings":"Common Functions","what":"Arithmetic","title":"An R primer for humdrumR users","text":"x + y — Addition; \\(x + y\\). x - y — Subtraction; \\(x - y\\). -x — Negation; \\(-x\\). x * y — Multiplication; \\(xy\\) Use parentheses things like x^(1/3); \\(x^{\\frac{1}{3}}\\). x / y — Real division; \\(\\frac{x}{y}\\). E.g., whole-number division remainder. E.g., remainder whole-number division.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html","id":"other-math-functions","dir":"Articles","previous_headings":"Common Functions","what":"Other Math functions","title":"An R primer for humdrumR users","text":"sqrt() — Square-root numbers; \\(\\sqrt{x}\\). abs() — Absolute value numbers; \\(|x|\\) round() — Round number nearest integer; \\(\\lfloor x \\rceil\\)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html","id":"making-your-own-functions","dir":"Articles","previous_headings":"","what":"Making your own functions","title":"An R primer for humdrumR users","text":"make function R, use function keyword, like : example, let’s make function subtracts mean vector numbers. ’ll one argument, ’ll call numbers. ’ve created function, assigned name myfunc, just like assignment. Let’s try : Notice last expression function definition value gets “returned” function. feeling lazy, can also define function using less keystrokes using command \\() instead function(). example,","code":"function(argument1, argument2, etc.) {   Expressions to evaluate here, involving the arguments  } myfunc <- function(numbers) {   mean <- mean(numbers)   numbers - mean } myfunc(1:9) >    [1] -4 -3 -2 -1  0  1  2  3  4 \\(x) x + 1 >    \\(x) x + 1"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/ReadWrite.html","id":"reading-humdrum-data","dir":"Articles","previous_headings":"","what":"Reading humdrum data","title":"Reading and writing data","text":"readHumdrum function gateway humdrum\\(_{\\mathbb{R}}\\): function use read humdrum data, encoded humdrum-syntax text files, R.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/ReadWrite.html","id":"practice-data","dir":"Articles","previous_headings":"Reading humdrum data","what":"Practice Data","title":"Reading and writing data","text":"following examples, make use small number raw humdrum data files included humdrum\\(_{\\mathbb{R}}\\). access files, need navigate directory computer installed humdrum\\(_{\\mathbb{R}}\\)—fortunately, humdrum\\(_{\\mathbb{R}}\\) records directory computer variable called humdrumRroot. load humdrum\\(_{\\mathbb{R}}\\) library, just need set R “working directory” location using command setwd. humdrum data stored subdirectory called “HumdrumData”—can look contents directory using dir(recursive = TRUE): can see, five directories containing total fifty files.","code":"library(humdrumR) setwd(humdrumRroot) dir('HumdrumData', recursive = TRUE) #>  [1] \"BachChorales/chor001.krn\"                   #>  [2] \"BachChorales/chor002.krn\"                   #>  [3] \"BachChorales/chor003.krn\"                   #>  [4] \"BachChorales/chor004.krn\"                   #>  [5] \"BachChorales/chor005.krn\"                   #>  [6] \"BachChorales/chor006.krn\"                   #>  [7] \"BachChorales/chor007.krn\"                   #>  [8] \"BachChorales/chor008.krn\"                   #>  [9] \"BachChorales/chor009.krn\"                   #> [10] \"BachChorales/chor010.krn\"                   #> [11] \"BeethovenVariations/B075_00_01_a.krn\"       #> [12] \"BeethovenVariations/B075_00_02_a.krn\"       #> [13] \"BeethovenVariations/B075_00_03_a.krn\"       #> [14] \"BeethovenVariations/B075_00_04_a.krn\"       #> [15] \"BeethovenVariations/B075_00_05_a.krn\"       #> [16] \"BeethovenVariations/B075_00_06_a.krn\"       #> [17] \"BeethovenVariations/B075_01_01_a.krn\"       #> [18] \"BeethovenVariations/B075_01_02_a.krn\"       #> [19] \"BeethovenVariations/B075_01_03_a.krn\"       #> [20] \"BeethovenVariations/B075_01_04_a.krn\"       #> [21] \"BeethovenVariations/B075_01_05_a.krn\"       #> [22] \"BeethovenVariations/B075_01_06_a.krn\"       #> [23] \"MozartVariations/M354_00_01a_a.krn\"         #> [24] \"MozartVariations/M354_00_02b_a.krn\"         #> [25] \"MozartVariations/M354_00_03c_a.krn\"         #> [26] \"MozartVariations/M354_00_04d_a.krn\"         #> [27] \"MozartVariations/M354_01_01a_a.krn\"         #> [28] \"MozartVariations/M354_01_02b_a.krn\"         #> [29] \"MozartVariations/M354_01_03c_a.krn\"         #> [30] \"MozartVariations/M354_01_04d_a.krn\"         #> [31] \"RapFlow/2pac_IGetAround.rap\"                #> [32] \"RapFlow/BeastieBoys_BrassMonkey.rap\"        #> [33] \"RapFlow/Coolio_GangstasParadise.rap\"        #> [34] \"RapFlow/Ludacris_MoneyMaker.rap\"            #> [35] \"RapFlow/NotoriousBIG_Hypnotize.rap\"         #> [36] \"RapFlow/RobBase_ItTakesTwo.rap\"             #> [37] \"RapFlow/WillSmith_Summertime.rap\"           #> [38] \"RollingStoneCorpus/all_apologies.hum\"       #> [39] \"RollingStoneCorpus/back_in_black.hum\"       #> [40] \"RollingStoneCorpus/blue_suede_shoes.hum\"    #> [41] \"RollingStoneCorpus/born_to_be_wild.hum\"     #> [42] \"RollingStoneCorpus/god_only_knows.hum\"      #> [43] \"RollingStoneCorpus/hey_jude.hum\"            #> [44] \"RollingStoneCorpus/i_walk_the_line.hum\"     #> [45] \"RollingStoneCorpus/kashmir.hum\"             #> [46] \"RollingStoneCorpus/layla.hum\"               #> [47] \"RollingStoneCorpus/lets_stay_together.hum\"  #> [48] \"RollingStoneCorpus/living_for_the_city.hum\" #> [49] \"RollingStoneCorpus/me_and_bobby_mcgee.hum\"  #> [50] \"RollingStoneCorpus/your_song.hum\""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/ReadWrite.html","id":"targeting-files","dir":"Articles","previous_headings":"Reading humdrum data","what":"Targeting files","title":"Reading and writing data","text":"use readHumdrum call function one () character-string arguments. (function documentation (?readHumdrum), ’ll see arguments called ...—R, ... means number arguments.) arguments interpreted regular expressions, matched directories files system. call “REpath-patterns,” short Regular Expression directory-path patterns. example, uses REpath-pattern \"HumdrumData/BachChorales/chor.*.krn\" match files ‘HumdrumData/BachChorales’ directory whose name matches regular expression “chor..krn.” can see, REpath-pattern includes directory (folder) paths (relative absolute)—using operating system’s appopriate delimeter (”\" windows, ”/” everybody else)—* pattern matching file paths. directory also treated regular expression, possibly matching multiple directories. Let’s break : humdrum\\(_{\\mathbb{R}}\\) splits REpath-pattern input string three parts: \"HumdrumData\", \"BachChorales\", \"chor.*.krn\", treats three regular expressions. first two expressions used match directories, last expression used match files. , readHumdrum('HumdrumData/BeethovenVariations/.*.krn') matches files ”.krn” extension “BeethovenVariations” directories readHumdrum('HumdrumData/MozartVariations/.*.krn') matches files “MozartVariations” directories, command readHumdrum('HumdrumData/.*Variations/.*.krn') match kern files directories! careful: since directory/file name always treated like regular expression, can sometimes specify something general intend. instance, command readHumdrum('MyFolder/.*') match files folder called “MyFolder,” also match folders names “MyFolder_Also”, “ThisIsMyFolder.” want sure match exactly one one directory/file, use “^” “$” regular-expression markers explicitely mark beginning end pattern: command readHumdrum('^MyFolder$/.*') read files one directory “MyFolder.” read test files can enter: Note: Since humdrum\\(_{\\mathbb{R}}\\) can read files multiple directories , possible two files file name, different directories matched. happens, humdrum\\(_{\\mathbb{R}}\\) identifies file enough ’s directory path make sure unique.","code":"library(humdrumR) setwd(humdrumRroot)  readHumdrum('HumdrumData/BachChorales/chor.*.krn') #> ############################# vvv chor001.krn vvv ############################# #>      1:  !!!COM: Bach, Johann Sebastian #>      2:  !!!CDT: 1685/02/21/-1750/07/28/ #>      3:  !!!OTL@@DE: Aus meines Herzens Grunde #>      4:  !!!OTL@EN:      From the Depths of My Heart #>      5:  !!!SCT: BWV 269 #>      6:  !!!PC#: 1 #>      7:  !!!AGN: chorale #>      8:          **kern        **kern        **kern        **kern #>      9:          *ICvox        *ICvox        *ICvox        *ICvox #>     10:          *Ibass       *Itenor        *Ialto       *Isoprn #>     11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano #>     12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] #>     13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] #>     14:             *>A           *>A           *>A           *>A #>     15:         *clefF4      *clefGv2       *clefG2       *clefG2 #>     16:          *k[f#]        *k[f#]        *k[f#]        *k[f#] #>     17:             *G:           *G:           *G:           *G: #>     18:             *F:             *             *             * #>     19:           *M3/4         *M3/4         *M3/4         *M3/4 #>     20:          *MM100        *MM100        *MM100        *MM100 #>     21:             4GG            4B            4d            4g #>     22:              =1            =1            =1            =1 #>     23:              4G            4B            4d            2g #>     24:              4E           8cL            4e             . #>     25:               .           8BJ             .             . #>     26:             4F#            4A            4d           4dd #>     27:              =2            =2            =2            =2 #>     28:              4G            4G            2d           4.b #>     29:              4D           4F#             .             . #>     30:               .             .             .            8a #>     31:              4E            4G            4B            4g #>     32:              =3            =3            =3            =3 #>     33:              4C           8cL           8eL           4.g #>     34:               .           8BJ            8d             . #>     35:            8BBL            4c            8e             . #>     36:            8AAJ             .          8f#J            8a #>     37:             4GG            4d            4g            4b #>     38:              =4            =4            =4            =4 #>     39:             2D;           2d;          2f#;           2a; #>     40:             4GG            4d            4g            4b #> 41-134::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: #> ############################# ^^^ chor001.krn ^^^ ############################# #>  #>      (8 more files...) #>  #> ############################# vvv chor010.krn vvv ############################# #>   1-60::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: #>     61:            2AA;           2c;           2e;           2a; #>     62:              2A            2e            2a           2cc #>     63:              =9            =9            =9            =9 #>     64:              4E            4e            4g            4b #>     65:             8DL            4e            4g           4cc #>     66:             8CJ             .             .             . #>     67:             4BB            4d           8gL           4dd #>     68:               .             .           8fJ             . #>     69:              4C            4c            4e            4g #>     70:             =10           =10           =10           =10 #>     71:              4D           8F#            4d            4b #>     72:               .            4G             .             . #>     73:              4D             .            4c            4a #>     74:               .           8F#             .             . #>     75:            2GG;           2G;           2B;           2g; #>     76:             =11           =11           =11           =11 #>     77:              2C            2G            2e            2g #>     78:             4AA            4A            4e           4cc #>     79:              4E           4G#           8eL            4b #>     80:               .             .           8dJ             . #>     81:             =12           =12           =12           =12 #>     82:              4F            4A            4c            4a #>     83:              4C            4G            4c            4e #>     84:            4BB-            4G           [2d            4g #>     85:             4AA            4A             .            4f #>     86:             =13           =13           =13           =13 #>     87:            4GG#            4B           4d]           1e; #>     88:             4AA            4A            4c             . #>     89:            2EE;         2G#X;           2B;             . #>     90:              ==            ==            ==            == #>     91:              *-            *-            *-            *- #>     92:  !!!hum2abc: -Q '' #>     93:  !!!title: @{PC#}. @{OTL@@DE} #>     94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** #>     95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** #>     96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** #>     97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** #>     98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 #>     99:  !!!EED:  Craig Stuart Sapp #>    100:  !!!EEV:  2009/05/22 #> ############################# ^^^ chor010.krn ^^^ ############################# #>                        (***four global comments truncated due to screen size***) #>  #>  humdrumR corpus of ten files. #>   Data fields:  #>          *Token :: character readHumdrum('HumdrumData/.*Variations/.*.krn') #> ################ vvv B075_00_01_a.krn vvv ################ #>     1:  !!!COM: Beethoven #>     2:  !!!OTL: 7 Variations on a Quartet by Winter #>     3:  !!!Variation: Theme a #>     4:    **function  **harm     **kern             **kern #>     5:             *       *    *clefG2            *clefG2 #>     6:             *       *     *k[b-]             *k[b-] #>     7:         *M2/4   *M2/4      *M2/4              *M2/4 #>     8:           *F:     *F:        *F:                *F: #>     9:            4T      4I         4r           4aa 4ccc #>    10:            =1      =1         =1                 =1 #>    11:            2T      2I         2f         8ff'L 8aa' #>    12:             .       .          .         8cc'J 8ff' #>    13:             .       .          .         8ff'L 8aa' #>    14:             .       .          .        8aa'J 8ccc' #>    15:            =2      =2         =2                 =2 #>    16:            4T     4V7  (4c 4e 4g          (4gg 4bb- #>    17:            4T      4I        4f)           4ff) 4aa #>    18:            =3      =3         =3                 =3 #>    19:            2T      2V         4c         8ee'L 8gg' #>    20:             .       .          .         8dd'J 8ff' #>    21:             .       .         4c         8cc'L 8ee' #>    22:             .       .          .         8dd'J 8ff' #>    23:            =4      =4         =4                 =4 #>    24:            4T      4V         8c            8ee 8gg #>    25:             .       .         8r                 8r #>    26:            4T      4I         4r           4aa 4ccc #>    27:            =5      =5         =5                 =5 #>    28:            2T      2I         2f         8ff'L 8aa' #>    29:             .       .          .         8cc'J 8ff' #>    30:             .       .          .         8ff'L 8aa' #>    31:             .       .          .        8aa'J 8ccc' #>    32:            =6      =6         =6                 =6 #>    33:            4T     4V7  (4c 4e 4g          (4gg 4bb- #>    34:            4T      4I     4f) 4a           4ff) 4aa #>    35:            =7      =7         =7                 =7 #>    36:            4P    4iib       8B-L           8ddL 8gg #>    37:             .       .       8B-J           8ddJ 8gg #>    38:            4D     4V7        8cL          (8b-L 8ee #>    39:             .       .        8cJ         16b-L 16dd #>    40:             .       .          .            16eeJJ) #> 41-45::::::::::::::::::::::::::::::::::::::::::::::::::::: #> ################ ^^^ B075_00_01_a.krn ^^^ ################ #>  #>      (18 more files...) #>  #> ############### vvv M354_01_04d_a.krn vvv ################ #>  1-14::::::::::::::::::::::::::::::::::::::::::::::::::::: #>    15:             .       .          .     .      (16ccLL #>    16:             .       .          .     .         16b- #>    17:             .       .         8f     .          16a #>    18:             .       .          .     .      16b-JJ) #>    19:           =41     =41        =41   =41          =41 #>    20:            2D    2V7d         8r   2A-     (16ee-LL #>    21:             .       .          .     .         16dd #>    22:             .       .     4B- 4f     .        16cc# #>    23:             .       .          .     .      16ddJJ) #>    24:             .       .          .     .      (16ccLL #>    25:             .       .          .     .         16b- #>    26:             .       .     8B- 8f     .          16a #>    27:             .       .          .     .      16b-JJ) #>    28:             *       *         *v    *v            * #>    29:           =42     =42        =42                =42 #>    30:             *       *    *clefF4                  * #>    31:            4T     4Ib         8r           (16ee-LL #>    32:             .       .          .               16ff #>    33:             .       .     8G 8e-              16gg) #>    34:             .       .          .             16b'JJ #>    35:            4P     4IV         8r            (16ccLL #>    36:             .       .          .               16dd #>    37:             .       .    8A- 8e-             16ee-) #>    38:             .       .          .            16a-'JJ #>    39:           =43     =43        =43                =43 #>    40:             *       *         *^                  * #>    41:            4D     4Cc         8r  2BB-       (16gLL #>    42:             .       .          .     .         16a- #>    43:             .       .        (8G     .        16b-) #>    44:             .       .          .     .       16e'JJ #>    45:            4D     4V7       8A-L     .       (16fLL #>    46:             .       .          .     .          16g #>    47:             .       .       8FJ)     .        16a-) #>    48:             .       .          .     .       16d'JJ #>    49:             *       *         *v    *v            * #>    50:           =44     =44        =44                =44 #>    51:            2T      2I       8E-L                4e- #>    52:             .       .      8BB-J                  . #>    53:             .       .       4EE-                 4r #>    54:            *-      *-         *-                 *- #> ############### ^^^ M354_01_04d_a.krn ^^^ ################ #>  #>  humdrumR corpus of twenty files. #>   Data fields:  #>          *Token :: character readHumdrum('HumdrumData/.*/.*') #> ############################ vvv chor001.krn vvv ############################ #>      1:  !!!COM: Bach, Johann Sebastian #>      2:  !!!CDT: 1685/02/21/-1750/07/28/ #>      3:  !!!OTL@@DE: Aus meines Herzens Grunde #>      4:  !!!OTL@EN:      From the Depths of My Heart #>      5:  !!!SCT: BWV 269 #>      6:  !!!PC#: 1 #>      7:  !!!AGN: chorale #>      8:          **kern        **kern        **kern        **kern #>      9:          *ICvox        *ICvox        *ICvox        *ICvox #>     10:          *Ibass       *Itenor        *Ialto       *Isoprn #>     11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano #>     12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] #>     13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] #>     14:             *>A           *>A           *>A           *>A #>     15:         *clefF4      *clefGv2       *clefG2       *clefG2 #>     16:          *k[f#]        *k[f#]        *k[f#]        *k[f#] #>     17:             *G:           *G:           *G:           *G: #>     18:             *F:             *             *             * #>     19:           *M3/4         *M3/4         *M3/4         *M3/4 #>     20:          *MM100        *MM100        *MM100        *MM100 #>     21:             4GG            4B            4d            4g #>     22:              =1            =1            =1            =1 #>     23:              4G            4B            4d            2g #>     24:              4E           8cL            4e             . #>     25:               .           8BJ             .             . #>     26:             4F#            4A            4d           4dd #>     27:              =2            =2            =2            =2 #>     28:              4G            4G            2d           4.b #>     29:              4D           4F#             .             . #>     30:               .             .             .            8a #>     31:              4E            4G            4B            4g #>     32:              =3            =3            =3            =3 #>     33:              4C           8cL           8eL           4.g #>     34:               .           8BJ            8d             . #>     35:            8BBL            4c            8e             . #>     36:            8AAJ             .          8f#J            8a #>     37:             4GG            4d            4g            4b #>     38:              =4            =4            =4            =4 #>     39:             2D;           2d;          2f#;           2a; #>     40:             4GG            4d            4g            4b #> 41-134::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: #> ############################ ^^^ chor001.krn ^^^ ############################ #>  #>      (48 more files...) #>  #> ########################### vvv your_song.hum vvv ########################### #> 1-1194::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: #>   1195:               .             .             3             . #>   1196:               .             .             .             . #>   1197:               .             .             2             . #>   1198:               .             .             1             . #>   1199:               .             .             .             . #>   1200:            =119          =119          =119          =119 #>   1201:            ii65            IV             2       222.340 #>   1202:               .             .             .             . #>   1203:               .             .             .             . #>   1204:               .             .             6             . #>   1205:               .             .             .             . #>   1206:               .             .             .             . #>   1207:               .             .             .             . #>   1208:               .             .             6             . #>   1209:            =120          =120          =120          =120 #>   1210:               .             .            b3       224.253 #>   1211:               .             .             2             . #>   1212:               .             .             .             . #>   1213:               .             .             1             . #>   1214:               .             .             .             . #>   1215:               .             .             1             . #>   1216:               .             .             1             . #>   1217:               .             .             .             . #>   1218:            =121          =121          =121          =121 #>   1219:            *tb1          *tb1          *tb1             * #>   1220:               I             I             .       226.135 #>   1221:            =122          =122          =122          =122 #>   1222:              IV          IV64             .       228.013 #>   1223:            =123          =123          =123          =123 #>   1224:               V           Vs4             .       229.838 #>   1225:            =124          =124          =124          =124 #>   1226:              IV          IV64             .       231.691 #>   1227:            =125          =125          =125          =125 #>   1228:               I             I             .       233.583 #>   1229:              *-            *-            *-            *- #>   1230:  !!!ONB: Translated from original encodings in the Rolling Stone C*** #>   1231:  !!!ONB: Original transcribers noted in comments in each spine: !D*** #>   1232:  !!!YOE: David Temperley, Trevor de Clercq #>   1233:  !!!EED: Nathaniel Condit-Schultz (fathermckenzie.net) #>   1234:  !!!ENC: Nathaniel Condit-Schultz (fathermckenzie.net), automated #> ########################### ^^^ your_song.hum ^^^ ########################### #>                     (***three global comments truncated due to screen size***) #>  #>  humdrumR corpus of fifty files. #>   Data fields:  #>          *Token :: character"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/ReadWrite.html","id":"multi-argument-approach","dir":"Articles","previous_headings":"Reading humdrum data > Targeting files","what":"Multi-Argument Approach","title":"Reading and writing data","text":"Earlier mentioned can one RE-path patterns. one? Well, can divided RE-path patterns across multiple arguments (left right): Instead writing readHumdrum(\"HumdrumData/BachChorales/chor.*.krn\"), can write readHumdrum(\"HumdrumData\", \"BachChorales\", \"chor.*.krn\"). Thus two approaches identical. ’s advantage approach? ’ll see next section.","code":"readHumdrum(\"HumdrumData/BachChorales/chor.*.krn\")  readHumdrum(\"HumdrumData\", \"BachChorales\", \"chor.*.krn\")"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/ReadWrite.html","id":"multiple-patterns","dir":"Articles","previous_headings":"Reading humdrum data > Targeting files","what":"Multiple Patterns","title":"Reading and writing data","text":"Sometimes, expressing files want single regular expression possible. Luckily, readHumdrum can accept many separate patterns want, just group vector. Instead writing readHumdrum('HumdrumData/.*Variations/.*.krn'), explicit write ’ve used c command create vector two REpath-patterns. However, lot (bug-prone) typing…combine multiple patterns Multi-Argument Approach ?: get result! work exactly? ’ve fed three arguments readHumdrum. first last arguments (\"HumdrumData\" \".*.krn\") length one. However, middle argument (\"...Variations\") length two. readHumdrum concatenates three arguments together, making two separate REpath-patterns: Note: possible write multiple patterns match () files. argument multipleInstances = FALSE, unique file read (first matching pattern). multipleInstances = TRUE, file(s) can read .","code":"readHumdrum(c('HumdrumData/BeethovenVariations/.*.krn', 'HumdrumData/MozartVariations/.*.krn')) #> ################ vvv B075_00_01_a.krn vvv ################ #>     1:  !!!COM: Beethoven #>     2:  !!!OTL: 7 Variations on a Quartet by Winter #>     3:  !!!Variation: Theme a #>     4:    **function  **harm     **kern             **kern #>     5:             *       *    *clefG2            *clefG2 #>     6:             *       *     *k[b-]             *k[b-] #>     7:         *M2/4   *M2/4      *M2/4              *M2/4 #>     8:           *F:     *F:        *F:                *F: #>     9:            4T      4I         4r           4aa 4ccc #>    10:            =1      =1         =1                 =1 #>    11:            2T      2I         2f         8ff'L 8aa' #>    12:             .       .          .         8cc'J 8ff' #>    13:             .       .          .         8ff'L 8aa' #>    14:             .       .          .        8aa'J 8ccc' #>    15:            =2      =2         =2                 =2 #>    16:            4T     4V7  (4c 4e 4g          (4gg 4bb- #>    17:            4T      4I        4f)           4ff) 4aa #>    18:            =3      =3         =3                 =3 #>    19:            2T      2V         4c         8ee'L 8gg' #>    20:             .       .          .         8dd'J 8ff' #>    21:             .       .         4c         8cc'L 8ee' #>    22:             .       .          .         8dd'J 8ff' #>    23:            =4      =4         =4                 =4 #>    24:            4T      4V         8c            8ee 8gg #>    25:             .       .         8r                 8r #>    26:            4T      4I         4r           4aa 4ccc #>    27:            =5      =5         =5                 =5 #>    28:            2T      2I         2f         8ff'L 8aa' #>    29:             .       .          .         8cc'J 8ff' #>    30:             .       .          .         8ff'L 8aa' #>    31:             .       .          .        8aa'J 8ccc' #>    32:            =6      =6         =6                 =6 #>    33:            4T     4V7  (4c 4e 4g          (4gg 4bb- #>    34:            4T      4I     4f) 4a           4ff) 4aa #>    35:            =7      =7         =7                 =7 #>    36:            4P    4iib       8B-L           8ddL 8gg #>    37:             .       .       8B-J           8ddJ 8gg #>    38:            4D     4V7        8cL          (8b-L 8ee #>    39:             .       .        8cJ         16b-L 16dd #>    40:             .       .          .            16eeJJ) #> 41-45::::::::::::::::::::::::::::::::::::::::::::::::::::: #> ################ ^^^ B075_00_01_a.krn ^^^ ################ #>  #>      (18 more files...) #>  #> ############### vvv M354_01_04d_a.krn vvv ################ #>  1-14::::::::::::::::::::::::::::::::::::::::::::::::::::: #>    15:             .       .          .     .      (16ccLL #>    16:             .       .          .     .         16b- #>    17:             .       .         8f     .          16a #>    18:             .       .          .     .      16b-JJ) #>    19:           =41     =41        =41   =41          =41 #>    20:            2D    2V7d         8r   2A-     (16ee-LL #>    21:             .       .          .     .         16dd #>    22:             .       .     4B- 4f     .        16cc# #>    23:             .       .          .     .      16ddJJ) #>    24:             .       .          .     .      (16ccLL #>    25:             .       .          .     .         16b- #>    26:             .       .     8B- 8f     .          16a #>    27:             .       .          .     .      16b-JJ) #>    28:             *       *         *v    *v            * #>    29:           =42     =42        =42                =42 #>    30:             *       *    *clefF4                  * #>    31:            4T     4Ib         8r           (16ee-LL #>    32:             .       .          .               16ff #>    33:             .       .     8G 8e-              16gg) #>    34:             .       .          .             16b'JJ #>    35:            4P     4IV         8r            (16ccLL #>    36:             .       .          .               16dd #>    37:             .       .    8A- 8e-             16ee-) #>    38:             .       .          .            16a-'JJ #>    39:           =43     =43        =43                =43 #>    40:             *       *         *^                  * #>    41:            4D     4Cc         8r  2BB-       (16gLL #>    42:             .       .          .     .         16a- #>    43:             .       .        (8G     .        16b-) #>    44:             .       .          .     .       16e'JJ #>    45:            4D     4V7       8A-L     .       (16fLL #>    46:             .       .          .     .          16g #>    47:             .       .       8FJ)     .        16a-) #>    48:             .       .          .     .       16d'JJ #>    49:             *       *         *v    *v            * #>    50:           =44     =44        =44                =44 #>    51:            2T      2I       8E-L                4e- #>    52:             .       .      8BB-J                  . #>    53:             .       .       4EE-                 4r #>    54:            *-      *-         *-                 *- #> ############### ^^^ M354_01_04d_a.krn ^^^ ################ #>  #>  humdrumR corpus of twenty files (two subcorpora: _1, _2). #>   Data fields:  #>          *Token :: character readHumdrum('HumdrumData',             c('BeethovenVariations', 'MozartVariations'),             '.*.krn') #> ################ vvv B075_00_01_a.krn vvv ################ #>     1:  !!!COM: Beethoven #>     2:  !!!OTL: 7 Variations on a Quartet by Winter #>     3:  !!!Variation: Theme a #>     4:    **function  **harm     **kern             **kern #>     5:             *       *    *clefG2            *clefG2 #>     6:             *       *     *k[b-]             *k[b-] #>     7:         *M2/4   *M2/4      *M2/4              *M2/4 #>     8:           *F:     *F:        *F:                *F: #>     9:            4T      4I         4r           4aa 4ccc #>    10:            =1      =1         =1                 =1 #>    11:            2T      2I         2f         8ff'L 8aa' #>    12:             .       .          .         8cc'J 8ff' #>    13:             .       .          .         8ff'L 8aa' #>    14:             .       .          .        8aa'J 8ccc' #>    15:            =2      =2         =2                 =2 #>    16:            4T     4V7  (4c 4e 4g          (4gg 4bb- #>    17:            4T      4I        4f)           4ff) 4aa #>    18:            =3      =3         =3                 =3 #>    19:            2T      2V         4c         8ee'L 8gg' #>    20:             .       .          .         8dd'J 8ff' #>    21:             .       .         4c         8cc'L 8ee' #>    22:             .       .          .         8dd'J 8ff' #>    23:            =4      =4         =4                 =4 #>    24:            4T      4V         8c            8ee 8gg #>    25:             .       .         8r                 8r #>    26:            4T      4I         4r           4aa 4ccc #>    27:            =5      =5         =5                 =5 #>    28:            2T      2I         2f         8ff'L 8aa' #>    29:             .       .          .         8cc'J 8ff' #>    30:             .       .          .         8ff'L 8aa' #>    31:             .       .          .        8aa'J 8ccc' #>    32:            =6      =6         =6                 =6 #>    33:            4T     4V7  (4c 4e 4g          (4gg 4bb- #>    34:            4T      4I     4f) 4a           4ff) 4aa #>    35:            =7      =7         =7                 =7 #>    36:            4P    4iib       8B-L           8ddL 8gg #>    37:             .       .       8B-J           8ddJ 8gg #>    38:            4D     4V7        8cL          (8b-L 8ee #>    39:             .       .        8cJ         16b-L 16dd #>    40:             .       .          .            16eeJJ) #> 41-45::::::::::::::::::::::::::::::::::::::::::::::::::::: #> ################ ^^^ B075_00_01_a.krn ^^^ ################ #>  #>      (18 more files...) #>  #> ############### vvv M354_01_04d_a.krn vvv ################ #>  1-14::::::::::::::::::::::::::::::::::::::::::::::::::::: #>    15:             .       .          .     .      (16ccLL #>    16:             .       .          .     .         16b- #>    17:             .       .         8f     .          16a #>    18:             .       .          .     .      16b-JJ) #>    19:           =41     =41        =41   =41          =41 #>    20:            2D    2V7d         8r   2A-     (16ee-LL #>    21:             .       .          .     .         16dd #>    22:             .       .     4B- 4f     .        16cc# #>    23:             .       .          .     .      16ddJJ) #>    24:             .       .          .     .      (16ccLL #>    25:             .       .          .     .         16b- #>    26:             .       .     8B- 8f     .          16a #>    27:             .       .          .     .      16b-JJ) #>    28:             *       *         *v    *v            * #>    29:           =42     =42        =42                =42 #>    30:             *       *    *clefF4                  * #>    31:            4T     4Ib         8r           (16ee-LL #>    32:             .       .          .               16ff #>    33:             .       .     8G 8e-              16gg) #>    34:             .       .          .             16b'JJ #>    35:            4P     4IV         8r            (16ccLL #>    36:             .       .          .               16dd #>    37:             .       .    8A- 8e-             16ee-) #>    38:             .       .          .            16a-'JJ #>    39:           =43     =43        =43                =43 #>    40:             *       *         *^                  * #>    41:            4D     4Cc         8r  2BB-       (16gLL #>    42:             .       .          .     .         16a- #>    43:             .       .        (8G     .        16b-) #>    44:             .       .          .     .       16e'JJ #>    45:            4D     4V7       8A-L     .       (16fLL #>    46:             .       .          .     .          16g #>    47:             .       .       8FJ)     .        16a-) #>    48:             .       .          .     .       16d'JJ #>    49:             *       *         *v    *v            * #>    50:           =44     =44        =44                =44 #>    51:            2T      2I       8E-L                4e- #>    52:             .       .      8BB-J                  . #>    53:             .       .       4EE-                 4r #>    54:            *-      *-         *-                 *- #> ############### ^^^ M354_01_04d_a.krn ^^^ ################ #>  #>  humdrumR corpus of twenty files (two subcorpora: _1, _2). #>   Data fields:  #>          *Token :: character \"HumdrumData/BeethovenVariations/.*.krn\" \"HumdrumData/MozartVariations/.*.krn\""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/ReadWrite.html","id":"pattern-names","dir":"Articles","previous_headings":"Reading humdrum data > Targeting files > Multiple Patterns","what":"Pattern Names","title":"Reading and writing data","text":"Whenever specific one REpath-pattern, humdrum\\(_{\\mathbb{R}}\\) gives names can access Label field resulting humdrum\\(_{\\mathbb{R}}\\) data object. can choose labels giving names patterns multi-pattern vectors: Thus, write two separate patterns matched read names \"Rap\" \"Rock\" associated resulting Label field. feature useful working multiple heterogeneous datasets want able apply analyses/parsing one data subsets.","code":"readHumdrum('HumdrumData',             c(Rap  = 'Rap/.*',               Rock = 'RollingStone/.*')) -> rapAndRock"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/ReadWrite.html","id":"contains","dir":"Articles","previous_headings":"Reading humdrum data > Targeting files","what":"Contains","title":"Reading and writing data","text":"Sometimes want read humdrum files contain particular data. instance, might want read files minor key. One option read files corpus filter files don’t want (see humdrumR filtering vignette learn . However, cases, can save lot time effort filter files want parsing . contains argument readHumdrum can used just way! contains argument must character vector—character string treated regular expression, files contain matches regular expressions read. Thus, read pieces minor keys writing: (regular expression matches standard humdrum tandem interpretations minor keys.)","code":"readHumdrum('HumdrumData', 'BachChorales', 'chor.*.krn',             contains = '\\\\*[a-g][-b#]*:')  #> ############################# vvv chor003.krn vvv ############################# #>      1:  !!!COM: Bach, Johann Sebastian #>      2:  !!!CDT: 1685/02/21/-1750/07/28/ #>      3:  !!!OTL@@DE: Ach Gott, vom Himmel sieh darein #>      4:  !!!OTL@EN: Oh God, look down from Heaven #>      5:  !!!OPR: Cantata BWV 153: Schau, lieber Gott, wie meine Feind #>      6:  !!!SCT: BWV 153/1 #>      7:  !!!PC#: 3 #>      8:  !!!AGN: chorale #>      9:          **kern        **kern        **kern        **kern #>     10:          *ICvox        *ICvox        *ICvox        *ICvox #>     11:          *Ibass       *Itenor        *Ialto       *Isoprn #>     12:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano #>     13:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] #>     14:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] #>     15:             *>A           *>A           *>A           *>A #>     16:         *clefF4      *clefGv2       *clefG2       *clefG2 #>     17:          *k[f#]        *k[f#]        *k[f#]        *k[f#] #>     18:             *a:           *a:           *a:           *a: #>     19:         !dorian       !dorian       !dorian       !dorian #>     20:           *M4/4         *M4/4         *M4/4         *M4/4 #>     21:         *met(c)       *met(c)       *met(c)       *met(c) #>     22:          *MM100        *MM100        *MM100        *MM100 #>     23:              4E            4e           4g#            4b #>     24:              =1            =1            =1            =1 #>     25:              4A            4e            4a           4cc #>     26:              4B            4d           4g#            4b #>     27:              4c            4e            4a            4a #>     28:             8BL           8dL          8g#L           4ee #>     29:             8AJ           8cJ           8aJ             . #>     30:              =2            =2            =2            =2 #>     31:             4G#            4B            4b          8eeL #>     32:               .             .             .          8ddJ #>     33:              4A           8cL           8eL           4cc #>     34:               .           8dJ          8f#J             . #>     35:             4E;           4e;          4g#;           4b; #>     36:             4BB            4f           4g#           4dd #>     37:              =3            =3            =3            =3 #>     38:             8CL            4e            4a           4cc #>     39:             8DJ             .             .             . #>     40:              4E           8eL           4g#            4b #> 41-110::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: #> ############################# ^^^ chor003.krn ^^^ ############################# #>  #>      (1 more files...) #>  #> ############################# vvv chor010.krn vvv ############################# #>   1-60::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: #>     61:            2AA;           2c;           2e;           2a; #>     62:              2A            2e            2a           2cc #>     63:              =9            =9            =9            =9 #>     64:              4E            4e            4g            4b #>     65:             8DL            4e            4g           4cc #>     66:             8CJ             .             .             . #>     67:             4BB            4d           8gL           4dd #>     68:               .             .           8fJ             . #>     69:              4C            4c            4e            4g #>     70:             =10           =10           =10           =10 #>     71:              4D           8F#            4d            4b #>     72:               .            4G             .             . #>     73:              4D             .            4c            4a #>     74:               .           8F#             .             . #>     75:            2GG;           2G;           2B;           2g; #>     76:             =11           =11           =11           =11 #>     77:              2C            2G            2e            2g #>     78:             4AA            4A            4e           4cc #>     79:              4E           4G#           8eL            4b #>     80:               .             .           8dJ             . #>     81:             =12           =12           =12           =12 #>     82:              4F            4A            4c            4a #>     83:              4C            4G            4c            4e #>     84:            4BB-            4G           [2d            4g #>     85:             4AA            4A             .            4f #>     86:             =13           =13           =13           =13 #>     87:            4GG#            4B           4d]           1e; #>     88:             4AA            4A            4c             . #>     89:            2EE;         2G#X;           2B;             . #>     90:              ==            ==            ==            == #>     91:              *-            *-            *-            *- #>     92:  !!!hum2abc: -Q '' #>     93:  !!!title: @{PC#}. @{OTL@@DE} #>     94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** #>     95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** #>     96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** #>     97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** #>     98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 #>     99:  !!!EED:  Craig Stuart Sapp #>    100:  !!!EEV:  2009/05/22 #> ############################# ^^^ chor010.krn ^^^ ############################# #>                        (***four global comments truncated due to screen size***) #>  #>  humdrumR corpus of three files. #>   Data fields:  #>          *Token :: character"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/ReadWrite.html","id":"finding-files","dir":"Articles","previous_headings":"Reading humdrum data","what":"Finding Files","title":"Reading and writing data","text":"readHumdrum interprets REpath-patterns finds files using helper function findHumdrum. sure humdrum files , pattern want use find , might start using findHumdrum. findHumdrum takes input readHumdrum, doesn’t fully parse input humdrum\\(_{\\mathbb{R}}\\). Instead, returns data.table containing matching filenames () raw file content. use verbose = TRUE option either findHumdrum readHumdrum, complete list matches files printed. useful check reading files intend read.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/ReadWrite.html","id":"validation","dir":"Articles","previous_headings":"Reading humdrum data > Finding Files","what":"Validation","title":"Reading and writing data","text":"findHumdrum(), extension readHumdrum(), smart functions ignore non-humdrum files matched pattern. Non-text files (like .pdf .jpg) ignored. Whats , text files fail conform humdrum syntax read either. see message checks files “valid humdrum,” tell many () text files read. trying read file think valid humdrum readHumdrum() won’t read , use validateHumdrum() see detailed report problem. Humdrum\\(_{\\mathbb{R}}\\) won’t read files humdrum-syntax violations, even relatively minor ones. see problems validateHumdrum() finding data, ’ll need fix can use humdrum\\(_{\\mathbb{R}}\\) data. Check [validateHumdrum][reference/validateHumdrum.html] documentation learn humdrum\\(_{\\mathbb{R}}\\)’s data validation tools, can used identify errors humdrum data. Note validateHumdrum() automatically check humdrum data encoded correctly makes sense, just structurally sound, accordance humdrum syntax.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/ReadWrite.html","id":"reading","dir":"Articles","previous_headings":"Reading humdrum data","what":"Reading","title":"Reading and writing data","text":", actually happens run readHumdrum? now, ’ve seen readHumdrum prints messages describing process. First, files match search patterns () identified, text read R. Next, files checked see valid humdrum files. files parsed—.e., translated humdrum\\(_{\\mathbb{R}}\\)’s data.table backend. step takes longest far, includes parsing humdrum files’ data tokens, interpretations, reference records, (worst ) spine paths. Indeed, reading humdrum data spine paths take significantly longer reading pathless data. save time, can potentially use tandems reference arguments (see “Parsing Metadata” ).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/ReadWrite.html","id":"parsing-metadata","dir":"Articles","previous_headings":"Reading humdrum data","what":"Parsing Metadata","title":"Reading and writing data","text":"default, humdrum\\(_{\\mathbb{R}}\\) parses metadata humdrum files reads. includes true global metadata files, encoded humdrum reference records, well local tandem interpretations.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/ReadWrite.html","id":"reference-records","dir":"Articles","previous_headings":"Reading humdrum data > Parsing Metadata","what":"Reference Records","title":"Reading and writing data","text":"default, humdrum\\(_{\\mathbb{R}}\\) parses reference records files reads, creating unique field reference key. (one instance given key, combined string separated semicolons.) lot unique reference keys dataset, can end taking lot memory humdrum table. cases, might find useful limit readHumdrum parsing reference records actually going use. can accomplished quite easily reference argument. reference argument defaults \"\", means reference records parsed. However, reference can also character vector reference codes. Thus, parse COM reference record piece. can use rename reference fields like—case, COM reference records parsed saved field called Composer instead COM. don’t want parse reference records, specify reference = NULL.","code":"readHumdrum('HumdrumData',             c('BeethovenVariations', 'MozartVariations'),             '.*.krn',             reference = 'COM') #> ################ vvv B075_00_01_a.krn vvv ################ #>     1:  !!!COM: Beethoven #>     2:  !!!OTL: 7 Variations on a Quartet by Winter #>     3:  !!!Variation: Theme a #>     4:    **function  **harm     **kern             **kern #>     5:             *       *    *clefG2            *clefG2 #>     6:             *       *     *k[b-]             *k[b-] #>     7:         *M2/4   *M2/4      *M2/4              *M2/4 #>     8:           *F:     *F:        *F:                *F: #>     9:            4T      4I         4r           4aa 4ccc #>    10:            =1      =1         =1                 =1 #>    11:            2T      2I         2f         8ff'L 8aa' #>    12:             .       .          .         8cc'J 8ff' #>    13:             .       .          .         8ff'L 8aa' #>    14:             .       .          .        8aa'J 8ccc' #>    15:            =2      =2         =2                 =2 #>    16:            4T     4V7  (4c 4e 4g          (4gg 4bb- #>    17:            4T      4I        4f)           4ff) 4aa #>    18:            =3      =3         =3                 =3 #>    19:            2T      2V         4c         8ee'L 8gg' #>    20:             .       .          .         8dd'J 8ff' #>    21:             .       .         4c         8cc'L 8ee' #>    22:             .       .          .         8dd'J 8ff' #>    23:            =4      =4         =4                 =4 #>    24:            4T      4V         8c            8ee 8gg #>    25:             .       .         8r                 8r #>    26:            4T      4I         4r           4aa 4ccc #>    27:            =5      =5         =5                 =5 #>    28:            2T      2I         2f         8ff'L 8aa' #>    29:             .       .          .         8cc'J 8ff' #>    30:             .       .          .         8ff'L 8aa' #>    31:             .       .          .        8aa'J 8ccc' #>    32:            =6      =6         =6                 =6 #>    33:            4T     4V7  (4c 4e 4g          (4gg 4bb- #>    34:            4T      4I     4f) 4a           4ff) 4aa #>    35:            =7      =7         =7                 =7 #>    36:            4P    4iib       8B-L           8ddL 8gg #>    37:             .       .       8B-J           8ddJ 8gg #>    38:            4D     4V7        8cL          (8b-L 8ee #>    39:             .       .        8cJ         16b-L 16dd #>    40:             .       .          .            16eeJJ) #> 41-45::::::::::::::::::::::::::::::::::::::::::::::::::::: #> ################ ^^^ B075_00_01_a.krn ^^^ ################ #>  #>      (18 more files...) #>  #> ############### vvv M354_01_04d_a.krn vvv ################ #>  1-14::::::::::::::::::::::::::::::::::::::::::::::::::::: #>    15:             .       .          .     .      (16ccLL #>    16:             .       .          .     .         16b- #>    17:             .       .         8f     .          16a #>    18:             .       .          .     .      16b-JJ) #>    19:           =41     =41        =41   =41          =41 #>    20:            2D    2V7d         8r   2A-     (16ee-LL #>    21:             .       .          .     .         16dd #>    22:             .       .     4B- 4f     .        16cc# #>    23:             .       .          .     .      16ddJJ) #>    24:             .       .          .     .      (16ccLL #>    25:             .       .          .     .         16b- #>    26:             .       .     8B- 8f     .          16a #>    27:             .       .          .     .      16b-JJ) #>    28:             *       *         *v    *v            * #>    29:           =42     =42        =42                =42 #>    30:             *       *    *clefF4                  * #>    31:            4T     4Ib         8r           (16ee-LL #>    32:             .       .          .               16ff #>    33:             .       .     8G 8e-              16gg) #>    34:             .       .          .             16b'JJ #>    35:            4P     4IV         8r            (16ccLL #>    36:             .       .          .               16dd #>    37:             .       .    8A- 8e-             16ee-) #>    38:             .       .          .            16a-'JJ #>    39:           =43     =43        =43                =43 #>    40:             *       *         *^                  * #>    41:            4D     4Cc         8r  2BB-       (16gLL #>    42:             .       .          .     .         16a- #>    43:             .       .        (8G     .        16b-) #>    44:             .       .          .     .       16e'JJ #>    45:            4D     4V7       8A-L     .       (16fLL #>    46:             .       .          .     .          16g #>    47:             .       .       8FJ)     .        16a-) #>    48:             .       .          .     .       16d'JJ #>    49:             *       *         *v    *v            * #>    50:           =44     =44        =44                =44 #>    51:            2T      2I       8E-L                4e- #>    52:             .       .      8BB-J                  . #>    53:             .       .       4EE-                 4r #>    54:            *-      *-         *-                 *- #> ############### ^^^ M354_01_04d_a.krn ^^^ ################ #>  #>  humdrumR corpus of twenty files (two subcorpora: _1, _2). #>   Data fields:  #>          *Token :: character readHumdrum('HumdrumData',             c('BeethovenVariations', 'MozartVariations'),             '.*.krn',             reference = c(Composer = 'COM')) #> ################ vvv B075_00_01_a.krn vvv ################ #>     1:  !!!COM: Beethoven #>     2:  !!!OTL: 7 Variations on a Quartet by Winter #>     3:  !!!Variation: Theme a #>     4:    **function  **harm     **kern             **kern #>     5:             *       *    *clefG2            *clefG2 #>     6:             *       *     *k[b-]             *k[b-] #>     7:         *M2/4   *M2/4      *M2/4              *M2/4 #>     8:           *F:     *F:        *F:                *F: #>     9:            4T      4I         4r           4aa 4ccc #>    10:            =1      =1         =1                 =1 #>    11:            2T      2I         2f         8ff'L 8aa' #>    12:             .       .          .         8cc'J 8ff' #>    13:             .       .          .         8ff'L 8aa' #>    14:             .       .          .        8aa'J 8ccc' #>    15:            =2      =2         =2                 =2 #>    16:            4T     4V7  (4c 4e 4g          (4gg 4bb- #>    17:            4T      4I        4f)           4ff) 4aa #>    18:            =3      =3         =3                 =3 #>    19:            2T      2V         4c         8ee'L 8gg' #>    20:             .       .          .         8dd'J 8ff' #>    21:             .       .         4c         8cc'L 8ee' #>    22:             .       .          .         8dd'J 8ff' #>    23:            =4      =4         =4                 =4 #>    24:            4T      4V         8c            8ee 8gg #>    25:             .       .         8r                 8r #>    26:            4T      4I         4r           4aa 4ccc #>    27:            =5      =5         =5                 =5 #>    28:            2T      2I         2f         8ff'L 8aa' #>    29:             .       .          .         8cc'J 8ff' #>    30:             .       .          .         8ff'L 8aa' #>    31:             .       .          .        8aa'J 8ccc' #>    32:            =6      =6         =6                 =6 #>    33:            4T     4V7  (4c 4e 4g          (4gg 4bb- #>    34:            4T      4I     4f) 4a           4ff) 4aa #>    35:            =7      =7         =7                 =7 #>    36:            4P    4iib       8B-L           8ddL 8gg #>    37:             .       .       8B-J           8ddJ 8gg #>    38:            4D     4V7        8cL          (8b-L 8ee #>    39:             .       .        8cJ         16b-L 16dd #>    40:             .       .          .            16eeJJ) #> 41-45::::::::::::::::::::::::::::::::::::::::::::::::::::: #> ################ ^^^ B075_00_01_a.krn ^^^ ################ #>  #>      (18 more files...) #>  #> ############### vvv M354_01_04d_a.krn vvv ################ #>  1-14::::::::::::::::::::::::::::::::::::::::::::::::::::: #>    15:             .       .          .     .      (16ccLL #>    16:             .       .          .     .         16b- #>    17:             .       .         8f     .          16a #>    18:             .       .          .     .      16b-JJ) #>    19:           =41     =41        =41   =41          =41 #>    20:            2D    2V7d         8r   2A-     (16ee-LL #>    21:             .       .          .     .         16dd #>    22:             .       .     4B- 4f     .        16cc# #>    23:             .       .          .     .      16ddJJ) #>    24:             .       .          .     .      (16ccLL #>    25:             .       .          .     .         16b- #>    26:             .       .     8B- 8f     .          16a #>    27:             .       .          .     .      16b-JJ) #>    28:             *       *         *v    *v            * #>    29:           =42     =42        =42                =42 #>    30:             *       *    *clefF4                  * #>    31:            4T     4Ib         8r           (16ee-LL #>    32:             .       .          .               16ff #>    33:             .       .     8G 8e-              16gg) #>    34:             .       .          .             16b'JJ #>    35:            4P     4IV         8r            (16ccLL #>    36:             .       .          .               16dd #>    37:             .       .    8A- 8e-             16ee-) #>    38:             .       .          .            16a-'JJ #>    39:           =43     =43        =43                =43 #>    40:             *       *         *^                  * #>    41:            4D     4Cc         8r  2BB-       (16gLL #>    42:             .       .          .     .         16a- #>    43:             .       .        (8G     .        16b-) #>    44:             .       .          .     .       16e'JJ #>    45:            4D     4V7       8A-L     .       (16fLL #>    46:             .       .          .     .          16g #>    47:             .       .       8FJ)     .        16a-) #>    48:             .       .          .     .       16d'JJ #>    49:             *       *         *v    *v            * #>    50:           =44     =44        =44                =44 #>    51:            2T      2I       8E-L                4e- #>    52:             .       .      8BB-J                  . #>    53:             .       .       4EE-                 4r #>    54:            *-      *-         *-                 *- #> ############### ^^^ M354_01_04d_a.krn ^^^ ################ #>  #>  humdrumR corpus of twenty files (two subcorpora: _1, _2). #>   Data fields:  #>          *Token :: character"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/ReadWrite.html","id":"tandem-interpretations","dir":"Articles","previous_headings":"Reading humdrum data > Parsing Metadata","what":"Tandem Interpretations","title":"Reading and writing data","text":"Tandem interpretations used humdrum data represent “local,” real-time metainformation associated specific spines—review humdrum syntax vignette details. Humdrum\\(_{\\mathbb{R}}\\) can read arbitrary tandem interpretations humdrum data. However, non-standard interpretations used, humdrum\\(_{\\mathbb{R}}\\) way knowing parse . default, humdrum\\(_{\\mathbb{R}}\\) always reads tandem interpretations field called Tandem. field tabulates tandem interpretations far appeared spine order, concatenating single comma-delimited, recent distant. instance, Tandem field spine parsed , interpretations pile longer longer string piece progresses. Notice \"D:\" \"C:\" interpretations get piled separately, just like interpretation, even though tandem class, \"D:\" supersede \"C:\". ? Well, general way know arbitrary tandem interpretations class. create humdrum data new interpretations , humdrum\\(_{\\mathbb{R}}\\) doesn’t know parse , just pile like Tandem field. Fortunately, humdrum\\(_{\\mathbb{R}}\\) know parse many standard tandem interpretations. run command see currently ten classes tandem interpretations humdrumR recognizes, associated regular expression. Thus, really apply readHumdrum file recognize tokens \"C:\" \"D:\" match known regular expression Key tandem interpretation, parse field called Key, look like: Likewise, ’d get TimeSignature BPM fields.","code":"**kern *C: *M4/4 *MM100 c e c g *D: d f# *- \"\" C: M4/4,C: MM100,M4/4,C: MM100,M4/4,C: MM100,M4/4,C: D:,MM100,M4/4,C: D:,MM100,M4/4,C: D:,MM100,M4/4,C: knownInterpretations[Type == 'Tandem']  #>                      Name Exclusive #>  1:                   Key           #>  2:          KeySignature           #>  3:                  Clef           #>  4:         TimeSignature           #>  5:           Mensuration           #>  6:                   BPM           #>  7:              Timebase           #>  8:            Instrument           #>  9:       InstrumentClass           #> 10: TransposingInstrument           #>                                                      RE Pretty   Type #>  1: [A-Ga-g][-#b]*:(mix|dor|phr|lyd|loc)?([#bn]?[1-7])*     _: Tandem #>  2:                              k\\\\[([a-g][#-]* *)*\\\\]   k[_] Tandem #>  3:                                   clef[A-G]v*[1-5]*  clef_ Tandem #>  4:                     M[1-9][0-9]*/((16)|(32)|[1248])   M_/_ Tandem #>  5:                                      met\\\\([^)]*\\\\) met(_) Tandem #>  6:                                            MM[0-9]+    MM_ Tandem #>  7:                     tb[1-9][0-9]*%?[1-9]?[0-9]*[.]*    tb_ Tandem #>  8:                                             I[^C,]+     I_ Tandem #>  9:                                             IC[^,]*    IC_ Tandem #> 10:                                            ITr[^,]*   ITr_ Tandem **kern *C: *M4/4 *MM100 c e c g *D: d f# *- NA C: C: C: C: C: D: D: D:"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/ReadWrite.html","id":"custom-tandems","dir":"Articles","previous_headings":"Reading humdrum data > Parsing Metadata > Tandem Interpretations","what":"Custom Tandems","title":"Reading and writing data","text":"readHumdrum tandems argument allows us take control tandem interpretation parsing process. tandems character vector, defaulting known, parses known interpretations fields (following knownInterpretations table). can use tandems two ways. 1.) can remove \"known\" vector specify Name specific tandem interpretations want parse. instance, write tandem = \"Clef\", Clef pattern knownInterpretations table parsed, (others). 2.) character string tandems \"known\" exact match Name knownInterpretations, instead treated regular expression match new tandem interpretation class. instance, tandems = \"[Aa]pple|[Bb]anana\" match “*Apple”, “*apple”, “*Banana”, “*banana,” parsing four patterns field (called [Aa]pple|[Bb]anana]). give field name writing tandems = c(Fruit = \"[Aa]pple|[Bb]anana\"). (fact, can rename known interpretations well, instance writing tandems = c(Meter = \"TimeSignature\".) tandems = NULL, tandem interpretations parsed —can used shorten parsing time.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Reshaping.html","id":"filtering-data","dir":"Articles","previous_headings":"","what":"Filtering Data","title":"Shaping humdrum data","text":"first step might remove data don’t need. article, ’ll show common, basic, ways might filter data. details humdrum\\(_{\\mathbb{R}}\\) filtering functionality, check data filtering article.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Reshaping.html","id":"indexing","dir":"Articles","previous_headings":"Filtering Data","what":"Indexing","title":"Shaping humdrum data","text":"example, studying tonality, might simply want ignore lyric data. easiest way index spines don’t want, either using numeric indices exclusive interpretation:","code":"example[[ , c(1,3,5)]] >     vvv Reshaping_example.hum vvv # >       1:    **kern   **kern  **harm >       2:    *ICvox   *ICvox       * >       3:    *Ialto  *Isoprn       * >       4:     *M4/4    *M4/4       * >       5:       *C:      *C:     *C: >       6:       4.c      4.e       I >       7:        8d       8f       . >       8:        4e       4g       . >       9:        4f       4a      IV >      10:         =        =       = >      11:        2g      4dd     I64 >      12:         .      4cc       . >      13:        2g       2b       V >      14:        *-       *-      *- >     ^^^ Reshaping_example.hum ^^^ # >        Data fields:  >               *Token :: character example[[ , c('**kern', '**harm')]] >     vvv Reshaping_example.hum vvv # >       1:    **kern   **kern  **harm >       2:    *ICvox   *ICvox       * >       3:    *Ialto  *Isoprn       * >       4:     *M4/4    *M4/4       * >       5:       *C:      *C:     *C: >       6:       4.c      4.e       I >       7:        8d       8f       . >       8:        4e       4g       . >       9:        4f       4a      IV >      10:         =        =       = >      11:        2g      4dd     I64 >      12:         .      4cc       . >      13:        2g       2b       V >      14:        *-       *-      *- >     ^^^ Reshaping_example.hum ^^^ # >        Data fields:  >               *Token :: character"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Reshaping.html","id":"parsing-token","dir":"Articles","previous_headings":"Filtering Data","what":"Parsing Token","title":"Shaping humdrum data","text":"file, **kern spines example file include rhythmic data (**recip) pitch data. just studying tonality, extract just pitch information Token field, save new field. example, can use kern extract pitch information Token, put new field—let’s call Pitch. new Pitch field, can still access original Token field. can see easily setting “active” field back Token:","code":"within(example,         kern(Token) -> Pitch) -> example  example >    ######### vvv Reshaping_example.hum vvv ########## >       1:    **kern  **silbe   **kern  **silbe  **harm >       2:    *ICvox        *   *ICvox        *       * >       3:    *Ialto        *  *Isoprn        *       * >       4:     *M4/4        *    *M4/4        *       * >       5:       *C:        *      *C:        *     *C: >       6:         c        .        e        .       . >       7:         d        .        f        .       . >       8:         e        .        g        .       . >       9:         f        .        a        .       . >      10:         =        =        =        =       = >      11:         g        .       dd        .       . >      12:         .        .       cc        .       . >      13:         g        .        b        .       . >      14:        *-       *-       *-       *-      *- >    ######### ^^^ Reshaping_example.hum ^^^ ########## >        Data fields:  >                Token :: character >               *Pitch :: character example$Token >    ######### vvv Reshaping_example.hum vvv ########## >       1:    **kern  **silbe   **kern  **silbe  **harm >       2:    *ICvox        *   *ICvox        *       * >       3:    *Ialto        *  *Isoprn        *       * >       4:     *M4/4        *    *M4/4        *       * >       5:       *C:        *      *C:        *     *C: >       6:       4.c     This      4.e     This       I >       7:        8d       is       8f       is       . >       8:        4e       an       4g       an       . >       9:        4f      ex-       4a      ex-      IV >      10:         =        =        =        =       = >      11:        2g     -am-      4dd     -am-     I64 >      12:         .        .      4cc        _       . >      13:        2g     -ple       2b     -ple       V >      14:        *-       *-       *-       *-      *- >    ######### ^^^ Reshaping_example.hum ^^^ ########## >        Data fields:  >               *Token :: character >                Pitch :: character"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Reshaping.html","id":"splittingseparating-data","dir":"Articles","previous_headings":"","what":"Splitting/Separating Data","title":"Shaping humdrum data","text":"Humdrum data often packs multiple pieces information compact, concise, readable tokens. classic example, course, **kern often includes rhythm, pitch, phrasing, beaming, pitch ornamentation information! tokens great reading/writing, analyzing, typically want separate information want.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Reshaping.html","id":"pitch-and-rhythm","dir":"Articles","previous_headings":"Splitting/Separating Data","what":"Pitch and Rhythm","title":"Shaping humdrum data","text":"’ve seen, **kern spines example file include rhythmic data (**recip) pitch data. cases, might want access pieces information, separately. can separate applying different functions Token field, saving output new fields. example, uses pitch function extract pitch information saves new field call Pitch uses recip function extract rhythm information saves new field call Rhythm. (course, choose different names new fields, instead Pitch Rhythm.) can use either new fields, , call within.humdrumR, make active fields see print:","code":"within(example,         Pitch <- pitch(Token),        Rhythm <- recip(Token)) -> example   example >    ######### vvv Reshaping_example.hum vvv ########## >       1:    **kern  **silbe   **kern  **silbe  **harm >       2:    *ICvox        *   *ICvox        *       * >       3:    *Ialto        *  *Isoprn        *       * >       4:     *M4/4        *    *M4/4        *       * >       5:       *C:        *      *C:        *     *C: >       6:    C4, 4.        .   E4, 4.        .       . >       7:     D4, 8        .    F4, 8        .       . >       8:     E4, 4        .    G4, 4        .       . >       9:     F4, 4        .    A4, 4        .       . >      10:         =        =        =        =       = >      11:     G4, 2        .    D5, 4        .    , 64 >      12:         .        .    C5, 4        .       . >      13:     G4, 2        .    B4, 2        .       . >      14:        *-       *-       *-       *-      *- >    ######### ^^^ Reshaping_example.hum ^^^ ########## >        Data fields:  >                Token  :: character >               *Pitch  :: character >               *Rhythm :: character example$Pitch >    ######### vvv Reshaping_example.hum vvv ########## >       1:    **kern  **silbe   **kern  **silbe  **harm >       2:    *ICvox        *   *ICvox        *       * >       3:    *Ialto        *  *Isoprn        *       * >       4:     *M4/4        *    *M4/4        *       * >       5:       *C:        *      *C:        *     *C: >       6:        C4        .       E4        .       . >       7:        D4        .       F4        .       . >       8:        E4        .       G4        .       . >       9:        F4        .       A4        .       . >      10:         =        =        =        =       = >      11:        G4        .       D5        .       . >      12:         .        .       C5        .       . >      13:        G4        .       B4        .       . >      14:        *-       *-       *-       *-      *- >    ######### ^^^ Reshaping_example.hum ^^^ ########## >        Data fields:  >                Token  :: character >               *Pitch  :: character >                Rhythm :: character  example$Rhythm >    ######### vvv Reshaping_example.hum vvv ########## >       1:    **kern  **silbe   **kern  **silbe  **harm >       2:    *ICvox        *   *ICvox        *       * >       3:    *Ialto        *  *Isoprn        *       * >       4:     *M4/4        *    *M4/4        *       * >       5:       *C:        *      *C:        *     *C: >       6:        4.        .       4.        .       . >       7:         8        .        8        .       . >       8:         4        .        4        .       . >       9:         4        .        4        .       . >      10:         =        =        =        =       = >      11:         2        .        4        .      64 >      12:         .        .        4        .       . >      13:         2        .        2        .       . >      14:        *-       *-       *-       *-      *- >    ######### ^^^ Reshaping_example.hum ^^^ ########## >        Data fields:  >                Token  :: character >                Pitch  :: character >               *Rhythm :: character"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Reshaping.html","id":"pastingaligning","dir":"Articles","previous_headings":"","what":"Pasting/Aligning","title":"Shaping humdrum data","text":"next step might align/combine information currently separated. many humdrum\\(_{\\mathbb{R}}\\) datasets, multiple pieces information spread across multiple spines, cases, across spine paths stops. , given research question, need think multiple pieces information describing single data point, ’ll reshape data. example, example file **silbe (lyric) spines associate syllable exactly one note adjacent **kern spines.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Reshaping.html","id":"folding-data","dir":"Articles","previous_headings":"Pasting/Aligning","what":"Folding Data","title":"Shaping humdrum data","text":"powerful approach aligning separated data “folding” information new field using family “folding functions.” Folding means taking information one spine, path, stop, moving new data field “top ” another spine. means taking, example, data Spine 2 putting new field Spine 1.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Reshaping.html","id":"lyrics","dir":"Articles","previous_headings":"Pasting/Aligning > Folding Data > Folding Spines","what":"Lyrics","title":"Shaping humdrum data","text":"example, want align notes **kern spines syllables **silbe spine. can directly using foldHumdrum: use fold argument indicate spine fold, onto argument indicate spine move onto. Notice second spine disappeared, now new field called Result1, first (onto) spine, containing data old Spine 2. **silbe spines like : datasets, might different numbers **kern/**silbe spines different files within dataset. Though foldHumdrum can handle case, usually easier use special foldExclusive function, folds based exclusive interpretation. Just specify fold onto arguments character strings matching names exclusive interpretations file: Notice foldExclusive automatically folded **sible spines onto respective **kern spines, new field name.","code":"example <- readHumdrum(humdrumRroot, 'examples/Reshaping_example.hum') foldHumdrum(example, fold = 2, onto = 1) >    ##### vvv Reshaping_example.hum vvv ###### >       1:    **silbe   **kern  **silbe  **harm >       2:     *ICvox   *ICvox        *       * >       3:     *Ialto  *Isoprn        *       * >       4:      *M4/4    *M4/4        *       * >       5:        *C:      *C:        *     *C: >       6:       This        .        .       . >       7:         is        .        .       . >       8:         an        .        .       . >       9:        ex-        .        .       . >      10:          =        =        =       = >      11:       -am-        .        .       . >      12:          .        .        .       . >      13:       -ple        .        .       . >      14:         *-       *-       *-      *- >    ##### ^^^ Reshaping_example.hum ^^^ ###### >        Data fields:  >                Token   :: character >               *Result1 :: character foldHumdrum(example, fold = c(2, 4), onto = c(1, 3)) >    # vvv Reshaping_example.hum vvv # >       1:    **silbe  **silbe  **harm >       2:     *ICvox   *ICvox       * >       3:     *Ialto  *Isoprn       * >       4:      *M4/4    *M4/4       * >       5:        *C:      *C:     *C: >       6:       This     This       . >       7:         is       is       . >       8:         an       an       . >       9:        ex-      ex-       . >      10:          =        =       = >      11:       -am-     -am-       . >      12:          .        _       . >      13:       -ple     -ple       . >      14:         *-       *-      *- >    # ^^^ Reshaping_example.hum ^^^ # >        Data fields:  >                Token   :: character >               *Result1 :: character foldExclusive(example, 'silbe', 'kern') >    # vvv Reshaping_example.hum vvv # >       1:    **silbe  **silbe  **harm >       2:     *ICvox   *ICvox       * >       3:     *Ialto  *Isoprn       * >       4:      *M4/4    *M4/4       * >       5:        *C:      *C:     *C: >       6:       This     This       . >       7:         is       is       . >       8:         an       an       . >       9:        ex-      ex-       . >      10:          =        =       = >      11:       -am-     -am-       . >      12:          .        _       . >      13:       -ple     -ple       . >      14:         *-       *-      *- >    # ^^^ Reshaping_example.hum ^^^ # >        Data fields:  >                Token :: character >               *Silbe :: character"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Reshaping.html","id":"harmonic-interval","dir":"Articles","previous_headings":"Pasting/Aligning > Folding Data > Folding Spines","what":"Harmonic Interval","title":"Shaping humdrum data","text":"Let’s consider another common use case “folding” humdrum data. Lots humdrum files multiple spines **kern. cases, research question lead us think note, across spines, individual data points. However, research question concerns harmonic intervals (combinations pitches happening time) might think record multiple pitches single data observation. case, might want fold kern data one spine, top another! can using foldHumdrum well: now cross tabulate two spines data:","code":"example <- readHumdrum(humdrumRroot, 'examples/Reshaping_example.hum')  kernonly <- example[[ , '**kern']]  kernonly <- foldHumdrum(kernonly, 2, 1, newFieldNames = 'Spine2') with(kernonly, table(Token, Spine2)) >         Spine2 >    Token 2b 4.e 4a 4cc 4dd 4g 8f >      2g   1   0  0   0   1  0  0 >      4.c  0   1  0   0   0  0  0 >      4e   0   0  0   0   0  1  0 >      4f   0   0  1   0   0  0  0 >      8d   0   0  0   0   0  0  1"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Reshaping.html","id":"harmony-spreading-data","dir":"Articles","previous_headings":"Pasting/Aligning > Folding Data > Folding Spines","what":"Harmony (Spreading Data)","title":"Shaping humdrum data","text":"another common use case, might one spine data actually describes happening entire record data. example, example’s **harm spine. chords indicated spine associated pitches , either, **kern spines. Luckily, foldHumdrum foldExclusive given onto spines fold spines, fold spine duplicated fill one target spines: harm spine copied new field “top ” **kern spines!","code":"example <- readHumdrum(humdrumRroot, 'examples/Reshaping_example.hum')  foldExclusive(example, 'harm', 'kern')  >    ##### vvv Reshaping_example.hum vvv ###### >       1:    **harm  **silbe   **harm  **silbe >       2:    *ICvox        *   *ICvox        * >       3:    *Ialto        *  *Isoprn        * >       4:     *M4/4        *    *M4/4        * >       5:       *C:        *      *C:        * >       6:         I        .        I        . >       7:         .        .        .        . >       8:         .        .        .        . >       9:        IV        .       IV        . >      10:         =        =        =        = >      11:       I64        .      I64        . >      12:         .        .        .        . >      13:         V        .        V        . >      14:        *-       *-       *-       *- >    ##### ^^^ Reshaping_example.hum ^^^ ###### >        Data fields:  >                Token :: character >               *Harm  :: character"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Reshaping.html","id":"folding-stops-and-paths","dir":"Articles","previous_headings":"Pasting/Aligning > Folding Data","what":"Folding Stops and Paths","title":"Shaping humdrum data","text":"Though spines common structure humdrum data might need “fold,” can also fold structures. course, depends questions trying ask data! Consider example, multi-stop chords **kern spine: default, humdrum\\(_{\\mathbb{R}}\\) treats token (note) stop separate data observation, row humdrum table. studying harmony, might want align stops “top” , different fields. Try foldStops function! working spine paths, often less obvious interpret different paths terms data observations, want fold , can using foldPaths: Note foldPaths something little bit different: wherever “folding” path null (non-existent) copies data base path. means get two complete copies melody, identical spine path, different different paths. get one melody (Token field) going 4c 4d 4e 4d 2c 2B another melody (new Token_Path field) going 4c 4d 4e 4f 2g 2g. option can used folding functions well, setting argument fillFromField == TRUE.","code":"example_stops <- readHumdrum(humdrumRroot, 'examples/Reshaping_example2_stops.hum')  example_stops >     vvv Reshaping_example2_stops.hum vvv  >       1:     **kern  **harm >       2:      *M4/4       * >       3:        *C:     *C: >       4:         4c       I >       5:         4B      Vb >       6:    4B- d g      vb >       7:     4A d f     IVb >       8:          =       = >       9:     2G c e     I64 >      10:     2G B d       V >      11:         *-      *- >     ^^^ Reshaping_example2_stops.hum ^^^  >        Data fields:  >               *Token :: character foldStops(example_stops) >     vvv Reshaping_example2_stops.hum vvv  >       1:    **kern  **harm >       2:     *M4/4       * >       3:       *C:     *C: >       4:         .       . >       5:         .       . >       6:      d, g       . >       7:      d, f       . >       8:         =       = >       9:      c, e       . >      10:      B, d       . >      11:        *-      *- >     ^^^ Reshaping_example2_stops.hum ^^^  >        Data fields:  >                Token       :: character >               *Token_Stop2 :: character >               *Token_Stop3 :: character example_paths <- readHumdrum(humdrumRroot, 'examples/Reshaping_example3_paths.hum')  example_paths >     vvv Reshaping_example3_paths.hum vvv  >       1:    **kern      **harm >       2:     *M4/4           * >       3:       *C:         *C: >       4:        4c           I >       5:        4d           . >       6:        4e           . >       7:        *^           * >       8:        4d  4f      ii >       9:         =   =       = >      10:        2c  2g       I >      11:        2B  2g      Vb >      12:        *v  *v       * >      13:         =           = >      14:        *-          *- >     ^^^ Reshaping_example3_paths.hum ^^^  >        Data fields:  >               *Token :: character  foldPaths(example_paths) >     vvv Reshaping_example3_paths.hum vvv  >       1:    **kern  **harm >       2:     *M4/4       * >       3:       *C:     *C: >       4:        4c       I >       5:        4d       . >       6:        4e       . >       7:        *^       * >       8:        4f      ii >       9:         =       = >      10:        2g       I >      11:        2g      Vb >      12:        *v       * >      13:         =       = >      14:        *-      *- >     ^^^ Reshaping_example3_paths.hum ^^^  >        Data fields:  >                Token       :: character >               *Token_Path1 :: character"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Reshaping.html","id":"folding-grace-notes","dir":"Articles","previous_headings":"Pasting/Aligning > Folding Data","what":"Folding Grace Notes","title":"Shaping humdrum data","text":"functionality hasn’t implemented yet. Bug us !","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Reshaping.html","id":"other-folding","dir":"Articles","previous_headings":"Pasting/Aligning > Folding Data","what":"Other Folding","title":"Shaping humdrum data","text":"Using foldHumdrum, also possible fold data structures. obvious example, folding consecutive records bars top . ’m sure want ! , use argument foldHumdrum.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Reshaping.html","id":"collapsing-data","dir":"Articles","previous_headings":"Pasting/Aligning","what":"Collapsing Data","title":"Shaping humdrum data","text":"TBA","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RhythmAndMeter.html","id":"rhythminterval","dir":"Articles","previous_headings":"","what":"rhythmInterval","title":"Rhythm and meter in humdrumR","text":"CONSTRUCTION","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Summary.html","id":"summarizing-structure","dir":"Articles","previous_headings":"","what":"Summarizing Structure","title":"Getting to know your data","text":"basic information ’ll want humdrum dataset “big” —much data ? Printing humdrumR object command line always tell many files data: can also call length() get number. census() function, however, gives us much detail size data, telling us many records, tokens, characters : corpus contains, total, 4,742 1,301. (unique) column tells us many unique Tokens per file (overall, bottom). (per token) column indicates average number characters file, overall. Notice census() defaults counting records/tokens. want count data tokens, specify census(chorales, dataTypes = 'D').","code":"census(chorales) >     >    ###### Census of GLIMDd records in humdrumR corpus \"chorales\" (ten files): >    ###### Grouped by ten Filenames: >                       Records   Tokens (unique)   Characters (per token) >    chor001.krn [ 1]       134      488    (150)         1916      (3.93) >    chor002.krn [ 2]       124      451    (148)         1897      (4.21) >    chor003.krn [ 3]       110      386    (132)         1867      (4.84) >    chor004.krn [ 4]       103      367    (129)         1711      (4.66) >    chor005.krn [ 5]       172      643    (159)         2233      (3.47) >    chor006.krn [ 6]        77      263    (125)         1313      (4.99) >    chor007.krn [ 7]       179      671    (168)         2415       (3.6) >    chor008.krn [ 8]       171      639    (165)         2298       (3.6) >    chor009.krn [ 9]       131      479    (167)         1923      (4.01) >    chor010.krn [10]       100      355    (133)         1599       (4.5) >    ###### Totals: >                         1,301    4,742    (504)       19,172      (4.04)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Summary.html","id":"spines-and-interpretations","dir":"Articles","previous_headings":"Summarizing Structure","what":"Spines and Interpretations","title":"Getting to know your data","text":"work humdrum data, really need know many spines (spine paths) present data, interpretations present. spines() interpretations() functions give us just information! toy dataset 10 chorales, output spines() pretty boring: chorales four spines, spine paths. interpretations() output also boring, see 10 files four **kern exclusive interpretations; However, interpretations() also tells tandem interpretations recognizes—case, tempo, key, instrument, time signature information. chorales dataset structurally homogeneous, generally good thing—’s much easier analyze sort data! However, humdrum datasets heterogeneous, spines() interpretations() come handy. Let’s switch another one pre-packaged corpora, Beethoven/Mozart variations (see read/write): Now see something interesting. , files four spines, eleven files include spine paths (\"9 1 path\" \"2 2 paths\"). Let’s check output interpretations(): Ah, time see file **function **harm spine, well two **kern spines. fact, “Tallies” bottom tells us 20 files exclusive interpretations (order), humdrum\\(_{\\mathbb{R}}\\) labels {}: **function, **harm, **kern, **kern.","code":"spines(chorales) >     >    ###### Spine structure in in humdrumR corpus \"chorales\" (ten files): >                        Spines  + Paths  In  *^  *v >    ############################################### >      chor001.krn [ 1]       4        0             >      chor002.krn [ 2]       4        0             >      chor003.krn [ 3]       4        0             >      chor004.krn [ 4]       4        0             >      chor005.krn [ 5]       4        0             >      chor006.krn [ 6]       4        0             >      chor007.krn [ 7]       4        0             >      chor008.krn [ 8]       4        0             >      chor009.krn [ 9]       4        0             >      chor010.krn [10]       4        0             >    ############################################### >                        Spines  + Paths  In  *^  *v >     >                      Tallies: >                            10 files with 4 spines  interpretations(chorales) >     >    ###### Interpretation content in humdrumR corpus \"chorales\" (ten files): >                        {X}  **kern    BPM   Clef  Instrument    *** >                                        (Total.Unique.Spines) >      chor001.krn [ 1]  {A}       4  4.1.4  4.3.4       8.8.8    *** >      chor002.krn [ 2]  {A}       4  4.1.4  4.3.4       8.8.8    *** >      chor003.krn [ 3]  {A}       4  4.1.4  4.3.4       8.8.8    *** >      chor004.krn [ 4]  {A}       4  4.1.4  4.3.4       8.8.8    *** >      chor005.krn [ 5]  {A}       4  4.1.4  4.3.4       8.8.8    *** >      chor006.krn [ 6]  {A}       4  4.1.4  4.3.4       8.8.8    *** >      chor007.krn [ 7]  {A}       4  4.1.4  4.3.4       8.8.8    *** >      chor008.krn [ 8]  {A}       4  4.1.4  4.3.4       8.8.8    *** >      chor009.krn [ 9]  {A}       4  4.1.4  4.3.4       8.8.8    *** >      chor010.krn [10]  {A}       4  4.1.4  4.3.4       8.8.8    *** >                                        (Total.Unique.Spines) >    ###### Totals: >                        {X}  **kern    BPM   Clef  Instrument    *** >                 Hits:           10     10     10          10    *** >     >                 (***five columns not displayed due to screensize***) >        Tallies: >                  {A} =   **kern, **kern, **kern, **kern:  10 setwd(humdrumRroot)  readHumdrum('HumdrumData/.*Variations/.*.krn') -> variations  spines(variations) >     >    ###### Spine structure in in humdrumR corpus \"variations\" (twenty files): >                              Spines  + Paths  In  *^  *v >    ##################################################### >       B075_00_01_a.krn [ 1]       4        0             >       B075_00_02_a.krn [ 2]       4        0             >       B075_00_03_a.krn [ 3]       4        2   2   2   2 >       B075_00_04_a.krn [ 4]       4        1   1   1   1 >       B075_00_05_a.krn [ 5]       4        0             >       B075_00_06_a.krn [ 6]       4        0             >       B075_01_01_a.krn [ 7]       4        0             >       B075_01_02_a.krn [ 8]       4        0             >       B075_01_03_a.krn [ 9]       4        1   1   2   2 >       B075_01_04_a.krn [10]       4        0             >       B075_01_05_a.krn [11]       4        0             >       B075_01_06_a.krn [12]       4        0             >      M354_00_01a_a.krn [13]       4        1   1   1   1 >      M354_00_02b_a.krn [14]       4        1   1   1   1 >      M354_00_03c_a.krn [15]       4        2   2   3   3 >      M354_00_04d_a.krn [16]       4        1   1   1   1 >      M354_01_01a_a.krn [17]       4        1   1   1   1 >      M354_01_02b_a.krn [18]       4        1   1   1   1 >      M354_01_03c_a.krn [19]       4        1   1   1   1 >      M354_01_04d_a.krn [20]       4        1   1   2   2 >    ##################################################### >                              Spines  + Paths  In  *^  *v >     >                            Tallies: >                                  20 files with 4 spines (9 with 0 paths, 9 with 1 path, and 2 with 2 paths) >     >    ###### Spine structure in in humdrumR corpus \"variations\" (twenty files): interpretations(variations) >     >    ###### Interpretation content in humdrumR corpus \"variations\" (twenty files): >                              {X}  **function  **harm  **kern   Clef    *** >                                               (Total.Unique.Spines) >       B075_00_01_a.krn [ 1]  {A}           1       1       2  3.2.3    *** >       B075_00_02_a.krn [ 2]  {A}           1       1       2  2.2.2    *** >       B075_00_03_a.krn [ 3]  {A}           1       1       2  2.2.2    *** >       B075_00_04_a.krn [ 4]  {A}           1       1       2  2.2.2    *** >       B075_00_05_a.krn [ 5]  {A}           1       1       2  2.2.2    *** >       B075_00_06_a.krn [ 6]  {A}           1       1       2  2.2.2    *** >       B075_01_01_a.krn [ 7]  {A}           1       1       2  3.2.3    *** >       B075_01_02_a.krn [ 8]  {A}           1       1       2  2.2.2    *** >       B075_01_03_a.krn [ 9]  {A}           1       1       2  2.2.2    *** >       B075_01_04_a.krn [10]  {A}           1       1       2  2.2.2    *** >       B075_01_05_a.krn [11]  {A}           1       1       2  2.1.2    *** >       B075_01_06_a.krn [12]  {A}           1       1       2  4.2.4    *** >      M354_00_01a_a.krn [13]  {A}           1       1       2  2.2.2    *** >      M354_00_02b_a.krn [14]  {A}           1       1       2  2.2.2    *** >      M354_00_03c_a.krn [15]  {A}           1       1       2  2.2.2    *** >      M354_00_04d_a.krn [16]  {A}           1       1       2  2.2.2    *** >      M354_01_01a_a.krn [17]  {A}           1       1       2  2.2.2    *** >      M354_01_02b_a.krn [18]  {A}           1       1       2  2.2.2    *** >      M354_01_03c_a.krn [19]  {A}           1       1       2  5.2.5    *** >      M354_01_04d_a.krn [20]  {A}           1       1       2  3.2.3    *** >                                               (Total.Unique.Spines) >    ###### Totals: >                              {X}  **function  **harm  **kern   Clef    *** >                       Hits:               20      20      20     20    *** >     >                       (***three columns not displayed due to screensize***) >        Tallies: >                  {A} =   **function, **harm, **kern, **kern:  20 >     >    ###### Interpretation content in humdrumR corpus \"variations\" (twenty files):"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Summary.html","id":"summarizing-metadata","dir":"Articles","previous_headings":"","what":"Summarizing Metadata","title":"Getting to know your data","text":"Another question ask dataset kind meta data encoded data’s reference records. function reference() answers question us: see ten chorale files , example COM CDT reference records, two OTL@@EN record. sure codes mean? can also call reference() character-string reference code: see actual reference records , can index result call reference() column row. example, see ODT@@DE records: see reference records third file:","code":"reference(chorales) >     >    ###### Reference recordsin humdrumR corpus \"chorales\" (ten files): >    ###### By file: >                      COM  CDT  OTL@@DE  OTL@EN  SCT  PC#  AGN  hum2abc    *** >    chor001.krn [ 1]    1    1        1       1    1    1    1        1    *** >    chor002.krn [ 2]    1    1        1       0    1    1    1        1    *** >    chor003.krn [ 3]    1    1        1       1    1    1    1        1    *** >    chor004.krn [ 4]    1    1        1       0    1    1    1        1    *** >    chor005.krn [ 5]    1    1        1       0    1    1    1        1    *** >    chor006.krn [ 6]    1    1        1       0    1    1    1        1    *** >    chor007.krn [ 7]    1    1        1       0    1    1    1        1    *** >    chor008.krn [ 8]    1    1        1       0    1    1    1        1    *** >    chor009.krn [ 9]    1    1        1       0    1    1    1        1    *** >    chor010.krn [10]    1    1        1       0    1    1    1        1    *** >     >    ###### Totals: >                Any:   10   10       10       2   10   10   10       10    *** >                Sum:   10   10       10       2   10   10   10       10    *** >             Unique:    1    1       10       2   10   10    1        1    *** >     >     >                               (six columns not displayed due to screensize***) reference('COM') >     >    (Authorship Information) >     >       !!!COM  =  Composer's name >     >       Examples: >               x!!COM: Chopin, Fryderyk; Chopin, Frederick >               x!!COM1: Composer, A.  >               x!!COM2: Composer, B.  reference('CDT') >     >    (Authorship Information) >     >       !!!CDT  =  Composer's dates reference(chorales)[ , 'OTL@@DE'] >     >    ###### Reference recordsin humdrumR corpus \"chorales[, j]\" (ten files): >    ###### By file: >                     OTL@@DE >    chor001.krn [ 1]   Aus meines Herzens Grunde >    chor002.krn [ 2]   Ich dank dir, lieber Herre >    chor003.krn [ 3]   Ach Gott, vom Himmel sieh darein >    chor004.krn [ 4]   Es ist das Heil uns kommen her >    chor005.krn [ 5]   An Wasserfl&uuml;ssen Babylon >    chor006.krn [ 6]   Christus, der ist mein Leben >    chor007.krn [ 7]   Nun lob, mein Seel, den Herren >    chor008.krn [ 8]   Freuet euch, ihr Christen alle >    chor009.krn [ 9]   Ermuntre dich, mein schwacher Geist >    chor010.krn [10]   Aus tiefer Not schrei ich zu dir >     >    ###### Totals: >               Any:  10 >               Sum:  10 >            Unique:  10 reference(chorales)[3, ] >     >    ###### Reference recordsin humdrumR corpus \"chorales[i]\" (one file): >    chor003.krn [3] >            COM:   Bach, Johann Sebastian >            CDT:   1685/02/21/-1750/07/28/ >        OTL@@DE:   Ach Gott, vom Himmel sieh darein >         OTL@EN:   Oh God, look down from Heaven >            SCT:   BWV 153/1 >            PC#:   3; 7 (Budapest/Imre, 1982) with first part written with repeats. >            AGN:   chorale >        hum2abc: -Q '' >          title: @{PC#}. @{OTL@@DE} >            YOR: 371 vierstimmige Choralges&auml;nge von Johann Sebastian Bach, ; 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&auml;rtel, ; c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 Four-Part ; Chorales (New York: Associated Music Publishers, Inc., c.1940). >            SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >            EED: Craig Stuart Sapp >            EEV: 2009/05/22 >            OPR: Cantata BWV 153: Schau, lieber Gott, wie meine Feind"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Summary.html","id":"summarizing-data","dir":"Articles","previous_headings":"","what":"Summarizing Data","title":"Getting to know your data","text":"next thing , getting started humdrum\\(_{\\mathbb{R}}\\) data analysis, get sense data content . tokens data actually contain? R’s unique(), table(), sort() functions perfect . ’ll need use .humdrumR() function apply commands data’s Token field—fully explained working data article. Let’s get unique values, sorted: Unlike unique(), table() count unique value, can sort see common tokens: Now get sense content dataset—case, lot different (unique) tokens!","code":"with(chorales, unique(Token) |> sort()) >      [1] \"[2d\"     \"[2e\"     \"[4a\"     \"[4A\"     \"[4B\"     \"[4c\"     \"[4d\"     >      [8] \"[4e\"     \"[4E\"     \"[4f\"     \"[4f#\"    \"[4g\"     \"[4G\"     \"[8cJ\"    >     [15] \"[8CJ\"    \"[8gJ\"    \"16AL\"    \"16B-Jk\"  \"16b-XJJ\" \"16BBJJ\"  \"16BJJ\"   >     [22] \"16C#L\"   \"16c#LL\"  \"16ccL\"   \"16ccLL\"  \"16d#JJ\"  \"16ddJJ\"  \"16dJJ\"   >     [29] \"16EJJ\"   \"16eL\"    \"16F#L\"   \"1e;\"     \"2.a;\"    \"2.A;\"    \"2.AA;\"   >     [36] \"2.b\"     \"2.b;\"    \"2.B;\"    \"2.BB;\"   \"2.c;\"    \"2.C#\"    \"2.c#;\"   >     [43] \"2.d\"     \"2.d;\"    \"2.e\"     \"2.e;\"    \"2.ee\"    \"2.f;\"    \"2.f#;\"   >     [50] \"2.FF;\"   \"2.g;\"    \"2.GG;\"   \"2a\"      \"2A\"      \"2a-;\"    \"2A-;\"    >     [57] \"2a;\"     \"2A;\"     \"2AA-;\"   \"2AA;\"    \"2b\"      \"2B\"      \"2b-;\"    >     [64] \"2b;\"     \"2B;\"     \"2BB\"     \"2BB-;\"   \"2BB;\"    \"2c\"      \"2C\"      >     [71] \"2c;\"     \"2C;\"     \"2c#\"     \"2c#;\"    \"2cc\"     \"2cc#\"    \"2cc#;\"   >     [78] \"2d\"      \"2D\"      \"2d-;\"    \"2d;\"     \"2D;\"     \"2d#\"     \"2D#\"     >     [85] \"2d#;\"    \"2dd\"     \"2DnX\"    \"2e\"      \"2E\"      \"2e-;\"    \"2e;\"     >     [92] \"2E;\"     \"2E#\"     \"2EE;\"    \"2f;\"     \"2f#\"     \"2F#\"     \"2f#;\"    >     [99] \"2F#;\"    \"2FF;\"    \"2FF#;\"   \"2g\"      \"2G\"      \"2g;\"     \"2G;\"     >    [106] \"2g#\"     \"2G#\"     \"2g#;\"    \"2G#;\"    \"2G#X;\"   \"2GG;\"    \"4.a\"     >    [113] \"4.a-\"    \"4.b\"     \"4.B\"     \"4.b-\"    \"4.BB\"    \"4.c\"     \"4.cc#\"   >    [120] \"4.d\"     \"4.dd\"    \"4.e\"     \"4.e-\"    \"4.ee\"    \"4.f\"     \"4.f#\"    >    [127] \"4.g\"     \"4a\"      \"4A\"      \"4a-\"     \"4A-\"     \"4a-;\"    \"4A-;\"    >    [134] \"4a-X\"    \"4a;\"     \"4A;\"     \"4a#\"     \"4A#\"     \"4AA\"     \"4AA-\"    >    [141] \"4AA-;\"   \"4AA;\"    \"4AA#\"    \"4anX\"    \"4b\"      \"4B\"      \"4b-\"     >    [148] \"4B-\"     \"4B-X\"    \"4b;\"     \"4B;\"     \"4B]\"     \"4BB\"     \"4BB-\"    >    [155] \"4BB;\"    \"4c\"      \"4C\"      \"4c;\"     \"4C;\"     \"4c]\"     \"4c#\"     >    [162] \"4C#\"     \"4c#;\"    \"4C#;\"    \"4cc\"     \"4cc;\"    \"4cc#\"    \"4ccnX\"   >    [169] \"4CnX\"    \"4d\"      \"4D\"      \"4d-\"     \"4D-\"     \"4d;\"     \"4D;\"     >    [176] \"4d]\"     \"4d#\"     \"4D#\"     \"4d#;\"    \"4dd\"     \"4DD\"     \"4dd-\"    >    [183] \"4dd;\"    \"4dd#\"    \"4dnX\"    \"4DnX\"    \"4e\"      \"4E\"      \"4e-\"     >    [190] \"4E-\"     \"4e-;\"    \"4e;\"     \"4E;\"     \"4e]\"     \"4E]\"     \"4e#\"     >    [197] \"4E#\"     \"4e#;\"    \"4E#X\"    \"4ee\"     \"4EE\"     \"4ee-\"    \"4ee-X\"   >    [204] \"4ee;\"    \"4EE;\"    \"4enX\"    \"4EnX\"    \"4f\"      \"4F\"      \"4f;\"     >    [211] \"4F;\"     \"4f#\"     \"4F#\"     \"4f#;\"    \"4F#;\"    \"4F#X\"    \"4F#X;\"   >    [218] \"4ff\"     \"4FF\"     \"4ff;\"    \"4FF;\"    \"4ff#\"    \"4FF#\"    \"4g\"      >    [225] \"4G\"      \"4g-\"     \"4g;\"     \"4G;\"     \"4g]\"     \"4G]\"     \"4g#\"     >    [232] \"4G#\"     \"4g#;\"    \"4G#;\"    \"4G#X\"    \"4G#X;\"   \"4gg\"     \"4GG\"     >    [239] \"4GG;\"    \"4GG#\"    \"4gnX\"    \"4GnX\"    \"4r\"      \"4ry\"     \"8.cL\"    >    [246] \"8a\"      \"8A\"      \"8a-\"     \"8A-\"     \"8a-J\"    \"8A-J\"    \"8a-L\"    >    [253] \"8A-L\"    \"8a-XJ\"   \"8A#\"     \"8a#J\"    \"8A#J\"    \"8AA\"     \"8AA-\"    >    [260] \"8AAJ\"    \"8AAL\"    \"8aJ\"     \"8AJ\"     \"8aL\"     \"8AL\"     \"8aL]\"    >    [267] \"8AL]\"    \"8AnXL\"   \"8b\"      \"8b-\"     \"8B-\"     \"8b-J\"    \"8B-J\"    >    [274] \"8b-L\"    \"8BB\"     \"8BB-J\"   \"8BB-L\"   \"8BBJ\"    \"8BBL\"    \"8bJ\"     >    [281] \"8BJ\"     \"8bL\"     \"8BL\"     \"8c\"      \"8C\"      \"8C#\"     \"8c#J\"    >    [288] \"8C#J\"    \"8c#L\"    \"8C#L\"    \"8c#XJ\"   \"8cc\"     \"8cc#J\"   \"8cc#L\"   >    [295] \"8ccJ\"    \"8ccL\"    \"8cJ\"     \"8CJ\"     \"8cL\"     \"8CL\"     \"8cL]\"    >    [302] \"8CL]\"    \"8cnXJ\"   \"8d\"      \"8D\"      \"8d-\"     \"8D-\"     \"8D-J\"    >    [309] \"8D-L\"    \"8d-XJ\"   \"8d#J\"    \"8D#J\"    \"8d#L\"    \"8D#L\"    \"8dd\"     >    [316] \"8dd#J\"   \"8ddJ\"    \"8ddL\"    \"8dJ\"     \"8DJ\"     \"8dL\"     \"8DL\"     >    [323] \"8dL]\"    \"8dnJ\"    \"8e\"      \"8E\"      \"8E-\"     \"8e-J\"    \"8E-J\"    >    [330] \"8e-L\"    \"8E-L\"    \"8EEJ\"    \"8eeL\"    \"8EEL\"    \"8eJ\"     \"8EJ\"     >    [337] \"8eL\"     \"8EL\"     \"8eL]\"    \"8EL]\"    \"8f\"      \"8F\"      \"8f#\"     >    [344] \"8F#\"     \"8f#J\"    \"8F#J\"    \"8f#L\"    \"8F#L\"    \"8f#L]\"   \"8F#XJ\"   >    [351] \"8f#XL\"   \"8FF#J\"   \"8FFL\"    \"8fJ\"     \"8FJ\"     \"8fL\"     \"8FL\"     >    [358] \"8fL]\"    \"8FnXL\"   \"8g\"      \"8G\"      \"8g#\"     \"8G#\"     \"8g#J\"    >    [365] \"8G#J\"    \"8g#L\"    \"8G#L\"    \"8g#XJ\"   \"8GG\"     \"8GGJ\"    \"8GGL\"    >    [372] \"8gJ\"     \"8GJ\"     \"8gL\"     \"8GL\"     \"8gL]\"    \"8GL]\"    \"8gnXL\"   >    [379] \"8GnXL\" with(chorales, table(Token) |> sort()) >    Token >        [2d     [2e     [4a     [4B     [4c     [4d     [4f    [4f#    [8cJ    [8CJ  >          1       1       1       1       1       1       1       1       1       1  >       [8gJ    16AL  16B-Jk 16b-XJJ  16BBJJ   16BJJ   16C#L  16c#LL   16ccL  16ccLL  >          1       1       1       1       1       1       1       1       1       1  >     16d#JJ  16ddJJ   16EJJ   16F#L     1e;    2.a;    2.A;   2.AA;     2.b    2.b;  >          1       1       1       1       1       1       1       1       1       1  >       2.B;   2.BB;    2.c;    2.C#   2.c#;     2.d     2.e    2.e;    2.ee    2.f;  >          1       1       1       1       1       1       1       1       1       1  >      2.f#;   2.FF;    2.g;   2.GG;    2a-;   2AA-;    2b-;   2BB-;    2BB;      2c  >          1       1       1       1       1       1       1       1       1       1  >         2C     2C;   2cc#;    2d-;     2d#     2D#    2d#;    2DnX    2e-;     2E#  >          1       1       1       1       1       1       1       1       1       1  >       2EE;    2F#;   2FF#;      2G     2G;     2G#    2g#;   2G#X;    4.a-     4.c  >          1       1       1       1       1       1       1       1       1       1  >      4.cc#     4.d    4.dd     4.e    4.e-    4.ee    4.f#    4a-X   4AA-;    4AA#  >          1       1       1       1       1       1       1       1       1       1  >       4anX    4B-X     4B]     4c]    4C#;   4ccnX    4CnX     4d]     4DD    4DnX  >          1       1       1       1       1       1       1       1       1       1  >        4e]     4E]    4e#;    4E#X   4ee-X    4ee;    4enX    4EnX    4F#X   4F#X;  >          1       1       1       1       1       1       1       1       1       1  >       4ff;    4FF;    4ff#     4g-     4G]    4G#X   4G#X;     4gg    4gnX    4GnX  >          1       1       1       1       1       1       1       1       1       1  >       8.cL     8A-    8A-J    8A-L   8a-XJ    8a#J    8A#J    8AA-    8aL]   8AnXL  >          1       1       1       1       1       1       1       1       1       1  >        8b-     8B-    8b-J      8c   8c#XJ    8cL]    8CL]   8cnXJ     8d-   8d-XJ  >          1       1       1       1       1       1       1       1       1       1  >       8D#J    8d#L     8dd   8dd#J    8dL]    8dnJ    8e-J    8E-J    8e-L    8EEJ  >          1       1       1       1       1       1       1       1       1       1  >       8EEL    8EL]   8f#L]   8F#XJ   8f#XL    8fL]   8FnXL   8g#XJ    8GL]   8GnXL  >          1       1       1       1       1       1       1       1       1       1  >        [4A     [4e     [4E     [4G   16dJJ    16eL    2.d;    2A-;     2A;      2B  >          2       2       2       2       2       2       2       2       2       2  >        2BB    2GG;     4.a     4.b    4.b-    4.BB    4a-;    4A-;     4A#    4AA-  >          2       2       2       2       2       2       2       2       2       2  >        4C;    4c#;    4dd;    4dnX    4e-;     4E#     4EE    4EE;     4f;     4F;  >          2       2       2       2       2       2       2       2       2       2  >       4F#;    4FF#     4g]    4GG#      4r     4ry     8a-    8a-J     8A#    8AL]  >          2       2       2       2       2       2       2       2       2       2  >         8b    8b-L     8C#    8C#J     8cc   8cc#J   8cc#L    8D-L    8D#L    8ddJ  >          2       2       2       2       2       2       2       2       2       2  >         8E    8eeL    8eL]     8f#   8FF#J    8FFL     8GG    8GGJ    8GGL   8gnXL  >          2       2       2       2       2       2       2       2       2       2  >        2b;    2c#;     2cc    2cc#    2FF;     2g;     4.B     4.f     4A;    4BB;  >          3       3       3       3       3       3       3       3       3       3  >       4cc;    4d#;    4dd#     4e#    4ee-     4FF     4G;    4G#;     8AA     8BB  >          3       3       3       3       3       3       3       3       3       3  >      8BB-L    8c#J      8D      8f     8F#      8g    8G#L    8gL]     [4g    2AA;  >          3       3       3       3       3       3       3       3       4       4  >         2E     2f;     2F#     2g#    2G#;     4A-     4a#     4D-     4D;    4f#;  >          4       4       4       4       4       4       4       4       4       4  >       8a-L    8AAL    8BBL    8C#L    8D-J    8ddL    8E-L      8F     8fJ      8G  >          4       4       4       4       4       4       4       4       4       4  >        8g#     8G#     2c#      2D     2D;     2E;    2f#;     4.g    4AA;    4g#;  >          4       4       5       5       5       5       5       5       5       5  >       4GG;      8a      8A      8C    8c#L      8d    8d#J     8FJ     8fL    8g#L  >          5       5       5       5       5       5       5       5       5       5  >        2c;      2d     2d;     4E-     4ff    8B-J   8BB-J    8BBJ     8D-     8DL  >          6       6       6       6       6       6       6       6       6       6  >         8e     8E-     8FL      2g    4BB-    4dd-     4e-     4E;    8AAJ    8ccJ  >          6       6       6       7       7       7       7       7       7       7  >       8ccL     8EJ    8F#L    8g#J    8G#J     2B;     2dd     4a;     4c;     4d;  >          7       7       7       7       7       8       8       8       8       8  >        4D#     4g;     8CJ     8GJ     2a;     2e;     4b;     4B;     4d-     4d#  >          8       8       8       8       9       9       9       9       9       9  >         2A      2b     2f#     4B-     8aL     8bJ      4F     8AL    8f#L      2e  >         10      10      10      10      10      11      12      12      12      13  >        4e;     8bL     8cL     8CL    8F#J     8gJ     8gL     4a-     4GG     8aJ  >         14      14      14      14      14      14      14      15      15      15  >        8BJ     8cJ     8DJ     8EL     4b-      2a     8AJ     8GL     8BL     4C#  >         15      15      15      15      16      17      17      17      18      19  >        8dJ     4AA     4ee     8eJ     4G#      4C     8dL     4BB    8f#J     4c#  >         19      20      20      20      21      23      24      25      26      27  >       4cc#     4dd      4D     4F#      4G     4g#     8eL      4E     4f#     4cc  >         28      29      30      30      33      34      35      43      47      48  >         4c      4f      4d      4B      4A      4g      4b      4a      4e  >         49      50      53      56      58      66      81      90     103"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Summary.html","id":"digging-into-details","dir":"Articles","previous_headings":"Summarizing Data","what":"Digging into Details","title":"Getting to know your data","text":"point ’re starting get better picture content dataset. don’t get hasty—’s good idea dig little get confident really know data. call interpretations() told us expect **kern data, representing musical “notes” (pitch rhythm). probably expected see things like 4. (dotted quarter note) f# (F sharp middle-C). X 4dnX? Js Ls ;s? can look **kern definition, point , probably didn’t know took look! might think know ’s data…get unpleasantly surprised. especially true less mature (newer) datasets, DEFINITELY CONTAIN ERRORS. see lot ; tokens output. look , ’ll learn “pause signs”, used represent fermatas. many tokens fermatas? Let’s use %~% operator, allows us search matches (regular expression) pattern vector. case, want search \";\" Token. %~% returns logical value (TRUE FALSE), can sum() get count TRUEs: 256 ; tokens data. use within instead (get rid sum()), can see fermatas appear: Ah, see fermatas tend happen time across four spines. Good know!","code":"with(chorales, Token %~% ';' |> sum()) >    [1] 256 within(chorales, Token %~% ';') >    ############################# vvv chor001.krn vvv ############################# >         1:  !!!COM: Bach, Johann Sebastian >         2:  !!!CDT: 1685/02/21/-1750/07/28/ >         3:  !!!OTL@@DE: Aus meines Herzens Grunde >         4:  !!!OTL@EN:      From the Depths of My Heart >         5:  !!!SCT: BWV 269 >         6:  !!!PC#: 1 >         7:  !!!AGN: chorale >         8:          **kern        **kern        **kern        **kern >         9:          *ICvox        *ICvox        *ICvox        *ICvox >        10:          *Ibass       *Itenor        *Ialto       *Isoprn >        11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >        12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >        13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >        14:             *>A           *>A           *>A           *>A >        15:         *clefF4      *clefGv2       *clefG2       *clefG2 >        16:          *k[f#]        *k[f#]        *k[f#]        *k[f#] >        17:             *G:           *G:           *G:           *G: >        18:             *F:             *             *             * >        19:           *M3/4         *M3/4         *M3/4         *M3/4 >        20:          *MM100        *MM100        *MM100        *MM100 >        21:           FALSE         FALSE         FALSE         FALSE >        22:              =1            =1            =1            =1 >        23:           FALSE         FALSE         FALSE         FALSE >        24:           FALSE         FALSE         FALSE             . >        25:               .         FALSE             .             . >        26:           FALSE         FALSE         FALSE         FALSE >        27:              =2            =2            =2            =2 >        28:           FALSE         FALSE         FALSE         FALSE >        29:           FALSE         FALSE             .             . >        30:               .             .             .         FALSE >        31:           FALSE         FALSE         FALSE         FALSE >        32:              =3            =3            =3            =3 >        33:           FALSE         FALSE         FALSE         FALSE >        34:               .         FALSE         FALSE             . >        35:           FALSE         FALSE         FALSE             . >        36:           FALSE             .         FALSE         FALSE >        37:           FALSE         FALSE         FALSE         FALSE >        38:              =4            =4            =4            =4 >        39:            TRUE          TRUE          TRUE          TRUE >        40:           FALSE         FALSE         FALSE         FALSE >    41-134::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################# ^^^ chor001.krn ^^^ ############################# >     >           (8 more files...) >     >    ############################# vvv chor010.krn vvv ############################# >      1-60::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >        61:            TRUE          TRUE          TRUE          TRUE >        62:           FALSE         FALSE         FALSE         FALSE >        63:              =9            =9            =9            =9 >        64:           FALSE         FALSE         FALSE         FALSE >        65:           FALSE         FALSE         FALSE         FALSE >        66:           FALSE             .             .             . >        67:           FALSE         FALSE         FALSE         FALSE >        68:               .             .         FALSE             . >        69:           FALSE         FALSE         FALSE         FALSE >        70:             =10           =10           =10           =10 >        71:           FALSE         FALSE         FALSE         FALSE >        72:               .         FALSE             .             . >        73:           FALSE             .         FALSE         FALSE >        74:               .         FALSE             .             . >        75:            TRUE          TRUE          TRUE          TRUE >        76:             =11           =11           =11           =11 >        77:           FALSE         FALSE         FALSE         FALSE >        78:           FALSE         FALSE         FALSE         FALSE >        79:           FALSE         FALSE         FALSE         FALSE >        80:               .             .         FALSE             . >        81:             =12           =12           =12           =12 >        82:           FALSE         FALSE         FALSE         FALSE >        83:           FALSE         FALSE         FALSE         FALSE >        84:           FALSE         FALSE         FALSE         FALSE >        85:           FALSE         FALSE             .         FALSE >        86:             =13           =13           =13           =13 >        87:           FALSE         FALSE         FALSE          TRUE >        88:           FALSE         FALSE         FALSE             . >        89:            TRUE          TRUE          TRUE             . >        90:              ==            ==            ==            == >        91:              *-            *-            *-            *- >        92:  !!!hum2abc: -Q '' >        93:  !!!title: @{PC#}. @{OTL@@DE} >        94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** >        95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** >        96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** >        97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** >        98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >        99:  !!!EED:  Craig Stuart Sapp >       100:  !!!EEV:  2009/05/22 >    ############################# ^^^ chor010.krn ^^^ ############################# >                           (***four global comments truncated due to screen size***) >     >       humdrumR corpus of ten files. >        Data fields:  >                Token   :: character >               *Result1 :: logical"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/WorkingWithData.html","id":"with-and-within-you","dir":"Articles","previous_headings":"","what":"With and within you","title":"Working with humdrum data","text":"key functions working humdrum\\(_{\\mathbb{R}}\\) data objects within. functions allow get “inside” data. Basically, call /within, data fields within data become available , .","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/WorkingWithData.html","id":"with","dir":"Articles","previous_headings":"With and within you","what":"With","title":"Working with humdrum data","text":"Let’s start . call humdrum\\(_{\\mathbb{R}}\\) data object first argument. second argument can arbitrary R expression like, can use fields humdrum data. “expression” just valid bit R code; example, 2 + 2, c(1, 2, 3), (x - mean(x))^2, nchar(letters) |> mean() examples expressions. “arbitrary R expression” just fancy way saying R code want. execute R command, R “evaluates” expression(s) returns results. starting point, lets tabulate tokens dataset. first load humdrum data, original data tokens always put field called Token. use awesome built-R function, table, tabulate unique tokens Token field. However, can’t access Token field directly; just write expression table(Token) ’ll get error—R able “find”, say “Error: object 'Token' found.” Instead, use enter data, R can “see” Token (data fields): worked! However, ’s lot unique tokens data, kind mess. Let’s take page pitch vignette extract just pitch information using kern function: Much better! Notice whole expression kern(Token) |> table() executed within data. expressions can get complicated want. Let’s add call sort: Ah, now can clearly see top 10 common notes data e, , g, d, b, B, , f#, c, E. last step might make plot. ’ll use built tail function grab top (last) 10, built-barplot function.  Notice writing big complex expression like ’s helpful spread expression across multiple lines. |> (pipe) operator great place .","code":"with(chorales, table(Token)) >    Token >        [2d     [2e     [4a     [4A     [4B     [4c     [4d     [4e     [4E     [4f  >          1       1       1       2       1       1       1       2       2       1  >       [4f#     [4g     [4G    [8cJ    [8CJ    [8gJ    16AL  16B-Jk 16b-XJJ  16BBJJ  >          1       4       2       1       1       1       1       1       1       1  >      16BJJ   16C#L  16c#LL   16ccL  16ccLL  16d#JJ  16ddJJ   16dJJ   16EJJ    16eL  >          1       1       1       1       1       1       1       2       1       2  >      16F#L     1e;    2.a;    2.A;   2.AA;     2.b    2.b;    2.B;   2.BB;    2.c;  >          1       1       1       1       1       1       1       1       1       1  >       2.C#   2.c#;     2.d    2.d;     2.e    2.e;    2.ee    2.f;   2.f#;   2.FF;  >          1       1       1       2       1       1       1       1       1       1  >       2.g;   2.GG;      2a      2A    2a-;    2A-;     2a;     2A;   2AA-;    2AA;  >          1       1      17      10       1       2       9       2       1       4  >         2b      2B    2b-;     2b;     2B;     2BB   2BB-;    2BB;      2c      2C  >         10       2       1       3       8       2       1       1       1       1  >        2c;     2C;     2c#    2c#;     2cc    2cc#   2cc#;      2d      2D    2d-;  >          6       1       5       3       3       3       1       6       5       1  >        2d;     2D;     2d#     2D#    2d#;     2dd    2DnX      2e      2E    2e-;  >          6       5       1       1       1       8       1      13       4       1  >        2e;     2E;     2E#    2EE;     2f;     2f#     2F#    2f#;    2F#;    2FF;  >          9       5       1       1       4      10       4       5       1       3  >      2FF#;      2g      2G     2g;     2G;     2g#     2G#    2g#;    2G#;   2G#X;  >          1       7       1       3       1       4       1       1       4       1  >       2GG;     4.a    4.a-     4.b     4.B    4.b-    4.BB     4.c   4.cc#     4.d  >          2       2       1       2       3       2       2       1       1       1  >       4.dd     4.e    4.e-    4.ee     4.f    4.f#     4.g      4a      4A     4a-  >          1       1       1       1       3       1       5      90      58      15  >        4A-    4a-;    4A-;    4a-X     4a;     4A;     4a#     4A#     4AA    4AA-  >          4       2       2       1       8       3       4       2      20       2  >      4AA-;    4AA;    4AA#    4anX      4b      4B     4b-     4B-    4B-X     4b;  >          1       5       1       1      81      56      16      10       1       9  >        4B;     4B]     4BB    4BB-    4BB;      4c      4C     4c;     4C;     4c]  >          9       1      25       7       3      49      23       8       2       1  >        4c#     4C#    4c#;    4C#;     4cc    4cc;    4cc#   4ccnX    4CnX      4d  >         27      19       2       1      48       3      28       1       1      53  >         4D     4d-     4D-     4d;     4D;     4d]     4d#     4D#    4d#;     4dd  >         30       9       4       8       4       1       9       8       3      29  >        4DD    4dd-    4dd;    4dd#    4dnX    4DnX      4e      4E     4e-     4E-  >          1       7       2       3       2       1     103      43       7       6  >       4e-;     4e;     4E;     4e]     4E]     4e#     4E#    4e#;    4E#X     4ee  >          2      14       7       1       1       3       2       1       1      20  >        4EE    4ee-   4ee-X    4ee;    4EE;    4enX    4EnX      4f      4F     4f;  >          2       3       1       1       2       1       1      50      12       2  >        4F;     4f#     4F#    4f#;    4F#;    4F#X   4F#X;     4ff     4FF    4ff;  >          2      47      30       4       2       1       1       6       3       1  >       4FF;    4ff#    4FF#      4g      4G     4g-     4g;     4G;     4g]     4G]  >          1       1       2      66      33       1       8       3       2       1  >        4g#     4G#    4g#;    4G#;    4G#X   4G#X;     4gg     4GG    4GG;    4GG#  >         34      21       5       3       1       1       1      15       5       2  >       4gnX    4GnX      4r     4ry    8.cL      8a      8A     8a-     8A-    8a-J  >          1       1       2       2       1       5       5       2       1       2  >       8A-J    8a-L    8A-L   8a-XJ     8A#    8a#J    8A#J     8AA    8AA-    8AAJ  >          1       4       1       1       2       1       1       3       1       7  >       8AAL     8aJ     8AJ     8aL     8AL    8aL]    8AL]   8AnXL      8b     8b-  >          4      15      17      10      12       1       2       1       2       1  >        8B-    8b-J    8B-J    8b-L     8BB   8BB-J   8BB-L    8BBJ    8BBL     8bJ  >          1       1       6       2       3       6       3       6       4      11  >        8BJ     8bL     8BL      8c      8C     8C#    8c#J    8C#J    8c#L    8C#L  >         15      14      18       1       5       2       3       2       5       4  >      8c#XJ     8cc   8cc#J   8cc#L    8ccJ    8ccL     8cJ     8CJ     8cL     8CL  >          1       2       2       2       7       7      15       8      14      14  >       8cL]    8CL]   8cnXJ      8d      8D     8d-     8D-    8D-J    8D-L   8d-XJ  >          1       1       1       5       3       1       6       4       2       1  >       8d#J    8D#J    8d#L    8D#L     8dd   8dd#J    8ddJ    8ddL     8dJ     8DJ  >          5       1       1       2       1       1       2       4      19      15  >        8dL     8DL    8dL]    8dnJ      8e      8E     8E-    8e-J    8E-J    8e-L  >         24       6       1       1       6       2       6       1       1       1  >       8E-L    8EEJ    8eeL    8EEL     8eJ     8EJ     8eL     8EL    8eL]    8EL]  >          4       1       2       1      20       7      35      15       2       1  >         8f      8F     8f#     8F#    8f#J    8F#J    8f#L    8F#L   8f#L]   8F#XJ  >          3       4       2       3      26      14      12       7       1       1  >      8f#XL   8FF#J    8FFL     8fJ     8FJ     8fL     8FL    8fL]   8FnXL      8g  >          1       2       2       4       5       5       6       1       1       3  >         8G     8g#     8G#    8g#J    8G#J    8g#L    8G#L   8g#XJ     8GG    8GGJ  >          4       4       4       7       7       5       3       1       2       2  >       8GGL     8gJ     8GJ     8gL     8GL    8gL]    8GL]   8gnXL   8GnXL  >          2      14       8      14      17       3       1       2       1 with(chorales,       kern(Token) |> table()) >     >      a   A  a-  A-  a#  A#  AA AA- AA#   b   B  b-  B-  BB BB-   c   C  c#  C#  cc  >    160 114  29  11   5   5  44   5   1 134 115  24  19  48  17 102  57  48  30  73  >    cc#   d   D  d-  D-  d#  D#  dd  DD dd- dd#   e   E  e-  E-  e#  E#  ee  EE ee-  >     37 134  70  12  16  21  12  48   1   7   4 213  89  13  17   4   4  25   7   4  >      f   F  f#  F#  ff  FF ff# FF#   g   G  g-  g#  G#  gg  GG GG#  >     74  30 111  65   7  10   1   5 134  73   1  61  46   1  29   2 with(chorales,       kern(Token) |>  table() |>  sort()) >     >    AA#  DD ff#  g-  gg GG# dd#  e#  E# ee-  a#  A# AA- FF# dd-  EE  ff  FF  A-  d-  >      1   1   1   1   1   2   4   4   4   4   5   5   5   5   7   7   7  10  11  12  >     D#  e-  D- BB-  E-  B-  d#  b-  ee  a-  GG  C#   F cc#  AA  G#  BB  c#  dd   C  >     12  13  16  17  17  19  21  24  25  29  29  30  30  37  44  46  48  48  48  57  >     g#  F#   D  cc   G   f   E   c  f#   A   B   b   d   g   a   e  >     61  65  70  73  73  74  89 102 111 114 115 134 134 134 160 213 with(chorales,       kern(Token) |>         table() |>         sort() |>         tail(n = 10) |>         barplot()) kern(Token) |>         table() |>         sort() |>         tail(n = 10) |>         barplot()"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/WorkingWithData.html","id":"within","dir":"Articles","previous_headings":"With and within you","what":"Within","title":"Working with humdrum data","text":"many cases, want apply functions humdrum data, keep humdrum/humdrum\\(_{\\mathbb{R}}\\) structure place. within . just returns ever output commands , within (attempt ) put results commands “back inside” humdrum\\(_{\\mathbb{R}}\\) data object, new field. example, let’s say want translate kern data different pitch representation, like scientific pitch. can pitch command. use … just get notes! Let’s try within instead: Now get humdrum\\(_{\\mathbb{R}}\\) data back, Token data transformed **kern **pitch. Notice, now two “Data fields” listed bottom: Token (original data) Result1—default name new fields produced within, yes, get higher numbers keep making new fields. “Result1” informative, ’s actually good idea give new fields specific names. can assigning expressions within:","code":"with(chorales, pitch(Token)) >       [1] \"G2\"  \"G3\"  \"E3\"  \"F#3\" \"G3\"  \"D3\"  \"E3\"  \"C3\"  \"B2\"  \"A2\"  \"G2\"  \"D3\"  >      [13] \"G2\"  \"F#2\" \"G2\"  \"A2\"  \"B2\"  \"C3\"  \"D3\"  \"G2\"  \"G2\"  \"G2\"  \"A2\"  \"B2\"  >      [25] \"B2\"  \"A2\"  \"G2\"  \"D3\"  \"E3\"  \"E3\"  \"D3\"  \"C3\"  \"B2\"  \"C3\"  \"D3\"  \"G2\"  >      [37] \"A2\"  \"B2\"  \"G2\"  \"C3\"  \"G2\"  \"F#2\" \"G2\"  \"A2\"  \"B2\"  \"G2\"  \"D3\"  \"E3\"  >      [49] \"D3\"  \"C3\"  \"B2\"  \"A2\"  \"G2\"  \"D3\"  \"G3\"  \"G3\"  \"F#3\" \"E3\"  \"E3\"  \"D3\"  >      [61] \"C3\"  \"D3\"  \"G2\"  \"B3\"  \"B3\"  \"C4\"  \"B3\"  \"A3\"  \"G3\"  \"F#3\" \"G3\"  \"C4\"  >      [73] \"B3\"  \"C4\"  \"D4\"  \"D4\"  \"D4\"  \"A3\"  \"B3\"  \"C4\"  \"D4\"  \"E4\"  \"D4\"  \"C4\"  >      [85] \"B3\"  \"D4\"  \"D4\"  \"C4\"  \"B3\"  \"A3\"  \"B3\"  \"C4\"  \"D4\"  \"D4\"  \"D4\"  \"B3\"  >      [97] \"G3\"  \"B3\"  \"E4\"  \"D4\"  \"D4\"  \"D4\"  \"C4\"  \"D4\"  \"D4\"  \"C4\"  \"B3\"  \"C4\"  >     [109] \"D4\"  \"D4\"  \"C4\"  \"B3\"  \"C4\"  \"D4\"  \"D4\"  \"D4\"  \"D4\"  \"E4\"  \"E4\"  \"D4\"  >     [121] \"C4\"  \"B3\"  \"D4\"  \"D4\"  \"E4\"  \"D4\"  \"D4\"  \"B3\"  \"E4\"  \"D4\"  \"E4\"  \"F#4\" >     [133] \"G4\"  \"F#4\" \"G4\"  \"D4\"  \"E4\"  \"F#4\" \"G4\"  \"F#4\" \"D4\"  \"G4\"  \"G4\"  \"F#4\" >     [145] \"E4\"  \"F#4\" \"G4\"  \"G4\"  \"A4\"  \"G4\"  \"F#4\" \"G4\"  \"F#4\" \"E4\"  \"E4\"  \"F#4\" >     [157] \"G4\"  \"A4\"  \"A4\"  \"G4\"  \"F#4\" \"G4\"  \"F4\"  \"E4\"  \"G4\"  \"A4\"  \"G4\"  \"F#4\" >     [169] \"G4\"  \"F#4\" \"F#4\" \"E4\"  \"E4\"  \"F#4\" \"G4\"  \"F#4\" \"G4\"  \"A4\"  \"G4\"  \"F#4\" >     [181] \"G4\"  \"F#4\" \"D4\"  \"G4\"  \"G4\"  \"D5\"  \"B4\"  \"A4\"  \"G4\"  \"G4\"  \"A4\"  \"B4\"  >     [193] \"A4\"  \"B4\"  \"D5\"  \"C5\"  \"B4\"  \"A4\"  \"G4\"  \"B4\"  \"B4\"  \"C5\"  \"D5\"  \"D5\"  >     [205] \"C5\"  \"B4\"  \"A4\"  \"G4\"  \"B4\"  \"C5\"  \"D5\"  \"C5\"  \"B4\"  \"G4\"  \"B4\"  \"D5\"  >     [217] \"C5\"  \"B4\"  \"A4\"  \"G4\"  \"A4\"  \"B4\"  \"A4\"  \"B4\"  \"D5\"  \"C5\"  \"B4\"  \"A4\"  >     [229] \"G4\"  \"A3\"  \"G#3\" \"F#3\" \"C#3\" \"D3\"  \"D#3\" \"E3\"  \"B2\"  \"E2\"  \"E3\"  \"A3\"  >     [241] \"B3\"  \"C#4\" \"B3\"  \"A3\"  \"B3\"  \"B2\"  \"E3\"  \"C#3\" \"F#3\" \"G#3\" \"A3\"  \"E3\"  >     [253] \"C#3\" \"A2\"  \"D3\"  \"C#3\" \"D3\"  \"E3\"  \"C#3\" \"B2\"  \"C#3\" \"D3\"  \"G3\"  \"F#3\" >     [265] \"B2\"  \"C#3\" \"F#3\" \"E3\"  \"D3\"  \"C#3\" \"B2\"  \"A2\"  \"B2\"  \"C#3\" \"D3\"  \"E3\"  >     [277] \"B2\"  \"F#3\" \"G#3\" \"A3\"  \"G#3\" \"E3\"  \"A3\"  \"A3\"  \"G#3\" \"F#3\" \"E3\"  \"D3\"  >     [289] \"E3\"  \"A2\"  \"C#4\" \"C#4\" \"C#4\" \"B3\"  \"A3\"  \"G#3\" \"F#3\" \"B3\"  \"A3\"  \"G#3\" >     [301] \"E4\"  \"E4\"  \"D#4\" \"C#4\" \"B3\"  \"A3\"  \"G#3\" \"G#3\" \"A3\"  \"B3\"  \"C#4\" \"D4\"  >     [313] \"E4\"  \"E4\"  \"D4\"  \"E4\"  \"E4\"  \"E4\"  \"F#4\" \"B3\"  \"A#3\" \"B3\"  \"C#4\" \"D4\"  >     [325] \"G#3\" \"A3\"  \"G#3\" \"F#3\" \"E3\"  \"E4\"  \"D4\"  \"C#4\" \"D4\"  \"E4\"  \"F#4\" \"G#4\" >     [337] \"F#4\" \"F#4\" \"E4\"  \"D4\"  \"C#4\" \"B3\"  \"C#4\" \"D4\"  \"E4\"  \"D4\"  \"C#4\" \"F#4\" >     [349] \"B3\"  \"E4\"  \"D4\"  \"C#4\" \"E4\"  \"F#4\" \"E4\"  \"F#4\" \"F#4\" \"E4\"  \"D#4\" \"B3\"  >     [361] \"G#4\" \"A4\"  \"G#4\" \"F#4\" \"E4\"  \"E4\"  \"D#4\" \"B3\"  \"C#5\" \"B4\"  \"A4\"  \"A4\"  >     [373] \"G#4\" \"A4\"  \"G4\"  \"F#4\" \"G#4\" \"A4\"  \"G#4\" \"A#4\" \"B4\"  \"A4\"  \"G4\"  \"F#4\" >     [385] \"E4\"  \"F#4\" \"F#4\" \"E4\"  \"D4\"  \"C#4\" \"D4\"  \"E4\"  \"F#4\" \"G#4\" \"A4\"  \"E4\"  >     [397] \"B4\"  \"A4\"  \"G#4\" \"F#4\" \"E4\"  \"F#4\" \"G#4\" \"A4\"  \"A4\"  \"G#4\" \"E4\"  \"A4\"  >     [409] \"A4\"  \"A4\"  \"A4\"  \"B4\"  \"G4\"  \"F#4\" \"E4\"  \"B4\"  \"C#5\" \"B4\"  \"A4\"  \"G#4\" >     [421] \"F#4\" \"G#4\" \"F#4\" \"E4\"  \"E5\"  \"D5\"  \"C#5\" \"B4\"  \"A4\"  \"A4\"  \"B4\"  \"C#5\" >     [433] \"B4\"  \"C#5\" \"D5\"  \"C#5\" \"B4\"  \"A#4\" \"B4\"  \"E4\"  \"A4\"  \"B4\"  \"C#5\" \"D5\"  >     [445] \"E5\"  \"D5\"  \"C#5\" \"B4\"  \"D5\"  \"C#5\" \"B4\"  \"E5\"  \"D5\"  \"C#5\" \"B4\"  \"A4\"  >     [457] \"B4\"  \"C#5\" \"B4\"  \"A4\"  \"E3\"  \"A3\"  \"B3\"  \"C4\"  \"B3\"  \"A3\"  \"G#3\" \"A3\"  >     [469] \"E3\"  \"B2\"  \"C3\"  \"D3\"  \"E3\"  \"F3\"  \"E3\"  \"D3\"  \"E3\"  \"A2\"  \"F#3\" \"G3\"  >     [481] \"F#3\" \"E3\"  \"B3\"  \"A3\"  \"G3\"  \"F#3\" \"E3\"  \"D3\"  \"C3\"  \"B2\"  \"E3\"  \"F3\"  >     [493] \"C3\"  \"D3\"  \"E3\"  \"A2\"  \"B2\"  \"C3\"  \"D3\"  \"E3\"  \"A2\"  \"A3\"  \"G#3\" \"A3\"  >     [505] \"G3\"  \"F3\"  \"E3\"  \"D3\"  \"C#3\" \"D3\"  \"D#3\" \"E3\"  \"E4\"  \"E4\"  \"D4\"  \"E4\"  >     [517] \"D4\"  \"C4\"  \"B3\"  \"C4\"  \"D4\"  \"E4\"  \"F4\"  \"E4\"  \"E4\"  \"D4\"  \"C4\"  \"D4\"  >     [529] \"G#3\" \"A3\"  \"G#3\" \"C4\"  \"A3\"  \"G3\"  \"A3\"  \"B3\"  \"B3\"  \"B3\"  \"A3\"  \"B3\"  >     [541] \"C4\"  \"F#3\" \"E4\"  \"D4\"  \"C4\"  \"D4\"  \"E4\"  \"E4\"  \"E4\"  \"D4\"  \"C4\"  \"B3\"  >     [553] \"C4\"  \"C4\"  \"B3\"  \"A3\"  \"A3\"  \"Bb3\" \"A3\"  \"E3\"  \"F#3\" \"G#3\" \"G#4\" \"A4\"  >     [565] \"G#4\" \"A4\"  \"G#4\" \"A4\"  \"B4\"  \"E4\"  \"F#4\" \"G#4\" \"G#4\" \"A4\"  \"G#4\" \"A4\"  >     [577] \"G4\"  \"F4\"  \"E4\"  \"E4\"  \"D4\"  \"D4\"  \"D#4\" \"E4\"  \"D#4\" \"E4\"  \"D#4\" \"E4\"  >     [589] \"G4\"  \"F#4\" \"E4\"  \"D#4\" \"B3\"  \"A3\"  \"A4\"  \"G#4\" \"A4\"  \"E4\"  \"E4\"  \"E4\"  >     [601] \"E4\"  \"E4\"  \"E4\"  \"F4\"  \"G4\"  \"F#4\" \"G#4\" \"A4\"  \"E4\"  \"B4\"  \"C5\"  \"B4\"  >     [613] \"A4\"  \"E5\"  \"E5\"  \"D5\"  \"C5\"  \"B4\"  \"D5\"  \"C5\"  \"B4\"  \"A4\"  \"B4\"  \"C5\"  >     [625] \"D5\"  \"C5\"  \"B4\"  \"A4\"  \"A4\"  \"B4\"  \"A4\"  \"G4\"  \"F#4\" \"E4\"  \"F#4\" \"G4\"  >     [637] \"A4\"  \"B4\"  \"G4\"  \"A4\"  \"B4\"  \"C5\"  \"B4\"  \"C5\"  \"B4\"  \"A4\"  \"G#4\" \"A4\"  >     [649] \"A4\"  \"E5\"  \"C5\"  \"D5\"  \"E5\"  \"D5\"  \"C5\"  \"B4\"  \"E3\"  \"D#3\" \"B2\"  \"E3\"  >     [661] \"F#3\" \"G#3\" \"A3\"  \"E3\"  \"A2\"  \"D#3\" \"E3\"  \"F#3\" \"G#3\" \"C#3\" \"F#3\" \"E3\"  >     [673] \"D#3\" \"C#3\" \"B2\"  \"F#3\" \"B2\"  \"E3\"  \"C#3\" \"D#3\" \"E3\"  \"F#3\" \"B3\"  \"G#3\" >     [685] \"E3\"  \"F#3\" \"B2\"  \"E3\"  \"G#3\" \"E3\"  \"A3\"  \"B3\"  \"C#4\" \"E#3\" \"F#3\" \"C#3\" >     [697] \"E3\"  \"B2\"  \"C#3\" \"D#3\" \"E3\"  \"B2\"  \"A#2\" \"B2\"  \"E2\"  \"E4\"  \"F#4\" \"E4\"  >     [709] \"D#4\" \"E4\"  \"A3\"  \"B3\"  \"C#4\" \"D4\"  \"E4\"  \"D4\"  \"C#4\" \"B3\"  \"B3\"  \"A3\"  >     [721] \"G#3\" \"F#3\" \"F#3\" \"B3\"  \"A#3\" \"F#3\" \"G#3\" \"C#4\" \"F#3\" \"F#4\" \"F#4\" \"B3\"  >     [733] \"A#3\" \"D#4\" \"E4\"  \"B3\"  \"E4\"  \"E4\"  \"C#4\" \"D4\"  \"C#4\" \"C#4\" \"B3\"  \"B3\"  >     [745] \"E4\"  \"E4\"  \"D#4\" \"B3\"  \"F#3\" \"G#3\" \"G#4\" \"F#4\" \"G#4\" \"A4\"  \"G#4\" \"F#4\" >     [757] \"E4\"  \"A4\"  \"G#4\" \"E4\"  \"F#4\" \"E4\"  \"E4\"  \"D#4\" \"E4\"  \"C#4\" \"F#4\" \"E4\"  >     [769] \"D#4\" \"E4\"  \"D#4\" \"E4\"  \"F#4\" \"G#4\" \"A#4\" \"B4\"  \"A#4\" \"B4\"  \"B4\"  \"F#4\" >     [781] \"F#4\" \"G#4\" \"E4\"  \"F#4\" \"G#4\" \"A4\"  \"E4\"  \"F#4\" \"G#4\" \"F#4\" \"E#4\" \"E4\"  >     [793] \"D#4\" \"C#4\" \"B3\"  \"B3\"  \"C#4\" \"B3\"  \"B3\"  \"B4\"  \"B4\"  \"B4\"  \"B4\"  \"D5\"  >     [805] \"C#5\" \"B4\"  \"A4\"  \"B4\"  \"G#4\" \"E4\"  \"F#4\" \"G#4\" \"A#4\" \"B4\"  \"C#5\" \"B4\"  >     [817] \"B4\"  \"E5\"  \"D#5\" \"C#5\" \"D#5\" \"E5\"  \"D#5\" \"C#5\" \"B4\"  \"B4\"  \"E5\"  \"B4\"  >     [829] \"C#5\" \"G#4\" \"A4\"  \"B4\"  \"A4\"  \"G#4\" \"G#4\" \"F#4\" \"A4\"  \"G#4\" \"F#4\" \"C#4\" >     [841] \"D#4\" \"E4\"  \"G3\"  \"C3\"  \"D3\"  \"E3\"  \"F#3\" \"G3\"  \"A3\"  \"D3\"  \"G3\"  \"F#3\" >     [853] \"G3\"  \"F#3\" \"E3\"  \"B2\"  \"C3\"  \"D3\"  \"G2\"  \"G3\"  \"F#3\" \"E3\"  \"D3\"  \"E3\"  >     [865] \"F#3\" \"G3\"  \"D3\"  \"G2\"  \"C3\"  \"G3\"  \"F3\"  \"E3\"  \"D3\"  \"C3\"  \"B2\"  \"C3\"  >     [877] \"D3\"  \"E3\"  \"A2\"  \"D3\"  \"G3\"  \"A3\"  \"B3\"  \"C4\"  \"F#3\" \"G#3\" \"A3\"  \"A2\"  >     [889] \"E3\"  \"G#2\" \"A2\"  \"B2\"  \"C3\"  \"A2\"  \"F3\"  \"E3\"  \"D3\"  \"E3\"  \"E2\"  \"A2\"  >     [901] \"A2\"  \"B2\"  \"C#3\" \"D3\"  \"C#3\" \"D3\"  \"A2\"  \"D3\"  \"B2\"  \"E3\"  \"D3\"  \"G3\"  >     [913] \"F#3\" \"E3\"  \"B2\"  \"A2\"  \"G2\"  \"C3\"  \"B2\"  \"A2\"  \"D3\"  \"C3\"  \"D3\"  \"G2\"  >     [925] \"B3\"  \"C4\"  \"B3\"  \"A3\"  \"E4\"  \"A3\"  \"B3\"  \"C4\"  \"E4\"  \"D4\"  \"D4\"  \"D4\"  >     [937] \"D4\"  \"G3\"  \"A3\"  \"B3\"  \"G3\"  \"E4\"  \"A3\"  \"B3\"  \"C4\"  \"B3\"  \"B3\"  \"A3\"  >     [949] \"D4\"  \"G3\"  \"A3\"  \"A3\"  \"G3\"  \"G3\"  \"F#3\" \"G3\"  \"G3\"  \"G3\"  \"G3\"  \"G3\"  >     [961] \"G3\"  \"G3\"  \"A3\"  \"B3\"  \"A3\"  \"A3\"  \"G3\"  \"G3\"  \"D4\"  \"C4\"  \"B3\"  \"A3\"  >     [973] \"E4\"  \"E4\"  \"E4\"  \"E4\"  \"D4\"  \"C4\"  \"B3\"  \"A3\"  \"A3\"  \"G#3\" \"A3\"  \"B3\"  >     [985] \"G#3\" \"A3\"  \"G#3\" \"A3\"  \"E3\"  \"F#3\" \"G3\"  \"D4\"  \"C4\"  \"Bb3\" \"A3\"  \"A3\"  >     [997] \"G3\"  \"F#3\" \"F#3\" \"G3\"  \"D4\"  \"D4\"  \"E4\"  \"D4\"  \"E4\"  \"D4\"  \"C4\"  \"D4\"  >    [1009] \"E4\"  \"D4\"  \"C4\"  \"B3\"  \"G4\"  \"G4\"  \"F#4\" \"G4\"  \"F#4\" \"E4\"  \"G4\"  \"G4\"  >    [1021] \"F#4\" \"G4\"  \"A4\"  \"G4\"  \"G4\"  \"G4\"  \"G4\"  \"G4\"  \"F#4\" \"D4\"  \"D4\"  \"D4\"  >    [1033] \"E4\"  \"F#4\" \"E4\"  \"E4\"  \"D4\"  \"D4\"  \"C4\"  \"B3\"  \"E4\"  \"D4\"  \"E4\"  \"F4\"  >    [1045] \"E4\"  \"F#4\" \"G4\"  \"F#4\" \"G4\"  \"A4\"  \"F#4\" \"D4\"  \"G4\"  \"G4\"  \"A4\"  \"B4\"  >    [1057] \"B4\"  \"G#4\" \"A4\"  \"G#4\" \"B4\"  \"A4\"  \"E4\"  \"C4\"  \"D4\"  \"E4\"  \"F4\"  \"E4\"  >    [1069] \"D4\"  \"C4\"  \"A4\"  \"D4\"  \"E4\"  \"F4\"  \"E4\"  \"D4\"  \"E4\"  \"E4\"  \"D4\"  \"D4\"  >    [1081] \"C#4\" \"D4\"  \"D4\"  \"C4\"  \"B3\"  \"A3\"  \"G3\"  \"F#3\" \"G3\"  \"G4\"  \"F#4\" \"G4\"  >    [1093] \"G4\"  \"G4\"  \"G4\"  \"F#4\" \"D4\"  \"D5\"  \"E5\"  \"D5\"  \"C5\"  \"B4\"  \"C5\"  \"D5\"  >    [1105] \"C5\"  \"B4\"  \"C5\"  \"B4\"  \"A4\"  \"B4\"  \"C5\"  \"D5\"  \"C5\"  \"B4\"  \"A4\"  \"G4\"  >    [1117] \"A4\"  \"G4\"  \"G4\"  \"A4\"  \"B4\"  \"C5\"  \"B4\"  \"A4\"  \"B4\"  \"A4\"  \"G4\"  \"G4\"  >    [1129] \"A4\"  \"B4\"  \"C5\"  \"D5\"  \"E5\"  \"B4\"  \"C#5\" \"D5\"  \"B4\"  \"C5\"  \"D5\"  \"E5\"  >    [1141] \"D5\"  \"C5\"  \"B4\"  \"C5\"  \"B4\"  \"E5\"  \"E5\"  \"E5\"  \"A4\"  \"D5\"  \"C5\"  \"B4\"  >    [1153] \"A4\"  \"C5\"  \"B4\"  \"A4\"  \"G4\"  \"A4\"  \"G4\"  \"F4\"  \"E4\"  \"D4\"  \"D4\"  \"G4\"  >    [1165] \"A4\"  \"B4\"  \"C5\"  \"D5\"  \"C5\"  \"B4\"  \"A4\"  \"B4\"  \"C5\"  \"A4\"  \"G4\"  \"F2\"  >    [1177] \"F3\"  \"E3\"  \"Eb3\" \"D3\"  \"C3\"  \"D3\"  \"E3\"  \"C3\"  \"F3\"  \"Bb2\" \"A2\"  \"G2\"  >    [1189] \"F2\"  \"A2\"  \"C3\"  \"F2\"  NA    \"A3\"  \"B2\"  \"C3\"  \"D3\"  \"F3\"  \"A3\"  \"G3\"  >    [1201] \"F3\"  \"D3\"  \"G3\"  \"C3\"  \"F2\"  \"G2\"  \"A2\"  \"Bb2\" \"C3\"  \"F2\"  \"A3\"  \"C4\"  >    [1213] \"C4\"  \"C4\"  \"D4\"  \"G3\"  \"C4\"  \"C4\"  \"Bb3\" \"C4\"  \"D4\"  \"Bb3\" \"C4\"  \"C4\"  >    [1225] \"C4\"  NA    \"F4\"  \"F4\"  \"E4\"  \"E4\"  \"D4\"  \"C4\"  \"C4\"  \"B3\"  \"E4\"  \"C4\"  >    [1237] \"Bb3\" \"C4\"  \"D4\"  \"C4\"  \"Bb3\" \"A3\"  \"C4\"  \"F4\"  \"G4\"  \"F4\"  \"F4\"  \"E4\"  >    [1249] \"F4\"  \"G4\"  \"E4\"  \"F4\"  \"F4\"  \"F4\"  \"E4\"  \"F4\"  \"E4\"  \"F4\"  NA    \"A4\"  >    [1261] \"A4\"  \"G4\"  \"G4\"  \"C5\"  \"Bb4\" \"A4\"  \"A4\"  \"A4\"  \"G4\"  \"G4\"  \"F4\"  \"F4\"  >    [1273] \"E4\"  \"F4\"  \"F4\"  \"E4\"  \"C4\"  \"F4\"  \"A4\"  \"G4\"  \"A4\"  \"Bb4\" \"C5\"  \"A4\"  >    [1285] \"D5\"  \"C5\"  \"Bb4\" \"A4\"  \"G4\"  \"A4\"  NA    \"C5\"  \"D5\"  \"E5\"  \"F5\"  \"E5\"  >    [1297] \"D5\"  \"C5\"  \"A4\"  \"Bb4\" \"A4\"  \"G4\"  \"G4\"  \"F4\"  \"A3\"  \"F#3\" \"C#3\" \"D3\"  >    [1309] \"D3\"  \"C#3\" \"D3\"  \"E3\"  \"A2\"  \"A3\"  \"E#3\" \"C#3\" \"F#3\" \"E3\"  \"D3\"  \"C#3\" >    [1321] \"D3\"  \"E3\"  \"A2\"  \"A2\"  \"D3\"  \"A3\"  \"G#3\" \"F#3\" \"E#3\" \"F#3\" \"B2\"  \"C#3\" >    [1333] \"F#2\" \"D#3\" \"E3\"  \"D3\"  \"C#3\" \"A2\"  \"B2\"  \"E3\"  \"C#3\" \"F#3\" \"E3\"  \"F#3\" >    [1345] \"G#3\" \"F#3\" \"E3\"  \"A3\"  \"A2\"  \"D3\"  \"C#3\" \"B2\"  \"B3\"  \"A3\"  \"G3\"  \"F#3\" >    [1357] \"E3\"  \"F#3\" \"G3\"  \"F#3\" \"B2\"  \"E3\"  \"A3\"  \"G#3\" \"F#3\" \"B3\"  \"A3\"  \"G3\"  >    [1369] \"C#3\" \"D3\"  \"A3\"  \"D#3\" \"E3\"  \"A2\"  \"B2\"  \"E3\"  \"C#3\" \"F#3\" \"E3\"  \"B2\"  >    [1381] \"C#3\" \"D3\"  \"D#3\" \"E3\"  \"E#3\" \"F#3\" \"G#3\" \"A3\"  \"E3\"  \"F#3\" \"D3\"  \"E3\"  >    [1393] \"E3\"  \"A2\"  \"C#4\" \"C#4\" \"C#4\" \"A3\"  \"G#3\" \"A3\"  \"G#3\" \"A3\"  \"C#4\" \"C#4\" >    [1405] \"B3\"  \"A3\"  \"E4\"  \"E4\"  \"F#4\" \"E4\"  \"C#4\" \"C#4\" \"D4\"  \"E4\"  \"E#4\" \"F#4\" >    [1417] \"G#4\" \"C#4\" \"D4\"  \"C#4\" \"A3\"  \"A3\"  \"G#3\" \"A3\"  \"B3\"  \"C#4\" \"B3\"  \"A3\"  >    [1429] \"G#3\" \"G#3\" \"A3\"  \"D4\"  \"B3\"  \"E4\"  \"E4\"  \"D4\"  \"E4\"  \"F#4\" \"B3\"  \"E4\"  >    [1441] \"D4\"  \"C#4\" \"B3\"  \"A#3\" \"B3\"  \"G#3\" \"A3\"  \"A3\"  \"B3\"  \"B3\"  \"B3\"  \"A3\"  >    [1453] \"G3\"  \"F#3\" \"A3\"  \"F#3\" \"B3\"  \"C#4\" \"B3\"  \"A3\"  \"G#3\" \"G#3\" \"A3\"  \"B3\"  >    [1465] \"B3\"  \"A3\"  \"G#3\" \"D4\"  \"A3\"  \"G#3\" \"C#4\" \"F#4\" \"E4\"  \"E4\"  \"E4\"  \"D4\"  >    [1477] \"C#4\" \"F#4\" \"E4\"  \"D4\"  \"C#4\" \"E4\"  \"F#4\" \"E4\"  \"D4\"  \"C#4\" \"B3\"  \"E4\"  >    [1489] \"F#4\" \"E4\"  \"E4\"  \"E4\"  \"F#4\" \"G#4\" \"E#4\" \"F#4\" \"G#4\" \"A4\"  \"G#4\" \"E4\"  >    [1501] \"E4\"  \"F#4\" \"G#4\" \"A4\"  \"B4\"  \"A4\"  \"G#4\" \"F#4\" \"E#4\" \"C#4\" \"F#4\" \"E4\"  >    [1513] \"E4\"  \"E4\"  \"D#4\" \"B3\"  \"C#4\" \"C#4\" \"F#4\" \"E4\"  \"F#4\" \"G#4\" \"A4\"  \"G4\"  >    [1525] \"F#4\" \"A4\"  \"B4\"  \"B4\"  \"A4\"  \"G4\"  \"A4\"  \"B4\"  \"E4\"  \"D#4\" \"E4\"  \"E4\"  >    [1537] \"F#4\" \"F#4\" \"G4\"  \"G4\"  \"F#4\" \"E4\"  \"D4\"  \"E4\"  \"F#4\" \"E4\"  \"E4\"  \"D#4\" >    [1549] \"B3\"  \"C#4\" \"C#4\" \"D#4\" \"E4\"  \"D#4\" \"E4\"  \"F#4\" \"G#4\" \"A4\"  \"E4\"  \"G#4\" >    [1561] \"A4\"  \"B4\"  \"A4\"  \"G#4\" \"A4\"  \"A4\"  \"G#4\" \"E4\"  \"A4\"  \"A4\"  \"G#4\" \"F#4\" >    [1573] \"E4\"  \"A4\"  \"B4\"  \"C#5\" \"C#5\" \"C#5\" \"B4\"  \"C#5\" \"C#5\" \"B4\"  \"A4\"  \"B4\"  >    [1585] \"A4\"  \"A4\"  \"A4\"  \"B4\"  \"C#5\" \"B4\"  \"C#5\" \"A4\"  \"G#4\" \"F#4\" \"B4\"  \"B4\"  >    [1597] \"A4\"  \"G#4\" \"A4\"  \"F#4\" \"E4\"  \"E4\"  \"A4\"  \"A4\"  \"B4\"  \"B4\"  \"C#5\" \"B4\"  >    [1609] \"C#5\" \"A4\"  \"A4\"  \"D5\"  \"D5\"  \"C#5\" \"B4\"  \"C#5\" \"B4\"  \"B4\"  \"C#5\" \"C#5\" >    [1621] \"D5\"  \"D5\"  \"E5\"  \"A4\"  \"C#5\" \"B4\"  \"A4\"  \"G#4\" \"A4\"  \"F#4\" \"E4\"  \"E4\"  >    [1633] \"A4\"  \"G#4\" \"F#4\" \"E4\"  \"B4\"  \"C#5\" \"B4\"  \"C#5\" \"D5\"  \"C#5\" \"B4\"  \"A4\"  >    [1645] \"G#4\" \"A4\"  \"B4\"  \"C#5\" \"B4\"  \"A4\"  \"F3\"  \"Eb3\" \"Db3\" \"C3\"  \"Bb2\" \"C3\"  >    [1657] \"F2\"  \"F2\"  \"F3\"  \"Eb3\" \"Db3\" \"C3\"  \"Bb2\" \"Ab2\" \"Db3\" \"Eb3\" \"Ab2\" \"Db3\" >    [1669] \"C3\"  \"Bb2\" \"C3\"  \"Db3\" \"Bb2\" \"C3\"  \"F2\"  \"F3\"  \"G3\"  \"A3\"  \"F3\"  \"Bb2\" >    [1681] \"C3\"  \"Db3\" \"Bb2\" \"Eb3\" \"F3\"  \"G3\"  \"Eb3\" \"Ab3\" \"Ab3\" \"Db3\" \"Eb3\" \"F3\"  >    [1693] \"Db3\" \"Bb2\" \"C3\"  \"Db3\" \"Bb2\" \"Eb3\" \"C3\"  \"F3\"  \"Bb2\" \"Bb3\" \"Ab3\" \"G3\"  >    [1705] \"F3\"  \"Bb2\" \"C3\"  \"F2\"  \"F2\"  \"G2\"  \"Ab2\" \"Bb2\" \"C3\"  \"D3\"  \"Eb3\" \"F3\"  >    [1717] \"G3\"  \"G2\"  \"C3\"  \"C3\"  \"F3\"  \"Eb3\" \"Db3\" \"C3\"  \"Bb2\" \"C3\"  \"Db3\" \"Eb3\" >    [1729] \"Eb3\" \"Ab2\" \"Ab2\" \"Db3\" \"Eb3\" \"Db3\" \"C3\"  \"Bb2\" \"C3\"  \"Db3\" \"Bb2\" \"Eb3\" >    [1741] \"F3\"  \"Eb3\" \"Db3\" \"C3\"  \"Db3\" \"Eb3\" \"C3\"  \"F3\"  \"E3\"  \"F3\"  \"G3\"  \"Ab3\" >    [1753] \"G3\"  \"Ab3\" \"Bb3\" \"C4\"  \"C3\"  \"F3\"  \"F3\"  \"Ab3\" \"A3\"  \"Bb3\" \"C4\"  \"Db4\" >    [1765] \"C4\"  \"Bb3\" \"Ab3\" \"Ab3\" \"C4\"  \"Bb3\" \"Eb4\" \"Eb4\" \"F4\"  \"Eb4\" \"Db4\" \"C4\"  >    [1777] \"Db4\" \"Db4\" \"G3\"  \"F3\"  \"Ab3\" \"Db4\" \"C4\"  \"Bb3\" \"Ab3\" \"A3\"  \"Bb3\" \"C4\"  >    [1789] \"A3\"  \"Bb3\" \"Bb3\" \"Bb3\" \"Eb4\" \"Eb4\" \"Eb4\" \"Db4\" \"Db4\" \"F4\"  \"F4\"  \"Gb4\" >    [1801] \"F4\"  \"Eb4\" \"Db4\" \"C4\"  \"C4\"  \"Bb3\" \"C4\"  \"Db4\" \"C4\"  \"Bb3\" \"Ab3\" \"C4\"  >    [1813] \"C4\"  \"C4\"  \"C4\"  \"C4\"  \"B3\"  \"C4\"  \"G3\"  \"A3\"  \"A3\"  \"Bb3\" \"Eb3\" \"Eb4\" >    [1825] \"Db4\" \"C4\"  \"C4\"  \"Db4\" \"Db4\" \"F4\"  \"F4\"  \"Eb4\" \"Eb4\" \"G4\"  \"G4\"  \"F4\"  >    [1837] \"F4\"  \"C4\"  \"F3\"  \"C4\"  \"C4\"  \"C4\"  \"C4\"  \"F4\"  \"F4\"  \"F4\"  \"E4\"  \"F4\"  >    [1849] \"F4\"  \"G4\"  \"E4\"  \"F4\"  \"C4\"  \"F4\"  \"G4\"  \"Ab4\" \"Ab4\" \"Ab4\" \"F4\"  \"G4\"  >    [1861] \"Eb4\" \"F4\"  \"G4\"  \"E4\"  \"F4\"  \"F4\"  \"E4\"  \"C4\"  \"F4\"  \"F4\"  \"F4\"  \"F4\"  >    [1873] \"G4\"  \"Ab4\" \"Bb4\" \"G4\"  \"Ab4\" \"Ab4\" \"F4\"  \"F4\"  \"Bb4\" \"Bb4\" \"Bb4\" \"A4\"  >    [1885] \"F4\"  \"E4\"  \"F4\"  \"F4\"  \"E4\"  \"F4\"  \"F4\"  \"E4\"  \"C4\"  \"Ab4\" \"Ab4\" \"G4\"  >    [1897] \"G4\"  \"G4\"  \"Ab4\" \"G4\"  \"F4\"  \"E4\"  \"E4\"  \"F4\"  \"F4\"  \"F4\"  \"G4\"  \"Ab4\" >    [1909] \"Ab4\" \"F4\"  \"G4\"  \"Eb4\" \"Eb4\" \"F4\"  \"F4\"  \"Bb4\" \"Bb4\" \"G4\"  \"G4\"  \"C5\"  >    [1921] \"C5\"  \"Ab4\" \"G4\"  \"Ab4\" \"Bb4\" \"C5\"  \"Bb4\" \"Ab4\" \"G4\"  \"G4\"  \"A4\"  \"A4\"  >    [1933] \"C5\"  \"C5\"  \"Bb4\" \"Ab4\" \"G4\"  \"F4\"  \"F4\"  \"F4\"  \"Ab4\" \"Bb4\" \"C5\"  \"C5\"  >    [1945] \"Bb4\" \"Ab4\" \"Ab4\" \"Ab4\" \"Bb4\" \"Bb4\" \"Ab4\" \"G4\"  \"F4\"  \"F4\"  \"C5\"  \"C5\"  >    [1957] \"Db5\" \"Db5\" \"Bb4\" \"Bb4\" \"C5\"  \"C5\"  \"Ab4\" \"Ab4\" \"Db5\" \"Db5\" \"C5\"  \"C5\"  >    [1969] \"Bb4\" \"G4\"  \"Ab4\" \"Bb4\" \"Ab4\" \"G4\"  \"G4\"  \"F4\"  \"F5\"  \"F5\"  \"Eb5\" \"Eb5\" >    [1981] \"D5\"  \"D5\"  \"C5\"  \"C5\"  \"C5\"  \"C5\"  \"Db5\" \"C5\"  \"Bb4\" \"Ab4\" \"Ab4\" \"Ab4\" >    [1993] \"Ab4\" \"Ab4\" \"Db5\" \"Db5\" \"Bb4\" \"Bb4\" \"Eb5\" \"Eb5\" \"C5\"  \"C5\"  \"F5\"  \"F5\"  >    [2005] \"E5\"  \"E5\"  \"F5\"  \"F5\"  \"G3\"  \"F#3\" \"E3\"  \"D3\"  \"G3\"  \"F#3\" \"G3\"  \"A3\"  >    [2017] \"A2\"  \"D3\"  \"D#3\" \"E3\"  \"F#3\" \"G3\"  \"C3\"  \"C3\"  \"B2\"  \"A2\"  \"G2\"  \"D3\"  >    [2029] \"D2\"  \"G2\"  \"D3\"  \"D4\"  \"C4\"  \"B3\"  \"A3\"  \"D#3\" \"E3\"  \"E2\"  \"A2\"  \"E3\"  >    [2041] \"F#3\" \"G3\"  \"G#3\" \"A3\"  \"A#3\" \"B3\"  \"B2\"  \"E3\"  \"D3\"  \"C3\"  \"B2\"  \"A2\"  >    [2053] \"G2\"  \"F#2\" \"E2\"  \"F#2\" \"G2\"  \"E2\"  \"C#3\" \"B2\"  \"C#3\" \"A2\"  \"D3\"  \"B2\"  >    [2065] \"C3\"  \"D3\"  \"E3\"  \"F#3\" \"G3\"  \"C3\"  \"D3\"  \"G2\"  \"B3\"  \"B3\"  \"C4\"  \"C4\"  >    [2077] \"D4\"  \"B3\"  \"A3\"  \"A3\"  \"A3\"  \"A3\"  \"A3\"  \"B3\"  \"A3\"  \"G3\"  \"A3\"  \"B3\"  >    [2089] \"C4\"  \"D4\"  \"D4\"  \"D4\"  \"C4\"  \"B3\"  \"D4\"  \"E4\"  \"F#4\" \"E4\"  \"D4\"  \"E4\"  >    [2101] \"F#4\" \"B3\"  \"E4\"  \"D4\"  \"C4\"  \"G3\"  \"A3\"  \"B3\"  \"C4\"  \"D4\"  \"E4\"  \"C4\"  >    [2113] \"C#4\" \"B3\"  \"B3\"  \"B3\"  \"D4\"  \"D4\"  \"G4\"  \"G3\"  \"A3\"  \"B3\"  \"E4\"  \"D4\"  >    [2125] \"E4\"  \"C#4\" \"D4\"  \"D4\"  \"D4\"  \"C4\"  \"C4\"  \"B3\"  \"B3\"  \"A3\"  \"G3\"  \"G3\"  >    [2137] \"F#3\" \"E3\"  \"F#3\" \"C4\"  \"B3\"  \"D4\"  \"E4\"  \"F#4\" \"D4\"  \"E4\"  \"F#4\" \"E4\"  >    [2149] \"F#4\" \"G4\"  \"F#4\" \"F#4\" \"E4\"  \"D4\"  \"E4\"  \"F#4\" \"G4\"  \"G4\"  \"F#4\" \"D4\"  >    [2161] \"F#4\" \"G4\"  \"A4\"  \"G#4\" \"A4\"  \"G#4\" \"A4\"  \"A4\"  \"G#4\" \"E4\"  \"E4\"  \"D#4\" >    [2173] \"E4\"  \"E4\"  \"E4\"  \"F#4\" \"G4\"  \"F#4\" \"F#4\" \"G4\"  \"A4\"  \"G4\"  \"A4\"  \"G4\"  >    [2185] \"A4\"  \"B4\"  \"B4\"  \"A4\"  \"A4\"  \"G4\"  \"G4\"  \"F#4\" \"G4\"  \"F#4\" \"E4\"  \"F#4\" >    [2197] \"G4\"  \"A4\"  \"D4\"  \"E4\"  \"D4\"  \"D4\"  \"G4\"  \"G4\"  \"A4\"  \"B4\"  \"C#5\" \"D5\"  >    [2209] \"D5\"  \"C#5\" \"D5\"  \"B4\"  \"C5\"  \"B4\"  \"A4\"  \"B4\"  \"A4\"  \"G4\"  \"A4\"  \"A4\"  >    [2221] \"B4\"  \"C5\"  \"C5\"  \"B4\"  \"A4\"  \"B4\"  \"A4\"  \"B4\"  \"B4\"  \"B4\"  \"C5\"  \"D5\"  >    [2233] \"E5\"  \"E5\"  \"D#5\" \"E5\"  \"F#5\" \"G5\"  \"B4\"  \"C5\"  \"B4\"  \"A4\"  \"A4\"  \"D5\"  >    [2245] \"E5\"  \"D5\"  \"C5\"  \"B4\"  \"C5\"  \"A4\"  \"G4\"  \"D3\"  \"C3\"  \"B2\"  \"A2\"  \"B2\"  >    [2257] \"C3\"  \"B2\"  \"A2\"  \"E3\"  \"E3\"  \"A3\"  \"G3\"  \"F3\"  \"E3\"  \"F3\"  \"C3\"  \"D3\"  >    [2269] \"E3\"  \"C4\"  \"B3\"  \"A3\"  \"G3\"  \"F3\"  \"E3\"  \"D3\"  \"E3\"  \"A2\"  \"A3\"  \"E3\"  >    [2281] \"D3\"  \"C3\"  \"B2\"  \"C3\"  \"D3\"  \"D3\"  \"G2\"  \"C3\"  \"A2\"  \"E3\"  \"F3\"  \"C3\"  >    [2293] \"Bb2\" \"A2\"  \"G#2\" \"A2\"  \"E2\"  \"G#3\" \"A3\"  \"D4\"  \"E4\"  \"D4\"  \"E4\"  \"D4\"  >    [2305] \"C4\"  \"B3\"  \"E4\"  \"E4\"  \"F4\"  \"G4\"  \"C4\"  \"C4\"  \"B3\"  \"A3\"  \"G#3\" \"A3\"  >    [2317] \"B3\"  \"C4\"  \"D4\"  \"D4\"  \"E4\"  \"F4\"  \"B3\"  \"C4\"  \"E4\"  \"E4\"  \"E4\"  \"D4\"  >    [2329] \"C4\"  \"F#3\" \"G3\"  \"F#3\" \"G3\"  \"G3\"  \"A3\"  \"G#3\" \"A3\"  \"G3\"  \"G3\"  \"A3\"  >    [2341] \"B3\"  \"A3\"  \"G#3\" \"E4\"  \"E4\"  \"G#4\" \"A4\"  \"G4\"  \"F#4\" \"E4\"  \"F#4\" \"G#4\" >    [2353] \"G#4\" \"A4\"  \"B4\"  \"C5\"  \"F4\"  \"E4\"  \"D4\"  \"C4\"  \"B3\"  \"E4\"  \"D4\"  \"E4\"  >    [2365] \"F#4\" \"G4\"  \"A4\"  \"B4\"  \"A4\"  \"G#4\" \"E4\"  \"A4\"  \"G4\"  \"G4\"  \"G4\"  \"F4\"  >    [2377] \"E4\"  \"D4\"  \"C4\"  \"B3\"  \"E4\"  \"E4\"  \"E4\"  \"D4\"  \"C4\"  \"C4\"  \"D4\"  \"D4\"  >    [2389] \"C4\"  \"B3\"  \"B4\"  \"E4\"  \"B4\"  \"C5\"  \"B4\"  \"A4\"  \"G4\"  \"A4\"  \"B4\"  \"B4\"  >    [2401] \"C5\"  \"D5\"  \"C5\"  \"B4\"  \"A4\"  \"G4\"  \"F4\"  \"E4\"  \"A4\"  \"G4\"  \"C5\"  \"B4\"  >    [2413] \"A4\"  \"D5\"  \"C5\"  \"B4\"  \"A4\"  \"C5\"  \"B4\"  \"C5\"  \"D5\"  \"G4\"  \"B4\"  \"A4\"  >    [2425] \"G4\"  \"G4\"  \"C5\"  \"B4\"  \"A4\"  \"E4\"  \"G4\"  \"F4\"  \"E4\" within(chorales, pitch(Token)) >    ############################# vvv chor001.krn vvv ############################# >         1:  !!!COM: Bach, Johann Sebastian >         2:  !!!CDT: 1685/02/21/-1750/07/28/ >         3:  !!!OTL@@DE: Aus meines Herzens Grunde >         4:  !!!OTL@EN:      From the Depths of My Heart >         5:  !!!SCT: BWV 269 >         6:  !!!PC#: 1 >         7:  !!!AGN: chorale >         8:          **kern        **kern        **kern        **kern >         9:          *ICvox        *ICvox        *ICvox        *ICvox >        10:          *Ibass       *Itenor        *Ialto       *Isoprn >        11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >        12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >        13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >        14:             *>A           *>A           *>A           *>A >        15:         *clefF4      *clefGv2       *clefG2       *clefG2 >        16:          *k[f#]        *k[f#]        *k[f#]        *k[f#] >        17:             *G:           *G:           *G:           *G: >        18:             *F:             *             *             * >        19:           *M3/4         *M3/4         *M3/4         *M3/4 >        20:          *MM100        *MM100        *MM100        *MM100 >        21:              G2            B3            D4            G4 >        22:              =1            =1            =1            =1 >        23:              G3            B3            D4            G4 >        24:              E3            C4            E4             . >        25:               .            B3             .             . >        26:             F#3            A3            D4            D5 >        27:              =2            =2            =2            =2 >        28:              G3            G3            D4            B4 >        29:              D3           F#3             .             . >        30:               .             .             .            A4 >        31:              E3            G3            B3            G4 >        32:              =3            =3            =3            =3 >        33:              C3            C4            E4            G4 >        34:               .            B3            D4             . >        35:              B2            C4            E4             . >        36:              A2             .           F#4            A4 >        37:              G2            D4            G4            B4 >        38:              =4            =4            =4            =4 >        39:              D3            D4           F#4            A4 >        40:              G2            D4            G4            B4 >    41-134::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################# ^^^ chor001.krn ^^^ ############################# >     >           (8 more files...) >     >    ############################# vvv chor010.krn vvv ############################# >      1-60::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >        61:              A2            C4            E4            A4 >        62:              A3            E4            A4            C5 >        63:              =9            =9            =9            =9 >        64:              E3            E4            G4            B4 >        65:              D3            E4            G4            C5 >        66:              C3             .             .             . >        67:              B2            D4            G4            D5 >        68:               .             .            F4             . >        69:              C3            C4            E4            G4 >        70:             =10           =10           =10           =10 >        71:              D3           F#3            D4            B4 >        72:               .            G3             .             . >        73:              D3             .            C4            A4 >        74:               .           F#3             .             . >        75:              G2            G3            B3            G4 >        76:             =11           =11           =11           =11 >        77:              C3            G3            E4            G4 >        78:              A2            A3            E4            C5 >        79:              E3           G#3            E4            B4 >        80:               .             .            D4             . >        81:             =12           =12           =12           =12 >        82:              F3            A3            C4            A4 >        83:              C3            G3            C4            E4 >        84:             Bb2            G3            D4            G4 >        85:              A2            A3             .            F4 >        86:             =13           =13           =13           =13 >        87:             G#2            B3            D4            E4 >        88:              A2            A3            C4             . >        89:              E2           G#3            B3             . >        90:              ==            ==            ==            == >        91:              *-            *-            *-            *- >        92:  !!!hum2abc: -Q '' >        93:  !!!title: @{PC#}. @{OTL@@DE} >        94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** >        95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** >        96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** >        97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** >        98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >        99:  !!!EED:  Craig Stuart Sapp >       100:  !!!EEV:  2009/05/22 >    ############################# ^^^ chor010.krn ^^^ ############################# >                           (***four global comments truncated due to screen size***) >     >       humdrumR corpus of ten files. >        Data fields:  >                Token   :: character >               *Result1 :: character within(chorales, Pitch <- pitch(Token)) -> chorales  chorales >    ############################# vvv chor001.krn vvv ############################# >         1:  !!!COM: Bach, Johann Sebastian >         2:  !!!CDT: 1685/02/21/-1750/07/28/ >         3:  !!!OTL@@DE: Aus meines Herzens Grunde >         4:  !!!OTL@EN:      From the Depths of My Heart >         5:  !!!SCT: BWV 269 >         6:  !!!PC#: 1 >         7:  !!!AGN: chorale >         8:          **kern        **kern        **kern        **kern >         9:          *ICvox        *ICvox        *ICvox        *ICvox >        10:          *Ibass       *Itenor        *Ialto       *Isoprn >        11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >        12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >        13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >        14:             *>A           *>A           *>A           *>A >        15:         *clefF4      *clefGv2       *clefG2       *clefG2 >        16:          *k[f#]        *k[f#]        *k[f#]        *k[f#] >        17:             *G:           *G:           *G:           *G: >        18:             *F:             *             *             * >        19:           *M3/4         *M3/4         *M3/4         *M3/4 >        20:          *MM100        *MM100        *MM100        *MM100 >        21:              G2            B3            D4            G4 >        22:              =1            =1            =1            =1 >        23:              G3            B3            D4            G4 >        24:              E3            C4            E4             . >        25:               .            B3             .             . >        26:             F#3            A3            D4            D5 >        27:              =2            =2            =2            =2 >        28:              G3            G3            D4            B4 >        29:              D3           F#3             .             . >        30:               .             .             .            A4 >        31:              E3            G3            B3            G4 >        32:              =3            =3            =3            =3 >        33:              C3            C4            E4            G4 >        34:               .            B3            D4             . >        35:              B2            C4            E4             . >        36:              A2             .           F#4            A4 >        37:              G2            D4            G4            B4 >        38:              =4            =4            =4            =4 >        39:              D3            D4           F#4            A4 >        40:              G2            D4            G4            B4 >    41-134::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################# ^^^ chor001.krn ^^^ ############################# >     >           (8 more files...) >     >    ############################# vvv chor010.krn vvv ############################# >      1-60::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >        61:              A2            C4            E4            A4 >        62:              A3            E4            A4            C5 >        63:              =9            =9            =9            =9 >        64:              E3            E4            G4            B4 >        65:              D3            E4            G4            C5 >        66:              C3             .             .             . >        67:              B2            D4            G4            D5 >        68:               .             .            F4             . >        69:              C3            C4            E4            G4 >        70:             =10           =10           =10           =10 >        71:              D3           F#3            D4            B4 >        72:               .            G3             .             . >        73:              D3             .            C4            A4 >        74:               .           F#3             .             . >        75:              G2            G3            B3            G4 >        76:             =11           =11           =11           =11 >        77:              C3            G3            E4            G4 >        78:              A2            A3            E4            C5 >        79:              E3           G#3            E4            B4 >        80:               .             .            D4             . >        81:             =12           =12           =12           =12 >        82:              F3            A3            C4            A4 >        83:              C3            G3            C4            E4 >        84:             Bb2            G3            D4            G4 >        85:              A2            A3             .            F4 >        86:             =13           =13           =13           =13 >        87:             G#2            B3            D4            E4 >        88:              A2            A3            C4             . >        89:              E2           G#3            B3             . >        90:              ==            ==            ==            == >        91:              *-            *-            *-            *- >        92:  !!!hum2abc: -Q '' >        93:  !!!title: @{PC#}. @{OTL@@DE} >        94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** >        95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** >        96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** >        97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** >        98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >        99:  !!!EED:  Craig Stuart Sapp >       100:  !!!EEV:  2009/05/22 >    ############################# ^^^ chor010.krn ^^^ ############################# >                           (***four global comments truncated due to screen size***) >     >       humdrumR corpus of ten files. >        Data fields:  >                Token :: character >               *Pitch :: character"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/WorkingWithData.html","id":"withwithin-subsets","dir":"Articles","previous_headings":"","what":"With/Within Subsets","title":"Working with humdrum data","text":"real power within functions, comes additional “control” arguments can pass. Two prominent examples allow automatically work subsets data: subset arguments. can indicate subset, multiple subsets, expressions evaluated separately within subset.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/WorkingWithData.html","id":"with-subset","dir":"Articles","previous_headings":"With/Within Subsets","what":"With Subset","title":"Working with humdrum data","text":"subset argument indicates subset data evaluate “within.” subset argument must expression evaluates logical vector (TRUE FALSE). main command evaluated wherever subset expression evaluates TRUE. Let’s try tabling example. Maybe want table tokens first spine: see low notes, ’d expect bass voice. , let’s tabulate even-numbered bars: datasets measures indicated (= tokens), Bar field integers counting bars within piece. want even numbers, can ask Bar modulo 2 zero?: Bar %% 2 == 0. use subset argument within, parts data don’t match within expression returned null: Notice, new Pitch field NULL spine except spine 1.","code":"with(chorales,       kern(Token) |> table() |> sort() |> tail(n = 10),      subset = Spine == 1) >     >    GG C#  A  G AA F# BB  C  D  E  >    29 30 36 36 44 44 48 57 70 85 with(chorales,       kern(Token) |> table() |> sort() |> tail(n = 10),      subset = Bar %% 2 == 0) >     >      G   c  f#   A   B   b   d   g   a   e  >     41  53  57  59  62  63  63  72  82 111 within(chorales,        Pitch <- pitch(Token, simple = TRUE),        subset = Spine == 1) >    ############################# vvv chor001.krn vvv ############################# >         1:  !!!COM: Bach, Johann Sebastian >         2:  !!!CDT: 1685/02/21/-1750/07/28/ >         3:  !!!OTL@@DE: Aus meines Herzens Grunde >         4:  !!!OTL@EN:      From the Depths of My Heart >         5:  !!!SCT: BWV 269 >         6:  !!!PC#: 1 >         7:  !!!AGN: chorale >         8:          **kern        **kern        **kern        **kern >         9:          *ICvox        *ICvox        *ICvox        *ICvox >        10:          *Ibass       *Itenor        *Ialto       *Isoprn >        11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >        12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >        13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >        14:             *>A           *>A           *>A           *>A >        15:         *clefF4      *clefGv2       *clefG2       *clefG2 >        16:          *k[f#]        *k[f#]        *k[f#]        *k[f#] >        17:             *G:           *G:           *G:           *G: >        18:             *F:             *             *             * >        19:           *M3/4         *M3/4         *M3/4         *M3/4 >        20:          *MM100        *MM100        *MM100        *MM100 >        21:               G             .             .             . >        22:              =1            =1            =1            =1 >        23:               G             .             .             . >        24:               E             .             .             . >        25:               .             .             .             . >        26:              F#             .             .             . >        27:              =2            =2            =2            =2 >        28:               G             .             .             . >        29:               D             .             .             . >        30:               .             .             .             . >        31:               E             .             .             . >        32:              =3            =3            =3            =3 >        33:               C             .             .             . >        34:               .             .             .             . >        35:               B             .             .             . >        36:               A             .             .             . >        37:               G             .             .             . >        38:              =4            =4            =4            =4 >        39:               D             .             .             . >        40:               G             .             .             . >    41-134::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################# ^^^ chor001.krn ^^^ ############################# >     >           (8 more files...) >     >    ############################# vvv chor010.krn vvv ############################# >      1-60::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >        61:               A             .             .             . >        62:               A             .             .             . >        63:              =9            =9            =9            =9 >        64:               E             .             .             . >        65:               D             .             .             . >        66:               C             .             .             . >        67:               B             .             .             . >        68:               .             .             .             . >        69:               C             .             .             . >        70:             =10           =10           =10           =10 >        71:               D             .             .             . >        72:               .             .             .             . >        73:               D             .             .             . >        74:               .             .             .             . >        75:               G             .             .             . >        76:             =11           =11           =11           =11 >        77:               C             .             .             . >        78:               A             .             .             . >        79:               E             .             .             . >        80:               .             .             .             . >        81:             =12           =12           =12           =12 >        82:               F             .             .             . >        83:               C             .             .             . >        84:              Bb             .             .             . >        85:               A             .             .             . >        86:             =13           =13           =13           =13 >        87:              G#             .             .             . >        88:               A             .             .             . >        89:               E             .             .             . >        90:              ==            ==            ==            == >        91:              *-            *-            *-            *- >        92:  !!!hum2abc: -Q '' >        93:  !!!title: @{PC#}. @{OTL@@DE} >        94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** >        95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** >        96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** >        97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** >        98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >        99:  !!!EED:  Craig Stuart Sapp >       100:  !!!EEV:  2009/05/22 >    ############################# ^^^ chor010.krn ^^^ ############################# >                           (***four global comments truncated due to screen size***) >     >       humdrumR corpus of ten files. >        Data fields:  >                Token :: character >               *Pitch :: character"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/WorkingWithData.html","id":"or-else","dir":"Articles","previous_headings":"With/Within Subsets > With Subset","what":"Or else…","title":"Working with humdrum data","text":"many cases using subset ’d like something , least keep, “” part data—complement subset. can expressing “complement” expression. idea say “evaluate X Y true, otherwise evaluate instead.” easiest understand use within example . Maybe want calculate simple pitch first spine, leave spines unchanged: pattern, comp = Token quite common.","code":"within(chorales,        Pitch <- pitch(Token, simple = TRUE),        subset = Spine == 1,        complement = Token) >    ############################# vvv chor001.krn vvv ############################# >         1:  !!!COM: Bach, Johann Sebastian >         2:  !!!CDT: 1685/02/21/-1750/07/28/ >         3:  !!!OTL@@DE: Aus meines Herzens Grunde >         4:  !!!OTL@EN:      From the Depths of My Heart >         5:  !!!SCT: BWV 269 >         6:  !!!PC#: 1 >         7:  !!!AGN: chorale >         8:          **kern        **kern        **kern        **kern >         9:          *ICvox        *ICvox        *ICvox        *ICvox >        10:          *Ibass       *Itenor        *Ialto       *Isoprn >        11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >        12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >        13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >        14:             *>A           *>A           *>A           *>A >        15:         *clefF4      *clefGv2       *clefG2       *clefG2 >        16:          *k[f#]        *k[f#]        *k[f#]        *k[f#] >        17:             *G:           *G:           *G:           *G: >        18:             *F:             *             *             * >        19:           *M3/4         *M3/4         *M3/4         *M3/4 >        20:          *MM100        *MM100        *MM100        *MM100 >        21:               G            4B            4d            4g >        22:              =1            =1            =1            =1 >        23:               G            4B            4d            2g >        24:               E           8cL            4e             . >        25:               .           8BJ             .             . >        26:              F#            4A            4d           4dd >        27:              =2            =2            =2            =2 >        28:               G            4G            2d           4.b >        29:               D           4F#             .             . >        30:               .             .             .            8a >        31:               E            4G            4B            4g >        32:              =3            =3            =3            =3 >        33:               C           8cL           8eL           4.g >        34:               .           8BJ            8d             . >        35:               B            4c            8e             . >        36:               A             .          8f#J            8a >        37:               G            4d            4g            4b >        38:              =4            =4            =4            =4 >        39:               D           2d;          2f#;           2a; >        40:               G            4d            4g            4b >    41-134::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################# ^^^ chor001.krn ^^^ ############################# >     >           (8 more files...) >     >    ############################# vvv chor010.krn vvv ############################# >      1-60::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >        61:               A           2c;           2e;           2a; >        62:               A            2e            2a           2cc >        63:              =9            =9            =9            =9 >        64:               E            4e            4g            4b >        65:               D            4e            4g           4cc >        66:               C             .             .             . >        67:               B            4d           8gL           4dd >        68:               .             .           8fJ             . >        69:               C            4c            4e            4g >        70:             =10           =10           =10           =10 >        71:               D           8F#            4d            4b >        72:               .            4G             .             . >        73:               D             .            4c            4a >        74:               .           8F#             .             . >        75:               G           2G;           2B;           2g; >        76:             =11           =11           =11           =11 >        77:               C            2G            2e            2g >        78:               A            4A            4e           4cc >        79:               E           4G#           8eL            4b >        80:               .             .           8dJ             . >        81:             =12           =12           =12           =12 >        82:               F            4A            4c            4a >        83:               C            4G            4c            4e >        84:              Bb            4G           [2d            4g >        85:               A            4A             .            4f >        86:             =13           =13           =13           =13 >        87:              G#            4B           4d]           1e; >        88:               A            4A            4c             . >        89:               E         2G#X;           2B;             . >        90:              ==            ==            ==            == >        91:              *-            *-            *-            *- >        92:  !!!hum2abc: -Q '' >        93:  !!!title: @{PC#}. @{OTL@@DE} >        94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** >        95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** >        96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** >        97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** >        98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >        99:  !!!EED:  Craig Stuart Sapp >       100:  !!!EEV:  2009/05/22 >    ############################# ^^^ chor010.krn ^^^ ############################# >                           (***four global comments truncated due to screen size***) >     >       humdrumR corpus of ten files. >        Data fields:  >                Token :: character >               *Pitch :: character"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/WorkingWithData.html","id":"with-subgroups","dir":"Articles","previous_headings":"With/Within Subsets","what":"With Subgroups","title":"Working with humdrum data","text":"keyword arguments short “group .” can indicate field data group data —main call applied separately group, groups returned. Let’s try tabling example. Let’s group data spine, tabulate spine data (voice) separately! get four different tables, one spine. want make multiple plots, can just add barplot like .  Let’s try something slightly different: Since four spines represent bass, tenor, alto, soprano voices (order) ’d expect average pitch spine significantly different. Let’s convert pitch data semitones (using semits) add call base-R function mean: Watch Oops, didn’t work! ’s Token data rests, like 4r. semits function doesn’t know read 4r returns NA value. Don’t worry, easy fix, good lesson data analysis general R particular. always need keep mind data “missing” Applicable (NA). R math functions option ignore missing data setting na.rm = TRUE (NA remove): ’s expected! course, might prefer plot.  Notice something differently ! don’t want make separate plot group-calculation—just single number spine. want make plot four numbers, put barplot call (outside) call. Notice can also control labels barplot using names.arg argument. Maybe want inspect whole histogram pitches voice. can use base-R hist function; Since want histogram spine, want put hist “inside” call :  Pro tips: setting xlim (x-limit) argument, make sure four barplots cover ranges pitches, comparable. also set main argument (figure title) using Instrument field, gives us names instrument. ’s right, can refer /fields humdrum data! (datasets tandem interpretation, wouldn’t always work.)","code":"with(chorales,       kern(Token) |> table() |> sort() |> tail(n = 10),      by = Spine) >    $`1` >     >    GG C#  A  G AA F# BB  C  D  E  >    29 30 36 36 44 44 48 57 70 85  >     >    $`2` >     >    B- F# G# c#  G  e  A  c  B  d  >    17 20 29 34 35 75 76 83 85 88  >     >    $`3` >     >      B  d#   b   d  g#   f   a  f#   g   e  >     16  16  19  43  44  50  67  83  88 121  >     >    $`4` >     >     b-  g#   e  ee cc#   g  dd  cc   a   b  >     15  15  17  25  36  42  48  68  93 115 with(chorales,       kern(Token) |> table() |> sort() |> tail(n = 10) |> barplot(),      by = Spine) with(chorales,       semits(Token) |> mean(),      by = Spine) >             1          2          3          4  >    -9.6692308 -0.1143317  5.6065041 10.5672192 with(chorales,       semits(Token) |> mean(na.rm = TRUE),      by = Spine) >             1          2          3          4  >    -9.6692308 -0.1143317  5.6065041 10.5672192 with(chorales,       semits(Token) |> mean(na.rm = TRUE),      by = Spine) |> barplot(names.arg = c('Bass', 'Tenor', 'Alto', 'Soprano'),                              main = 'Mean Pitch by Voice',                             ylab = 'Semitones') with(chorales,       semits(Token) |> hist(xlim = c(-24, 24), main = Instrument[1]),      by = Spine)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/WorkingWithData.html","id":"advanced-grouping","dir":"Articles","previous_headings":"With/Within Subsets > With Subgroups","what":"Advanced Grouping","title":"Working with humdrum data","text":"can group data arbitrary grouping data. fact keyword argument can complex expression, long output length input. example, maybe ’d like reproduce histograms, lumping male (bass/tenor) female (alto/soprano) voices together.  expression Spine < 3 returns FALSE spines 1 2 (bass tenor) TRUE spines 3 4. two categories (FALSE TRUE) used group data.","code":"with(chorales,       semits(Token) |> hist(xlim = c(-24, 24), main = paste(unique(Instrument), sep = ' and ')),      by = Spine < 3)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/WorkingWithData.html","id":"recycling-results","dir":"Articles","previous_headings":"With/Within Subsets","what":"Recycling results","title":"Working with humdrum data","text":"cases, ’d like perform command within data might output smaller vector input, including single value, still want reconstruct data fully. R, usually called “recycling”—.e., repeating value matches certain length. using within, can cause results recycled full field length using recycle argument expression. useful want group something, fill group value: command ? looks every bar file finds lowest note, “fills” notes bar , single, note. calculate harmonic interval bar’s bass note:","code":"within(chorales,        Semits <- semits(Token)) -> chorales  within(chorales,         recycle = BarBassNote <- min(Semits),        by = list(File, Bar)) -> chorales  chorales >    ############################# vvv chor001.krn vvv ############################# >         1:  !!!COM: Bach, Johann Sebastian >         2:  !!!CDT: 1685/02/21/-1750/07/28/ >         3:  !!!OTL@@DE: Aus meines Herzens Grunde >         4:  !!!OTL@EN:      From the Depths of My Heart >         5:  !!!SCT: BWV 269 >         6:  !!!PC#: 1 >         7:  !!!AGN: chorale >         8:          **kern        **kern        **kern        **kern >         9:          *ICvox        *ICvox        *ICvox        *ICvox >        10:          *Ibass       *Itenor        *Ialto       *Isoprn >        11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >        12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >        13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >        14:             *>A           *>A           *>A           *>A >        15:         *clefF4      *clefGv2       *clefG2       *clefG2 >        16:          *k[f#]        *k[f#]        *k[f#]        *k[f#] >        17:             *G:           *G:           *G:           *G: >        18:             *F:             *             *             * >        19:           *M3/4         *M3/4         *M3/4         *M3/4 >        20:          *MM100        *MM100        *MM100        *MM100 >        21:             -17           -17           -17           -17 >        22:              =1            =1            =1            =1 >        23:              -8            -8            -8            -8 >        24:              -8            -8            -8             . >        25:               .            -8             .             . >        26:              -8            -8            -8            -8 >        27:              =2            =2            =2            =2 >        28:             -10           -10           -10           -10 >        29:             -10           -10             .             . >        30:               .             .             .           -10 >        31:             -10           -10           -10           -10 >        32:              =3            =3            =3            =3 >        33:             -17           -17           -17           -17 >        34:               .           -17           -17             . >        35:             -17           -17           -17             . >        36:             -17             .           -17           -17 >        37:             -17           -17           -17           -17 >        38:              =4            =4            =4            =4 >        39:             -17           -17           -17           -17 >        40:             -17           -17           -17           -17 >    41-134::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################# ^^^ chor001.krn ^^^ ############################# >     >           (8 more files...) >     >    ############################# vvv chor010.krn vvv ############################# >      1-60::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >        61:             -15           -15           -15           -15 >        62:             -15           -15           -15           -15 >        63:              =9            =9            =9            =9 >        64:             -13           -13           -13           -13 >        65:             -13           -13           -13           -13 >        66:             -13             .             .             . >        67:             -13           -13           -13           -13 >        68:               .             .           -13             . >        69:             -13           -13           -13           -13 >        70:             =10           =10           =10           =10 >        71:             -17           -17           -17           -17 >        72:               .           -17             .             . >        73:             -17             .           -17           -17 >        74:               .           -17             .             . >        75:             -17           -17           -17           -17 >        76:             =11           =11           =11           =11 >        77:             -15           -15           -15           -15 >        78:             -15           -15           -15           -15 >        79:             -15           -15           -15           -15 >        80:               .             .           -15             . >        81:             =12           =12           =12           =12 >        82:             -15           -15           -15           -15 >        83:             -15           -15           -15           -15 >        84:             -15           -15           -15           -15 >        85:             -15           -15             .           -15 >        86:             =13           =13           =13           =13 >        87:             -20           -20           -20           -20 >        88:             -20           -20           -20             . >        89:             -20           -20           -20             . >        90:              ==            ==            ==            == >        91:              *-            *-            *-            *- >        92:  !!!hum2abc: -Q '' >        93:  !!!title: @{PC#}. @{OTL@@DE} >        94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** >        95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** >        96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** >        97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** >        98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >        99:  !!!EED:  Craig Stuart Sapp >       100:  !!!EEV:  2009/05/22 >    ############################# ^^^ chor010.krn ^^^ ############################# >                           (***four global comments truncated due to screen size***) >     >       humdrumR corpus of ten files. >        Data fields:  >                Token       :: character >                Pitch       :: character >                Semits      :: integer >               *BarBassNote :: integer within(chorales,        Semits - BarBassNote) >    ############################# vvv chor001.krn vvv ############################# >         1:  !!!COM: Bach, Johann Sebastian >         2:  !!!CDT: 1685/02/21/-1750/07/28/ >         3:  !!!OTL@@DE: Aus meines Herzens Grunde >         4:  !!!OTL@EN:      From the Depths of My Heart >         5:  !!!SCT: BWV 269 >         6:  !!!PC#: 1 >         7:  !!!AGN: chorale >         8:          **kern        **kern        **kern        **kern >         9:          *ICvox        *ICvox        *ICvox        *ICvox >        10:          *Ibass       *Itenor        *Ialto       *Isoprn >        11:         *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano >        12:       *>[A,A,B]     *>[A,A,B]     *>[A,A,B]     *>[A,A,B] >        13:    *>norep[A,B]  *>norep[A,B]  *>norep[A,B]  *>norep[A,B] >        14:             *>A           *>A           *>A           *>A >        15:         *clefF4      *clefGv2       *clefG2       *clefG2 >        16:          *k[f#]        *k[f#]        *k[f#]        *k[f#] >        17:             *G:           *G:           *G:           *G: >        18:             *F:             *             *             * >        19:           *M3/4         *M3/4         *M3/4         *M3/4 >        20:          *MM100        *MM100        *MM100        *MM100 >        21:               0            16            19            24 >        22:              =1            =1            =1            =1 >        23:               3             7            10            15 >        24:               0             8            12             . >        25:               .             7             .             . >        26:               2             5            10            22 >        27:              =2            =2            =2            =2 >        28:               5             5            12            21 >        29:               0             4             .             . >        30:               .             .             .            19 >        31:               2             5             9            17 >        32:              =3            =3            =3            =3 >        33:               5            17            21            24 >        34:               .            16            19             . >        35:               4            17            21             . >        36:               2             .            23            26 >        37:               0            19            24            28 >        38:              =4            =4            =4            =4 >        39:               7            19            23            26 >        40:               0            19            24            28 >    41-134::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >    ############################# ^^^ chor001.krn ^^^ ############################# >     >           (8 more files...) >     >    ############################# vvv chor010.krn vvv ############################# >      1-60::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: >        61:               0            15            19            24 >        62:              12            19            24            27 >        63:              =9            =9            =9            =9 >        64:               5            17            20            24 >        65:               3            17            20            25 >        66:               1             .             .             . >        67:               0            15            20            27 >        68:               .             .            18             . >        69:               1            13            17            20 >        70:             =10           =10           =10           =10 >        71:               7            11            19            28 >        72:               .            12             .             . >        73:               7             .            17            26 >        74:               .            11             .             . >        75:               0            12            16            24 >        76:             =11           =11           =11           =11 >        77:               3            10            19            22 >        78:               0            12            19            27 >        79:               7            11            19            26 >        80:               .             .            17             . >        81:             =12           =12           =12           =12 >        82:               8            12            15            24 >        83:               3            10            15            19 >        84:               1            10            17            22 >        85:               0            12             .            20 >        86:             =13           =13           =13           =13 >        87:               4            19            22            24 >        88:               5            17            20             . >        89:               0            16            19             . >        90:              ==            ==            ==            == >        91:              *-            *-            *-            *- >        92:  !!!hum2abc: -Q '' >        93:  !!!title: @{PC#}. @{OTL@@DE} >        94:  !!!YOR1: 371 vierstimmige Choralges&auml;nge von Johann Sebastian B*** >        95:  !!!YOR2: 4th ed. by Alfred D&ouml;rffel (Leipzig: Breitkopf und H&a*** >        96:  !!!YOR2: c.1875). 178 pp. Plate \"V.A.10\".  reprint: J.S. Bach, 371 *** >        97:  !!!YOR4: Chorales (New York: Associated Music Publishers, Inc., c.1*** >        98:  !!!SMS: B&H, 4th ed, Alfred D&ouml;rffel, c.1875, plate V.A.10 >        99:  !!!EED:  Craig Stuart Sapp >       100:  !!!EEV:  2009/05/22 >    ############################# ^^^ chor010.krn ^^^ ############################# >                           (***four global comments truncated due to screen size***) >     >       humdrumR corpus of ten files. >        Data fields:  >                Token       :: character >                Pitch       :: character >                Semits      :: integer >                BarBassNote :: integer >               *Result1     :: integer  with(chorales, hist(Semits - BarBassNote))"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Nathaniel Condit-Schultz. Author, maintainer. Claire Arthur. Author.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Condit-Schultz N, Arthur C (2019). “humdrumR: New Take Old Approach Computational Musicology.” Proceedings International Society Music Information Retrieval, 715–722. doi: 10.5281/zenodo.3527910, https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR.","code":"@InProceedings{,   title = {humdrumR: a New Take on an Old Approach to Computational Musicology},   author = {Nathaniel Condit-Schultz and Claire Arthur},   booktitle = {Proceedings of the International Society for Music Information Retrieval},   year = {2019},   pages = {715--722},   doi = {10.5281/zenodo.3527910},   url = {https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR}, }"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html","id":"humdrum_mathbbr","dir":"","previous_headings":"","what":"humdrumR","title":"humdrumR","text":"Welcome main website humdrumℝ!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html","id":"what-is-humdrum_mathbbr","dir":"","previous_headings":"","what":"What is humdrumℝ?","title":"humdrumR","text":"Humdrumℝ R package: “library” preexisting code R programming language. Humdrumℝ code provides tools visualization, manipulation, analysis data formatted humdrum syntax. Note: name package pronounced hum-drum-ARRRRR, last syllable emphasized pirate fashion. name always typeset hμmℝΔrμm. Failure pronounce typeset hμmℝΔrμm correctly void warranty.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html","id":"what-is-humdrum","dir":"","previous_headings":"What is humdrumℝ?","what":"What is humdrum?","title":"humdrumR","text":"Humdrum system computational musicology developed David Huron. Humdrum “universe” includes two parts: data format called humdrum syntax musicological software system called humdrum toolkit. Humdrumℝ meant modernized replacement original humdrum toolkit, leveraging power R give us unprecedented power manipulate analyze humdrum data using concise, expressive syntax. Humdrumℝ mainly used manipulate analyze data encoded humdrum syntax /humdrum interpretations like **kern. humdrum syntax incredibly flexible, powerful, scheme encoding musical data. Tens thousands musical scores (musical data) encoded humdrum syntax, many available online repositories KernScores. humdrum syntax vignette gives detailed introduction data format.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html","id":"what-is-r","dir":"","previous_headings":"What is humdrumℝ?","what":"What is R?","title":"humdrumR","text":"R programming language, designed ground statistical computing data analysis. R many features make ideal data analysis, particularly research analysis background programming. R primer introduces core concepts R programming.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html","id":"what-can-humdrum_mathbbr-do","dir":"","previous_headings":"","what":"What can humdrumℝ do?","title":"humdrumR","text":"Humdrumℝ provides number tools working humdrum data generally, musicological analysis. Humdrumℝ seven main things:","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html","id":"represent-humdrum-data-in-r","dir":"","previous_headings":"What can humdrumℝ do?","what":"Represent humdrum data in R","title":"humdrumR","text":"represent humdrum data R, humdrumℝ defines special data type—humdrumR class—call “humdrumR objects” throughout documentation. important part humdrumR object “humdrum table” contains. can read humdrum-syntax data represented getting started humdrumR vignette.  details, read humdrumR class humdrum table; humdrumℝ installed loaded, can read directly R session typing ?humdrumR-class ?humTable.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html","id":"read-and-write-humdrum-data","dir":"","previous_headings":"What can humdrumℝ do?","what":"Read and write humdrum data","title":"humdrumR","text":"create humdrumR data objects, humdrumℝ includes humdrum data parser, finds humdrum data local machine, reads R, creates humdrumR object data. Reading writing data vignette best place realm works. can get details readHumdrum() writeHumdrum() documentation; humdrumℝ installed loaded, can read directly R session typing ?readHumdrum ?writeHumdrum.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html","id":"reshape-humdrum-data","dir":"","previous_headings":"What can humdrumℝ do?","what":"“Reshape” humdrum data","title":"humdrumR","text":"’ve imported humdrum data R, next step often organize prepare data. ’ll often want pick specific subsets data, rearrange data representations easier work . Humdrumℝ gives us number powerful tools “shaping data”: Shaping humdrum data Filtering humdrum data vignettes best places learn processes. can find details sub-setting data subset.humdrumR() indexHumdrum documentation; humdrumℝ installed loaded, can read directly R session typing ?subset.humdrumR ?indexHumdrum.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html","id":"analyze-humdrum-data","dir":"","previous_headings":"What can humdrumℝ do?","what":"Analyze humdrum data","title":"humdrumR","text":"Humdrumℝ makes easy manipulate, modify, analyze humdrum data. Working humdrum data vignette gives overview functionality. can find details withinHumdrum documentation; humdrumℝ installed loaded, can read directly R session typing ?withinHumdrum.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html","id":"manipulate-musical-pitch-information","dir":"","previous_headings":"What can humdrumℝ do?","what":"Manipulate (musical) pitch information","title":"humdrumR","text":"Humdrumℝ defines tools manipulating numerous representations pitch tonality, including diatonic keys tertian harmonies. Pitch tonality vignette explains work pitch data humdrumℝ. can find details humdrumPitch documentation; humdrumℝ installed loaded, can read directly R session typing ?humdrumPitch.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html","id":"manipulate-musical-rhythm-information","dir":"","previous_headings":"What can humdrumℝ do?","what":"Manipulate (musical) rhythm information","title":"humdrumR","text":"Humdrumℝ defines tools manipulating numerous representations rhythm, timing, meter. Rhythm meter vignette explains work rhythmic information humdrumℝ. can find details humdrumRhythm documentation; humdrumℝ installed loaded, can read directly R session typing ?humdrumRhythm.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html","id":"develop-new-humdrum-tools","dir":"","previous_headings":"What can humdrumℝ do?","what":"Develop new humdrum tools","title":"humdrumR","text":"facilitate development new functions work humdrum tokens—simple character strings packed information—, Humdrumℝ provides several useful development tools, including struct data type useful API call regular-expression dispatch system, makes easy dispatch different methods based matches regular expressions.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html","id":"installing-r","dir":"","previous_headings":"Installing humdrumℝ","what":"Installing R","title":"humdrumR","text":"use humdrumℝ, ’ll first need install R, version 4.1 later. highly recommend install Integrated Development Environment RStudio well! link—Installing R RStudio—good starting place.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html","id":"installing-humdrum_mathbbr-1","dir":"","previous_headings":"Installing humdrumℝ","what":"Installing humdrumℝ","title":"humdrumR","text":"Humdrumℝ yet available standard R package repository, CRAN, (now) can installed github repository. install latest version (master branch) humdrumℝ, ’ll first need install R package devtools—devtools used creating maintaining R packages. Luckily, devtools CRAN, open R session machine type: successfully installed devtools, now ready use install humdrumℝ straight github. R session, type:","code":"install.packages('devtools') devtools::install_github(\"Computational-Cognitive-Musicology-Lab/humdrumR\", build_vignettes = TRUE)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html","id":"humdrum_mathbbr-source","dir":"","previous_headings":"Installing humdrumℝ > Installing humdrumℝ","what":"Humdrumℝ source","title":"humdrumR","text":"Another option—useful, want inspect, contribute , humdrumℝ source code—actually download humdrumℝ package source github install directly. ’ll first need install git. git installed computer, can download humdrumℝ repository clicking “Clone download” github page. Alternatively, can use git directly: navigate directory machine ’d like save package source type: ’ve done , can install source computer using devtools: Open R session use setwd move working directory inside repository just downloaded (.e., cloned). , type downloaded RStudio, can use “Open Project” option select file humdrumR.Rproj repository. ’ve done can just click “Install Restart” “Build” pane. ’ve completed installation humdrumℝ can used simply calling:","code":"git clone https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR devtools::install() library(humdrumR)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html","id":"updating-humdrum_mathbbr","dir":"","previous_headings":"Installing humdrumℝ","what":"Updating humdrumℝ","title":"humdrumR","text":"Humdrumℝ active development, new features added, documentation updated, bugs fixed weekly basis. recommend keep date newest version humdrumℝ. Luckily, can easily update latest version simply running devtools::install_github() command R session. However, already loaded humdrumRℝ library R session—using library(humdrumR)—’ll need “detach” old version new version work. can either 1) quitting R studio opening , 2) going RStudio’s package panel unchecking humdrumR, 3) running command detach(\"package:humdrumR\", unload = TRUE). installed humdrumℝ source using git clone command, can’t simply run clone . Instead, navigate package directory run git pull origin main. “pull” latest changes local machine. can rerun devtools::install().","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html","id":"learning-humdrum_mathbbr","dir":"","previous_headings":"","what":"Learning humdrumℝ","title":"humdrumR","text":"learn use humdrumℝ “Articles” list top page best place start—particular, Getting started humdrumR article! Documentation specific functions general topics can found “Reference” section. humdrumℝ installed, can also access documentation directly R sessions. R command line, use ? operator name function topic see documentation:","code":"library(humdrumR)  ?humdrumR"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/LO5th.html","id":null,"dir":"Reference","previous_headings":"","what":"Line of Fifths — LO5th","title":"Line of Fifths — LO5th","text":"function LO5th S3-generic function methods extract \"line--fifths\" value various pitch objects representations.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/LO5th.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Line of Fifths — LO5th","text":"","code":"LO5th(x, generic = FALSE, ...)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/LO5th.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Line of Fifths — LO5th","text":"Returns integer vector array, matching input.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/LO5th.html","id":"the-line-of-fifths","dir":"Reference","previous_headings":"","what":"The Line of Fifths","title":"Line of Fifths — LO5th","text":"Every interval Western music associated integer line fifths: Bb = m7 = -2 F =  P4  = -1 C =  P1 = 0 G =  P5 = 1 D =  M2 = 2 =  M6 = 3 E =  M3 = 4 B =  M7 = 5 F# = A4 = 6 etc. natural notes (C) major scale---also call generic intervals---fall range -1:5. fact, diatonic key block seven consecutive numbers line--fifths: example, Eb major -4:2. \"Sharps\" \"flats\" represent +7 -7 line--fifths respectively.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/REparser.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse String Using Regular expressions — REparser","title":"Parse String Using Regular expressions — REparser","text":"Takes input string parses sequence regular expressions.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/REparser.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse String Using Regular expressions — REparser","text":"","code":"REparser(   res,   parse.strict = TRUE,   parse.exhaust = TRUE,   parse.lead = FALSE,   parse.rest = FALSE,   toEnv = FALSE )  REparse(   str,   res,   parse.strict = TRUE,   parse.exhaust = TRUE,   parse.lead = FALSE,   parse.rest = FALSE,   reverse = FALSE,   sep = NULL,   toEnv = FALSE )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/REparser.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parse String Using Regular expressions — REparser","text":"exhaustive TRUE, string must exhaustively broken matching regular expressions. Superfluous (non-match) characters begginning, end, bettween matches, result NA returned. ------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/RegexFind.html","id":null,"dir":"Reference","previous_headings":"","what":"Match strings against regular expression — RegexFind","title":"Match strings against regular expression — RegexFind","text":"functions give concise way search regular expressions character vectors. \"infix\" functions, meaning write function two arguments: myvector %~% regex.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/RegexFind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match strings against regular expression — RegexFind","text":"","code":"x %~l% regex  x %~i% regex  x %~n% regex  x %~m% regex  x %~% regex  ... %!~% NA  ... %!~l% NA  x %!~i% pattern"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/RegexFind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Match strings against regular expression — RegexFind","text":"x character vector search . regex One regular expressions. one regex supplied, matches regexes returned. (See \"Multiple regexes\" section.)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/RegexFind.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Match strings against regular expression — RegexFind","text":"version function returns different type information regex matches () input vector: %~l%: returns logical (TRUE/FALSE) indicating x matches. %~%: returns integer indicating indices matches x. %~n%: returns integer indicating number (count) matches string. %~m%: returns character string matched string . Returns NA match. basic function (%~%) %~l%. also negative versions l functions: giving strings match given regular expression. %!~%, %!~l%, %!~%. functions simply syntactic sugar existing R regular expression matching functions: %~l%: base::grepl() %~%: base::grep() %~n%: stringi::stri_count_regex() %~m%: stringi::stri_extract_first_regex()","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/RegexFind.html","id":"multiple-regexes","dir":"Reference","previous_headings":"","what":"Multiple regexes","title":"Match strings against regular expression — RegexFind","text":"one regex supplied, %~l% %~% return indices regexes match. case %~n%, matching regex counted separately, summed. case %~m%, matches () pasted together, including multiple matches string.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/SOI.html","id":null,"dir":"Reference","previous_headings":"","what":"Onset/Offset interval since beginning. — SOI","title":"Onset/Offset interval since beginning. — SOI","text":"Refers duration rhythmic time elapsed since starting point (usually, beginning piece). music21 described \"offsets\"---however, prefer reserve words \"onset\" \"offset\" refer beginning (attacK) end (release) rhythmic events. STO takes vector numbers representing durations (numeric values) cummulatively sums starting value. Unlike sigma(), SOI returns timestamp onset rhythmic duration offset. SOI interprets first duration starting zero---different value specified start argument.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/SOI.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Onset/Offset interval since beginning. — SOI","text":"","code":"SOI(durations, start = 0L)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/SOI.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Onset/Offset interval since beginning. — SOI","text":"durations vector numeric values representing durations. start duration value (coerced class durations), offset begins.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/SOI.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Onset/Offset interval since beginning. — SOI","text":"S3 object class \"rhythmOffset\", essentially data.frame two columns---Onset Offset--- numeric values class input durations argument.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/accidental.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract accidental from pitch — accidental","title":"Extract accidental from pitch — accidental","text":"Extract accidental pitch","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/accidental.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract accidental from pitch — accidental","text":"","code":"accidental(x, ..., Key = NULL, parseArgs = list(), inPlace = FALSE)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/accidental.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract accidental from pitch — accidental","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). Key (diatonicSet something coercable diatonicSet, length == 1 | length == length(x)) input Key used parser, deparser, transposer. parseArgs (list) parseArgs can list arguments passed pitch parser. inPlace (logical, length == 1) argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/apply2Humdrum.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply functions to humdrum data\n\napply2Humdrum is just a wrapper for\n[humdrumR:with-in-Humdrum][with(in)Humdrum],\nincluded to parallel the R family of [base:lapply][_apply] functions.\napply2Humdrum uses non-standard evaluation\nto capture arguments fed to it without the user needing to make explicit\n[base:tilde][formula] using ~. This is only guaranteed to work\nin the [base:environment][global environment], so be careful. If you run into\nproblems, switch over to [humdrumR:with-in-Humdrum][with(in)Humdrum] and use\nexplicit [base:tilde][X~formulas]. — apply2Humdrum","title":"Apply functions to humdrum data\n\napply2Humdrum is just a wrapper for\n[humdrumR:with-in-Humdrum][with(in)Humdrum],\nincluded to parallel the R family of [base:lapply][_apply] functions.\napply2Humdrum uses non-standard evaluation\nto capture arguments fed to it without the user needing to make explicit\n[base:tilde][formula] using ~. This is only guaranteed to work\nin the [base:environment][global environment], so be careful. If you run into\nproblems, switch over to [humdrumR:with-in-Humdrum][with(in)Humdrum] and use\nexplicit [base:tilde][X~formulas]. — apply2Humdrum","text":"Apply functions humdrum data apply2Humdrum just wrapper [humdrumR:--Humdrum][()Humdrum], included parallel R family [base:lapply][_apply] functions. apply2Humdrum uses non-standard evaluation capture arguments fed without user needing make explicit [base:tilde][formula] using ~. guaranteed work [base:environment][global environment], careful. run problems, switch [humdrumR:--Humdrum][()Humdrum] use explicit [base:tilde][X~formulas].","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/apply2Humdrum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply functions to humdrum data\n\napply2Humdrum is just a wrapper for\n[humdrumR:with-in-Humdrum][with(in)Humdrum],\nincluded to parallel the R family of [base:lapply][_apply] functions.\napply2Humdrum uses non-standard evaluation\nto capture arguments fed to it without the user needing to make explicit\n[base:tilde][formula] using ~. This is only guaranteed to work\nin the [base:environment][global environment], so be careful. If you run into\nproblems, switch over to [humdrumR:with-in-Humdrum][with(in)Humdrum] and use\nexplicit [base:tilde][X~formulas]. — apply2Humdrum","text":"","code":"apply2Humdrum(humdrumR, FUN, ..., within = TRUE, doplot = FALSE)  happly(humdrumR, FUN, ..., within = TRUE, doplot = FALSE)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/apply2Humdrum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply functions to humdrum data\n\napply2Humdrum is just a wrapper for\n[humdrumR:with-in-Humdrum][with(in)Humdrum],\nincluded to parallel the R family of [base:lapply][_apply] functions.\napply2Humdrum uses non-standard evaluation\nto capture arguments fed to it without the user needing to make explicit\n[base:tilde][formula] using ~. This is only guaranteed to work\nin the [base:environment][global environment], so be careful. If you run into\nproblems, switch over to [humdrumR:with-in-Humdrum][with(in)Humdrum] and use\nexplicit [base:tilde][X~formulas]. — apply2Humdrum","text":"humdrumR humdrumRclass data object. FUN function apply humdrumR:humdrumRfield(s) thehumdrumR` object. ... arguments can fed [humdrumR:--Humdrum][()Humdrum] formulae (except expressions, replaced FUN argument!). However, rather writinging formula format Keyword ~ Expression, apply2Humdrum arguments written normal R arguments: Keyword = Expression. Unnamed arguments ignored. #' @param within logical. TRUE (default), [humdrumR:--Humdrum][withinHumdrum] used apply function---meaning output reconstituted new field humdrumR object. within == FALSE, [humdrumR:--Humdrum][withHumdrum] used instead, results function's output returned inprocessed. doplot Boolean. TRUE FUN argument treated doplot expression [humdrumR:--Humdrum][()Humdrum], result ignored (plotting side-effects purposes).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/bhatk.html","id":null,"dir":"Reference","previous_headings":"","what":"Swara representation — bhatk","title":"Swara representation — bhatk","text":"Swara syllabes used represent scale degrees hindustani music---like solfege.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/bhatk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Swara representation — bhatk","text":"","code":"bhatk(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   Key = NULL,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/bhatk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Swara representation — bhatk","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). generic (logical, length == 1) generic = TRUE \"specific\" pitch information (accidentals qualites) discarded. simple (logical, length == 1) simple = TRUE \"compound\" pitch information (octave/contour) discarded. Key (diatonicSet something coercable diatonicSet, length == 1 | length == length(x)) input Key used parser, deparser, transposer. transposeArgs (list) transposeArgs can list arguments passed special call transpose. parseArgs (list) parseArgs can list arguments passed pitch parser. inPlace (logical, length == 1) argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/bhatk.html","id":"basic-pitch-arguments","dir":"Reference","previous_headings":"","what":"Basic pitch arguments","title":"Swara representation — bhatk","text":"pitch function standard arguments control details output. important generic simple arguments, allow control type pitch information returned.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/bhatk.html","id":"generic-vs-specific","dir":"Reference","previous_headings":"","what":"Generic vs Specific","title":"Swara representation — bhatk","text":"generic = TRUE, specific pitch information (accidentals qualities) omitted output. alternative way controlling functionality, can use specific argument, specific == !generic. case atonal functions, \"generic\" version pitch output: example, semits('c#', generic = TRUE) return 0, \"generic\" version C# C, corresponds 0. However, note generic version pitch follows key, semits('c#', generic = TRUE, Key = ':') return 1!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/bhatk.html","id":"simple-vs-compound","dir":"Reference","previous_headings":"","what":"Simple vs Compound","title":"Swara representation — bhatk","text":"simple = TRUE, compound pitch information (octave contour) omitted output. alternative way controlling functionality, can use compound argument ,compound == !simple. actually one way might want divide compound intervals simple octave parts. example, might like call output -M2 (descending major 2nd) +m7 (ascending minor 7th octave ). functionality can controlled octave.round argument: see pitch deparsing documentation.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/bhatk.html","id":"key","dir":"Reference","previous_headings":"","what":"Key","title":"Swara representation — bhatk","text":"Key argument must diatonicSet, something can parsed one. Key argument passed parser, deparser, transpose---unless alternate Key passed transposeArgs parseArgs. Various deparsing options use Key argument; example, use implicitSpecies (see advanced parsing section) dependent Key. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function---means, cases, need explicitly anything Key argument! (want happen, need explicitly specify Key argument, Key = NULL.)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/bhatk.html","id":"parse-arguments","dir":"Reference","previous_headings":"","what":"Parse arguments","title":"Swara representation — bhatk","text":"parseArgs argument must list() (named) arguments passed input parser. example, input representation uses \"X\" represent double sharps, specify kern('CX5', parseArgs = list(doublesharp = 'X')) get correct result (\"cc##\"). convenient shorthand, \"syntactic sugar,\" can specify parseArgs alternate way: Simply input parse(args...) unnamed argument pitch function. example, can get exact result typing kern('CX5', parse(doublesharp = 'X')).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/bhatk.html","id":"transpose-arguments","dir":"Reference","previous_headings":"","what":"Transpose arguments","title":"Swara representation — bhatk","text":"transposeArgs argument must list() (named) arguments passed internal call transpose(), allowing us easily transpose pitch information. example, type kern(c('C', 'D', 'E'), transposeArgs = list(= 'M9')) can get output c('d', 'e', 'f#'). possible transpose args : (tonalInterval, length == 1 | length == (x)) (diatonicSet, length == 1 | length == (x))  (diatonicSet, length == 1 | length == (x)) real (logical, length == 1) transposition real tonal? relative (logical, length == 1) key-wise transposition based relative parallel keys? convenient shorthand, \"syntactic sugar,\" can specify transposeArgs alternate way: Simply input transpose(args...) unnamed argument pitch function. example, can get exact result typing kern(c('C', 'D', 'E'), transpose(= 'M9')).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/bhatk.html","id":"transposing-by-interval","dir":"Reference","previous_headings":"","what":"Transposing by interval","title":"Swara representation — bhatk","text":"calling transpose() directly, argument can anything coercable tonalInterval, output transposed amount. real = FALSE, tonal transposition (within Key) performed. details transposition behavior, check transpose() docs.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/bhatk.html","id":"transposing-by-key","dir":"Reference","previous_headings":"","what":"Transposing by key","title":"Swara representation — bhatk","text":"Another way transposing specifying input (\"\") key output (\"\") key. default, Key argument passed transpose , nothing actually happens. Thus, specify either key key, transposition happen /key Key. course, specify transposition happen keys specify. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function. specify key, Key field passed transpose key, result, pitches input transposed whatever keys target () key! real relative arguments give special control key-wise transposition works, check transpose() docs details!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/bhatk.html","id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Swara representation — bhatk","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/census.html","id":null,"dir":"Reference","previous_headings":"","what":"Tabulate records and tokens in a humdrumR corpus — census","title":"Tabulate records and tokens in a humdrumR corpus — census","text":"census tabulates raw \"size\" humdrumR corpus, including total number records tokens. census one humdrumR's basic corpus summary functions.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/census.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tabulate records and tokens in a humdrumR corpus — census","text":"","code":"census(   humdrumR,   dataTypes = \"GLIMDd\",   by = Filename,   removeEmpty = FALSE,   drop = FALSE )  census(humdata)[i]  # S3 method for humCensus print(censusTable, showEach = TRUE, screenWidth = options(\"width\")$width - 10L)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/census.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tabulate records and tokens in a humdrumR corpus — census","text":"humdrumR humdrumR object dataTypes types humdrum records include census. Legal values 'G', 'L', '', 'M', 'D', 'd' combination (e.g., \"LIM\"). (see humdrum table documentation Fields section explanation.). arbitrary expression indicates group data. removeEmpty (logical, length == 1) set TRUE, groups zero tokens included humCensus table. drop drop = TRUE, normal data.table returned instead humCensus table. numeric, selects rows index. character, string matched regular expression \"-group\" names.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/census.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tabulate records and tokens in a humdrumR corpus — census","text":"census returns special data.frame called humCensus table. humCensus table five columns information: Records total number records. Tokens total number tokens. (unique) number unique tokens Characters total number characters. (includes humdrum control characters like * !!.) (per token) simply Characters / Tokens, indicating mean length token. default, census tabulates data within files corpus, file tabulated row humCensus table. Rows labeled filename. humCensus object printed, totals across files printed well---(unique) (per token) values calculated across files well, summed. argument can used tabulate data across divisions data (see next section).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/census.html","id":"tabulate-by-other-groups","dir":"Reference","previous_headings":"","what":"Tabulate \"by\" other groups","title":"Tabulate records and tokens in a humdrumR corpus — census","text":"argument census indicates groupings data tabulate within, grouping across filenames corpus default. can arbitrary expression evaluated inside humdrum table, like groupby argument /within call. expression must full length humdrum table.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/cents.html","id":null,"dir":"Reference","previous_headings":"","what":"12-tone equal-temperament cent representation — cents","title":"12-tone equal-temperament cent representation — cents","text":"default, output cents simply semits(x) * 100. However, tonalHarmonic value can modified cents produce cent-values alternate tunings. example, cents('g', tonalHarmonic = 3) returns 701.955000865387, \"pure\" third harmonic (3) 1.955 sharper equal-temperment. Thus, midi semits return integers, cents always returns real-number (double) values.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/cents.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"12-tone equal-temperament cent representation — cents","text":"","code":"cents(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   Key = NULL,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE,   tonalHarmonic = 2^(19/12) )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/cents.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"12-tone equal-temperament cent representation — cents","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). generic (logical, length == 1) generic = TRUE \"specific\" pitch information (accidentals qualites) discarded. simple (logical, length == 1) simple = TRUE \"compound\" pitch information (octave/contour) discarded. Key (diatonicSet something coercable diatonicSet, length == 1 | length == length(x)) input Key used parser, deparser, transposer. transposeArgs (list) transposeArgs can list arguments passed special call transpose. parseArgs (list) parseArgs can list arguments passed pitch parser. inPlace (logical, length == 1) argument effect input (x argument) character strings, extral, non-pitch information strings \"beside\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ). tonalHarmonic (numeric, length == 1) frequency \"tonal harmonic\" (perfect 10th) tuned ? default, value 2^(19/12), 12-tone equal-temperament10th. Pythagorean tuning, set tonalHarmonic = 3.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/cents.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"12-tone equal-temperament cent representation — cents","text":"TonalIntervals parsed frequency might also arbitrary cent deviations. example, cents(440 * 10/9, Exclusive = 'freq') returns 1082.404---correspond \"minor tone\" =440.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/cents.html","id":"basic-pitch-arguments","dir":"Reference","previous_headings":"","what":"Basic pitch arguments","title":"12-tone equal-temperament cent representation — cents","text":"pitch function standard arguments (details ), control details output. important generic simple arguments, allow control type pitch information returned.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/cents.html","id":"generic-vs-specific","dir":"Reference","previous_headings":"","what":"Generic vs Specific","title":"12-tone equal-temperament cent representation — cents","text":"generic = TRUE, specific pitch information (accidentals qualities) omitted output. alternative way controlling functionality, can use specific argument, specific == !generic. case atonal outputs, \"generic\" version pitch output: example, semits('c#', generic = TRUE) return 0, \"generic\" version C# C, corresponds 0. However, note generic version pitch follows key, semits('c#', generic = TRUE, Key = ':') return 1!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/cents.html","id":"simple-vs-compound","dir":"Reference","previous_headings":"","what":"Simple vs Compound","title":"12-tone equal-temperament cent representation — cents","text":"simple = TRUE, compound pitch information (octave contour) omitted output. alternative way controlling functionality, can use compound argument ,compound == !simple. actually one way might want divide compound intervals simple octave parts. example, might like call output -M2 (descending major 2nd) +m7 (ascending minor 7th octave ). functionality can controlled octave.round argument: see \"advanced deparsing\" section .","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/cents.html","id":"key","dir":"Reference","previous_headings":"","what":"Key","title":"12-tone equal-temperament cent representation — cents","text":"Key argument must diatonicSet, something can parsed one. Key argument passed parser, deparser, transpose---unless alternate Key passed transposeArgs parseArgs. Various deparsing options use Key argument; example, use implicitSpecies (see advanced parsing section) dependent Key. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function---means, cases, need explicitly anything Key argument! (want happen, need explicitly specify Key argument, Key = NULL.)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/cents.html","id":"parse-arguments","dir":"Reference","previous_headings":"","what":"Parse arguments","title":"12-tone equal-temperament cent representation — cents","text":"parseArgs argument must list() (named) arguments passed input parser. example, input representation uses \"X\" represent double sharps, specify kern('CX5', parseArgs = list(doublesharp = 'X')) get correct result (\"cc##\"). convenient shorthand, \"syntactic sugar,\" can specify parseArgs alternate way: Simply input parse(args...) unnamed argument pitch function. example, can get exact result typing kern('CX5', parse(doublesharp = 'X')).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/cents.html","id":"transpose-arguments","dir":"Reference","previous_headings":"","what":"Transpose arguments","title":"12-tone equal-temperament cent representation — cents","text":"transposeArgs argument must list() (named) arguments passed internal call transpose(), allowing us easily transpose pitch information. example, type kern(c('C', 'D', 'E'), transposeArgs = list(= 'M9')) can get output c('d', 'e', 'f#'). possible transpose args : (tonalInterval, length == 1 | length == (x)) (diatonicSet, length == 1 | length == (x))  (diatonicSet, length == 1 | length == (x)) real (logical, length == 1) transposition real tonal? relative (logical, length == 1) key-wise transposition based relative parallel keys? convenient shorthand, \"syntactic sugar,\" can specify transposeArgs alternate way: Simply input transpose(args...) unnamed argument pitch function. example, can get exact result typing kern(c('C', 'D', 'E'), transpose(= 'M9')).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/cents.html","id":"transposing-by-interval","dir":"Reference","previous_headings":"","what":"Transposing by interval","title":"12-tone equal-temperament cent representation — cents","text":"calling transpose() directly, argument can anything coercable tonalInterval, output transposed amount. real = FALSE, tonal transposition (within Key) performed. details transposition behavior, check transpose() docs.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/cents.html","id":"transposing-by-key","dir":"Reference","previous_headings":"","what":"Transposing by key","title":"12-tone equal-temperament cent representation — cents","text":"Another way transposing specifying input (\"\") key output (\"\") key. default, Key argument passed transpose , nothing actually happens. Thus, specify either key key, transposition happen /key Key. course, specify transposition happen keys specify. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function. specify key, Key field passed transpose key, result, pitches input transposed whatever keys target () key! real relative arguments give special control key-wise transposition works, check transpose() docs details!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/cents.html","id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"12-tone equal-temperament cent representation — cents","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.Advanced Deparsing Options Though pitch functions (listed top) outputs different pitch representation, share lot common \"deparsing\" functionality. basic arguments like generic simple work pitch function. using \"advanced\" deparsing arguments, can tweak deparsing done, generate even output representations! means controlling bin second step pipeline: Input representation |> Parsing |> Intermediate (tonalInterval) representation |> Transformation  |> Deparsing (DEPARSING ARGS GO ) |> Output representation Note arguments similar identical parallel parsing arguments. following \"advanced\" deparsing arguments available (read details ): Steps step.labels step.signed Species (accidentals qualities) qualities specifier.maximum Accidentals natural, flat, sharp, doubleflat, doublesharp Qualities perfect, major, minor, augment, diminish Implicit vs Explicit Species implicitSpecies absoluteSpecies explicitNaturals cautionary memory, memoryWindows Octave octave.integer , , octave.offset octave.round octave.relative, octave.absolute String parsing parts sep. \"advanced\" arguments can used directly pitch function: example, kern(x, qualities = TRUE). humdrumR pitch functions associated default deparsing arguments. example, use kern(), flat set (default) \"-\". However, wanted print **kern-like pitch data, except different flat symbol, like \"_\", modify deparser: kern('Eb5', flat = \"_\"). overrides default value **kern, output \"ee_\" instead \"ee-\".","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/cents.html","id":"steps","dir":"Reference","previous_headings":"","what":"Steps","title":"12-tone equal-temperament cent representation — cents","text":"representations \"tonal\" pitch information include representation diatonic steps. can control deparser writes diatonic steps using step.labels argument. step.labels argument must atomic vector unique values, length positive multiple seven. Examples step.labels arguments currently used humdrumR pitch functions include: step.labels = c('', 'B', 'C', 'D', 'E', 'F', 'G') step.labels = c('', 'II', 'III', 'IV', 'V', 'VI', 'VII') step.labels = c('d', 'r', 'm', 'f', 's', 'l', 't') step.labels NULL, steps assumed printed integers, including negative integers representing downward steps. also step.signed (logical, length == 1) argument: step.signed = TRUE, lowercase versions step.labels interpreted negative (downward) steps uppercase versions step.labels interpreted positive (upwards) steps. option used, example, default kern() helmholtz() parsers.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/cents.html","id":"species","dir":"Reference","previous_headings":"","what":"Species","title":"12-tone equal-temperament cent representation — cents","text":"tonal pitch representations, \"specific\" versions tonal pitches---tonal \"species\"---indicated \"specifiers\": either accidentals qualities. qualities (logical, length == 1) argument indicates whether accidentals used (qualities = FALSE) qualities (qualities = TRUE). specifiers can repeated number times, like \"triple sharps\" \"doubly augmented\"; specifier.maximum (integer, length == 1) argument sets maximum limit number specifiers write. example, force triple sharps (\"###\") double sharps (\"##\") deparse just \"#\", specifying specifier.maximum = 1L.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/cents.html","id":"accidentals","dir":"Reference","previous_headings":"","what":"Accidentals","title":"12-tone equal-temperament cent representation — cents","text":"qualities = FALSE deparser print accidentals three types: naturals, flats, sharps. natural, flat, /sharp (character, length == 1) arguments can used indicate accidentals printed output. example, set kern('Eb5', flat = 'flat') get output \"eeflat\". Examples accidental argument combinations currently used humdrumR pitch functions include: (flat = \"b\", sharp = \"#\") ->  pitch() (flat = \"-\", sharp = \"#\") ->  kern() (flat = \"es\", sharp = \"\") -> lilypond() (flat = \"-\", sharp = \"+\") -> degree() doubleflat, doublesharp (character, length == 1) arguments NULL default, can set special symbol wanted represent two sharps flats. example, modify pitch() use special double sharp symbol: pitch(\"f##\", doublesharp = \"x\") output \"Fx4\". printing naturals controlled natural argument. However, default, humdrumR deparsers printing naturals. can force naturals print setting explicitNaturals (logical, length == 1) argument TRUE. exact behavior explicitNaturals depends implicitSpecies, absoluteSpecies, Key argument (details ).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/cents.html","id":"qualities","dir":"Reference","previous_headings":"","what":"Qualities","title":"12-tone equal-temperament cent representation — cents","text":"qualities = TRUE deparser print qualities, five types: perfect, minor, major, augmented, diminished. perfect, major, minor, diminish, /augment (character, length == 1) arguments can used indicate qualities printed output. (Note: talking interval/degree qualities , chord qualities!) example, can write interval(c(\"g-\", \"f#\"), augment = 'aug', diminish = 'dim') output c(\"+dim5\", \"+aug4\"). Examples quality argument combinations currently used humdrumR pitch functions include: parse(major = \"M\", minor = \"m\", perfect = \"P\", diminish = \"d\", augment = \"\") parse(diminish = \"o\", augment = \"+\")","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/cents.html","id":"implicit-vs-explicit-species","dir":"Reference","previous_headings":"","what":"Implicit vs Explicit Species","title":"12-tone equal-temperament cent representation — cents","text":"musical data, specifiers (e.g., accidentals qualities) explicitly indicated; instead, must infer species pitch context---like key signature!.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/cents.html","id":"from-the-key","dir":"Reference","previous_headings":"","what":"From the Key","title":"12-tone equal-temperament cent representation — cents","text":"important argument implicitSpecies (logical, length == 1): implicitSpecies = TRUE, species input without explicit species indicated interpreted using Key. example, kern('C', Key = ':', parse(implicitSpecies = TRUE)) parsed \"C#\" C sharp major. kern('C', Key = ':', parse(implicitSpecies = TRUE)) parsed \"C\" C natural minor. kern('C', Key = '-:', parse(implicitSpecies = TRUE)) parsed \"C-\" C flat -flat minor. default, input already specifiers, interpreted absolutely---overriding \"implicit\" Key---, even implicitSpecies = TRUE. Thus, major: kern(\"C#\", Key = ':', parse(implicitSpecies = TRUE)) parsed \"C#\". \"#\" unnecessary. kern(\"Cn\", Key = ':', parse(implicitSpecies = TRUE)) parsed \"C\". \"n\" overrides Key. kern(\"C#\", Key = ':', parse(implicitSpecies = TRUE)) parsed \"C#\". \"#\" overrides Key. However! can also change behavior setting absoluteSpecies (logical, length == 1) argument FALSE. , specifiers input interpreted \"top \" key accidental: kern(\"C#\", Key = ':', parse(implicitSpecies = TRUE, absoluteSpecies = FALSE)) parsed \"C##\". \"#\" input added \"#\" Key, resulting double sharp! unusual behavior, absolute pitch representations like **kern. However, use scale chord degrees, absoluteSpecies = FALSE might appropriate. example, reading figured bass key E minor, \"b7\" figure E bass interpreted double flat (diminished) 7th (Db E)! data encoded, use absoluteSpecies = FALSE.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/cents.html","id":"memory","dir":"Reference","previous_headings":"","what":"Memory","title":"12-tone equal-temperament cent representation — cents","text":"musical data, assume accidental note \"stays effect\" scale step next bar, different accidental replaces . Fortunately, humdrumR parser (tonalInterval()) also knows parse data encoded \"memory\" way. memory = TRUE, accidental (quality) input note \"remembered\" previous appearances scale step. example, kern(c(\"D#\", \"E\", \"D\", \"E\", \"Dn\", \"C\", \"D\"), parse(memory = TRUE)) parsed c(\"D#\", \"E\", \"D#\", \"E\", \"D\", \"C\", \"D\") want \"memory\" last specific time windows (like bars), can also specify memoryWindows argument. memoryWindows must atomic vector length input (x argument). unique value within memoryWindows vector treated \"window\" within memory operates. common use case pass Bar field humdrumR dataset memoryWindows! memory memoryWindows argument work whatever values implicitSpecies absoluteSpecies specified! Though examples use accidentals, arguments effect parsing qualities (qualities = TRUE).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/cents.html","id":"octave","dir":"Reference","previous_headings":"","what":"Octave","title":"12-tone equal-temperament cent representation — cents","text":"final piece information encoded () pitch representations indication \"compound pitch\"--- incorporating octave information. humdrumR octaves always defined terms scale steps: two notes scale degree/letter name always octave. mainly comes regards Cb B#: Cb4 semitone ; B#3 enharmonically middle-C.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/cents.html","id":"integer-octaves","dir":"Reference","previous_headings":"","what":"Integer Octaves","title":"12-tone equal-temperament cent representation — cents","text":"simplest way octave information can encoded integer value, Scientific Pitch. need parse integer-encoded octaves, set octave.integer (logical, length == 1) argument TRUE. default, humdrumR considers \"central\" octave (octave == 0) octave , equivalently, unison. However, different octave used central octave, can specify octave.offset (integer, length == 1) argument. illustrate, default Scientific Pitch parser used arguments: kern('C5', parse(octave.integer = TRUE, octave.offset = 4) Returns \"cc\" (octave middle C).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/cents.html","id":"non-integer-octave-markers","dir":"Reference","previous_headings":"","what":"Non-integer Octave Markers","title":"12-tone equal-temperament cent representation — cents","text":"octave.integer = FALSE, humdrumR parser instead looks three possible symbols indicate octave information. symbols controlled using , , (character, length == 1) arguments. symbol, symbol, interpreted \"central\" octave; repeating strings symbols indicate increasing positive () negative () octaves. example, lilypond notation, , represents lower octaves, ' (single apostrophe) represents upper octaves. default lilypond() parser uses arguments: pitch(c(\"c\", \"c\", \"c'\"), parse(octave.integer = FALSE, = \"'\", = \",\", octave.offset = 1)) Returns c(\"C2\", \"C3\", \"C4\"). (Note lilypond makes octave  central octave, using octave.offset = 1.)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/cents.html","id":"octave-rounding-","dir":"Reference","previous_headings":"","what":"Octave \"Rounding\"","title":"12-tone equal-temperament cent representation — cents","text":"situations, pitch data might interpret \"boundaries\" octaves little differently. absolute pitch representations (e.g., kern(), pitch()), \"boundary\" one octave next B (degree 7) C (degree 1). However, example, working data representing intervals, might think \"octave\" spanning range -P4 (G) +P4 (f). case, \"octave boundary\" centered around unison (), rather starting middle-C/unison. data represented way, use octave.round argument; octave.round must rounding function, either round, floor, ceiling, trunc, expand. functions indicate interpret simple pitches \"rounding\" nearest C/unison. default behavior pitch representations octave.round = floor: scale step rounded downwards nearest C. B associated C 7 steps . , hand, octave.round = round, scale-steps \"rounded\" closest C, B associated closer C . Indeed, octave.round = round gets us -P4 <-> +P4 behavior mentioned earlier! working parsing intervals, octave.round option allows control \"simple part\" (less octave) compound interval represented. example, might think ascending major 12th ascending octave plus ascending perfect 5th: ** +P8 + P5**. encode interval two ascending octaves minus perfect fourth: + P15 - P4. following table illustrates different octave.round arguments \"partition\" compound intervals simple parts octaves: Notice , octave.floor used, simple intervals represented ascending. parsing \"absolute\" pitch representations, octave.round option allows control octave notes associated . following table illustrates:","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/cents.html","id":"absolute-or-relative-contour-octave","dir":"Reference","previous_headings":"","what":"Absolute or Relative (contour) Octave","title":"12-tone equal-temperament cent representation — cents","text":"notation encoding schemes, \"octave\" note interpreted relative previous note, rather absolute reference. prominent system Lilypond's relative octave entry style. style often used combination scale degree representations---RS200 corpus. example, data set might say Re Mi vSo La Ti , \"v\" indicating jump . activate relative-octave parsing, set octave.relative = TRUE---alternatively, can use octave.absolute = FALSE, equivalent. relative-octave data, assume octave indications indicate shift relative previous note. usually used combination octave markers like \"^\" () \"v\" (). Different combinations octave.round allow us parse different behaviors: octave.round = round, marker (marker) indicates note pitch closest previous pitch. Octave markers indicate alterations assumption. always, based scale steps, semitones! fourth \"closer\" fifth, regardless quality: C F# ascending C Gb descending! ascending diminished 5th written C ^Gb---= ^. octave.round = floor, marker (marker) indicates note octave previous pitch. Octave markers indicate alterations assumption. setting, going C B always requires mark.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/cents.html","id":"string-parsing","dir":"Reference","previous_headings":"","what":"String Parsing","title":"12-tone equal-temperament cent representation — cents","text":"addition three types musical parsing considerations reviewed (steps, species, octaves), also general string-parsing issues can consider/control.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/cents.html","id":"parts-and-order","dir":"Reference","previous_headings":"","what":"Parts and Order","title":"12-tone equal-temperament cent representation — cents","text":"far () discussed various ways tonal pitch information (step, species, octave) can encoded, humdrumR parser can modified handle different options. However, two general parsing issues/options consider: information encoded, order? parts argument can specifyied indicate . parts argument must character vector length 1--3. characters must partial match either \"step\", \"species\", \"octave\". presense strings parts vector indicate information parsed. order strings indicates order pieces pitch information encoded input strings. illustrate, imagine input data identical standard interval representation---e.g., M2 P5---except quality appears step---e.g., 2M 5P. call interval(c(\"2M\", \"5P\"), parse(parts = c(\"step\", \"species\"))) sure enough get correct parse! One final string-parsing argument sep, indicates character string separating pitch information components: common case comma space. example, use parse command like : kern(\"E flat 5\", parse(flat = \"flat\", sep = \" \")).","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/chord.html","id":null,"dir":"Reference","previous_headings":"","what":"","title":"","text":"function outputs generic \"jazz\" chord symbol representation tonal harmony.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/chord.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"","text":"","code":"chord(   x,   ...,   Key = NULL,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/chordDeparsing.html","id":null,"dir":"Reference","previous_headings":"","what":"Generating (","title":"Generating (","text":"humdrumR includes easy--use system generating variety tertian harmony (chord) representations, can flexibly modified users. \"hood\" humdrumR represents tonal chord information using underlying representation, typically extracted input data using chord parser. representation can \"deparsed\" variety predefined output formats (like **harm), new formats create!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/chordDeparsing.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generating (","text":"Deparsing second step chord function processing pipeline: Input representation |> Parsing |> Intermediate (tertianSet) representation |> Transformation  |> Deparsing (DEPARSING ARGS GO ) |> Output representation Various pitch representations can generated using predefined chord functions like chord() tertian(), roman(). functions use common deparsing framework, specified using different combinations arguments deparser. modifying \"deparsing\" arguments, can exercise fine control want pitch information represented output.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/chordFunctions.html","id":null,"dir":"Reference","previous_headings":"","what":"Parsing and deparsing chord information — chordFunctions","title":"Parsing and deparsing chord information — chordFunctions","text":"functions can used extract \"translate,\" otherwise modify, data representing tertian harmony information. functions :","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/chordFunctions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parsing and deparsing chord information — chordFunctions","text":"chord() figuredBass() harm() roman() tertian()","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/chordParsing.html","id":null,"dir":"Reference","previous_headings":"","what":"Parsing chord information — chordParsing","title":"Parsing chord information — chordParsing","text":"humdrumR includes easy--use powerful system parsing tertian harmony information: various basic chord representations (including numeric character-string representations) can \"parsed\"---read interpreted humdrumR. part, parsing automatically happens \"behind scenes\" whenever use humdrumR chord function, like harm() roman(), chord().","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/chordParsing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parsing chord information — chordParsing","text":"","code":"tertianSet(...)  # S3 method for tertianSet tertianSet(x, ...)  # S3 method for logical tertianSet(x, ...)  # S3 method for `NULL` tertianSet(x, ...)  # S3 method for numeric tertianSet(x)  # S3 method for integer tertianSet(x)  # S3 method for character tertianSet(x, ..., Exclusive = NULL, multiDispatch = FALSE)"},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/chordTransformer.html","id":null,"dir":"Reference","previous_headings":"","what":"Parsing and deparsing chord information. — chordTransformer","title":"Parsing and deparsing chord information. — chordTransformer","text":"functions used work chord information.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/chordTransformer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parsing and deparsing chord information. — chordTransformer","text":"","code":"figuredBass(   x,   ...,   Key = NULL,   Exclusive = NULL,   parseArgs = list(),   transposeArgs = list(),   figurationArgs = list(),   inPlace = FALSE,   memoize = TRUE,   deparse = TRUE )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/chordTransformer.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parsing and deparsing chord information. — chordTransformer","text":"xxx Tertian sets can read/wrote various ways.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/collapseHumdrum.html","id":null,"dir":"Reference","previous_headings":"","what":"","title":"","text":"collapseHumdrum allows collapse data field across across groups within data indicated argument. Data \"collapsed\" either pasting data string, putting list. collapseStops, collapsePaths, collapseRecords built-calls collapseHumtab, additional optimizations.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/collapseHumdrum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"","text":"","code":"collapseHumdrum(   humdrumR,   by,   collapseField = getActiveFields(humdrumR)[1],   dataTypes = \"GLIMDd\",   collapseAtomic = TRUE,   sep = \" \" )  collapseStops(   humdrumR,   collapseField = getActiveFields(humdrumR)[1],   collapseAtomic = TRUE,   sep = \" \" )  collapsePaths(   humdrumR,   collapseField = getActiveFields(humdrumR)[1],   collapseAtomic = TRUE,   sep = \" \" )  collapseRecords(   humdrumR,   collapseField = getActiveFields(humdrumR)[1],   collapseAtomic = TRUE,   sep = \" \" )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/collapseHumdrum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"","text":"humdrumR humdrumR data object. (character) vector field names group data . Data collapseField collapsed within groups. collapseField (character, length == 1) target field humdrumR data collapse. Defaults first active field. dataTypes (character) types humdrum records collapse. Legal values 'G', 'L', '', 'M', 'D', 'd' combination (e.g., \"LIM\"). collapseAtomic (logical, length == 1) TRUE, data collapsed single character string. FALSE, data conctanated list. sep (character, length == 1) collapseAtomic == TRUE, collapsed tokens separated string.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/degree.html","id":null,"dir":"Reference","previous_headings":"","what":"Tonal scale degree representation (absolute) — degree","title":"Tonal scale degree representation (absolute) — degree","text":"humdrum **degree **deg interpretations represent Western \"scale degrees\" two slightly different formats. **degree representation, octave pitch represented \"absolutely,\" standard octave scheme scientific pitch. **deg representation, octave pitch indicated relative previous pitch--- \"^\" indicates pitch higher previous pitch \"v\" indicates pitch lower previous pitch.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/degree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tonal scale degree representation (absolute) — degree","text":"","code":"degree(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   Key = NULL,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )  deg(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   Key = NULL,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/degree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tonal scale degree representation (absolute) — degree","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). generic (logical, length == 1) generic = TRUE \"specific\" pitch information (accidentals qualites) discarded. simple (logical, length == 1) simple = TRUE \"compound\" pitch information (octave/contour) discarded. Key (diatonicSet something coercable diatonicSet, length == 1 | length == length(x)) input Key used parser, deparser, transposer. transposeArgs (list) transposeArgs can list arguments passed special call transpose. parseArgs (list) parseArgs can list arguments passed pitch parser. inPlace (logical, length == 1) argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/degree.html","id":"basic-pitch-arguments","dir":"Reference","previous_headings":"","what":"Basic pitch arguments","title":"Tonal scale degree representation (absolute) — degree","text":"pitch function standard arguments control details output. important generic simple arguments, allow control type pitch information returned.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/degree.html","id":"generic-vs-specific","dir":"Reference","previous_headings":"","what":"Generic vs Specific","title":"Tonal scale degree representation (absolute) — degree","text":"generic = TRUE, specific pitch information (accidentals qualities) omitted output. alternative way controlling functionality, can use specific argument, specific == !generic. case atonal functions, \"generic\" version pitch output: example, semits('c#', generic = TRUE) return 0, \"generic\" version C# C, corresponds 0. However, note generic version pitch follows key, semits('c#', generic = TRUE, Key = ':') return 1!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/degree.html","id":"simple-vs-compound","dir":"Reference","previous_headings":"","what":"Simple vs Compound","title":"Tonal scale degree representation (absolute) — degree","text":"simple = TRUE, compound pitch information (octave contour) omitted output. alternative way controlling functionality, can use compound argument ,compound == !simple. actually one way might want divide compound intervals simple octave parts. example, might like call output -M2 (descending major 2nd) +m7 (ascending minor 7th octave ). functionality can controlled octave.round argument: see pitch deparsing documentation.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/degree.html","id":"key","dir":"Reference","previous_headings":"","what":"Key","title":"Tonal scale degree representation (absolute) — degree","text":"Key argument must diatonicSet, something can parsed one. Key argument passed parser, deparser, transpose---unless alternate Key passed transposeArgs parseArgs. Various deparsing options use Key argument; example, use implicitSpecies (see advanced parsing section) dependent Key. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function---means, cases, need explicitly anything Key argument! (want happen, need explicitly specify Key argument, Key = NULL.)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/degree.html","id":"parse-arguments","dir":"Reference","previous_headings":"","what":"Parse arguments","title":"Tonal scale degree representation (absolute) — degree","text":"parseArgs argument must list() (named) arguments passed input parser. example, input representation uses \"X\" represent double sharps, specify kern('CX5', parseArgs = list(doublesharp = 'X')) get correct result (\"cc##\"). convenient shorthand, \"syntactic sugar,\" can specify parseArgs alternate way: Simply input parse(args...) unnamed argument pitch function. example, can get exact result typing kern('CX5', parse(doublesharp = 'X')).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/degree.html","id":"transpose-arguments","dir":"Reference","previous_headings":"","what":"Transpose arguments","title":"Tonal scale degree representation (absolute) — degree","text":"transposeArgs argument must list() (named) arguments passed internal call transpose(), allowing us easily transpose pitch information. example, type kern(c('C', 'D', 'E'), transposeArgs = list(= 'M9')) can get output c('d', 'e', 'f#'). possible transpose args : (tonalInterval, length == 1 | length == (x)) (diatonicSet, length == 1 | length == (x))  (diatonicSet, length == 1 | length == (x)) real (logical, length == 1) transposition real tonal? relative (logical, length == 1) key-wise transposition based relative parallel keys? convenient shorthand, \"syntactic sugar,\" can specify transposeArgs alternate way: Simply input transpose(args...) unnamed argument pitch function. example, can get exact result typing kern(c('C', 'D', 'E'), transpose(= 'M9')).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/degree.html","id":"transposing-by-interval","dir":"Reference","previous_headings":"","what":"Transposing by interval","title":"Tonal scale degree representation (absolute) — degree","text":"calling transpose() directly, argument can anything coercable tonalInterval, output transposed amount. real = FALSE, tonal transposition (within Key) performed. details transposition behavior, check transpose() docs.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/degree.html","id":"transposing-by-key","dir":"Reference","previous_headings":"","what":"Transposing by key","title":"Tonal scale degree representation (absolute) — degree","text":"Another way transposing specifying input (\"\") key output (\"\") key. default, Key argument passed transpose , nothing actually happens. Thus, specify either key key, transposition happen /key Key. course, specify transposition happen keys specify. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function. specify key, Key field passed transpose key, result, pitches input transposed whatever keys target () key! real relative arguments give special control key-wise transposition works, check transpose() docs details!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/degree.html","id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Tonal scale degree representation (absolute) — degree","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/delta.html","id":null,"dir":"Reference","previous_headings":"","what":"Lagged differences — delta","title":"Lagged differences — delta","text":"Calculate sequential differences values numeric vectors.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/delta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lagged differences — delta","text":"","code":"delta(x, lag, skip, init, right, ...)  # S3 method for default delta(   x,   lag = 1,   skip = is.na,   init = as(NA, class(x)),   right = FALSE,   groupby = list(),   orderby = list(),   ... )  # S3 method for matrix delta(x, margin = 2L, ...)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/delta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lagged differences — delta","text":"x (numeric vector.) NULL values returned NULL. lag (Non-zero integer.) lag use. Results look like: x[] - x[- lag]. skip (function.) must function can applied x returns logical vector length. TRUE values skipped calculations. default, skip function .na, NA values input (x argument) skipped. skipped values returned output vector. init (Atomic value class x, length(init) <= lag.) NA values beginning (end right == TRUE) filled values summing. right (single logical value) init padding \"right\" (end vector)? default, right == FALSE init padding beginning output. groupby (vector length x, list vectors) Differences calculated across groups indicated groupby vector(s). orderby (vector length x, list vectors) Differences x calculated based order orderby vector(s), determined base::order().","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/delta.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Lagged differences — delta","text":"delta similar base-R diff(). However, delta favored humdrumR use : output always length  input. achieved padding beginning end output with1 NA values (options). groupby argument, automatically used humdrumR () commands constrain differences within files/spines/paths humdrum data. groupby approach (details ) generally faster applying commands within groupby groups. (can) automatically skip NA () values. applied matrix, delta applied separately column, unless margin set 1 (rows) , higher-dimensional array, higher value.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/delta.html","id":"initial-padding-values","dir":"Reference","previous_headings":"","what":"Initial/padding values","title":"Lagged differences — delta","text":"lagged pair numbers vector summed/subtracted. leaves abs(lag) numbers end nothing pair . example, lag == 1, indices getting subtracted look like : \\(x_1 - x_?\\) \\(x_2 - x_1\\) \\(x_3 - x_2\\) \\(x_4 - x_3\\) \\(x_5 - x_4\\) lag == 3: \\(x_1 - x_?\\) \\(x_2 - x_?\\) \\(x_3 - x_?\\) \\(x_4 - x_1\\) \\(x_5 - x_2\\) init argument (\"initial\") value, values, pair first lag values. default, init NA, since n + NA n - NA , NA, output vector padded NA values. lag == 3 : \\(x_1 - NA\\) \\(x_2 - NA\\) \\(x_3 - NA\\) \\(x_4 - x_1\\) \\(x_5 - x_2\\) However, init argument can 1 abs(lag) numeric values. result, lag==3 : \\(x_1 - init_1\\) \\(x_2 - init_2\\) \\(x_3 - init_3\\) \\(x_4 - x_1\\) \\(x_5 - x_2\\) right == TRUE, init values placed end, like: \\(x_4 - x_1\\) \\(x_5 - x_2\\) \\(init[1] - x_3\\) \\(init[2] - x_4\\) \\(init[3] - x_5\\) init argument functions similarly init argument Reduce().","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/delta.html","id":"negative-lag","dir":"Reference","previous_headings":"","what":"Negative lag","title":"Lagged differences — delta","text":"lag negative, differences simply reversed, resulting numbers equivalent positive lag, * -1. \\(x_1 - NA\\) \\(x_2 - x_1\\) \\(x_3 - x_2\\) \\(x_4 - x_3\\) \\(x_5 - x_5\\) \\(NA - x_1\\) \\(x_1 - x_2\\) \\(x_2 - x_3\\) \\(x_3 - x_4\\) \\(x_4 - x_5\\)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/delta.html","id":"grouping","dir":"Reference","previous_headings":"","what":"Grouping","title":"Lagged differences — delta","text":"many cases want perform lagged calculations vector, across certain boundaries. example, vector includes data multiple pieces, want calculate melodic intervals pieces, within pieces. groupby argument indicates one, , grouping vectors, break x (input) argument groups. groupby vectors given, change vector indicates boundary. Value pairs cross groups treated beginning. Basically, using groupby argument function similar identical using tapply(x, groupby, laggedFunction, ...) using groupby expession call ().humdrumR. However, using groupby argument directly usually much faster, specially optimized functions. common use case humdrum data, looking \"melodies\" within spines. , want groupby = list(File, Spine, Path). fact, humdrumR () calls automatically feed three fields groupby arguments certain functions: mint, delta, sigma, lag, ditto. use delta call (), automatically calculate delta \"melodic\" way, within spine path file. However, wanted, instance, calculate differences across spines (like harmonic intervals) manually set groupby = list(File, Record).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/delta.html","id":"order","dir":"Reference","previous_headings":"","what":"Order","title":"Lagged differences — delta","text":"performing lagged calculations, typically assume order values input vector (x) order want \"lag\" across. E.g., first element \"\" second element, \"\" third element, etc. [Humdrum tables][humTable] always ordered File > Piece > Spine > Path > Record > Stop. Thus, lagged calculations across fields humtable , default, \"melodic\": next element next element spine path. example, consider data: default order tokens (Token field) b c d e f. wanted instead lag across tokens harmonically (across records) need specifiy different order example, say orderby = list(File, Record, Spine)---lagged function interpret Token field d b e c f. another example, note Stop comes last order. consider happens stops data:","code":"**kern  **kern a       d b       e c       f *-      *- **kern  **kern a       d b D     e g c A     f a *-      *- ```  The default ordering here (`File > Spine > Record > Stop`) \"sees\" this in the order `a b D c A d e g f a`. That may or may not be what you want! If we wanted, we could reorder such that `Stop` takes precedence over `Record`: `orderby = list(File, Spine, Stop, Record)`. The resulting order would be `a b c d e f D G g a`.       [humTable]: R:humTable"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/delta.html","id":"invertability","dir":"Reference","previous_headings":"","what":"Invertability","title":"Lagged differences — delta","text":"sigma delta functions inverses , meaning right arguments set, sigma(delta(x)) == x delta(sigma(x)) == x. words, two functions \"reverse\" . key init argument needs set 0, arguments (lag, skip, groupby, etc.) need match. actually,  sigma(delta(x, init = 0, ...)) == x delta(sigma(x), init = 0)) == x. take differences values (delta(x)), resulting differences tell us fully reconstruct original unless know \"start\" (constant offset). example, delta(c(5, 7, 5, 6)) == c(NA, 2, -2, 1) know input goes 2, back 2, 1, starting value (first 5) lost. call sigma , get: sigma(c(NA, 2, -2, 1)) == c(0, 2,0, 1) get right contour, offset constant 5. call delta(x, init = 0) necessary constant (first value) kept beginning vector delta(c(5, 7, 5, 6), init = 0) == c(5, 2, -2, 1) sigma gets want, full invertability: sigma(delta(c(5, 7, 5, 6), init = 0)) == c(5, 7, 5, 6) Alternatively, specify necessary constant init argument sigma: sigma(delta(c(5, 7, 5, 6)), init = 5) == c(5, 7, 5, 6) init arguments two functions complementary. Currently, right argument delta complement sigma, invertability holds true right = FALSE (default).","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/diatonicSet.html","id":null,"dir":"Reference","previous_headings":"","what":"Tonal (diatonic) sets — diatonicSet","title":"Tonal (diatonic) sets — diatonicSet","text":"diatonicSet one humdrumR's types tonal data, representing Western diatonic keys. part, users need interact diatonicSets directly---rather, diatonicSets work behind scene numerous humdrumR pitch functions. See keyRepresentations keyTransformations documentation details usage functionality Tonality humdrumR vignette detailed explanation theory specifics diatonicSets.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/diatonicSet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tonal (diatonic) sets — diatonicSet","text":"","code":"dset(root = 0L, signature = root, alterations = 0L)  is.diatonicSet(x)  is.diatonicSet(x)  order.diatonicSet(   x,   ...,   parallel = TRUE,   na.last = TRUE,   decreasing = FALSE,   method = c(\"auto\", \"shell\", \"radix\") )  # S4 method for diatonicSet,diatonicSet ==(e1, e2)  # S4 method for diatonicSet,diatonicSet Compare(e1, e2)  # S3 method for diatonicSet diatonicSet(x, ...)  # S3 method for logical diatonicSet(x, ...)  # S3 method for numeric diatonicSet(x)  # S3 method for integer diatonicSet(x)  # S3 method for character diatonicSet(x, Exclusive = NULL, str, Key = NULL, ..., multiDispatch = FALSE)  # S4 method for tertianSet as.character(x)  # S4 method for tertianSet,tertianSet ==(e1, e2)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/diatonicSet.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tonal (diatonic) sets — diatonicSet","text":"diatonicSet S4 subclass humdrumR's virtual class struct, inherits lot useful \"vector-like\" behaviors/functionality. constructor function dset can used create diatonicSets directly. three arguments corespond three slots: root, mode, alteration. inputs coerced match length. root argument attempt coerce character strings tonalIntervals, use LO5th value root. default, .character method, thus (via struct) show method, diatonicSets call key(). Thus, return diatonicSet command line (call print one one), see key interpretation representation printed.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/diatonicSet.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Tonal (diatonic) sets — diatonicSet","text":"Root integers representing root key line--fifths Signature integers representing signature (number accidentals) key. Alteration integers representing alterations diatonic set key represented two integers, Root Signature. Root simply tonic note key circle fifths. Signature value circle fifths, indicating diatonic mode. can think Signature value indicating number accidentals, negative numbers flats positive numbers sharps. can also think signature indicating much \"natural key\" (C major) slid line--fifths. traditional diatonic modes Western music occur wherever Signature - Tonic range -5:1: Signature - Tonic = +1 => Lydian Signature - Tonic = +0 => Major (Ionian) Signature - Tonic = -1 => Mixolydian Signature - Tonic = -2 => Dorian Signature - Tonic = -3 => Minor (Aeolian) Signature - Tonic = -5 => Locrian Signature - Tonic = -4 => Phyrgian Note can make diatonicSets Root outside Key. unusual, may result sets predict.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/diatonicSet.html","id":"alterations","dir":"Reference","previous_headings":"","what":"Alterations","title":"Tonal (diatonic) sets — diatonicSet","text":"Alteration slots (also integer) can used represent various \"altered\" scales. integer values interpreted seven-trit balanced ternary string. (\"trits\" ternary equivalent binary \"bits.\") Balanced ternary allows three digits, 0 (unaltered degree), 1 (sharpened degree), -1 (flattened degree). seven trits correspond seven scale degrees line--fifth indicated signature---.e., ordered lowest hightest line--fifths, relative root. (instance, Signature == 0, degrees c(-1, 0, 1, 2, 3, 4, 5).) ternary arrangement maps powers three scale degree, Alteration integer: ± 1: raise flatten 7th scale degree. ± 3: raise flatten 3rd scale degree. ± 9: raise flatten 6th scale degree. ± 27: raise flatten 2nd scale degree. ± 81: raise flatten 5th scale degree. ± 243: raise flatten 1st scale degree. ± 749: raise flatten 4th scale degree. example, consider Alteration == 26: balanced ternary representation, decimal integer 26 represented 1 0 0 1 0 -1 0. (words 1 \"27s  place\" -1 \"ones place\"---.e., 27 - 1). represents raised 2nd (27) lowered 7th (-1). Alteration integer allows us concisely represent 2,187 possible combinations raised lowered diatonic scale degrees! However, combined Signature slot, redundancy scale representation. example, melodic minor scale can represented major scale (Signature - Root == 0) lowered third degree (Alteration == -3) minor scale (Signature - Root == -3) raised 6ths 7ths (Alteration == 10). However, though two representations result set line--fifths, might consider conceptually different contexts, consider redundancy acceptable. Another case encoding redundancy Alteration - 1 (flatten 7th) exactly equivalent Signature - 1. Similarly, Alteration + 749 (raise 4th) exactly equivalent Signature + 1. Double-flat double-sharp degrees encodable diatonicSet. However, combination Signature slot, sets double-flat/sharps (like doubly-diminished 7ths) can encoded.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/diatonicSet.html","id":"arithmatic","dir":"Reference","previous_headings":"","what":"Arithmatic","title":"Tonal (diatonic) sets — diatonicSet","text":"Arithmetic diatonicSets defined. However, number useful arithmetic operations diatonicSets data types defined: XXXX Elaborate XXXX Need implement special logic adding Alterations! (Taking account Signature addition.)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/diatonicSet.html","id":"relational-operators","dir":"Reference","previous_headings":"","what":"Relational Operators","title":"Tonal (diatonic) sets — diatonicSet","text":"diatonicSets can compared using standard relational operations ==, !=. Two diatonicSets equal (according ==) slots (Root, Signature, Alteration) exactly identical. Ordinal comparisons (e.g., >, <=) diatonicSets Signature .","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/diatonicSet.html","id":"coercion","dir":"Reference","previous_headings":"","what":"Coercion","title":"Tonal (diatonic) sets — diatonicSet","text":"humdrumR knows coerce several base-R atomic types diatonicSets. can done using function---e.g., (3, \"diatonicSet\")---intuitively using function diatonicSet(). Coercision methods defined integer: interpreted root major key numeric: rounded nearest integer intepreted root major key character: interpreted using humdrumRs regular expression dispatch system, explained fully .","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/diatonicSetS4.html","id":null,"dir":"Reference","previous_headings":"","what":"Tonal (diatonic) sets — diatonicSetS4","title":"Tonal (diatonic) sets — diatonicSetS4","text":"diatonicSet one humdrumR's types tonal data, representing Western diatonic keys. part, users need interact diatonicSets directly---rather, diatonicSets work behind scene numerous humdrumR pitch functions. See keyRepresentations keyTransformations documentation details usage functionality Tonality humdrumR vignette detailed explanation theory specifics diatonicSets.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/diatonicSetS4.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tonal (diatonic) sets — diatonicSetS4","text":"","code":"diatonicSet(...)  dset(root = 0L, signature = root, alterations = 0L)  is.diatonicSet(x)  order.diatonicSet(   x,   ...,   parallel = TRUE,   na.last = TRUE,   decreasing = FALSE,   method = c(\"auto\", \"shell\", \"radix\") )  # S4 method for diatonicSet,diatonicSet ==(e1, e2)  # S4 method for diatonicSet,diatonicSet Compare(e1, e2)  # S4 method for tertianSet,tertianSet ==(e1, e2)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/diatonicSetS4.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tonal (diatonic) sets — diatonicSetS4","text":"diatonicSet S4 subclass humdrumR's virtual class struct, inherits lot useful \"vector-like\" behaviors/functionality. constructor function dset can used create diatonicSets directly. three arguments corespond three slots: root, mode, alteration. inputs coerced match length. root argument attempt coerce character strings tonalIntervals, use LO5th value root. default, .character method, thus (via struct) show method, diatonicSets call key(). Thus, return diatonicSet command line (call print one one), see key interpretation representation printed.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/diatonicSetS4.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Tonal (diatonic) sets — diatonicSetS4","text":"Root integers representing root key line--fifths Signature integers representing signature (number accidentals) key. Alteration integers representing alterations diatonic set key represented two integers, Root Signature. Root simply tonic note key circle fifths. Signature value circle fifths, indicating diatonic mode. can think Signature value indicating number accidentals, negative numbers flats positive numbers sharps. can also think signature indicating much \"natural key\" (C major) slid line--fifths. traditional diatonic modes Western music occur wherever Signature - Tonic range -5:1: Signature - Tonic = +1 => Lydian Signature - Tonic = +0 => Major (Ionian) Signature - Tonic = -1 => Mixolydian Signature - Tonic = -2 => Dorian Signature - Tonic = -3 => Minor (Aeolian) Signature - Tonic = -5 => Locrian Signature - Tonic = -4 => Phyrgian Note can make diatonicSets Root outside Key. unusual, may result sets predict.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/diatonicSetS4.html","id":"alterations","dir":"Reference","previous_headings":"","what":"Alterations","title":"Tonal (diatonic) sets — diatonicSetS4","text":"Alteration slots (also integer) can used represent various \"altered\" scales. integer values interpreted seven-trit balanced ternary string. (\"trits\" ternary equivalent binary \"bits.\") Balanced ternary allows three digits, 0 (unaltered degree), 1 (sharpened degree), -1 (flattened degree). seven trits correspond seven scale degrees line--fifth indicated signature---.e., ordered lowest hightest line--fifths, relative root. (instance, Signature == 0, degrees c(-1, 0, 1, 2, 3, 4, 5).) ternary arrangement maps powers three scale degree, Alteration integer: ± 1: raise flatten 7th scale degree. ± 3: raise flatten 3rd scale degree. ± 9: raise flatten 6th scale degree. ± 27: raise flatten 2nd scale degree. ± 81: raise flatten 5th scale degree. ± 243: raise flatten 1st scale degree. ± 749: raise flatten 4th scale degree. example, consider Alteration == 26: balanced ternary representation, decimal integer 26 represented 1 0 0 1 0 -1 0. (words 1 \"27s  place\" -1 \"ones place\"---.e., 27 - 1). represents raised 2nd (27) lowered 7th (-1). Alteration integer allows us concisely represent 2,187 possible combinations raised lowered diatonic scale degrees! However, combined Signature slot, redundancy scale representation. example, melodic minor scale can represented major scale (Signature - Root == 0) lowered third degree (Alteration == -3) minor scale (Signature - Root == -3) raised 6ths 7ths (Alteration == 10). However, though two representations result set line--fifths, might consider conceptually different contexts, consider redundancy acceptable. Another case encoding redundancy Alteration - 1 (flatten 7th) exactly equivalent Signature - 1. Similarly, Alteration + 749 (raise 4th) exactly equivalent Signature + 1. Double-flat double-sharp degrees encodable diatonicSet. However, combination Signature slot, sets double-flat/sharps (like doubly-diminished 7ths) can encoded.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/diatonicSetS4.html","id":"arithmetic","dir":"Reference","previous_headings":"","what":"Arithmetic","title":"Tonal (diatonic) sets — diatonicSetS4","text":"Arithmetic diatonicSets defined. However, number useful arithmetic operations diatonicSets data types defined: XXXX Elaborate XXXX Need implement special logic adding Alterations! (Taking account Signature addition.)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/diatonicSetS4.html","id":"relational-operators","dir":"Reference","previous_headings":"","what":"Relational Operators","title":"Tonal (diatonic) sets — diatonicSetS4","text":"diatonicSets can compared using standard relational operations ==, !=. Two diatonicSets equal (according ==) slots (Root, Signature, Alteration) exactly identical. Ordinal comparisons (e.g., >, <=) diatonicSets Signature .","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/diatonicSetS4.html","id":"coercion","dir":"Reference","previous_headings":"","what":"Coercion","title":"Tonal (diatonic) sets — diatonicSetS4","text":"humdrumR knows coerce several base-R atomic types diatonicSets. can done using function---e.g., (3, \"diatonicSet\")---intuitively using function diatonicSet(). Coercision methods defined integer: interpreted root major key numeric: rounded nearest integer intepreted root major key character: interpreted using humdrumRs regular expression dispatch system, explained fully .","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/ditto.html","id":null,"dir":"Reference","previous_headings":"","what":"Propagate data points to ","title":"Propagate data points to ","text":"ditto function allow \"fill\" null values vector non-null values earlier/later vector. default, \"forward,\" behavior fills null value previous (lower index) non-null value, . reverse argument can used cause \"backward\" filling, next (higher index) non-null value used. input begins (ends reverse == TRUE) null value, initial argument filled instead; defaults NA.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/ditto.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Propagate data points to ","text":"","code":"ditto(x, ...)  # S3 method for default ditto(   x,   null = function(x) is.na(x) | x == \".\",   initial = NA,   reverse = FALSE,   groupby = list(),   orderby = list() )  # S3 method for data.frame ditto(x, ...)  # S3 method for matrix ditto(x, margin = 2, ...)  # S3 method for humdrumR ditto(   x,   field = getActiveFields(x)[1],   ...,   newField = paste0(field, \"_ditto\") )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/ditto.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Propagate data points to ","text":"x vector. null Either logical vector (length(x) == length(null)), numeric vector positive indices, function , applied x returns appropriate logical/numeric vector. initial value (length == 1) class x, used pad beginning (end, reverse == TRUE) output, necessary. reverse (logical & length == 1) reverse == TRUE, \"non-null\" values coped overwrite null values earlier (lower indices) vector. groupby vector list vectors, length x. segment x delineated groupby vector(s) treated separately. margin vector giving subscripts function applied . E.g., matrix 1 indicates rows, 2 indicates columns. x named dimnames, can character vector selecting dimension names. field field (partially matched) humdrumR dataset dittoed? newField (character length == 1) name new (dittoed) field.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/ditto.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Propagate data points to ","text":"values considered \"null\" can controlled using null argument. null argument can either logical vector length input (x) argument, numeric vector positive indices, function , applied x returns appropriate logical/numeric vector. values x null == FALSE copied forward/backwards replace adjacent vales null == TRUE. default, null function \\(x) .na(x) | x == '.', means NA values string \".\" \"null\", overwritten adjacent values. ditto methods defined data.frames matrices. data.frame method simply applies ditto column data.frame separately. matrices, ditto can applied across columns (margin == 2), rows (margin == 1), dimensions. ditto method humdrumR object simply applies ditto , default, active field; thus ditto(humData) equivalent within(humData, newField <- ditto(.), dataTypes = 'Dd'). field argument can used indicated different field apply . result dittoing saved new field---newField argument can used control name new field.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/ditto.html","id":"grouping","dir":"Reference","previous_headings":"","what":"Grouping","title":"Propagate data points to ","text":"many cases want perform lagged calculations vector, across certain boundaries. example, vector includes data multiple pieces, want calculate melodic intervals pieces, within pieces. groupby argument indicates one, , grouping vectors, break x (input) argument groups. groupby vectors given, change vector indicates boundary. Value pairs cross groups treated beginning. Basically, using groupby argument function similar identical using tapply(x, groupby, laggedFunction, ...) using groupby expession call ().humdrumR. However, using groupby argument directly usually much faster, specially optimized functions. common use case humdrum data, looking \"melodies\" within spines. , want groupby = list(File, Spine, Path). fact, humdrumR () calls automatically feed three fields groupby arguments certain functions: mint, delta, sigma, lag, ditto. use delta call (), automatically calculate delta \"melodic\" way, within spine path file. However, wanted, instance, calculate differences across spines (like harmonic intervals) manually set groupby = list(File, Record).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/ditto.html","id":"order","dir":"Reference","previous_headings":"","what":"Order","title":"Propagate data points to ","text":"performing lagged calculations, typically assume order values input vector (x) order want \"lag\" across. E.g., first element \"\" second element, \"\" third element, etc. [Humdrum tables][humTable] always ordered File > Piece > Spine > Path > Record > Stop. Thus, lagged calculations across fields humtable , default, \"melodic\": next element next element spine path. example, consider data: default order tokens (Token field) b c d e f. wanted instead lag across tokens harmonically (across records) need specifiy different order example, say orderby = list(File, Record, Spine)---lagged function interpret Token field d b e c f. another example, note Stop comes last order. consider happens stops data:","code":"**kern  **kern a       d b       e c       f *-      *- **kern  **kern a       d b D     e g c A     f a *-      *- ```  The default ordering here (`File > Spine > Record > Stop`) \"sees\" this in the order `a b D c A d e g f a`. That may or may not be what you want! If we wanted, we could reorder such that `Stop` takes precedence over `Record`: `orderby = list(File, Spine, Stop, Record)`. The resulting order would be `a b c d e f D G g a`.       [humTable]: R:humTable"},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/expand.html","id":null,"dir":"Reference","previous_headings":"","what":"Expand numbers outwards from zero — expand","title":"Expand numbers outwards from zero — expand","text":"Expand complement base R rounding functions, particularly trunc.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/expand.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expand numbers outwards from zero — expand","text":"","code":"expand(x)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/expand.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Expand numbers outwards from zero — expand","text":"four base R functions---round, ceiling, floor, trunc---follow different logic round real numbers ingegers: round: round nearest integer either direction. floor: round downward towards negative infinity. Negative numbers rounded \"negative\" numbers. ceiling: round upward towards infinity. Negative numbers rounded \"less negative\" numbers. trunc: round \"inward\" towards zero. Negative numbers rounded \"less negative\" numbers, positive numbers still rounded downwards \"less positive\" numbers. Just ceiling compliments floor, humdrumR function expand acts compliment trunc: expand rounds \"outward\" away zero. Negative numbers rounded \"negative\" numbers positive numbers rounded \"positive\" numbers. table explains better words:","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/extractTandem.html","id":null,"dir":"Reference","previous_headings":"","what":"Get tandem interpretation information from humdrum data — extractTandem","title":"Get tandem interpretation information from humdrum data — extractTandem","text":"extractTandem extracts tandem interpretations raw Tandem spine humdrumR object.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/extractTandem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get tandem interpretation information from humdrum data — extractTandem","text":"","code":"extractTandem(Tandem, regex)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/extractTandem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get tandem interpretation information from humdrum data — extractTandem","text":"Tandem always Tandem field humdrumR object. regex (character, length == 1). single regular expression match tandem interpretations. include * beginning---* marker tandem interpretations already removed Tandem field.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/extractTandem.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get tandem interpretation information from humdrum data — extractTandem","text":"Every humdrumR object field called Tandem, vector strings accumulates tandem interpretations Spine. record, previous tandems occured spine listed (comma separated), recent appearing first. example, consider file: Tandem field two spines look like : Notice \"C:\" erased appearance \"G:\"---naive parser \"know\" \"C:\" \"G:\" related. earlier tandem (\"C:\") just pushed back onto stack. worry, humdrumR data parser recognize many common tandem interpretations (like *C: *G:) automatically parse present---case, put Key field automatically. However, Tandem field retained case data contains novel tandem intepretations humdrumR recognize.","code":"**kern **kern *C:    *C: *Ibass *Isoprn 2G     4g .      4f 2C     2e *G:    *G: 2D     2f# 2G     2g *-     *- \"\" \"C:\"                 \"C:\" \"Ibass,C:\"           \"Isoprn,C:\" \"Ibass,C:\"           \"Isoprn,C:\" \"Ibass,C:\"           \"Isoprn,C:\" \"Ibass,C:\"           \"Isoprn,C:\" \"G:,Ibass,C:\"        \"G:,Isoprn,C:\" \"G:,Ibass,C:\"        \"G:,Isoprn,C:\" \"G:,Ibass,C:\"        \"G:,Isoprn,C:\" \"G:,Ibass,C:\"        \"G:,Isoprn,C:\""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/extractTandem.html","id":"extracttandem","dir":"Reference","previous_headings":"","what":"extractTandem","title":"Get tandem interpretation information from humdrum data — extractTandem","text":"data contain novel/unknown tandem interpretations, can use extractTandem function pull Tandem field. first argument extractTandem must Tandem field humdrumR object. second argument (regex) regular expression matched tandem interpretations. token Tandem, recent match () retained. example, wanted manually extract key information Tandem field (humdrumR automatically ), call extractTandem(Tandem, \"[-Ga-g][#-]*:\").","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/figuredBass.html","id":null,"dir":"Reference","previous_headings":"","what":"Figured bass representation of harmony — figuredBass","title":"Figured bass representation of harmony — figuredBass","text":"function outputs figured bass representation tertian harmony.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/figuredBass.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Figured bass representation of harmony — figuredBass","text":"","code":"figuredBass(   x,   ...,   Key = NULL,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/fillThru.html","id":null,"dir":"Reference","previous_headings":"","what":"Propogate data points to ","title":"Propogate data points to ","text":"fillThru function allow \"fill\" null values vector non-null values earlier/later vector. default, \"foward,\" behavior fills null value previous (lower index) non-null value, . reverse argument can used cause \"backeward\" filling, next (higher index) non-null value used.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/fillThru.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Propogate data points to ","text":"","code":"fillThru(x, nonnull = function(x) !is.na(x) & x != \".\", reverse = FALSE)  fillForward(...)  fillBackwards(...)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/fillThru.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Propogate data points to ","text":"values considered \"non-null\" can controlled using nonnull argument. nonnull argument can either logical vector length input (x) argument, numeric vector positive indices, function , applied x returns appropriate logical/numeric vector.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/filterHumdrum.html","id":null,"dir":"Reference","previous_headings":"","what":"Filter humdrum data — filterHumdrum","title":"Filter humdrum data — filterHumdrum","text":"filterHumdrum command used filter humdrumR corpus Indexing humdrumR corpus (using [] [[]] operators) uses calls filterHumdrum!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/filterHumdrum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filter humdrum data — filterHumdrum","text":"","code":"filterHumdrum(humdrumR, ...)  removeEmptyFiles(humdrumR, fillfromTypes = \"D\")  removeEmptySpines(humdrumR, fillfromTypes = \"D\")  removeEmptyRecords(humdrumR, fillfromTypes = \"D\")  humdata[] # returns unchanged  humdata[x:y]  humdata['regex']  humdata[~expression]  humdata[[x:y]]  humdata[[ , x:y]]  humdata[['regex']]  humdata[[x:y, l:m]]"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/filterHumdrum.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Filter humdrum data — filterHumdrum","text":"filterHumdrum used similar manner withinHumdrum, taking number \"expressions\" (functions) arguments. (fact, expressions/function arguments passed directly internal call withinHumdrum.) difference expressions/functions fed filterHumdrum must predicate expressions return logical (TRUE/FALSE) vector. returned vector must also length input data (number rows humdrum table). (can use dofill~ expression want \"expand\" shorter outputs filtering pusposes.) filterHumdrum updates humdrum table's Filter field using logical (|) existing Filter field negation predicate: Filter | !Predicate. HumdrumR functions (mostly) ignore data points Filter == TRUE: print filtered humdrumR see filtered data points turned null data (.), calls withinHumdrum ignore filtered data. default, filterHumdrum completely removes files corpus data records filtered . However, can stop specifying removeEmptyFiles argumet FALSE. want remove empty files, spines, records, call removeEmptyFiles, removeEmptySpines, removeEmptyRecords.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/filterHumdrum.html","id":"indexing","dir":"Reference","previous_headings":"","what":"Indexing","title":"Filter humdrum data — filterHumdrum","text":"R, basic indexing operators, [] [[]], used select subsets data. many R data types (instance, base R lists) [single brackets] used \"shallower\" extraction [[double brackets]] used \"deeper\" extraction. HumdrumR corpus indexing follows basic pattern: [single brackets] used index humdrumR objects piece [[double brackets]] used index within pieces. (Accidentally writing [] need [[]] common error, watch !) Whether, indexing piece within, humdrumR objects can use three types indexing arguments: numeric (ordinal integers) character string (regular expressions) formula (arbitrary expressions) last option (formula) powerful option, indeed, first two options (numeric character indexing) just convenient shorthands indexing can accomplished using formula method.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/filterHumdrum.html","id":"numeric-indexing-","dir":"Reference","previous_headings":"","what":"Numeric indexing:","title":"Filter humdrum data — filterHumdrum","text":"Indexing humdrumR corpora [single brackets] accept one numeric argument. argument used pick pieces within humdrumR object ordinally. Thus, humdata[1:10] select first ten pieces data humdata[42] select 42nd piece. Indexing humdrumR objects [[double brackets]] accept one two numeric arguments, j, either can used isolation combination. (j used isolation, must placed comma, humdata[[ , j ]].) used index data records (.e., based humtable Record field) ordinally. Thus, humdata[[1:20]] indexes first twenty records file corpus, humdata[[42]] extracts 42nd record file. j used index spines  (.e., based Spine field) ordinally. Thus, humdata[[ , 3:4]] returns third fourth spines file corpus. indexing humdrumR corpora numbers, numeric (double) inputs converted integers. Note numeric humdrumR indexing entirely ordinal, meaning pieces/data records/spines matched based value respective fields, rather order among existing values. Thus, [single-bracket] indexing $i_th$ piece corpus taken, regardless FileN field associated piece. example, return 12th piece original humdata object, second piece. beacuse first call [] returns 11th 20th pieces, second call returns second piece still present (12th). Similarly, return third spine original data. normal R indexing, negative numbers can used, causing corresponding elements removed instead retained. Thus, humdata[-3:-5] remove third, fourth, fifth pieces data humdata[[ , -3:-5]] remove third, fourth, fifth spines piece. Positive negative indices mixed single argument. cases, indices outside range (value 0) ignored. E.g., corpus twenty files call corpus[21], 21st piece, 21 \"range\". input indices 0 error result. input indices range empty humdrumR object returned. instance, humdata[[401:500, ]] return empty humdrumR object pieces 400 data records.","code":"humsubset <- humdata[11:20] humsubset[2] humsubset2 <- humdata[[ , 2:4]] humsubset2[[ , 2]]"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/filterHumdrum.html","id":"character-indexing-","dir":"Reference","previous_headings":"","what":"Character indexing:","title":"Filter humdrum data — filterHumdrum","text":"Indexing humdrumR objects [single brackets] accept one vector character strings. strings treated regular expressions (regexes). tokens humdrumR object's Active fields searched matches regular expressions input. piece contains match regular expressions retained---pieces filtered . Note ([single-bracket] indexing) entire piece retained, even one match. matches occur pieces, empty humdrumR object returned. Indexing humdrumR objects [[double brackets]] accept one two vectors character strings, j, either can used isolation combination. (j used isolation, must placed comma, humdata[[ , j]].) strings treated regular expressions (regexes). tokens humdrumR object's Active fields searched matches regular expressions input. record contains least one token matching regex retained. Similarly, spine contains least one token matching regex j retained. j used together, matching spines (j) indexed first, tokens matching regular expression(s) must found matching spines. third argument, k, can also used, j arguments missing. order work, need put two commas mark \"missing\" j arguments: e.g., humdata[[ , , '[Ee]-']]. case k, matching tokens retained, regardless spine record number(s).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/filterHumdrum.html","id":"formula-indexing-","dir":"Reference","previous_headings":"","what":"Formula indexing:","title":"Filter humdrum data — filterHumdrum","text":"Indexing humdrumR objects formulae powerful, flexible indexing option. Either [single] [[double]] brackets accept (single) formula. formula fed directly arguments filterHumdrum---, music evaluate logical vector length input. case [single-bracket] indexing, one formula accepted, every piece evalues least one TRUE retained. instance, humdata[~Spine > 4] return pieces contain five () spines. [single-bracket] formula indexing especially useful indexing meta-data properties like reference records: instance, humdata[~COM == \"Paul McCartney\"] return pieces !!!COM: Paul McCartney reference record. case [[double-bracket]] indexing, one two formulas accepted, arguments j, either can used isolation combination. (j used isolation, must placed comma, humdata[[ , j]].) case formulae, record evaluates least one TRUE value retained. case j, spine evaluates least one TRUE value retained. piece contains matches dropped entirely. [[double-bracket]] formula indexing, third argument, k may used absence j. order work, need put two commas mark \"missing\" j arguments: e.g., humdata[[ , , ~formula]]. case k tokens evaluate TRUE retained, regardless piece/spine/record. Pieces, spines, records TRUE values simply dropped. Using k argument exactly \"plain\" call filterHumdrum.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/foldExclusive.html","id":null,"dir":"Reference","previous_headings":"","what":"","title":"","text":"foldExclusive() special version foldHumdrum(), \"folds\" spines based exclusive interpretations. instance, can \"fold\" **silbe spines corpus onto respective **kern spines.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/foldExclusive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"","text":"","code":"foldExclusive(humdrumR, fold, onto, fromField = getActiveFields(humdrumR)[1])"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/foldExclusive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"","text":"fold (character) target exclusive interpretation(s) \"fold\" spines new fields. Must specified without ** prefix: \"kern\" \"**kern\". onto (character, whole number) target exclusive interpretation (must one) \"fold\" data moved.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/foldExclusive.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"","text":"fold onto arguments (character, length == 1) must match exclusive interpretations humdrumR object input. Within file, mismatches number matching onto fold spines handled \"parallel,\" just like foldHumdrum(). Multi-matching spines matched left--right. matching exclusive interpetation pairs found, unchanged humdrumR object returned warning.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/foldGraceNotes.html","id":null,"dir":"Reference","previous_headings":"","what":"","title":"","text":"\"Fold\" grace notes neighbos","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/foldGraceNotes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"","text":"","code":"foldGraceNotes(humdrumR)"},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/foldHumdrum.html","id":null,"dir":"Reference","previous_headings":"","what":"","title":"","text":"Many humdrum datasets encode data across multiple spines, spine-paths, stops. default, humdrumR parses separate spine, spine-path, stop individual data points, taking one row humdrum table. want treat data multiple spines/paths/stops different aspects data easiest reshape data information different humdrumR fields rather separate spines/paths/stops. \"fold\" data one structural location \"top\" data using foldHumdrum.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/foldHumdrum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"","text":"","code":"foldHumdrum(   humdrumR,   fold,   onto,   what = \"Spine\",   File = NULL,   fromField = getActiveFields(humdrumR)[1],   fillFromField = FALSE,   newFieldNames = NULL )  foldPaths(   humdrumR,   fromField = getActiveFields(humdrumR)[1],   fillFromField = TRUE )  foldStops(   humdrumR,   fromField = getActiveFields(humdrumR)[1],   fillFromField = FALSE )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/foldHumdrum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"","text":"humdrumR humdrumR data object. fold (numeric, whole number) target structure (spine, path, etc.) \"fold\" data another structural position field(s). onto (numeric, whole number) target structure (spine, path, etc.) \"fold\" data moved. (character, length == 1) structural field folded across. Valid options \"Spine\", \"Path\", \"Stop\", \"Record\",\"NData\". File (NULL numeric, length == length(onto), whole number) Used specify specific folds different files corpus (see \"File-Specific Folding\" section, ). fromField (character, length == 1) string (partially) matching name data field humdrumR-object input. field field \"folded\" new field. fillFromField (logical, length == 1) folding field smaller field, content fromField copied NA sections? newFieldNames (character) Names use new fields created folding.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/foldHumdrum.html","id":"from-where-to-where","dir":"Reference","previous_headings":"","what":"From where to where","title":"","text":"numeric fold onto arguments specify fold /. fold indicates Spine/Path/Stop fold , \"\" Spine/Path/Stop indicated onto. example, specify foldHumdrum(mydata, fold = 2, onto = 1, = 'Spine') spine 2 folded \"top \" spine 1. fold onto targets may overlap. fold onto arguments can vectors length, interpreted parallel: example, combination fold = 1:2 onto = 3:4 map first spine third spine (1 -> 3) second spine 4th spine (2 -> 4). onto targets duplicated, fold spines folded onto multiple new fields: example, combination fold = 1:2 onto = c(3, 3) map first spine second spine two new fields third spine. fold target duplicated, fold spines can copied onto multiple onto spines: example, combination fold = 1 onto = 2:3 map contents first spine onto second third spine, duplicating spine-1 data. lengths fold onto automatically matched, arguments like fold = 1:2 onto = 3 equivalent fold = 1:2, onto = c(3, 3). makes easy things like \"copy four spines onto spine 1\": just write fold = 2:4, onto = 1. specify structural field want fold across, use argument (character, length == 1). default value \"Spine\"; common fold options \"Path\", \"Stop\", though might want use convenient foldPaths() foldStops() functions directly (details ). (may also fold across \"Record\" \"NData\"), advanced/tricky!)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/foldHumdrum.html","id":"which-fields","dir":"Reference","previous_headings":"","what":"Which fields","title":"","text":"fromField (character, length == 1) controls field fold spine/path/stop folded new field. fromField argument defaults (first) active field, must match (partially match) field humdrumR argument data set. cases, fold data smaller onto data---instance, spine paths often exist part spine, less data path full spine. cases, can helpful set fillFromField == TRUE, causes missing parts fold filled data field. foldPaths default. resulting new fields automatically named appropriate Results fields. newFieldNames argument (character) can used control output names: one new field created fold. specify many newFieldNames, later names ignored. specify newFieldNames, later names given result names, consistent default behavior.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/foldHumdrum.html","id":"file-specific-folding","dir":"Reference","previous_headings":"","what":"File-Specific Folding","title":"","text":"default, \"fold\" carried file input corpus (humdrumR argument). need specify different folds different files, specify File argument (numeric, whole number). every file corpus want apply folds , must specify fold onto arguments parallel vectors File argument (even reduendant files). example, specify combinations, File one: first spine mapped second spine third spine mapped fourth spine File two: first spine mapped second spine fourth spine mapped third spine files corpus included, affected !","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/foldHumdrum.html","id":"predefined-folds","dir":"Reference","previous_headings":"","what":"Predefined folds","title":"","text":"convenient foldStops() foldPaths() functions automatically fold stops/paths dataset onto first stop/path, creating new fields named, e.g., Path1, Path2, etc. Another extremely useful function foldExclusive(), automatically folds spines based exclusive interpretation.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/freq.html","id":null,"dir":"Reference","previous_headings":"","what":"Translate pitches to frequency (Hz) — freq","title":"Translate pitches to frequency (Hz) — freq","text":"Translate pitches frequency (Hz)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/freq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Translate pitches to frequency (Hz) — freq","text":"","code":"freq(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   Key = NULL,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE,   tonalHarmonic = 2^(19/12),   frequency.reference = 440,   frequence.reference.note = \"a\" )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/freq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Translate pitches to frequency (Hz) — freq","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). generic (logical, length == 1) generic = TRUE \"specific\" pitch information (accidentals qualites) discarded. simple (logical, length == 1) simple = TRUE \"compound\" pitch information (octave/contour) discarded. Key (diatonicSet something coercable diatonicSet, length == 1 | length == length(x)) input Key used parser, deparser, transposer. transposeArgs (list) transposeArgs can list arguments passed special call transpose. parseArgs (list) parseArgs can list arguments passed pitch parser. inPlace (logical, length == 1) argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ). tonalHarmonic (numeric, length == 1) frequency \"tonal harmonic\" (perfect 10th) tuned ? default, value 2^(19/12), 12-tone equal-temperament10th. Pythagorean tuning, set tonalHarmonic = 3. frequency.reference (numeric, length == 1) reference frequency---default 440 (Hz). frequency.reference.note (parsable pitch representation, length == 1) note reference.frequency tuned ? Default \"\"---middle-C.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/freq.html","id":"basic-pitch-arguments","dir":"Reference","previous_headings":"","what":"Basic pitch arguments","title":"Translate pitches to frequency (Hz) — freq","text":"pitch function standard arguments control details output. important generic simple arguments, allow control type pitch information returned.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/freq.html","id":"generic-vs-specific","dir":"Reference","previous_headings":"","what":"Generic vs Specific","title":"Translate pitches to frequency (Hz) — freq","text":"generic = TRUE, specific pitch information (accidentals qualities) omitted output. alternative way controlling functionality, can use specific argument, specific == !generic. case atonal functions, \"generic\" version pitch output: example, semits('c#', generic = TRUE) return 0, \"generic\" version C# C, corresponds 0. However, note generic version pitch follows key, semits('c#', generic = TRUE, Key = ':') return 1!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/freq.html","id":"simple-vs-compound","dir":"Reference","previous_headings":"","what":"Simple vs Compound","title":"Translate pitches to frequency (Hz) — freq","text":"simple = TRUE, compound pitch information (octave contour) omitted output. alternative way controlling functionality, can use compound argument ,compound == !simple. actually one way might want divide compound intervals simple octave parts. example, might like call output -M2 (descending major 2nd) +m7 (ascending minor 7th octave ). functionality can controlled octave.round argument: see pitch deparsing documentation.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/freq.html","id":"key","dir":"Reference","previous_headings":"","what":"Key","title":"Translate pitches to frequency (Hz) — freq","text":"Key argument must diatonicSet, something can parsed one. Key argument passed parser, deparser, transpose---unless alternate Key passed transposeArgs parseArgs. Various deparsing options use Key argument; example, use implicitSpecies (see advanced parsing section) dependent Key. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function---means, cases, need explicitly anything Key argument! (want happen, need explicitly specify Key argument, Key = NULL.)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/freq.html","id":"parse-arguments","dir":"Reference","previous_headings":"","what":"Parse arguments","title":"Translate pitches to frequency (Hz) — freq","text":"parseArgs argument must list() (named) arguments passed input parser. example, input representation uses \"X\" represent double sharps, specify kern('CX5', parseArgs = list(doublesharp = 'X')) get correct result (\"cc##\"). convenient shorthand, \"syntactic sugar,\" can specify parseArgs alternate way: Simply input parse(args...) unnamed argument pitch function. example, can get exact result typing kern('CX5', parse(doublesharp = 'X')).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/freq.html","id":"transpose-arguments","dir":"Reference","previous_headings":"","what":"Transpose arguments","title":"Translate pitches to frequency (Hz) — freq","text":"transposeArgs argument must list() (named) arguments passed internal call transpose(), allowing us easily transpose pitch information. example, type kern(c('C', 'D', 'E'), transposeArgs = list(= 'M9')) can get output c('d', 'e', 'f#'). possible transpose args : (tonalInterval, length == 1 | length == (x)) (diatonicSet, length == 1 | length == (x))  (diatonicSet, length == 1 | length == (x)) real (logical, length == 1) transposition real tonal? relative (logical, length == 1) key-wise transposition based relative parallel keys? convenient shorthand, \"syntactic sugar,\" can specify transposeArgs alternate way: Simply input transpose(args...) unnamed argument pitch function. example, can get exact result typing kern(c('C', 'D', 'E'), transpose(= 'M9')).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/freq.html","id":"transposing-by-interval","dir":"Reference","previous_headings":"","what":"Transposing by interval","title":"Translate pitches to frequency (Hz) — freq","text":"calling transpose() directly, argument can anything coercable tonalInterval, output transposed amount. real = FALSE, tonal transposition (within Key) performed. details transposition behavior, check transpose() docs.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/freq.html","id":"transposing-by-key","dir":"Reference","previous_headings":"","what":"Transposing by key","title":"Translate pitches to frequency (Hz) — freq","text":"Another way transposing specifying input (\"\") key output (\"\") key. default, Key argument passed transpose , nothing actually happens. Thus, specify either key key, transposition happen /key Key. course, specify transposition happen keys specify. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function. specify key, Key field passed transpose key, result, pitches input transposed whatever keys target () key! real relative arguments give special control key-wise transposition works, check transpose() docs details!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/freq.html","id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Translate pitches to frequency (Hz) — freq","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/getFields.html","id":null,"dir":"Reference","previous_headings":"","what":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------\nGet named — getFields","title":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------\nGet named — getFields","text":"------------------------------------------->             NEEDS DOCUMENTATION             <------------------------------------------- Get named","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/getFields.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------\nGet named — getFields","text":"","code":"getFields(humdrumR, fieldnames = NULL, dataTypes = \"D\")"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/getTandem.html","id":null,"dir":"Reference","previous_headings":"","what":"Get tandem interpretation information from humdrum data. — getTandem","title":"Get tandem interpretation information from humdrum data. — getTandem","text":"Every humdrumRclass object field called Tandem vector strings accumulates tandem interpretations Spine. function (getTandem) extracts tandem interpretations field, based matching regular expression. obligatory '*' need included regex, added automatically. Thus, want find tandem interpretations match '*clef..', just write regex = 'clef..'.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/getTandem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get tandem interpretation information from humdrum data. — getTandem","text":"","code":"getTandem(tandem, regex)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/harm.html","id":null,"dir":"Reference","previous_headings":"","what":"Roman numeral representations of harmony — harm","title":"Roman numeral representations of harmony — harm","text":"functions output roman numeral representations tertian harmony. **harm representation widely used standard roman numeral notation humdrum data. Unlike traditional roman numerals, **harm indicate inversions figuration, using lowercase letters (, b, c, etc.) instead. roman function however output (relatively) traditional figures. Unlike standard humdrum harm() representation, inversions indicated using traditional figures.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/harm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Roman numeral representations of harmony — harm","text":"","code":"harm(   x,   ...,   Key = NULL,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )  roman(   x,   ...,   Key = NULL,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/helmholtz.html","id":null,"dir":"Reference","previous_headings":"","what":"Helmholtz pitch representation — helmholtz","title":"Helmholtz pitch representation — helmholtz","text":"Helmholtz notation","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/helmholtz.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helmholtz pitch representation — helmholtz","text":"","code":"helmholtz(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   Key = NULL,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/helmholtz.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helmholtz pitch representation — helmholtz","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). generic (logical, length == 1) generic = TRUE \"specific\" pitch information (accidentals qualites) discarded. simple (logical, length == 1) simple = TRUE \"compound\" pitch information (octave/contour) discarded. Key (diatonicSet something coercable diatonicSet, length == 1 | length == length(x)) input Key used parser, deparser, transposer. transposeArgs (list) transposeArgs can list arguments passed special call transpose. parseArgs (list) parseArgs can list arguments passed pitch parser. inPlace (logical, length == 1) argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/helmholtz.html","id":"basic-pitch-arguments","dir":"Reference","previous_headings":"","what":"Basic pitch arguments","title":"Helmholtz pitch representation — helmholtz","text":"pitch function standard arguments control details output. important generic simple arguments, allow control type pitch information returned.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/helmholtz.html","id":"generic-vs-specific","dir":"Reference","previous_headings":"","what":"Generic vs Specific","title":"Helmholtz pitch representation — helmholtz","text":"generic = TRUE, specific pitch information (accidentals qualities) omitted output. alternative way controlling functionality, can use specific argument, specific == !generic. case atonal functions, \"generic\" version pitch output: example, semits('c#', generic = TRUE) return 0, \"generic\" version C# C, corresponds 0. However, note generic version pitch follows key, semits('c#', generic = TRUE, Key = ':') return 1!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/helmholtz.html","id":"simple-vs-compound","dir":"Reference","previous_headings":"","what":"Simple vs Compound","title":"Helmholtz pitch representation — helmholtz","text":"simple = TRUE, compound pitch information (octave contour) omitted output. alternative way controlling functionality, can use compound argument ,compound == !simple. actually one way might want divide compound intervals simple octave parts. example, might like call output -M2 (descending major 2nd) +m7 (ascending minor 7th octave ). functionality can controlled octave.round argument: see pitch deparsing documentation.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/helmholtz.html","id":"key","dir":"Reference","previous_headings":"","what":"Key","title":"Helmholtz pitch representation — helmholtz","text":"Key argument must diatonicSet, something can parsed one. Key argument passed parser, deparser, transpose---unless alternate Key passed transposeArgs parseArgs. Various deparsing options use Key argument; example, use implicitSpecies (see advanced parsing section) dependent Key. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function---means, cases, need explicitly anything Key argument! (want happen, need explicitly specify Key argument, Key = NULL.)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/helmholtz.html","id":"parse-arguments","dir":"Reference","previous_headings":"","what":"Parse arguments","title":"Helmholtz pitch representation — helmholtz","text":"parseArgs argument must list() (named) arguments passed input parser. example, input representation uses \"X\" represent double sharps, specify kern('CX5', parseArgs = list(doublesharp = 'X')) get correct result (\"cc##\"). convenient shorthand, \"syntactic sugar,\" can specify parseArgs alternate way: Simply input parse(args...) unnamed argument pitch function. example, can get exact result typing kern('CX5', parse(doublesharp = 'X')).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/helmholtz.html","id":"transpose-arguments","dir":"Reference","previous_headings":"","what":"Transpose arguments","title":"Helmholtz pitch representation — helmholtz","text":"transposeArgs argument must list() (named) arguments passed internal call transpose(), allowing us easily transpose pitch information. example, type kern(c('C', 'D', 'E'), transposeArgs = list(= 'M9')) can get output c('d', 'e', 'f#'). possible transpose args : (tonalInterval, length == 1 | length == (x)) (diatonicSet, length == 1 | length == (x))  (diatonicSet, length == 1 | length == (x)) real (logical, length == 1) transposition real tonal? relative (logical, length == 1) key-wise transposition based relative parallel keys? convenient shorthand, \"syntactic sugar,\" can specify transposeArgs alternate way: Simply input transpose(args...) unnamed argument pitch function. example, can get exact result typing kern(c('C', 'D', 'E'), transpose(= 'M9')).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/helmholtz.html","id":"transposing-by-interval","dir":"Reference","previous_headings":"","what":"Transposing by interval","title":"Helmholtz pitch representation — helmholtz","text":"calling transpose() directly, argument can anything coercable tonalInterval, output transposed amount. real = FALSE, tonal transposition (within Key) performed. details transposition behavior, check transpose() docs.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/helmholtz.html","id":"transposing-by-key","dir":"Reference","previous_headings":"","what":"Transposing by key","title":"Helmholtz pitch representation — helmholtz","text":"Another way transposing specifying input (\"\") key output (\"\") key. default, Key argument passed transpose , nothing actually happens. Thus, specify either key key, transposition happen /key Key. course, specify transposition happen keys specify. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function. specify key, Key field passed transpose key, result, pitches input transposed whatever keys target () key! real relative arguments give special control key-wise transposition works, check transpose() docs details!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/helmholtz.html","id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Helmholtz pitch representation — helmholtz","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/hint.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate harmonic intervals — hint","title":"Calculate harmonic intervals — hint","text":"hint calculates harmonic intervals vector, across records humdrumR data object.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/hint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate harmonic intervals — hint","text":"","code":"hint(   x,   lag = 1,   deparser = interval,   initial = kern,   bracket = TRUE,   classify = FALSE,   ...,   parseArgs = list(),   Exclusive = NULL,   Key = NULL,   boundaries = list() )"},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humActive.html","id":null,"dir":"Reference","previous_headings":"","what":"The ","title":"The ","text":"humdrumR objects contain many fields data stored underlying humdrum table; can explicitly access fields using ()Humdrum. explicitly indicate field, humdrumR generally default showing/using objects \"Active expression\".","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humActive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The ","text":"","code":"evalActive(   humdrumR,   dataTypes = \"D\",   forceAtomic = TRUE,   sep = \", \",   nullChar = FALSE )  getActive(humdrumR)  getActiveFields(humdrumR)  setActive(humdrumR, expr)  setActiveFields(humdrumR, fieldnames)  # S4 method for humdrumR $(x, name)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humActive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The ","text":"humdrumR humdrumR data object. dataTypes (character, length == 1) types humdrum records include. Legal values 'G', 'L', '', 'M', 'D', 'd',  combination single string (e.g., \"LIM\"). (see humdrum table documentation Fields section explanation.). forceAtomic (logical, length == 1) TRUE (default), evaluated active field forced/coerced atomic vector. sep (character, length == 1) used forceAtomic == TRUE; coercion involves pasting together lists vectors, sep used separator pasting. nullChar (logical, length == 1) used forceAtomic == TRUE; nullChar == TRUE NAs output vector replaced humdrum null character tokens: \".\", \"!\", \"=\", \"*\", depending type.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humActive.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The ","text":"time, active expression just points single field: first read , active expression/field Token. However, active expression can arbitrary R expression involving fields humdrum table. called , expression evaluated within object's humdrum table (similar \"within expression,\" without extra evaluation options). instance, active expression : paste(Token, Record), print Token record number pasted . fields referenced active expression called \"active fields.\" Common commands evaluate active expression include: printing humdrumR object terminal, active expression shown. (evalActive used evaluate expression character string, needed.) humdrumR object prints, active fields marked \"*\" name(s). writing files, active expression written.  \"within expression,\" variable . automatically replaced active expression. Functions like collapseHumdrum], foldHumdrum(), fields(), use active field(s) default arguments. current active field can seen calling getActive(humData). character vector fields used active expression can extracted getActiveFields(humData).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humActive.html","id":"setting-the-active-expression","dir":"Reference","previous_headings":"","what":"Setting the active expression","title":"The ","text":"active expression can changed several ways. simplest common using $ operator, takes field name (partially matched) sets active expression simply call field. handy way quickly look different fields data: complex active expressions can set using setActive, specified directly second argument: e.g., setActive(humData, paste(Token, Record)). Notice active field must Refer least one field humdrum table. Evaluate vector length humdrum table (given target dataTypes), list vectors length. programmatic work, setActiveFields accepts character vector partially matched field names; one field name given, active field just calls field. two field names given, active expression set expression form list(Field1, Field2, Field3, ...). easiest way quickly see two three fields side side. special syntactic sugar, call humData$, liit data fields set active field. useful way look data fields.","code":"humData$Token  humData$Spine humData$Sp # same as last one, because it partially matches Spine"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humActive.html","id":"null-data","dir":"Reference","previous_headings":"","what":"Null data","title":"The ","text":"humdrumR`` identifies \"null data\" based active field---might obvious,  one important jobs active field! Anywhere current active field evaluates \".\"orNA(orNULLfor [lists][base::list()]) considered null data; internal [humdrum table][humTable] data points set toTRUEin theNullfield assigned type\"d\"theType` field. Null data updated whenever active field changed reset, including functions create new fields, like foldHumdrum() within.humdrumR(). work, often data tokens null one field, another field. example, load **kern data, token like \"4r\" (quarter-note rest) token NA call pitch, NA call recip (rhythm). Now, change active field Pitch Rhythm (using $) see different numbers (non-null) data tokens: ntoken(kerndata$Pitch ,'D') vs ntoken(kerndata$Rhythm, 'D) return different numbers! (difference number rest tokens.) Similarly, apply functions/expressions data (using withinHumdrum() example), result depend active field : , get different numbers ! (Assuming rests data.) case even though -expression actually using Pitch Rhythm fields! Pitch active field, rest tokens null-data ignored!","code":"kerndata <- readHumdrum(...)  within(kerndata$Token,        Pitch  <- pitch(.),        Rhythm <- recip(.)) -> kerndata with(kerndata$Pitch, length(.)) with(kerndata$Rhythm, length(.))"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humActive.html","id":"evaluating-the-active-expression","dir":"Reference","previous_headings":"","what":"Evaluating the active expression","title":"The ","text":"Evaluation active expression usually something done automatically humdrumR functions, especially printing data console. However, can also manually using evalActive command. \"raw\" result evaluating active expression can returned specifying forceAtomic == FALSE. However, default forceAtomic == TRUE causes evalActive coerce evaluated results atomic vector. Obviously, evaluated active result atomic vector, coercion needed. evaluated active result list, must either full length humdrum table, list vectors/lists length. words, result must one \"full length\" vector/lists. full length list, element list coerced single atomic value unlisted create atomic vector. elements list atomic, converted various character representations. tables coerced string \"<table: k=x, n=y>\", x number categories table y total number values table (sum(table(...))). lists length < 5 coerced \"list(, b, c, d, e)\", -e elements list. Longer lists coerced \"list[n]:, n length list. R objects coerced <class>, class class object. Finally, thus-generated full-length vectors (one) pasted together, separated sep (default = \", \"). common practical illustration/application last specify active fields lists fields---example, list(Token, Spine, Record). Following algorithm , evaluated result character vector looking like \"Token, Spine, Record\". exactly setActiveFields fed multiple fieldNames, well special call humData$.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humAssignment.html","id":null,"dir":"Reference","previous_headings":"","what":"Assigning new fields — humAssignment","title":"Assigning new fields — humAssignment","text":"R objects often ways assigning new values part object using indexing operators. HumdrumR objects objects different, allow us insert new fields !","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humAssignment.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Assigning new fields — humAssignment","text":"new field can inserted humdrumR object two ways: field can copied one humdrumR object another internal humdrum tables exact number data tokens (.e., rows). might seem obvious, mechanism useful can used rename existing fields within humdrumR object (explained ). vector list vectors can inserted new fields humdrumR object. Fields can assigned using two syntaxes: \"fieldname\" can whatever want , course!","code":"humdata['fieldname'] <- x # or humdata[c('fieldname1', 'fieldname2')] <- x humdata$fieldname <- x"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humAssignment.html","id":"humdrumr-gt-humdrumr-assignment-","dir":"Reference","previous_headings":"","what":"humdrumR -> humdrumR assignment:","title":"Assigning new fields — humAssignment","text":"Assigning field one humdrumR object another works like : (Recall two objects must exact numbers data tokens.) name(s) given indexing expression left side assignment (.e., humdata[c('name1', 'name2')] humdata$name) used new field names. fields extracted right side assignment little trickier: fields right-side humdrumR object named $ResultN$ ($N$ integer) copied descending order named fields left side. $ResultN$ fields right side, fields used current Active formula (right side) copied instead. system might seem odd first, useful combination withinHumdrum function. withinHumdrum creates new fields, calls $Result1 ... Result2 ... ResultN$. Since output withinHumdrum always input except new \"Result\" fields, Byou can use humdrumR <- humdrumR assignment immediately assign result fields meaningful names original object. makes sense example: Calls within.humdrumR()  keep producing new result fields. one result fields, can assign multiple fields using []<- syntax: #' IMPORTANT NOTE!: \"ResultN\" fields humdrumR object assign assign field names simply dropped. nice, often might proceed serious resultd steps, want last one (two). want keep result fields either re-assign (.e., keep \"ResultN\" names) assign names using ->[c(\"name1\", \"name2\", \"name3\", ...)] syntax.","code":"humdata <- within(humdata, Semits <- semits(Token))"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humAssignment.html","id":"humdrumr-gt-vector-assignment-","dir":"Reference","previous_headings":"","what":"humdrumR -> vector assignment:","title":"Assigning new fields — humAssignment","text":"can assign vectors lists vectors straight humdrumR object. vectors must length number data tokens target object. provide multiple vectors assign (list data.frame vectors) must provide number fieldnames using ->[c('name1', 'name2', ...)] syntax. can use ntokens command determine right length vectors need!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humCensus.html","id":null,"dir":"Reference","previous_headings":"","what":"Tabulate records and tokens in a humdrumR corpus — humCensus","title":"Tabulate records and tokens in a humdrumR corpus — humCensus","text":"census one humdrumR's summary functions, used tabulate raw size humdrumR corpus. census takes humdrumR object returns humCensus table. dataType argument controls types records tabulate: legal values 'G', 'L', '', 'M', 'D', 'd' combination (e.g., \"LIM\"). default \"D\".","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humCensus.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tabulate records and tokens in a humdrumR corpus — humCensus","text":"","code":"census(humdrumR, dataTypes = \"GLIMDd\", by = \"Filename\", removeEmpty = FALSE)  census(humdata)[i]  # S3 method for humCensus print(censusTable, showEach = TRUE, screenWidth = options(\"width\")$width - 10L)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humCensus.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tabulate records and tokens in a humdrumR corpus — humCensus","text":"humdrumR humdrumR object dataTypes character string length 1. character string length 1. Must field humdrumR object.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humCensus.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tabulate records and tokens in a humdrumR corpus — humCensus","text":"humCensus table five columns information: Records total number records. Tokens total number tokens. (unique) number unique tokens Characters total numder characters. includes humdrum control characters like * !!. (per token) simply Characters / Tokens, indicating mean length token. humCensus table one row file corpus. Rows labeled file's corresponding number (humTable's File field) name (Filename field). addition, humCensus object printed, totals across files printed well---(unique) (per token) across files calculated across files well, summed.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humCensus.html","id":"indexing","dir":"Reference","previous_headings":"","what":"Indexing","title":"Tabulate records and tokens in a humdrumR corpus — humCensus","text":"Rows humCensus object can selected single argument : e.g., censusTable[]. numeric, corresponding rows selected ordinally (File number). character string, string mached regular expression file names. formula, right-hand side formula evaluated within table---evaluates logical vector, files selected accordingly. instance, censusTable[~Tokens > 100] select files 100 tokens. ('(unique)' '(per token)' columns must referred names enclosed \\``---example, censusTable~\\verb(unique)\\ > 100` return files 100 unique tokens. drop argument also available. TRUE, plain data.table::data.table() returned.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humCoercion.html","id":null,"dir":"Reference","previous_headings":"","what":"humdrumR coercion — humCoercion","title":"humdrumR coercion — humCoercion","text":"Many users may wish work humdrum data, without rely humdrumR's ().humdrumR functionality. Rather, like just get \"normal\" R objects humdrum data. humdrumR defines number functions/methods \"coercing\" humdrum data basic R data types.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humCoercion.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"humdrumR coercion — humCoercion","text":"","code":"# S4 method for humdrumR as.vector(x, mode = \"any\")  as.lines(   humdrumR,   dataTypes = \"GLIMDd\",   padPaths = \"dont\",   padder = \"\",   sep = \"\\t\" )  # S3 method for humdrumR as.matrix(x, dataTypes = \"GLIMDd\", padPaths = \"corpus\", padder = NA)  # S4 method for humdrumR as.data.frame(x, dataTypes = \"Dd\", padPaths = \"corpus\", padder = NA)  # S4 method for humdrumR as.data.frame(x, dataTypes = \"Dd\", padPaths = \"corpus\", padder = NA)  as.matrices(humdrumR, dataTypes = \"LIMDd\", padPaths = \"piece\", padder = NA)  as.data.frames(humdrumR, dataTypes = \"LIMDd\", padPaths = \"piece\", padder = NA)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humCoercion.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"humdrumR coercion — humCoercion","text":"mode single character string naming atomic vector type coerce output (possible). default, set '', lets output type simply whatever comes evalActive(). humdrumR humdrumR data object. dataTypes types humdrum records include. Legal values 'G', 'L', '', 'M', 'D', 'd' combination (e.g., \"LIM\"). (See humdrum table documentation Fields section explanation.) padPaths (character, length == 1) One three options: \"corpus\", \"piece\", \"dont\". See details explanation. padder atomic value length one. value padder argument used fill differences number columns files, spine paths. sep single character string, indicating separator place columns collapsed lines.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humCoercion.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"humdrumR coercion — humCoercion","text":"Generally, coercion works evaluating humdrumR object's active expression forcing result atomic vector. process accomplished evalActive() command. .vector(humdrumR) method essentially wrapper evalActive(), additional option coercing resulting vector particular type using mode argument. .matrix(humdrumR) method take things step putting evaluated active expression two-dimensional matrix, rows representing records columns indicating spine paths (see Padding section ). .data.frame(humdrumR) first calls .matrix converts matrix data.frame. Note .matrix(humdrumR) places entire corpus object one matrix, even multiple pieces. contrast, plural .matrices .data.frames call respective singular versions separately individual file humdrumR corpus return list. row names  matrix/data.frame(s) consist two integer values, separated ., representing: File.Record. .lines function converts humdrumR object character vector text lines, columns separated sep argument (defaults \"\\t\"), just see humdrum-syntax file. line single row .matrix.humdrumR, padded values right side removed. matrix's File.Record row names preserved lines' names. Note multiple-stop token (Stop > 1L) incorporated two dimensional matrix/data.frame. Thus, .matrix(humdrumR) calls collapseStops(collapseAtomic = TRUE, sep = \" \") humdrumR object creating matrix.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humCoercion.html","id":"padding","dir":"Reference","previous_headings":"","what":"Padding","title":"humdrumR coercion — humCoercion","text":"Different pieces single humdrumR object often differ number spines /spine paths contain. squish two dimensional object (matrix data.frame) must necessarily padded number columns. (Global comments---actually NA spines---also padded, placing record column 1.) pad argument single atomic value used pad matrix. Another consideration behavior spine paths. humdrum syntax, spine path leftward spine \"bumps\" data higher spines new columns, example: beginning end file, second column holds data second spine. However, middle file, second column holds data second spine path first spine. make spine structure clearer, .matrix(humdrumR) option pad spine paths. example, using \"_\" pad argument: aspect matrix padding behavior can controlled padPaths argument, three possible values/behaviors: \"corpus\": Paths padded spine-paths across pieces corpus align columns. even one file spine path, files padded spines stay aligned. default behavior .matrix(humdrumR). \"piece\": Paths padded, within piece. spines/paths different pieces may align. \"dont\": Paths padded .","code":"**kern  **kern A       E *^      * A       C       E G       B       D *v      *v      * A       C         *-      *- **kern   _        **kern A        _        E *^       _        * A        C        E G        B        D *v       *v       * A        _        C         *-       _        *-"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humColumns.html","id":null,"dir":"Reference","previous_headings":"","what":"Spines vs Paths vs Columns — humColumns","title":"Spines vs Paths vs Columns — humColumns","text":"humdrum syntax, data placed \"spines,\" \"columns\" spreadsheet. \"column\" refers tab-delineated group values. \"Spines\" can single column, may (time) split multiple columns, can turn split , using \"*^\" interpretation token. reverse can happen well, two columns merging single column, using \"v\" token. means , humdrum data first glance looks like simple two-dimensional table, actually flexible tree structure. spines split merge, total number columns can change piece, creating \"ragged\" edge. Another similar issue corpus humdrum files may varying numbers spines/columns, pieces. (\"Global\" comment/reference records also special case, always single value, even interspersed multi-column local records.)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humColumns.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spines vs Paths vs Columns — humColumns","text":"humdrumR, spines, columns, spine paths work like . First , actually assume slightly strict version humdrum syntax: assume spines appear beginning file (headed exlusive interpretations like \"**kern\") can never merge . Thus, humdrum file read humdrumR must end fewer columns starts. Spine merges (\"*v\") can happen within spine paths originally split spine. extra-strict specification spine paths humdrum syntax , fortunately, something informally followed humdrum datasets. strict spine-path definition makes everything work fairly simply: Within piece, spines appear beginning piece \"true\" spines rest piece, numbered left right, starting 1L. local token, value Spine field integer indicating \"true\" spines belongs ---global tokens NA value Spine field, considerd belong spine. spine path splits (\"*^\" main spines form subspines, call Paths. Every spine's paths numbered, right left, starting 0L. spine splits 0Ls Path field.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humColumns.html","id":"columns","dir":"Reference","previous_headings":"","what":"Columns","title":"Spines vs Paths vs Columns — humColumns","text":"useful sometimes turn humdrum data true two dimensional structure, ragged edges. (always requires removing global records.) order , maintaining sensible relationship spine spine paths, imagine humdrum data padded complete, non-ragged 2d table. instance, given file pad like: example, Spine, Path, Column values shown data. can see Column used indicate \"padded\" position data token.","code":"**kern  **kern A       E *^      * A       C       E G       B       D *v      *v      * A       C         *-      *- **kern   _P       **kern A        _P       E *^       _P       * A        C        E G        B        D *v       *v       * A        _P       C         *-       _P       *-  ########################################## 1        1        2        Spine 0        1        0        Path 1        2        3        Column"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humFormulae.html","id":null,"dir":"Reference","previous_headings":"","what":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------\nStandard humdrumR formulae. — humFormulae","title":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------\nStandard humdrumR formulae. — humFormulae","text":"humdrumR predefines ()humdrum command combinations, R formulae lists formulae.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humFormulae.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------\nStandard humdrumR formulae. — humFormulae","text":"","code":"ditto"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humFormulae.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------\nStandard humdrumR formulae. — humFormulae","text":"object class list length 3.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humFormulae.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------\nStandard humdrumR formulae. — humFormulae","text":"ditto calls fillThru() across pieces/spines/paths, replicating classic humdrum toolkit ditto command.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humInterpretations.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize humdrum corpus interpretations. — humInterpretations","title":"Summarize humdrum corpus interpretations. — humInterpretations","text":"interpretations one humdrumR's summary functions, used summarize interpretations pieces humdrumR corpus, including exclusive (**) tandem (*) interpretations. returns humInterpretations argument prints informative table terminal.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humInterpretations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize humdrum corpus interpretations. — humInterpretations","text":"","code":"interpretations(humdrumR)  # S3 method for humInterpretations print(interps, showEach = TRUE, screenWidth = options(\"width\")$width - 10L)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humInterpretations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize humdrum corpus interpretations. — humInterpretations","text":"humdrumR humdrumR data object.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humInterpretations.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summarize humdrum corpus interpretations. — humInterpretations","text":"row output table represents single piece corus. first column ((n)) indicates unique \"exclusive pattern\" associated piece---exclusive patterns tallied bottom. remaining columns indicate many interpretation (indicated column name) appear piece. tandem interpretations, counts returned format Total.Unique.Spines: Total: total instances interpretation, across spines. Unique: number unique versions interpretation. Spines: number spines interpretation appears . example, consider following file: file, several tandem key interpretations, humdrumR call Key. tabulation interpretations return Key column value 6.3.2 file: 6 six key interpretations total. 3 three unique keys: *C:, *e: *G:. 2 key interpretations occur two spines.","code":"**kern   **kern   **silbe    *C:      *C:         *      c        e        La      d        f        la      e        g        la    *e:      *e:         *     f#       d#        la      g        e         _      a        b         _    *G:      *G:         *     f#        a       doo      g        b       wop     *-       *-        *-"},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humMerge.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge two (or more) humdrumR datasets — humMerge","title":"Merge two (or more) humdrumR datasets — humMerge","text":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humMerge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge two (or more) humdrumR datasets — humMerge","text":"","code":"mergeHumdrum(...)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humMeter.html","id":null,"dir":"Reference","previous_headings":"","what":"Tools for analyzing rhythm and meter. — humMeter","title":"Tools for analyzing rhythm and meter. — humMeter","text":"humdrumR includes number useful functions working rhythms meter.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humMeter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tools for analyzing rhythm and meter. — humMeter","text":"rhythmDecompose() decomposes series rhythms terms desired pulses. rhythmOffset() Calculates cummulative offset durations starting point.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humMetric.html","id":null,"dir":"Reference","previous_headings":"","what":"Meter class — humMetric","title":"Meter class — humMetric","text":"Meter class","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humPipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Piping humdrumR data — humPipe","title":"Piping humdrumR data — humPipe","text":"infix operators make possible use [humdrumR:--Humdrum][()Humdrum] functions piping style, similar | (pipe) unix-style terminals, |>  pipe operator. R package magrittr.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humPipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Piping humdrumR data — humPipe","text":"","code":"humdrumR %hum>% formula  humdrumR %hum<% formula  humdrumR %humT% formula  e1 %s>% e2  list %hums>% formula  list %hums<% formula  list %humsT% formula  list %hums[]% formula"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humPipe.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Piping humdrumR data — humPipe","text":"key function [withinHumdrum][withinHumdrum] always returns new [humdrumR][humdrumR] data object. Thus, can always send output [withinHumdrum][withinHumdrum] back new call [withinHumdrum][withinHumdrum]. exactly %hum>% : left-hand side, input [humdrumR][humdrumR] object, right-hand side suitable arguments [withinHumdrum][withinHumdrum] (.e., formula, function, list formulae, functions, named arguments). can chain call another call %hum>% [withinHumdrum][withinHumdrum] arguments. %hum<% acts way %hum>% except calls [withHumdrum][withinHumdrum]. Since [withHumdrum][withinHumdrum] return [humdrumR][humdrumR], output piped (using %hum>% %hum<%). Thus, \\%hum<\\% used last step pipe---want extract last step pipe data's [humdrumR:humtable][Humdrum Table] normal vector list R data. ' \\%humT\\% creates \"T\" pipe, applying desired expression keeping result---unaltered humdrumR input object returned. works simply replacing ~ doplot~ call [withinHumdrum][withinHumdrum]. purpose option, want apply expressions side effects, instance, plotting. %hum[]% similar %hum>% except apply formulae right-hand side using [humdrumR][filterHumdrum]. Thus, can used filter/index [humdrumR][humdrumR] data object fly.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humPipe.html","id":"plural-pipes","dir":"Reference","previous_headings":"","what":"Plural pipes","title":"Piping humdrumR data — humPipe","text":"R often apply function list data. \"Plural pipes\" expand idea piping: take list data pipe element list expression/function. plural pipe versions singular pipe operator. Just add \"s\" make plural: |> (singular) : %s>% (plural); %hum>% (singular) : %hums>% (plural); %hum<% (singular) : %hums<% (plural); %humT% (singular) : %humsT% (plural); %hum[]% (singular) : %hums[]% (plural); Note: %s>% expansion \\> pipe operator, makes use clever meta-programming---guarantee always behave way might like!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humPipe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Piping humdrumR data — humPipe","text":"","code":"humdata <- readHumdrum('path*.krn') #> Finding and reading files... #> \tREpath-pattern 'path*.krn' matches 0 text files in 1 directory. #> Zero files read from disk. #> No files to validate.  humdata %hum>% ~table(.) #> humdrumR error in: #> \ttryCatch(withCallingHandlers({ #>   NULL #>   saveRDS(do.call(do.call, c(readRDS( #>     \"/home/nat/.tmp/Rtmpdij6pd/callr-fun-3daf19237390\"), list(envir = .GlobalEnv, #>     quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmpdij6pd/callr-res-3daf16c3946c9\") #>   flush(stdout()) #>   flush(stderr()) #>   NULL #>   invisible() #> }, error = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmpdij6pd/callr-res-3daf16c3946c9\", \".error\")) #>   } #> }, interrupt = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmpdij6pd/callr-res-3daf16c3946c9\", \".error\")) #>   } #> }, callr_message = function(e) { #>   try(signalCondition(e)) #> }), error = function(e) { #>   NULL #>   try(stop(e)) #> }, interrupt = function(e) { #>   NULL #>   e #> }) #> \t -> tryCatchList(expr, classes, parentenv, handlers) #> \t -> tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), names[nh], #> parentenv, handlers[[nh]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> tryCatchList(expr, names[-nh], parentenv, handlers[-nh]) #> \t -> tryCatchOne(expr, names, parentenv, handlers[[1L]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> withCallingHandlers({ #>   NULL #>   saveRDS(do.call(do.call, c(readRDS( #>     \"/home/nat/.tmp/Rtmpdij6pd/callr-fun-3daf19237390\"), list(envir = .GlobalEnv, #>     quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmpdij6pd/callr-res-3daf16c3946c9\") #>   flush(stdout()) #>   flush(stderr()) #>   NULL #>   invisible() #> }, error = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmpdij6pd/callr-res-3daf16c3946c9\", \".error\")) #>   } #> }, interrupt = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmpdij6pd/callr-res-3daf16c3946c9\", \".error\")) #>   } #> }, callr_message = function(e) { #>   try(signalCondition(e)) #> }) #> \t -> saveRDS(do.call(do.call, c(readRDS( #>   \"/home/nat/.tmp/Rtmpdij6pd/callr-fun-3daf19237390\"), list(envir = .GlobalEnv, #>   quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmpdij6pd/callr-res-3daf16c3946c9\") #> \t -> do.call(do.call, c(readRDS(\"/home/nat/.tmp/Rtmpdij6pd/callr-fun-3daf19237390\"), #> list(envir = .GlobalEnv, quote = TRUE)), envir = .GlobalEnv, quote = TRUE) #> \t -> <function(what, args, quote = FALSE, envir = parent.frame()) { #>   if (!is.list(args)) stop(\"second argument must be a list\") #>   if (quote) args <- lapply(args, enquote) #>   .Internal(do.call(what, args, envir)) #> }>(base::quote(<function(..., crayon_enabled, crayon_colors, pkgdown_internet) { #>   options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, #>     pkgdown.internet = pkgdown_internet) #>   pkgdown::build_site(...) #> }>), base::quote(<list: pkg = <pkgdown>, examples = TRUE, run_dont_run = FALSE, #>   seed = 1014, lazy = FALSE, ...>), envir = base::quote(<environment>), quote = base::quote( #>   TRUE)) #> \t -> <function(..., crayon_enabled, crayon_colors, pkgdown_internet) { #>   options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, #>     pkgdown.internet = pkgdown_internet) #>   pkgdown::build_site(...) #> }>(pkg = base::quote(<pkgdown>), examples = base::quote(TRUE), run_dont_run = base::quote( #>   FALSE), seed = base::quote(1014), lazy = base::quote(FALSE), override = base::quote( #>   <list: >), install = base::quote(FALSE), preview = base::quote(FALSE), #> new_process = base::quote(FALSE), devel = base::quote(FALSE), crayon_enabled = base::quote( #>   TRUE), crayon_colors = base::quote(256L), pkgdown_internet = base::quote(TRUE)) #> \t -> pkgdown::build_site(...) #> \t -> build_site_local(pkg = pkg, examples = examples, run_dont_run = run_dont_run, #>   seed = seed, lazy = lazy, override = override, preview = preview, devel = devel) #> \t -> build_reference(pkg, lazy = lazy, examples = examples, run_dont_run = run_dont_run, #>   seed = seed, override = override, preview = FALSE, devel = devel) #> \t -> purrr::map(topics, build_reference_topic, pkg = pkg, lazy = lazy, examples_env = examples_env, #>   run_dont_run = run_dont_run) #> \t -> .f(.x[[i]], ...) #> \t -> withCallingHandlers(data_reference_topic(topic, pkg, examples_env = examples_env, #>   run_dont_run = run_dont_run), error = function(err) { #>   msg <- c(paste0(\"Failed to parse Rd in \", topic$file_in), i = err$message) #>   abort(msg, parent = err) #> }) #> \t -> data_reference_topic(topic, pkg, examples_env = examples_env, run_dont_run = run_dont_run) #> \t -> run_examples(tags$tag_examples[[1]], env = if (is.null(examples_env) #> ) NULL else new.env(parent = examples_env), topic = tools::file_path_sans_ext( #>   topic$file_in), run_dont_run = run_dont_run) #> \t -> highlight_examples(code, topic, env = env) #> \t -> downlit::evaluate_and_highlight(code, fig_save = fig_save_topic, env = child_env( #>   env), output_handler = evaluate::new_output_handler(value = pkgdown_print)) #> \t -> evaluate::evaluate(code, child_env(env), new_device = TRUE, output_handler = output_handler) #> \t -> evaluate_call(expr, parsed$src[[i]], envir = envir, enclos = enclos, debug = debug, #> last = i == length(out), use_try = stop_on_error != 2L, keep_warning = keep_warning, #> keep_message = keep_message, output_handler = output_handler, include_timing = include_timing) #> \t -> timing_fn(handle(ev <- withCallingHandlers(withVisible(eval(expr, envir, enclos)), #> warning = wHandler, error = eHandler, message = mHandler))) #> \t -> handle(ev <- withCallingHandlers(withVisible(eval(expr, envir, enclos)), #> warning = wHandler, error = eHandler, message = mHandler)) #> \t -> try(f, silent = TRUE) #> \t -> tryCatch(expr, error = function(e) { #>   call <- conditionCall(e) #>   if (!is.null(call)) { #>     if (identical(call[[1L]], quote(doTryCatch))) call <- sys.call(-4L) #>     dcall <- deparse(call, nlines = 1L) #>     prefix <- paste(\"Error in\", dcall, \": \") #>     LONG <- 75L #>     sm <- strsplit(conditionMessage(e), \"\\n\")[[1L]] #>     w <- 14L + nchar(dcall, type = \"w\") + nchar(sm[1L], type = \"w\") #>     if (is.na(w)) w <- 14L + nchar(dcall, type = \"b\") + nchar(sm[1L], type = \"b\") #>     if (w > LONG) prefix <- paste0(prefix, \"\\n  \") #>   } else prefix <- \"Error : \" #>   msg <- paste0(prefix, conditionMessage(e), \"\\n\") #>   .Internal(seterrmessage(msg[1L])) #>   if (!silent && isTRUE(getOption(\"show.error.messages\"))) { #>     cat(msg, file = outFile) #>     .Internal(printDeferredWarnings()) #>   } #>   invisible(structure(msg, class = \"try-error\", condition = e)) #> }) #> \t -> tryCatchList(expr, classes, parentenv, handlers) #> \t -> tryCatchOne(expr, names, parentenv, handlers[[1L]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> withCallingHandlers(withVisible(eval(expr, envir, enclos)), warning = wHandler, #> error = eHandler, message = mHandler) #> \t -> withVisible(eval(expr, envir, enclos)) #> \t -> eval(expr, envir, enclos) #> \t -> eval(expr, envir, enclos) #> \t -> humdata %hum>% (~ table(.)) #> \t #> Error: In the call `%hum>%`(humdrumR = _), the argument humdrumR must be a humdrumR object.  humdata %hum>%      c(by~Spine, do ~ table(.)) %hum>%      c(mfcol ~ c(2,2), doplot~barplot(.)) #> humdrumR error in: #> \ttryCatch(withCallingHandlers({ #>   NULL #>   saveRDS(do.call(do.call, c(readRDS( #>     \"/home/nat/.tmp/Rtmpdij6pd/callr-fun-3daf19237390\"), list(envir = .GlobalEnv, #>     quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmpdij6pd/callr-res-3daf16c3946c9\") #>   flush(stdout()) #>   flush(stderr()) #>   NULL #>   invisible() #> }, error = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmpdij6pd/callr-res-3daf16c3946c9\", \".error\")) #>   } #> }, interrupt = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmpdij6pd/callr-res-3daf16c3946c9\", \".error\")) #>   } #> }, callr_message = function(e) { #>   try(signalCondition(e)) #> }), error = function(e) { #>   NULL #>   try(stop(e)) #> }, interrupt = function(e) { #>   NULL #>   e #> }) #> \t -> tryCatchList(expr, classes, parentenv, handlers) #> \t -> tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), names[nh], #> parentenv, handlers[[nh]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> tryCatchList(expr, names[-nh], parentenv, handlers[-nh]) #> \t -> tryCatchOne(expr, names, parentenv, handlers[[1L]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> withCallingHandlers({ #>   NULL #>   saveRDS(do.call(do.call, c(readRDS( #>     \"/home/nat/.tmp/Rtmpdij6pd/callr-fun-3daf19237390\"), list(envir = .GlobalEnv, #>     quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmpdij6pd/callr-res-3daf16c3946c9\") #>   flush(stdout()) #>   flush(stderr()) #>   NULL #>   invisible() #> }, error = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmpdij6pd/callr-res-3daf16c3946c9\", \".error\")) #>   } #> }, interrupt = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmpdij6pd/callr-res-3daf16c3946c9\", \".error\")) #>   } #> }, callr_message = function(e) { #>   try(signalCondition(e)) #> }) #> \t -> saveRDS(do.call(do.call, c(readRDS( #>   \"/home/nat/.tmp/Rtmpdij6pd/callr-fun-3daf19237390\"), list(envir = .GlobalEnv, #>   quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmpdij6pd/callr-res-3daf16c3946c9\") #> \t -> do.call(do.call, c(readRDS(\"/home/nat/.tmp/Rtmpdij6pd/callr-fun-3daf19237390\"), #> list(envir = .GlobalEnv, quote = TRUE)), envir = .GlobalEnv, quote = TRUE) #> \t -> <function(what, args, quote = FALSE, envir = parent.frame()) { #>   if (!is.list(args)) stop(\"second argument must be a list\") #>   if (quote) args <- lapply(args, enquote) #>   .Internal(do.call(what, args, envir)) #> }>(base::quote(<function(..., crayon_enabled, crayon_colors, pkgdown_internet) { #>   options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, #>     pkgdown.internet = pkgdown_internet) #>   pkgdown::build_site(...) #> }>), base::quote(<list: pkg = <pkgdown>, examples = TRUE, run_dont_run = FALSE, #>   seed = 1014, lazy = FALSE, ...>), envir = base::quote(<environment>), quote = base::quote( #>   TRUE)) #> \t -> <function(..., crayon_enabled, crayon_colors, pkgdown_internet) { #>   options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, #>     pkgdown.internet = pkgdown_internet) #>   pkgdown::build_site(...) #> }>(pkg = base::quote(<pkgdown>), examples = base::quote(TRUE), run_dont_run = base::quote( #>   FALSE), seed = base::quote(1014), lazy = base::quote(FALSE), override = base::quote( #>   <list: >), install = base::quote(FALSE), preview = base::quote(FALSE), #> new_process = base::quote(FALSE), devel = base::quote(FALSE), crayon_enabled = base::quote( #>   TRUE), crayon_colors = base::quote(256L), pkgdown_internet = base::quote(TRUE)) #> \t -> pkgdown::build_site(...) #> \t -> build_site_local(pkg = pkg, examples = examples, run_dont_run = run_dont_run, #>   seed = seed, lazy = lazy, override = override, preview = preview, devel = devel) #> \t -> build_reference(pkg, lazy = lazy, examples = examples, run_dont_run = run_dont_run, #>   seed = seed, override = override, preview = FALSE, devel = devel) #> \t -> purrr::map(topics, build_reference_topic, pkg = pkg, lazy = lazy, examples_env = examples_env, #>   run_dont_run = run_dont_run) #> \t -> .f(.x[[i]], ...) #> \t -> withCallingHandlers(data_reference_topic(topic, pkg, examples_env = examples_env, #>   run_dont_run = run_dont_run), error = function(err) { #>   msg <- c(paste0(\"Failed to parse Rd in \", topic$file_in), i = err$message) #>   abort(msg, parent = err) #> }) #> \t -> data_reference_topic(topic, pkg, examples_env = examples_env, run_dont_run = run_dont_run) #> \t -> run_examples(tags$tag_examples[[1]], env = if (is.null(examples_env) #> ) NULL else new.env(parent = examples_env), topic = tools::file_path_sans_ext( #>   topic$file_in), run_dont_run = run_dont_run) #> \t -> highlight_examples(code, topic, env = env) #> \t -> downlit::evaluate_and_highlight(code, fig_save = fig_save_topic, env = child_env( #>   env), output_handler = evaluate::new_output_handler(value = pkgdown_print)) #> \t -> evaluate::evaluate(code, child_env(env), new_device = TRUE, output_handler = output_handler) #> \t -> evaluate_call(expr, parsed$src[[i]], envir = envir, enclos = enclos, debug = debug, #> last = i == length(out), use_try = stop_on_error != 2L, keep_warning = keep_warning, #> keep_message = keep_message, output_handler = output_handler, include_timing = include_timing) #> \t -> timing_fn(handle(ev <- withCallingHandlers(withVisible(eval(expr, envir, enclos)), #> warning = wHandler, error = eHandler, message = mHandler))) #> \t -> handle(ev <- withCallingHandlers(withVisible(eval(expr, envir, enclos)), #> warning = wHandler, error = eHandler, message = mHandler)) #> \t -> try(f, silent = TRUE) #> \t -> tryCatch(expr, error = function(e) { #>   call <- conditionCall(e) #>   if (!is.null(call)) { #>     if (identical(call[[1L]], quote(doTryCatch))) call <- sys.call(-4L) #>     dcall <- deparse(call, nlines = 1L) #>     prefix <- paste(\"Error in\", dcall, \": \") #>     LONG <- 75L #>     sm <- strsplit(conditionMessage(e), \"\\n\")[[1L]] #>     w <- 14L + nchar(dcall, type = \"w\") + nchar(sm[1L], type = \"w\") #>     if (is.na(w)) w <- 14L + nchar(dcall, type = \"b\") + nchar(sm[1L], type = \"b\") #>     if (w > LONG) prefix <- paste0(prefix, \"\\n  \") #>   } else prefix <- \"Error : \" #>   msg <- paste0(prefix, conditionMessage(e), \"\\n\") #>   .Internal(seterrmessage(msg[1L])) #>   if (!silent && isTRUE(getOption(\"show.error.messages\"))) { #>     cat(msg, file = outFile) #>     .Internal(printDeferredWarnings()) #>   } #>   invisible(structure(msg, class = \"try-error\", condition = e)) #> }) #> \t -> tryCatchList(expr, classes, parentenv, handlers) #> \t -> tryCatchOne(expr, names, parentenv, handlers[[1L]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> withCallingHandlers(withVisible(eval(expr, envir, enclos)), warning = wHandler, #> error = eHandler, message = mHandler) #> \t -> withVisible(eval(expr, envir, enclos)) #> \t -> eval(expr, envir, enclos) #> \t -> eval(expr, envir, enclos) #> \t -> humdata %hum>% c(by ~ Spine, do ~ table(.)) %hum>% c(mfcol ~ c(2, 2), doplot ~ #>   barplot(.)) #> \t -> is.humdrumR((x)) #> \t -> humdata %hum>% c(by ~ Spine, do ~ table(.)) #> \t #> Error: In the call `%hum>%`(humdrumR = _), the argument humdrumR must be a humdrumR object.       humdata %hum>%      c(by ~ Spine, do ~ table(.)) %hum<%      (do ~ sort(.))     #> humdrumR error in: #> \ttryCatch(withCallingHandlers({ #>   NULL #>   saveRDS(do.call(do.call, c(readRDS( #>     \"/home/nat/.tmp/Rtmpdij6pd/callr-fun-3daf19237390\"), list(envir = .GlobalEnv, #>     quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmpdij6pd/callr-res-3daf16c3946c9\") #>   flush(stdout()) #>   flush(stderr()) #>   NULL #>   invisible() #> }, error = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmpdij6pd/callr-res-3daf16c3946c9\", \".error\")) #>   } #> }, interrupt = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmpdij6pd/callr-res-3daf16c3946c9\", \".error\")) #>   } #> }, callr_message = function(e) { #>   try(signalCondition(e)) #> }), error = function(e) { #>   NULL #>   try(stop(e)) #> }, interrupt = function(e) { #>   NULL #>   e #> }) #> \t -> tryCatchList(expr, classes, parentenv, handlers) #> \t -> tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), names[nh], #> parentenv, handlers[[nh]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> tryCatchList(expr, names[-nh], parentenv, handlers[-nh]) #> \t -> tryCatchOne(expr, names, parentenv, handlers[[1L]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> withCallingHandlers({ #>   NULL #>   saveRDS(do.call(do.call, c(readRDS( #>     \"/home/nat/.tmp/Rtmpdij6pd/callr-fun-3daf19237390\"), list(envir = .GlobalEnv, #>     quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmpdij6pd/callr-res-3daf16c3946c9\") #>   flush(stdout()) #>   flush(stderr()) #>   NULL #>   invisible() #> }, error = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmpdij6pd/callr-res-3daf16c3946c9\", \".error\")) #>   } #> }, interrupt = function(e) { #>   { #>     callr_data <- as.environment(\"tools:callr\")$`__callr_data__` #>     err <- callr_data$err #>     assign(\".Traceback\", .traceback(4), envir = callr_data) #>     dump.frames(\"__callr_dump__\") #>     assign(\".Last.dump\", .GlobalEnv$`__callr_dump__`, envir = callr_data) #>     rm(\"__callr_dump__\", envir = .GlobalEnv) #>     e$call <- deparse(conditionCall(e), nlines = 6) #>     e2 <- err$new_error(conditionMessage(e), call. = conditionCall(e)) #>     class(e2) <- c(\"callr_remote_error\", class(e2)) #>     e2$error <- e #>     calls <- sys.calls() #>     dcframe <- which(vapply(calls, function(x) length(x) >= 1 && identical(x[[ #>       1]], quote(do.call)), logical(1)))[1] #>     if (!is.na(dcframe)) e2$`_ignore` <- list(c(1, dcframe + 1L)) #>     e2$`_pid` <- Sys.getpid() #>     e2$`_timestamp` <- Sys.time() #>     if (inherits(e, \"rlib_error_2_0\")) e2$parent <- e$parent #>     e2 <- err$add_trace_back(e2, embed = FALSE) #>     saveRDS(list(\"error\", e2), file = paste0( #>       \"/home/nat/.tmp/Rtmpdij6pd/callr-res-3daf16c3946c9\", \".error\")) #>   } #> }, callr_message = function(e) { #>   try(signalCondition(e)) #> }) #> \t -> saveRDS(do.call(do.call, c(readRDS( #>   \"/home/nat/.tmp/Rtmpdij6pd/callr-fun-3daf19237390\"), list(envir = .GlobalEnv, #>   quote = TRUE)), envir = .GlobalEnv, quote = TRUE), file = \"/home/nat/.tmp/Rtmpdij6pd/callr-res-3daf16c3946c9\") #> \t -> do.call(do.call, c(readRDS(\"/home/nat/.tmp/Rtmpdij6pd/callr-fun-3daf19237390\"), #> list(envir = .GlobalEnv, quote = TRUE)), envir = .GlobalEnv, quote = TRUE) #> \t -> <function(what, args, quote = FALSE, envir = parent.frame()) { #>   if (!is.list(args)) stop(\"second argument must be a list\") #>   if (quote) args <- lapply(args, enquote) #>   .Internal(do.call(what, args, envir)) #> }>(base::quote(<function(..., crayon_enabled, crayon_colors, pkgdown_internet) { #>   options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, #>     pkgdown.internet = pkgdown_internet) #>   pkgdown::build_site(...) #> }>), base::quote(<list: pkg = <pkgdown>, examples = TRUE, run_dont_run = FALSE, #>   seed = 1014, lazy = FALSE, ...>), envir = base::quote(<environment>), quote = base::quote( #>   TRUE)) #> \t -> <function(..., crayon_enabled, crayon_colors, pkgdown_internet) { #>   options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, #>     pkgdown.internet = pkgdown_internet) #>   pkgdown::build_site(...) #> }>(pkg = base::quote(<pkgdown>), examples = base::quote(TRUE), run_dont_run = base::quote( #>   FALSE), seed = base::quote(1014), lazy = base::quote(FALSE), override = base::quote( #>   <list: >), install = base::quote(FALSE), preview = base::quote(FALSE), #> new_process = base::quote(FALSE), devel = base::quote(FALSE), crayon_enabled = base::quote( #>   TRUE), crayon_colors = base::quote(256L), pkgdown_internet = base::quote(TRUE)) #> \t -> pkgdown::build_site(...) #> \t -> build_site_local(pkg = pkg, examples = examples, run_dont_run = run_dont_run, #>   seed = seed, lazy = lazy, override = override, preview = preview, devel = devel) #> \t -> build_reference(pkg, lazy = lazy, examples = examples, run_dont_run = run_dont_run, #>   seed = seed, override = override, preview = FALSE, devel = devel) #> \t -> purrr::map(topics, build_reference_topic, pkg = pkg, lazy = lazy, examples_env = examples_env, #>   run_dont_run = run_dont_run) #> \t -> .f(.x[[i]], ...) #> \t -> withCallingHandlers(data_reference_topic(topic, pkg, examples_env = examples_env, #>   run_dont_run = run_dont_run), error = function(err) { #>   msg <- c(paste0(\"Failed to parse Rd in \", topic$file_in), i = err$message) #>   abort(msg, parent = err) #> }) #> \t -> data_reference_topic(topic, pkg, examples_env = examples_env, run_dont_run = run_dont_run) #> \t -> run_examples(tags$tag_examples[[1]], env = if (is.null(examples_env) #> ) NULL else new.env(parent = examples_env), topic = tools::file_path_sans_ext( #>   topic$file_in), run_dont_run = run_dont_run) #> \t -> highlight_examples(code, topic, env = env) #> \t -> downlit::evaluate_and_highlight(code, fig_save = fig_save_topic, env = child_env( #>   env), output_handler = evaluate::new_output_handler(value = pkgdown_print)) #> \t -> evaluate::evaluate(code, child_env(env), new_device = TRUE, output_handler = output_handler) #> \t -> evaluate_call(expr, parsed$src[[i]], envir = envir, enclos = enclos, debug = debug, #> last = i == length(out), use_try = stop_on_error != 2L, keep_warning = keep_warning, #> keep_message = keep_message, output_handler = output_handler, include_timing = include_timing) #> \t -> timing_fn(handle(ev <- withCallingHandlers(withVisible(eval(expr, envir, enclos)), #> warning = wHandler, error = eHandler, message = mHandler))) #> \t -> handle(ev <- withCallingHandlers(withVisible(eval(expr, envir, enclos)), #> warning = wHandler, error = eHandler, message = mHandler)) #> \t -> try(f, silent = TRUE) #> \t -> tryCatch(expr, error = function(e) { #>   call <- conditionCall(e) #>   if (!is.null(call)) { #>     if (identical(call[[1L]], quote(doTryCatch))) call <- sys.call(-4L) #>     dcall <- deparse(call, nlines = 1L) #>     prefix <- paste(\"Error in\", dcall, \": \") #>     LONG <- 75L #>     sm <- strsplit(conditionMessage(e), \"\\n\")[[1L]] #>     w <- 14L + nchar(dcall, type = \"w\") + nchar(sm[1L], type = \"w\") #>     if (is.na(w)) w <- 14L + nchar(dcall, type = \"b\") + nchar(sm[1L], type = \"b\") #>     if (w > LONG) prefix <- paste0(prefix, \"\\n  \") #>   } else prefix <- \"Error : \" #>   msg <- paste0(prefix, conditionMessage(e), \"\\n\") #>   .Internal(seterrmessage(msg[1L])) #>   if (!silent && isTRUE(getOption(\"show.error.messages\"))) { #>     cat(msg, file = outFile) #>     .Internal(printDeferredWarnings()) #>   } #>   invisible(structure(msg, class = \"try-error\", condition = e)) #> }) #> \t -> tryCatchList(expr, classes, parentenv, handlers) #> \t -> tryCatchOne(expr, names, parentenv, handlers[[1L]]) #> \t -> doTryCatch(return(expr), name, parentenv, handler) #> \t -> withCallingHandlers(withVisible(eval(expr, envir, enclos)), warning = wHandler, #> error = eHandler, message = mHandler) #> \t -> withVisible(eval(expr, envir, enclos)) #> \t -> eval(expr, envir, enclos) #> \t -> eval(expr, envir, enclos) #> \t -> humdata %hum>% c(by ~ Spine, do ~ table(.)) %hum<% (do ~ sort(.)) #> \t -> is.humdrumR((x)) #> \t -> humdata %hum>% c(by ~ Spine, do ~ table(.)) #> \t #> Error: In the call `%hum>%`(humdrumR = _), the argument humdrumR must be a humdrumR object."},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humReference.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize reference records in a humdrumR corpus — humReference","title":"Summarize reference records in a humdrumR corpus — humReference","text":"reference one humdrumR's summary functions, used tabulate reference records present humdrumR corpus. reference takes humdrumR object returns humReference table. Alternatively, reference can take character string, check known reference codes print information matching codes. instance, reference('OTL') returns description standard humdrum !!!OTL reference record (original title metadata).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humReference.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize reference records in a humdrumR corpus — humReference","text":"","code":"reference(x)  reference('OTL')  reference(humdata)  # S3 method for humReference [(refTable, i, j, drop = FALSE)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humReference.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summarize reference records in a humdrumR corpus — humReference","text":"humReference table one column reference code appears humdrumR corpus. Since reference records can long (much print one screen), humdrum files can multiple type reference code (instance multiple composers annotated \"!!!COM\"), default, humReference prints number type reference record appear file. However, one type reference code present humReference table, complete reference records code printed file. Likewise, one file present table, file's complete reference records printed. Thus, want see actualy reference records, try indexing humReference table one column row (see ). humReference table one row file corpus. Rows labeled file's corresponding number (humTable's File field) name (Filename field). addition, humReference object printed, three different summary totals printed reference code: indicates many files corpus least one example code . Sum indicates total number reference code appear corpus, including multiple appearances one file (like multiple \"!!!COM\" records). Finally, Unique tabulates number unique tokens reference code---corpus hase two unique composers (encoded \"!!!COM\"), Unique total 2.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humReference.html","id":"indexing","dir":"Reference","previous_headings":"","what":"Indexing","title":"Summarize reference records in a humdrumR corpus — humReference","text":"humReference tables can indexed much like base R [data.frames][base::data.frame()],  two arguments: (rows) andj(columns). Ifiorjarenumeric, select rows columns respectively, ordinally. iis acharacter, matched regular expression filenames corpus. jis acharacter`, partially matched column names. drop argument also available. TRUE, plain [data.table][data.table::data.table()] returned.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humSize.html","id":null,"dir":"Reference","previous_headings":"","what":"humdrumR data size and shape — humSize","title":"humdrumR data size and shape — humSize","text":"functions can used quickly get basic information size \"shape\" humdrumR corpus objects. details, use census() spines() functions instead. HumdrumR objects can divided \"subcorpora.\" anySubcorpora namesSubcorpora functions tell us subcorpora , , called.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humSize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"humdrumR data size and shape — humSize","text":"","code":"nrecord(humdrumR, dataTypes = \"GLIMDd\")  # S4 method for humdrumR nrow(x)  ntoken(humdrumR, dataTypes = \"GLIMDd\")  npiece(humdrumR)  nfile(humdrumR)  # S4 method for humdrumR length(x)  # S4 method for humdrumR ncol(x)  # S4 method for humdrumR dim(x)  is.empty(humdrumR)  anyMultiPieceFiles(humdrumR)  anyPaths(humdrumR)  anyStops(humdrumR)  anySubcorpora(humdrumR)  namesSubcorpora(humdrumR)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humSize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"humdrumR data size and shape — humSize","text":"humdrumR humdrumR data object. dataTypes (character) types humdrum records count. Legal values 'G', 'L', '', 'M', 'D', 'd' combination (e.g., \"LIM\"). x humdrumRclass data object.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humSize.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"humdrumR data size and shape — humSize","text":"following functions defined. nfile : number input files corpus. length(humdrumR) synonym. npiece: number pieces corpus. (may multiple pieces per file.) nrecord: number records corpus. nrow(humdrumR) synonym. ntoken: number tokens corpus. ncol(humdrumR): Returns maximum number \"columns\" need represent data 2d matrix. Matches default output .matrix(humdrumR). dim(humdrumR): c(nrow(humdrumR), ncol(humdrumR)).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humSize.html","id":"is-any","dir":"Reference","previous_headings":"","what":"Is/Any","title":"humdrumR data size and shape — humSize","text":"additional functions return quick TRUE/FALSE answers regarding humdrumR corpus: .empty: Returns TRUE corpus contains non-null data tokens (D tokens). anyPaths: Returns TRUE spine paths (Path > 0) pieces corpus. anyStops: Returns TRUE multi-stops (Stop > 1) pieces corpus. anySubcorpora: Returns TRUE corpus read different regex patterns matching \"subcorpora\" labels. namesSubcorpora returns names subcorpora labels (Label field). anyMultiPieceFiles: Returns TRUE files contain one piece (Piece != File).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humSpines.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize spines in humdrum dataset. — humSpines","title":"Summarize spines in humdrum dataset. — humSpines","text":"spines one humdrumR's summary functions, used summarize spines spine paths pieces humdrumR corpus.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humSpines.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize spines in humdrum dataset. — humSpines","text":"","code":"spines(humdrumR)  # S3 method for humSpines [(spines, i, j)  # S3 method for humSpines print(spineTable, showEach = TRUE)"},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humSummary.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize humdrumR corpora — humSummary","title":"Summarize humdrumR corpora — humSummary","text":"Summarizes content humdrumR corpus, calling five different corpus summary functions printing results.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humSummary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize humdrumR corpora — humSummary","text":"","code":"# S3 method for humdrumR summary(object)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humSummary.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summarize humdrumR corpora — humSummary","text":"humdrumR includes number separate functions summarizing different aspects humdrumR data objects: census() Tabulates raw size humdrumR corpus. reference() Tabulates reference records (metadata) file. spines() Tabulates number spines spine paths files corpus. interpretations() Tabulates types exclusive tandem interpretations corpus. sections() Tabulates formal data (*>) corpus, including barlines. function takes humdrumR object returns data.table. summary method humdrumR objects simply calls functions prints condensed version .","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humTable.html","id":null,"dir":"Reference","previous_headings":"","what":"Humdrum tables (and their Fields) — humTable","title":"Humdrum tables (and their Fields) — humTable","text":"humdrumR package, fundamental data structure called Humdrum Table. humdrum table encodes information collection one humdrum-syntax files single data.table (data.table \"enhanced\" version R's standard data.frame). Humdrum tables stored \"inside\" every humdrumRclass object work , various humdrumR functions allow study manipulate . want directly access humdrum table within humdrumRclass object, use getHumtab function. getHumtab extracts hudrum table humdrumR object. Individual fields humdrum table can extracted using getFields. Returns data.table(), column corresponding one field. (data.table column-subset humdrum table). Use fields list current fields humdrumRclass object. returns data.table() three columns: field's Name, Class data held field, Type field (e.g., \"Formal\").","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humTable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Humdrum tables (and their Fields) — humTable","text":"","code":"getHumtab(humdrumR, dataTypes = c(\"G\", \"L\", \"I\", \"M\", \"D\", \"d\"))  getFields(humdrumR, fields = getActiveFields(humdrumR), dataTypes = \"D\")  fields(   humdrumR,   fieldTypes = c(\"Data\", \"Structure\", \"Interpretation\", \"Formal\", \"Reference\") )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humTable.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Humdrum tables (and their Fields) — humTable","text":"humdrumR humdrumR data object. dataTypes character vector. Specifies types data tokens/records extract. Legal values : \"G\" (global comments), \"L\" (local comments), \"\" (interpretations), \"M\" (barlines), \"D\" (non-null data), \"d\" (null data). Multiple types can specified vector, smooshed single string: e.g., \"GLIMD\". fields (character) vector names partially matched field names humdrum table. NULL (default), active fields returned. fieldTypes character type indicating types fields list. Legal options \"Data\", \"Structure\", \"Interpretation\", \"Formal\", \"Reference\". Types can partially matched---example, \"S\" \"Structure\".","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humTable.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Humdrum tables (and their Fields) — humTable","text":"humdrum table, row represents single \"token\" original humdrum data. Even multistops---tokens separated spaces---broken onto rows. Meanwhile, column humdrum table represents single piece information associated token, call field. Throughout documentation, keep mind \"token\" refers row humdrum table \"field\" refers column: Token = row Field = column","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humTable.html","id":"fields-","dir":"Reference","previous_headings":"","what":"Fields:","title":"Humdrum tables (and their Fields) — humTable","text":"five types fields humdrum table: Data fields Structure fields Interpretation fields Formal fields Reference fields first created call readHumdrum() every humdrum table least eighteen fields: one data field (Token), two interpretation fields (Tandem Exclusive), three formal fields, fourteen structure fields. Additional interpretation reference fields may present depending content humdrum file(s), users can create additional data fields using within(humdrumR) (functions).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humTable.html","id":"data-fields-","dir":"Reference","previous_headings":"","what":"Data fields:","title":"Humdrum tables (and their Fields) — humTable","text":"Data fields used describe individual data points humdrum data (opposed groups points). Every humdrum table starts data field called Token, contains character strings representing original strings read humdrum files. Users can create many additional data fields like. Every call withinHumdrum() generates one N new data fields named \\(Result1, Result2, \\ldots, ResultN\\).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humTable.html","id":"structure-fields-","dir":"Reference","previous_headings":"","what":"Structure fields:","title":"Humdrum tables (and their Fields) — humTable","text":"Every humdrum table starts fourteen Structure fields, describe data token \"located\" original humdrum data: file, spine, record, etc. See vignette humdrum syntax fully understand terms . File info: Filename :: character unique name humdrum file. may include appended path one file name read different directories (see readHumdrum() docs). Filepath :: character full file name (always includes full path). Label :: character label specified call readHumdrum(), associated particular readHumdrum \"REpath-pattern.\" label specified, patterns just labeled \"_n\", \"n\" number pattern. File :: integer unique number associated file (ordered alphabetically, starting 1). Piece :: integer number specifying number piece corpus. identical File field except one piece read file. Location info: Spine :: integer spine, numbered (left--right) starting 1. field NA wherever Global == TRUE. Path :: integer \"spine path.\" time *^ spine path split occurs humdrum data, right side split becomes new \"path.\" original path numbered 0 additional paths numbered integers right. (spine path splits, Path field 0s.) field always NA Global == TRUE. Record :: integer record (.e., line) number original file. NData :: integer data record enumeration file, starting 1. Stop :: integer token multistop token, numbered starting 1. files multistops, Stop field 1s. field always NA Global == TRUE. Global :: logical token come global record (opposed local record)? Global == TRUE, Spine, Path, Stop fields always NA. Token info: Type :: character type record ? \"D\" = non-null data \"d\" = null data \"\" = interpretation \"M\" = measure/barline \"L\" = local comment \"G\" = global comment. Null :: logical active field data field null? See detailed discussion , section documentation called \"Null Data.\" Filter :: logical record/token filtered ?","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humTable.html","id":"interpretation-fields-","dir":"Reference","previous_headings":"","what":"Interpretation fields:","title":"Humdrum tables (and their Fields) — humTable","text":"Interpretation fields describe interpretation metadata humdrum file(s). Humdrum interpretations tokens \"carry forward\" data points , unless cancelled subsequent interpretation. (See humdrum syntax vignette detailed explanation.) humdrum data must exclusive interpretation humdrum tables always Exclusive (:: character) field indicating exclusive interpretation associated token/row Token field. Humdrum data may, may , include additional tandem interpretations. universal rule parsing tandem interpretations impossible, ) tandem interpretations can \"overwrite\" B) users can create tandem interpretations. best can cases identify tandem interpretations appeared previously spine (counting recent first). previous interpretations encoded single character string Tandem field (see extractTandem() docs details). working non-standard interpretations, users can parse Tandem field using extractTandem() function. tandem interpretations occur file, Tandem field full empty strings (\"\"). Fortunately, many tandem interpretations widely used standardized, interpretations known humdrumR. Recognized interpretations (*clefG4 *k[b-]) automatically parsed fields call readHumdrum(). See readHumdrum() documentation details.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humTable.html","id":"formal-fields-","dir":"Reference","previous_headings":"","what":"Formal fields:","title":"Humdrum tables (and their Fields) — humTable","text":"Formal fields indicate musical sections, time windows within piece, including formal designations (\"verse\", \"chorus\", etc.) measures/bars. Humdrum data may may include formal metadata fields, indicated token \"*>\". Classified formal marks put fields matching name. Unclassified formal marks placed field called Formal default. Nested formal categories appended underscore number level descent: Formal_1, Formal_2, ..., Formal_N. part section given name lower hierarchical level, field simply empty (\"\") point. Humdrum data may, may , also include barlines (tokens beginning \"=\"). Humdrum tables always include three formal fields related barlines: Bar :: integer many barline records (single double) passed token? \"=\" tokens occur file, Bar zeros. Note field independent whether barlines labeled numbers humdrum file! DoubleBar :: integer many double-barline records passed token? \"==\" tokens occur file, DoubleBar zeros. BarLabel :: character characters occur barline-token initial \"=\" \"==\". include \"-\" common \"implied barline\" token \"=-\", repeat tokens (like \"=:||\"), also explicit bar numbers. Note Bar field always enumerate every bar record, measure-number labels humdrum data (appear BarLabel field) may weird things like skipping numbers, repeating numbers, suffixes (e.g., \"19a\"). barline tokens appear file, BarLabel empty strings (\"\").","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humTable.html","id":"reference-fields-","dir":"Reference","previous_headings":"","what":"Reference fields:","title":"Humdrum tables (and their Fields) — humTable","text":"Reference fields describe Reference Records humdrum data. Every reference record (records beginning \"!!!\") humdrum file corpus read readHumdrum parsed field named reference code: \"XXX\" \"!!!XXX\". Reference tokens identical throughout humdrum piece. reference code appears one file another, field NA file code. reference records appear files read readHumdrum(), reference fields created. Examples common reference records \"!!!COM:\" (composer) \"!!!OTL:\" (original title). humdrum data records end COM OTL fields humdrum table.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humTable.html","id":"null-data-","dir":"Reference","previous_headings":"","what":"Null Data:","title":"Humdrum tables (and their Fields) — humTable","text":"humdrum syntax, requirement every spine-path contains data every record. Rather, spines often padded null tokens. cases, entire records may padded null tokens. type humdrum record uses different null token: Intepretation: * Comment: ! Barline: = Data: . Null tokens humdrum table identified logical Null field. Null field set humdrum table created (readHumdrum()) updated everytime new active field set. Null set TRUE wherever, either active field character data token single \".\", \"!\", \"=\", \"*\"; active field NA (including NA_character_). parallel Null field, null data tokens (\".\") identified record type: \"d\". updates/changes Null field also propagated Type field---.e., setting Type == d wherever data record Null. important/useful withinHumdrum() routines , default, applied \"D\" data, ignoring \"d\". Whenever print export [humdrumR objecthumdrumRclass, null data active field (.e., Null == TRUE) prints \".\". Thus, working numeric data NA values, NA values print \".\".","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humTable.html","id":"reshaping-","dir":"Reference","previous_headings":"","what":"Reshaping:","title":"Humdrum tables (and their Fields) — humTable","text":"Breaking complex syntax humdrum data \"flat\" structure humdrum table, every single token one line data.table, makes humdrum data easier analyze. course, thanks structure fields, can easily regroup reform original humdrum data use structure data (like spines) analyses. However, cases, might want work humdrum data different structure \"shape.\" humdrumR several options \"collapsing\" tokens within humdrum tables, \"folding\" different parts data new fields, otherwise reshaping humdrum data basic R data structures might prefer.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humValidation.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate humdrum files — humValidation","title":"Validate humdrum files — humValidation","text":"function checks files violations humdrum syntax.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humValidation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate humdrum files — humValidation","text":"","code":"validateHumdrum(   ...,   contains = NULL,   recursive = FALSE,   errorReport.path = NULL )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humValidation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate humdrum files — humValidation","text":"recursive logical. TRUE, final part search pattern (.e., file search) searched recursively sub directories. errorReport.path character. directory path , NULL, error report written file 'humdrumR_syntaxErrorReport_date.txt'. addition, files errors written directory ('errorMarkup' appended names), errors annotated inline. patterns character vector. Search pattern(s) identifying files (see [readHumdrum][readHumdrum]). files list character strings, representing record file.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humWindows.html","id":null,"dir":"Reference","previous_headings":"","what":"Create arbitrary ","title":"Create arbitrary ","text":"Create arbitrary \"windows\" across vectors.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humWindows.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create arbitrary ","text":"","code":"windows(   x,   open,   close = ~Next(open) - 1L,   start = 1,   end = length(x),   nest = FALSE,   depth = NULL,   groupby = NULL,   min_length = 1L,   max_length = Inf )  nested(x, open, close, depth = 1L)  hop(along, pattern = 1, start = 1L, end = length(along))  windowApply(   x,   func = c,   windows,   ...,   passOutside = FALSE,   reference = x,   rebuild = TRUE,   leftEdge = TRUE )  applyNgram(   n = 2,   vecs,   f = c,   by = NULL,   pad = TRUE,   fill = NA,   splat = !is.null(by),   ... )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumDispatch.html","id":null,"dir":"Reference","previous_headings":"","what":"Regular expression method dispatch and function application — humdrumDispatch","title":"Regular expression method dispatch and function application — humdrumDispatch","text":"humdrumR regular-expression method dispatch system simple system making new functions can smartly applied variety character strings. Humdrum dispatch works like normal R method dispatch, instead dispatching specific methods based class (integer, character, etc.) dispatches based regular expressions. addition, exclusive interpretations can used guide dispatch.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumDispatch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Regular expression method dispatch and function application — humdrumDispatch","text":"","code":"humdrumDispatch(   x,   dispatchDF,   Exclusive = NULL,   funcName = NULL,   regexApply = TRUE,   multiDispatch = FALSE,   ...,   outputClass = \"character\" )  exclusiveDispatch(   x,   dispatchDF,   Exclusive,   regexApply = TRUE,   outputClass = \"character\",   inPlace = FALSE,   ... )  makeDispatchDF(...)  makeHumdrumDispatcher(   ...,   funcName = \"humdrum-dispatch\",   outputClass = \"character\",   args = alist() )  # S3 method for humdrumDispatch print(x)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumDispatch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Regular expression method dispatch and function application — humdrumDispatch","text":"dispatchDF data.frame describes function called regex input. (See details). Exclusive Defaults NULL. NULL, regexes used dispatch. multiDispatch logical, length 1. FALSE (default) \"best\" regex/exclusive match dispatched Exclusive segment. TRUE, differenet functions can dispatched within input vector. ... Arguments pass dispatch functions. outputClass Character string: default output class function return. Generally, make sense, dispatched functions return type, explicitly indicate outputClass argument. Dispatch functions also vectorized. str input character string, dispatch called.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumDispatch.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Regular expression method dispatch and function application — humdrumDispatch","text":"Many humdrumR functions fact, humdrum-dispatch functions: example, tonalInterval.character(). call tonalInterval('ee-'), function recognize input string token  **kern representation, call appropriate parser. instead call tonalInterval(''), function recognize input string token **solfa representation, call appropriate parser .","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumDispatch.html","id":"dispatchdf","dir":"Reference","previous_headings":"","what":"dispatchDF","title":"Regular expression method dispatch and function application — humdrumDispatch","text":"dispatchDF must data.table::data.table() created using makeDispatchDF function. makeDispatchDF takes one arguments, list three components (ordered, nameed): character vector exclusive interpretations. (Specify \"\" want exclusive dispatch). regular expression (character string) function can generate regular expression, accepts ... arguments time dispatch. function dispatch.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumDispatch.html","id":"makehumdrumdispatcher","dir":"Reference","previous_headings":"","what":"makeHumdrumDispatcher","title":"Regular expression method dispatch and function application — humdrumDispatch","text":"makeHumdrumDispatcher function creates new function automatically performs humdrum-dispatch. number important humdrumR functions created makeHumdrumDispatcher: tonalInterval.character diatonicSet.character tertianSet.character rhythmInterval.character","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumDispatch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Regular expression method dispatch and function application — humdrumDispatch","text":"","code":"u <- c('A', 'B', 'CD', 'E', 'F', 'gh', 'L', 'KX') l <- c('a', 'b', 'cd', 'e', 'f', 'gh', 'l', 'kx')  lowercasefunc <- \\(x) 5L - nchar(x)  humdrumDispatch(l, outputClass = 'integer',                 makeDispatchDF(list('any', '[a-z]+',  lowercasefunc),                                list('any', '[A-Z]+',  nchar))) #> [1] 4 4 3 4 4 3 4 3 #> attr(,\"dispatch\") #> attr(,\"dispatch\")$Original #> [1] \"a\"  \"b\"  \"cd\" \"e\"  \"f\"  \"gh\" \"l\"  \"kx\" #>  #> attr(,\"dispatch\")$Regexes #>   [a-z]+  #> \"[a-z]+\"  #>  #> attr(,\"dispatch\")$Segments #> [1] 1 #>  #> attr(,\"dispatch\")$Exclusives #> [1] \"any\" #>   # lowercasefunc will be called on l, nchar on u"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumPitch.html","id":null,"dir":"Reference","previous_headings":"","what":"humdrumR and pitch — humdrumPitch","title":"humdrumR and pitch — humdrumPitch","text":"humdrumR includes number intertwined data structures, associated functions, representing manipulating musical pitch information.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumPitch.html","id":"tonality","dir":"Reference","previous_headings":"","what":"Tonality","title":"humdrumR and pitch — humdrumPitch","text":"four data types extensively used humdrumR encode/process tonal musical information: integers --- used encode \"line--fifths\" tonal information tonalInterval --- embeds line--fifth tonal integers alongside octave cent information encode tonal pitch representations (solfege, intervals, letternames, etc.) diatonicSet --- combines line--fifth tonal integer representations represent diatonic tonality, including alterations basic diatonic scale(s). tertianSet --- extension diatonicSet used encode  tertian diatonic harmonies. Users rarely need engage data types. Rather, users work humdrum data pitch information encoded strings, wish manipulate analyze data. widely used humdrumR tools pitch conversion/manipulation functions, including kern(), functions like invert() transpose(). functions make use sophisticated, flexible pitch parsing deparsing functions, bridge \"core\" pitch representations listed real-world humdrum data.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumPitch.html","id":"atonality","dir":"Reference","previous_headings":"","what":"Atonality","title":"humdrumR and pitch — humdrumPitch","text":"SECTION INCOMPLETE addition, xxx data types used encode non-tonal (atonal) pitch information. integers --- used encode semitones (well MIDI numbers). xxx --- sets? xxx --- 12-tone rows?","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumR.html","id":null,"dir":"Reference","previous_headings":"","what":"humdrumR — humdrumR","title":"humdrumR — humdrumR","text":"humdrumR toolkit analysis data encoded humdrum syntax. humdrum syntax incredibly flexible, powerful, scheme encoding musical data. Tens thousands musical scores (musical data) encoded humdrum syntax, many available online repositories KernScores.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumR.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"humdrumR — humdrumR","text":"humdrumR intended modernized replacement original humdrum toolkit, leveraging power R give us unprecedented power manipulate analyze humdrum data using concise, expressive syntax.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumR.html","id":"package-design","dir":"Reference","previous_headings":"","what":"Package design","title":"humdrumR — humdrumR","text":"package humdrumR seven main components: represent humdrum data R, humdrumR S4 class, core component humdrum table. create humdrumR data, sophisticated humdrum data parser: readHumdrum. humdrumR data can also written back humdrum-syntax text files using writeHumdrum. filter humdrumR data, subset.humdrumR() function, can also called using R's standard indexing operators: [] [[]]. manipulate modify humdrumR data, within methods humdrumR objects. facilitate development functions work humdrum tokens---simple character strings packed information---, useful API call regular-expression dispatch system. Several modules representing manipulating musical pitch information, including core tonalInterval class represent tonal pitch. module representing manipulating musical rhythm information, core rhythmInterval class represent rhythms.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumRclass.html","id":null,"dir":"Reference","previous_headings":"","what":"humdrumR class — humdrumRclass","title":"humdrumR class — humdrumRclass","text":"S4 class basic unit humdrumR package. humdrumR object represents data read one humdrum files. documentation, refer objects interchangeably \"humdrumR corpora\", \"humdrumR objects,\" humdrumR data(sets). coding examples name \"humData.\"","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumRclass.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"humdrumR class — humdrumRclass","text":"","code":"is.humdrumR(x)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumRclass.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"humdrumR class — humdrumRclass","text":"important part humdrumR object humdrum tables holds within ; essence, humdrumR object simply wrapper around humdrum table, helps users visualize, index, summarize, manipulate table variety ways. Basic information size shape humdrumR objects can obtained calls nrecord, npiece, length, ncol, etc.. detailed summary information can obtained humdrumR corpus summary functions. humdrumR data can also coerced basic R data types using .matrix, .data.frame, etc.. number helpful functions also defined \"reshape\" reorganize data (e.g., foldHumdrum(), collapseHumdrum()), extract data \"normal\" R data structures (e.g, .matrix.humdrumR(), evalActive()). powerful features humdrumR tools gives ... Print readable view data shorthand/curtailed humdrum syntax. Filter humdrumR data, using subset.humdrumR() standard R indexing operators: [] [[]]. Apply arbitrary commands humtable fields using ()Humdrum routines.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumRclass.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"humdrumR class — humdrumRclass","text":"Humtable humdrum tables---.e, data.table::data.table() particular fields. Files list two elements. first, \"Search\", contains single character representing pattern used call readHumdrum() created humdrumR object. second, \"Names,\" vector strings representing files matched pattern read humdrumR object, names() corresponding \"subcorpora\" labels (Label). Fields list containing strings corresponding existing fields humdrumR object's humdrum table. fields divided five categories: \"Data\", \"Structure\", \"Interpretation\", \"Formal\", \"Reference.\" Active rlang::quosure() expression serves default, \"active expression\" dataset. LoadTime POSIXct value, indicating time readHumdrum() called create humdrumR object.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumRroot.html","id":null,"dir":"Reference","previous_headings":"","what":"humdrumR's root directory on your machine. — humdrumRroot","title":"humdrumR's root directory on your machine. — humdrumRroot","text":"humdrumRroot path humdrumR package install machine. installed humdrumR basic humdrum files stored well, subdirectories examples HumdrumData.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumRroot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"humdrumR's root directory on your machine. — humdrumRroot","text":"","code":"humdrumRroot"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumRroot.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"humdrumR's root directory on your machine. — humdrumRroot","text":"object class character length 1.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/indexHumdrum.html","id":null,"dir":"Reference","previous_headings":"","what":"Indexing humdrumR objects — indexHumdrum","title":"Indexing humdrumR objects — indexHumdrum","text":"R's built-indexing operators, [] (single brakcets) [[]] (double brackets) can used shortcuts common calls subset.humdrumR(), allowing filter specific files, spines, records.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/indexHumdrum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Indexing humdrumR objects — indexHumdrum","text":"","code":"humdata[] # returns unchanged  humdata[x:y]  humdata['regex']  humdata[[x:y]]  humdata[[ , x:y]]  humdata[['regex']]  humdata[[ , 'regex']]  humdata[[x:y, l:m]]"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/indexHumdrum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Indexing humdrumR objects — indexHumdrum","text":"x humdrumR data object. integer/numeric value character string treated regular expression. j integer/numeric value character string treated regular expression.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/indexHumdrum.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Indexing humdrumR objects — indexHumdrum","text":"R, basic indexing operators, [] [[]], used select subsets data. many data types (instance, base R lists) [single brackets] used \"shallower\" extraction [[double brackets]] used \"deeper\" extraction. HumdrumR corpus indexing follows basic pattern: [single brackets] used index humdrumR objects piece [[double brackets]] used index within pieces. (Accidentally writing [] need [[]] common error, watch !) Whether, indexing piece within, humdrumR objects can use two types indexing arguments: numeric (ordinal integers) character string (regular expressions) powerful/flexible indexing options, use subset directly.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/indexHumdrum.html","id":"numeric-indexing-","dir":"Reference","previous_headings":"","what":"Numeric indexing:","title":"Indexing humdrumR objects — indexHumdrum","text":"Indexing humdrumR corpora [single brackets] accept one numeric argument. argument used pick pieces within humdrumR object ordinally. Thus, humdata[1:10] select first ten pieces data humdata[42] select 42nd piece. Indexing humdrumR objects [[double brackets]] accept one two numeric arguments, j, either can used isolation combination. (j used isolation, must named placed comma, humdata[[ , j ]].) used index data records (.e., based humtable Record field). Thus, humdata[[1:20]] indexes first twenty records file corpus, humdata[[42]] extracts 42nd record file. j used index spines  (.e., based Spine field). Thus, humdata[[ , 3:4]] returns third fourth spines file corpus. indexing humdrumR corpora numbers, numeric (double) inputs converted integers. Since subset always renumbers files/spines remain filtering/indexing, humdrumR indexing entirely ordinal. example, return 12th piece original humdata object. first call [] returns 11th 20th pieces, renumbered 1:10 second index call returns new 2nd index, 12th originally. Similarly, return third spine original data. normal R indexing, negative numbers can used, causing corresponding elements removed instead retained. Thus, humdata[-3:-5] remove third, fourth, fifth pieces data humdata[[ , -3:-5]] remove third, fourth, fifth spines piece. Positive negative indices mixed single argument. cases, indices outside range (value 0) ignored. E.g., corpus twenty files call corpus[21], 21st piece, 21 \"range\". input indices 0 error result. input indices range empty humdrumR object returned. instance, humdata[[401:500, ]] return empty humdrumR object pieces 400 data records.","code":"humsubset <- humdata[11:20] humsubset[2] humsubset2 <- humdata[[ , 2:4]] humsubset2[[ , 2]]"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/indexHumdrum.html","id":"character-indexing-","dir":"Reference","previous_headings":"","what":"Character indexing:","title":"Indexing humdrumR objects — indexHumdrum","text":"Indexing humdrumR objects [single brackets] accept one vector character strings. strings treated regular expressions (regexes). tokens humdrumR object's active field(s) searched matches regular expressions input. piece contains match regular expressions retained---pieces filtered . Note ([single-bracket] indexing) entire piece retained, even one match. matches occur pieces, empty humdrumR object returned. Indexing humdrumR objects [[double brackets]] accept one two vectors character strings, j, either can used isolation combination. (j used isolation, must placed comma, humdata[[ , j]].) strings treated regular expressions (regexes). tokens humdrumR object's active field(s) searched matches regular expressions input. record contains least one token matching regex retained. Similarly, spine contains least one token matching regex j retained. j used together, matching spines (j) indexed first, tokens matching regular expression(s) must found matching spines.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/indexHumdrum.html","id":"removeempty","dir":"Reference","previous_headings":"","what":"removeEmpty","title":"Indexing humdrumR objects — indexHumdrum","text":"default, calls indexing operators completely remove data filtering . However, set removeEmpty argument FALSE, filtered data set NULL, actually removed data object. (See subset.humdrumR() details.)","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/int.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate intervals between pitches — int","title":"Calculate intervals between pitches — int","text":"functions allow us calculate intervals pitches. int() basic form, calculating interval(s) two input vectors. mint() hint() special forms calculating intervals \"melodically\" \"harmonically,\" respectively.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/int.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate intervals between pitches — int","text":"","code":"int(   x,   from = tint(0L, 0L),   deparser = interval,   incomplete = NULL,   bracket = TRUE,   classify = FALSE,   ...,   Exclusive = NULL,   Key = NULL,   parseArgs = list() )  mint(   x,   lag = 1,   deparser = interval,   incomplete = kern,   bracket = TRUE,   classify = FALSE,   ...,   parseArgs = list(),   Exclusive = NULL,   Key = NULL,   groupby = list(),   orderby = list() )  hint(   x,   lag = 1,   deparser = interval,   incomplete = kern,   bracket = TRUE,   ...,   parseArgs = list(),   Exclusive = NULL,   Key = NULL,   groupby = list(),   orderby = list() )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/int.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate intervals between pitches — int","text":"x vector parsed tonal interval. vector parsed tonal interval. deparser pitch function generate output representation. Defaults interval(). incomplete Either pitch function atomic value length(incomplete) == abs(lag). bracket (logical, length == 1) TRUE, square brackets (\"[]\") printed around incomplete observations. classify (logical, length == 1) TRUE, deparser ignored output classified Unison, Step, Skip, Leap. parseArgs list arguments pass pitch parser. groupBy list vectors, length x, used group x . orderBy list vectors, length x, used interpret order elements x. Lagged computations done indicated order, output returned original order.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/int.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate intervals between pitches — int","text":"Input vectors x () parsed pitches (tonal interval objects), possible. (Parsing arguments can passed via parseArgs list, parse(...) sugar. Key Exclusive arguments also passed parser.) inputs fail parse show NA output. parsed, intervals pitches calculated x - . resulting intervals \"deparsed\" standard representation; default, intervals() representation used, can set deparser argument pitch function. However, alternative deparser commonly used (besides intervals()) semits(). deparser NULL, raw tonalIntervals returned.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/int.html","id":"melodic-and-harmonic-intervals","dir":"Reference","previous_headings":"","what":"Melodic and Harmonic intervals","title":"Calculate intervals between pitches — int","text":"mint hint calculate \"melodic\" \"harmonic\" intervals respectively. context, \"melodies\" sequences notes within spine path, \"harmonies\" intervals notes occurring record (time). Outside () call, mint hint exactly ; used call () see different behaviors, () automatically apply across spine paths (mint()) records (hint()). achieved modifying groupby orderby arguments lag()---can manually achieve default behaviors, behaviors, setting arguments . used () expression, mint() (default) calculate melodic interval approaching note previous note: example, mint('C4', 'D4', 'Eb4') fill return c('[c]', '+M2', '+m2'), D4 approached ascending whole step C4, Eb4 approached ascending half step D4. Similarly, default () behavior hint() calculate successive intervals record (across spine paths), left right. record C3  G4  C5 return values [CC]  +P12  +P4, G4 perfect 12th C3, C5 perfect fourth G4. mint() hint() work passing lagged /dittoed versions x argument int(). Basically, mint() equivalent int(x, lag(x, lag = lag, groupby = list(File, Spine, Path)), ...) hint() equivalent int(x, lag(x, lag = lag, groupby = list(File, Record), orderby = list(File, Record, Spine, Path)), ...). either case, parsed pitch vector copied lagged using lag(), pairs crossing outside groupby groups ignored. lag argument controls far apart melody intervals calculated. instance, lag 2 calculate intervals every note vector. Positive lags (default) calculate approaching intervals: token represents interval current note previous note. Negative lags calculate departing intervals: token represents interval current note next note. Note , passing directed = FALSE deparser, undirected (absolute value) melodic intervals can returned.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/int.html","id":"incomplete-value-padding","dir":"Reference","previous_headings":"","what":"Incomplete value padding","title":"Calculate intervals between pitches — int","text":"default, int return NA anywhere x NA. However, NA x NA, can ask different output \"incomplete\" pairs. using incomplete argument. incomplete atomic value, incomplete outputs indices willed value. incomplete argument pitch function (like deparser argument), function used (re)parse values x missing. bracket == TRUE, incomplete output values surrounded [], easier distinguish actual intervals. main use incomplete argument mint() hint(). lagged arguments used mint()/hint() (see previous section) necessarily padded abs(lag) NA values beginning (positive lag) end (negative lag). thus \"incomplete\" pairs passed int(), can controlled using incomplete argument. default, mint() hint() set incomplete = kern(), bracket = TRUE cause notes show bracketed kern, like [ee-] [C#]. incomplete NULL, incomplete values simply padded NA.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/int.html","id":"interval-classification","dir":"Reference","previous_headings":"","what":"Interval classification","title":"Calculate intervals between pitches — int","text":"classify argument set TRUE, intervals classified either \"Unison\", \"Step\", \"Skip\", \"Leap\". Alternatively, skips can interpreted leaps setting skips = FALSE. (classify = TRUE overrides deparser argument.) default, intervals categorized tonally, meaning interval tonal steps used basis classification. example, augmented 2nd step, diminished 3rd skip/leap. means augmented diminished unisons marked \"Unison\" well! However, directed = TRUE, augmented/diminished unisons marked + - indicate direction, whereas perfect unisons never marked +/-. Alternatively, may choose categorize intervals atonally setting atonal = TRUE. , intervals categorized based semitone (enharmonic) intervals: D# Eb classified .","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/int.html","id":"logical-ditto-lags","dir":"Reference","previous_headings":"","what":"Logical(ditto) lags","title":"Calculate intervals between pitches — int","text":"calls hint() mint() default behavior numeric lag argument passed lag(). alternate option specify lag argument  logical vector length input (x argument). Rather calculating interval pitch another pitch separated regular lag, logical lag argument \"lags\" pitch back previous value lag == TRUE. means one interval can calculated TRUE indices. canonic use \"logical lag\" feature calculate harmonic intervals relative voice, like bass voice. example, consider file: read file applied hint() Token field (default arguments) result : record, see intervals lagged (lag == 1) left right: see intervals bass tenoir, tenor alto, alto soprano. wanted see intervals bass? Well, can use logical lag argument, specify Spine == 1: (humData, hint(Token, lag = Spine == 1). means values \"lagged\" back previous value Spine == 1. result : Now see intervals relative bass. logical lag takes place within groupby groups. However, note values first index lag == TRUE calculated relative first value.","code":"**kern        **kern        **kern        **kern *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano       C             e             g            cc       G             d             f             b       C             c             e            cc                   *-            *-            *-            *- **kern        **kern        **kern        **kern *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano     [C]          +M10           +m3           +P4     [G]           +P5           +m3           +A4     [C]           +P8           +M3           +m6                   *-            *-            *-            *- **kern        **kern        **kern        **kern *I\"Bass      *I\"Tenor       *I\"Alto    *I\"Soprano     [C]          +M10          +P12          +P14     [G]           +P5           +m7          +M10     [C]           +P8          +M10          +P14                   *-            *-            *-            *-"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/int.html","id":"grouping","dir":"Reference","previous_headings":"","what":"Grouping","title":"Calculate intervals between pitches — int","text":"many cases want perform lagged calculations vector, across certain boundaries. example, vector includes data multiple pieces, want calculate melodic intervals pieces, within pieces. groupby argument indicates one, , grouping vectors, break x (input) argument groups. groupby vectors given, change vector indicates boundary. Value pairs cross groups treated beginning. Basically, using groupby argument function similar identical using tapply(x, groupby, laggedFunction, ...) using groupby expession call ().humdrumR. However, using groupby argument directly usually much faster, specially optimized functions. common use case humdrum data, looking \"melodies\" within spines. , want groupby = list(File, Spine, Path). fact, humdrumR () calls automatically feed three fields groupby arguments certain functions: mint, delta, sigma, lag, ditto. use delta call (), automatically calculate delta \"melodic\" way, within spine path file. However, wanted, instance, calculate differences across spines (like harmonic intervals) manually set groupby = list(File, Record).","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interpolateArguments.html","id":null,"dir":"Reference","previous_headings":"","what":"Change or insert values in an expression — interpolateArguments","title":"Change or insert values in an expression — interpolateArguments","text":"function can used modify arguments functions within existing expression (quosure/formula).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interpolateArguments.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Change or insert values in an expression — interpolateArguments","text":"","code":"interpolateArguments(quo, namedArgs)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interpolateArguments.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Change or insert values in an expression — interpolateArguments","text":"namedArgs list named arguments. Unnamed arguments simply ignored. expr unevaluated expression object.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interpolateArguments.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Change or insert values in an expression — interpolateArguments","text":"interpolateArguments inteprets named value namedArgs argument one two ways: named value list, interprets name list function call, inserts/swaps arguments list instances function call within expr. Named arguments inserted substituted already present expression. Unnamed argmuments simply added call. Examples: named valued namedArgs argument list, name/value pair substituted anywhere present expression. approach often conscise, arguments added expression way, substituted already present. Examples:","code":"myexpr <- quote(dnorm(x, mean = 5)) interpolateArguments(myexpr, list(dnorm = list(mean = 2, sd = 5, TRUE)))  # result is new expresson: dnorm(x, mean = 2, sd = 5, TRUE) myexpr <- quote(dnorm(x, mean = 5)) interpolateArguments(myexpr, mean = 2)  # result is new expression: dnorm(x, mean = 2) }"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interpolateArguments.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Change or insert values in an expression — interpolateArguments","text":"","code":"myexpr2 <- quote(A + b*x + rnorm(length(a), mean(Z), sd = 2))  interpolateArguments(myexpr2,                      list(sd = 10, mean = list(na.rm = TRUE))) #> Error in rlang::quo_get_expr(quo): `quo` must be a quosure                         # result is new expression:  # a + b*x + rnorm(length(a), mean(Z, na.rm = TRUE), sd = 10)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interpretations.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize humdrum corpus interpretations. — interpretations","title":"Summarize humdrum corpus interpretations. — interpretations","text":"interpretations used summarize interpretations pieces humdrumR corpus, including exclusive (**) tandem (*) interpretations. interpretations one humdrumR's basic corpus summary functions.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interpretations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize humdrum corpus interpretations. — interpretations","text":"","code":"interpretations(humdrumR)  # S3 method for humInterpretations [(interps, i)  # S3 method for humInterpretations print(interps, showEach = TRUE, screenWidth = options(\"width\")$width - 10L)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interpretations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize humdrum corpus interpretations. — interpretations","text":"humdrumR humdrumR data object. numeric, selects rows index. character, string matched regular expression filenames corpus.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interpretations.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summarize humdrum corpus interpretations. — interpretations","text":"interpretations returns special data.frame called humInterpretations table. row table represents single piece corpus. first column ({X}) variable indicating unique \"exclusive pattern\" associated file---exclusive patterns tallied bottom printout. remaining columns indicate many interpretation (indicated column name) appear piece. tandem interpretations, counts returned format Total.Unique.Spines: Total: total instances interpretation, across spines. Unique: number unique versions interpretation. Spines: number spines interpretation appears . example, consider following file: file, several tandem key interpretations, humdrumR call Key. tabulation interpretations return Key column value 6.3.2 file: 6 six key interpretations total. 3 three unique keys: *C:, *e: *G:. 2 key interpretations occur two spines.","code":"**kern   **kern   **silbe    *C:      *C:         *      c        e        La      d        f        la      e        g        la    *e:      *e:         *     f#       d#        la      g        e         _      a        b         _    *G:      *G:         *     f#        a       doo      g        b       wop     *-       *-        *-"},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interval.html","id":null,"dir":"Reference","previous_headings":"","what":"Tonal (pitch) interval representation — interval","title":"Tonal (pitch) interval representation — interval","text":"returns standard representations intervals Western music.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tonal (pitch) interval representation — interval","text":"","code":"interval(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   Key = NULL,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tonal (pitch) interval representation — interval","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). generic (logical, length == 1) generic = TRUE \"specific\" pitch information (accidentals qualites) discarded. simple (logical, length == 1) simple = TRUE \"compound\" pitch information (octave/contour) discarded. Key (diatonicSet something coercable diatonicSet, length == 1 | length == length(x)) input Key used parser, deparser, transposer. transposeArgs (list) transposeArgs can list arguments passed special call transpose. parseArgs (list) parseArgs can list arguments passed pitch parser. inPlace (logical, length == 1) argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interval.html","id":"basic-pitch-arguments","dir":"Reference","previous_headings":"","what":"Basic pitch arguments","title":"Tonal (pitch) interval representation — interval","text":"pitch function standard arguments control details output. important generic simple arguments, allow control type pitch information returned.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interval.html","id":"generic-vs-specific","dir":"Reference","previous_headings":"","what":"Generic vs Specific","title":"Tonal (pitch) interval representation — interval","text":"generic = TRUE, specific pitch information (accidentals qualities) omitted output. alternative way controlling functionality, can use specific argument, specific == !generic. case atonal functions, \"generic\" version pitch output: example, semits('c#', generic = TRUE) return 0, \"generic\" version C# C, corresponds 0. However, note generic version pitch follows key, semits('c#', generic = TRUE, Key = ':') return 1!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interval.html","id":"simple-vs-compound","dir":"Reference","previous_headings":"","what":"Simple vs Compound","title":"Tonal (pitch) interval representation — interval","text":"simple = TRUE, compound pitch information (octave contour) omitted output. alternative way controlling functionality, can use compound argument ,compound == !simple. actually one way might want divide compound intervals simple octave parts. example, might like call output -M2 (descending major 2nd) +m7 (ascending minor 7th octave ). functionality can controlled octave.round argument: see pitch deparsing documentation.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interval.html","id":"key","dir":"Reference","previous_headings":"","what":"Key","title":"Tonal (pitch) interval representation — interval","text":"Key argument must diatonicSet, something can parsed one. Key argument passed parser, deparser, transpose---unless alternate Key passed transposeArgs parseArgs. Various deparsing options use Key argument; example, use implicitSpecies (see advanced parsing section) dependent Key. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function---means, cases, need explicitly anything Key argument! (want happen, need explicitly specify Key argument, Key = NULL.)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interval.html","id":"parse-arguments","dir":"Reference","previous_headings":"","what":"Parse arguments","title":"Tonal (pitch) interval representation — interval","text":"parseArgs argument must list() (named) arguments passed input parser. example, input representation uses \"X\" represent double sharps, specify kern('CX5', parseArgs = list(doublesharp = 'X')) get correct result (\"cc##\"). convenient shorthand, \"syntactic sugar,\" can specify parseArgs alternate way: Simply input parse(args...) unnamed argument pitch function. example, can get exact result typing kern('CX5', parse(doublesharp = 'X')).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interval.html","id":"transpose-arguments","dir":"Reference","previous_headings":"","what":"Transpose arguments","title":"Tonal (pitch) interval representation — interval","text":"transposeArgs argument must list() (named) arguments passed internal call transpose(), allowing us easily transpose pitch information. example, type kern(c('C', 'D', 'E'), transposeArgs = list(= 'M9')) can get output c('d', 'e', 'f#'). possible transpose args : (tonalInterval, length == 1 | length == (x)) (diatonicSet, length == 1 | length == (x))  (diatonicSet, length == 1 | length == (x)) real (logical, length == 1) transposition real tonal? relative (logical, length == 1) key-wise transposition based relative parallel keys? convenient shorthand, \"syntactic sugar,\" can specify transposeArgs alternate way: Simply input transpose(args...) unnamed argument pitch function. example, can get exact result typing kern(c('C', 'D', 'E'), transpose(= 'M9')).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interval.html","id":"transposing-by-interval","dir":"Reference","previous_headings":"","what":"Transposing by interval","title":"Tonal (pitch) interval representation — interval","text":"calling transpose() directly, argument can anything coercable tonalInterval, output transposed amount. real = FALSE, tonal transposition (within Key) performed. details transposition behavior, check transpose() docs.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interval.html","id":"transposing-by-key","dir":"Reference","previous_headings":"","what":"Transposing by key","title":"Tonal (pitch) interval representation — interval","text":"Another way transposing specifying input (\"\") key output (\"\") key. default, Key argument passed transpose , nothing actually happens. Thus, specify either key key, transposition happen /key Key. course, specify transposition happen keys specify. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function. specify key, Key field passed transpose key, result, pitches input transposed whatever keys target () key! real relative arguments give special control key-wise transposition works, check transpose() docs details!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interval.html","id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Tonal (pitch) interval representation — interval","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/intervalCalculus.html","id":null,"dir":"Reference","previous_headings":"","what":"Interval ","title":"Interval ","text":"Interval \"calculus\"","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/intervalCalculus.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interval ","text":"","code":"sigma(x, skip, boundaries)  # S3 method for default sigma(x, skip = list(is.na), windows = list())  # S3 method for matrix sigma(x, ..., skip = list(is.na))  delta(x, skip, boundaries)  # S3 method for default delta(x, skip = list(is.na), windows = list(), firstNA = FALSE)  # S3 method for matrix delta(x, ..., skip = list(is.na))"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/invert.html","id":null,"dir":"Reference","previous_headings":"","what":"Invert or transpose tonal intervals. — invert","title":"Invert or transpose tonal intervals. — invert","text":"Invert transpose tonal intervals.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/invert.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Invert or transpose tonal intervals. — invert","text":"","code":"invert(tint, around, Key, ...)"},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/is.major.html","id":null,"dir":"Reference","previous_headings":"","what":"Test the major/minor modality of a set — is.major","title":"Test the major/minor modality of a set — is.major","text":"functions test majorness/minorness tertian diatonic set, logical TRUE/FALSE. functions testing whether chord strictly major minor chord, rather \"broad\" major/minorness: gnerally, presence minor third degree makes set \"minor\"; thus, diminished chord \"minor\" lydian key \"major.\"","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/is.major.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test the major/minor modality of a set — is.major","text":"","code":"is.major(x, ...)  is.minor(x, ...)  # S3 method for diatonicSet is.major(x)  # S3 method for diatonicSet is.minor(x)  # S3 method for default is.major(x, ...)  # S3 method for default is.minor(x, ...)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/is.major.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test the major/minor modality of a set — is.major","text":"x Either diatonicSet tertianSet, something can parsed one. ... Parameters passed parsers (tertianSet() diatonicSet()).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/is.major.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test the major/minor modality of a set — is.major","text":"Either function can called directly tertian diatonic sets. called anything else, functions first call tertianSet() parser. values fail parse (returning NA), diatonicSet() parser called .","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/is.simple.html","id":null,"dir":"Reference","previous_headings":"","what":"Test the properties of tonal information — is.simple","title":"Test the properties of tonal information — is.simple","text":"functions test basic properties pitch information. .simple returns TRUE pitch information constrained one octave. .generic returns TRUE pitch information \"natural\" key (Key) argument.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/is.simple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test the properties of tonal information — is.simple","text":"","code":"is.simple(x, ...)  # S3 method for tonalInterval is.simple(x, octave.round = floor, ...)  # S3 method for default is.simple(x, ...)  is.generic(x, Key, ...)  # S3 method for tonalInterval is.generic(x, Key = NULL)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/is.simple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test the properties of tonal information — is.simple","text":"x tonalInterval something can parsed one. ... Parameters passed tonalInterval(). octave.round rouding function. Controls simple intervals interpreted relative C. Key diatonicSet (tonal key) something can parsed one.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/is.simple.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test the properties of tonal information — is.simple","text":"functions can called directly tonalIntervals; called anything else, functions first calls tonalInterval() parser. values fail parse NA returned. \"Simple\" intervals fall particular octave relative middle-C/unison. octave.floor argument can used change works: default option, floor, interprets (**kern) pitches  c, d, e, f, g, , b \"simple.\" common alternative, round, identifies G, , B, c, d, e, f \"simple.\" See pitch deparsing docs detailed explanation. \"Generic\" intervals belong key.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/kern.html","id":null,"dir":"Reference","previous_headings":"","what":"Kern pitch representation — kern","title":"Kern pitch representation — kern","text":"Kern (**kern) common humdrum interpretation representing \"notes\" style traditional Western scores. However! humdrumR, kern function outputs pitch part **kern interpretation. **kern rhythms instead created using recip() function.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/kern.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Kern pitch representation — kern","text":"","code":"kern(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   Key = NULL,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/kern.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Kern pitch representation — kern","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). generic (logical, length == 1) generic = TRUE \"specific\" pitch information (accidentals qualites) discarded. simple (logical, length == 1) simple = TRUE \"compound\" pitch information (octave/contour) discarded. Key (diatonicSet something coercable diatonicSet, length == 1 | length == length(x)) input Key used parser, deparser, transposer. transposeArgs (list) transposeArgs can list arguments passed special call transpose. parseArgs (list) parseArgs can list arguments passed pitch parser. inPlace (logical, length == 1) argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/kern.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Kern pitch representation — kern","text":"pitch part **kern tokens breakdown tonal pitch information : Steps 1: \"C\" \"c\" 2: \"D\" \"d\" 3: \"E\" \"e\" 4: \"F\" \"f\" 5: \"G\" \"g\" 6: \"\" \"\" 7: \"B\" \"b\" Accidentals Flat: \"-\" Sharp: \"#\" Octave Octave indicated case step characters, well repetition step character. Uppercase letters used octaves ; lowercase letters middle-C octave higher.  octave, octave get one character , higher lower octaves repeating character. example, using C# step value, relative  octave: -3: \"CCC#\" -2: \"CC#\" -1: \"C#\" 0: \"c#\" +1: \"cc#\" +2: \"ccc#\" +3: \"cccc#\" Tokens ordered Step/Octave + Accidentals, separator. Like humdrumR pitch functions, ways kern parses deparses tokens can modified accomodate variations standard **kern pitch representation.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/kern.html","id":"basic-pitch-arguments","dir":"Reference","previous_headings":"","what":"Basic pitch arguments","title":"Kern pitch representation — kern","text":"pitch function standard arguments control details output. important generic simple arguments, allow control type pitch information returned.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/kern.html","id":"generic-vs-specific","dir":"Reference","previous_headings":"","what":"Generic vs Specific","title":"Kern pitch representation — kern","text":"generic = TRUE, specific pitch information (accidentals qualities) omitted output. alternative way controlling functionality, can use specific argument, specific == !generic. case atonal functions, \"generic\" version pitch output: example, semits('c#', generic = TRUE) return 0, \"generic\" version C# C, corresponds 0. However, note generic version pitch follows key, semits('c#', generic = TRUE, Key = ':') return 1!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/kern.html","id":"simple-vs-compound","dir":"Reference","previous_headings":"","what":"Simple vs Compound","title":"Kern pitch representation — kern","text":"simple = TRUE, compound pitch information (octave contour) omitted output. alternative way controlling functionality, can use compound argument ,compound == !simple. actually one way might want divide compound intervals simple octave parts. example, might like call output -M2 (descending major 2nd) +m7 (ascending minor 7th octave ). functionality can controlled octave.round argument: see pitch deparsing documentation.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/kern.html","id":"key","dir":"Reference","previous_headings":"","what":"Key","title":"Kern pitch representation — kern","text":"Key argument must diatonicSet, something can parsed one. Key argument passed parser, deparser, transpose---unless alternate Key passed transposeArgs parseArgs. Various deparsing options use Key argument; example, use implicitSpecies (see advanced parsing section) dependent Key. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function---means, cases, need explicitly anything Key argument! (want happen, need explicitly specify Key argument, Key = NULL.)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/kern.html","id":"parse-arguments","dir":"Reference","previous_headings":"","what":"Parse arguments","title":"Kern pitch representation — kern","text":"parseArgs argument must list() (named) arguments passed input parser. example, input representation uses \"X\" represent double sharps, specify kern('CX5', parseArgs = list(doublesharp = 'X')) get correct result (\"cc##\"). convenient shorthand, \"syntactic sugar,\" can specify parseArgs alternate way: Simply input parse(args...) unnamed argument pitch function. example, can get exact result typing kern('CX5', parse(doublesharp = 'X')).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/kern.html","id":"transpose-arguments","dir":"Reference","previous_headings":"","what":"Transpose arguments","title":"Kern pitch representation — kern","text":"transposeArgs argument must list() (named) arguments passed internal call transpose(), allowing us easily transpose pitch information. example, type kern(c('C', 'D', 'E'), transposeArgs = list(= 'M9')) can get output c('d', 'e', 'f#'). possible transpose args : (tonalInterval, length == 1 | length == (x)) (diatonicSet, length == 1 | length == (x))  (diatonicSet, length == 1 | length == (x)) real (logical, length == 1) transposition real tonal? relative (logical, length == 1) key-wise transposition based relative parallel keys? convenient shorthand, \"syntactic sugar,\" can specify transposeArgs alternate way: Simply input transpose(args...) unnamed argument pitch function. example, can get exact result typing kern(c('C', 'D', 'E'), transpose(= 'M9')).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/kern.html","id":"transposing-by-interval","dir":"Reference","previous_headings":"","what":"Transposing by interval","title":"Kern pitch representation — kern","text":"calling transpose() directly, argument can anything coercable tonalInterval, output transposed amount. real = FALSE, tonal transposition (within Key) performed. details transposition behavior, check transpose() docs.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/kern.html","id":"transposing-by-key","dir":"Reference","previous_headings":"","what":"Transposing by key","title":"Kern pitch representation — kern","text":"Another way transposing specifying input (\"\") key output (\"\") key. default, Key argument passed transpose , nothing actually happens. Thus, specify either key key, transposition happen /key Key. course, specify transposition happen keys specify. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function. specify key, Key field passed transpose key, result, pitches input transposed whatever keys target () key! real relative arguments give special control key-wise transposition works, check transpose() docs details!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/kern.html","id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Kern pitch representation — kern","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/key.html","id":null,"dir":"Reference","previous_headings":"","what":"Humdrum key interpretation — key","title":"Humdrum key interpretation — key","text":"Humdrum key interpretation","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/key.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Humdrum key interpretation — key","text":"","code":"key(x, ..., Key = NULL, parseArgs = list())"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/keyDeparsing.html","id":null,"dir":"Reference","previous_headings":"","what":"Generating (","title":"Generating (","text":"humdrumR includes easy--use system generating variety diatonic key representations, can flexibly modified users. \"hood\" humdrumR represents tonal chord information using underlying representation, typically extracted input data using key parser. representation can \"deparsed\" variety predefined output formats, new formats create!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/keyDeparsing.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generating (","text":"Deparsing second step key function processing pipeline: Input representation |> Parsing |> Intermediate (diatonicSet) representation |> Transformation  |> Deparsing (DEPARSING ARGS GO ) |> Output representation Various pitch representations can generated using predefined key functions like key() signature(), romanKey(). functions use common deparsing framework, specified using different combinations arguments deparser. modifying \"deparsing\" arguments, can exercise fine control want pitch information represented output.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/keyFunctions.html","id":null,"dir":"Reference","previous_headings":"","what":"Parsing and deparsing key information — keyFunctions","title":"Parsing and deparsing key information — keyFunctions","text":"functions can used extract \"translate,\" otherwise modify, data representing diatonic key information. functions :","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/keyFunctions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parsing and deparsing key information — keyFunctions","text":"key() romanKey() signature()","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/keyParsing.html","id":null,"dir":"Reference","previous_headings":"","what":"Parsing key information — keyParsing","title":"Parsing key information — keyParsing","text":"humdrumR includes easy--use powerful system parsing diatonic key information: various basic key representations (including numeric character-string representations) can \"parsed\"---read interpreted humdrumR. part, parsing automatically happens \"behind scenes\" whenever use humdrumR key function, like key() signature().","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/keyParsing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parsing key information — keyParsing","text":"","code":"diatonicSet(...)  # S3 method for diatonicSet diatonicSet(x, ...)  # S3 method for logical diatonicSet(x, ...)  # S3 method for `NULL` diatonicSet(x, ...)  # S3 method for numeric diatonicSet(x)  # S3 method for integer diatonicSet(x)  # S3 method for character diatonicSet(x, ..., Key = NULL, Exclusive = NULL, multiDispatch = FALSE)"},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/keyTransformer.html","id":null,"dir":"Reference","previous_headings":"","what":"Parsing and deparsing key information — keyTransformer","title":"Parsing and deparsing key information — keyTransformer","text":"XXX","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/keyTransformer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parsing and deparsing key information — keyTransformer","text":"","code":"key(x, ..., Key = NULL, parseArgs = list(), memoize = TRUE, deparse = TRUE)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lag.html","id":null,"dir":"Reference","previous_headings":"","what":"Shift data within a vector/matrix/data.frame — lag","title":"Shift data within a vector/matrix/data.frame — lag","text":"lag lead functions take input vectors, matrices, data.frames shifts data n indices. similar data.table::shift() function, additional options.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lag.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shift data within a vector/matrix/data.frame — lag","text":"","code":"lag(x, n = 1, fill, wrap, groupby, ...)  lead(x, n, ...)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lag.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shift data within a vector/matrix/data.frame — lag","text":"x input argument. vector (including lists), matrix, data.frame. n amount lag/lead data.  n == 0, x returned unchanged. fill wrap = FALSE parts output padded fill argument. Defaults NA. wrap wrap = TRUE, data end (head tail) copied end output, \"wrapping\" data within data structure. groupby vector list vectors, length x. segment x delineated groupby vector(s) treated separately. margin Arrays data.frames can lagged lead multiple dimensions using margin argument: margin == 1 shifts across rows margin == 2 shifts across columns.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lag.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Shift data within a vector/matrix/data.frame — lag","text":"lagged vector values original vector, except offset n indices. lag moves value high index (n > 0); lead opposite, moving value lower index (n > 0). n can positive negative---negative lags equivalent leads, vice versa. Values near end/beginning either \"wrapped\" opposite end vector, replaced/padded value fill argument. vector b c d e f g can lagged n==1 NA b c d e f. set wrap == TRUE, \"g\" moved beginning output: g b c d e f.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lag.html","id":"grouping","dir":"Reference","previous_headings":"","what":"Grouping","title":"Shift data within a vector/matrix/data.frame — lag","text":"many cases want perform lagged calculations vector, across certain boundaries. example, vector includes data multiple pieces, want calculate melodic intervals pieces, within pieces. groupby argument indicates one, , grouping vectors, break x (input) argument groups. groupby vectors given, change vector indicates boundary. Value pairs cross groups treated beginning. Basically, using groupby argument function similar identical using tapply(x, groupby, laggedFunction, ...) using groupby expession call ().humdrumR. However, using groupby argument directly usually much faster, specially optimized functions. common use case humdrum data, looking \"melodies\" within spines. , want groupby = list(File, Spine, Path). fact, humdrumR () calls automatically feed three fields groupby arguments certain functions: mint, delta, sigma, lag, ditto. use delta call (), automatically calculate delta \"melodic\" way, within spine path file. However, wanted, instance, calculate differences across spines (like harmonic intervals) manually set groupby = list(File, Record).","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lilypond.html","id":null,"dir":"Reference","previous_headings":"","what":"Lilypond pitch representation — lilypond","title":"Lilypond pitch representation — lilypond","text":"representation used represent (Western tonal) pitches Lilypond notation format. humdrumR, lilypond function relates pitch part Lilypond notation: Lilypond-like rhythms can creating using recip function.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lilypond.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lilypond pitch representation — lilypond","text":"","code":"lilypond(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   Key = NULL,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lilypond.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lilypond pitch representation — lilypond","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). generic (logical, length == 1) generic = TRUE \"specific\" pitch information (accidentals qualites) discarded. simple (logical, length == 1) simple = TRUE \"compound\" pitch information (octave/contour) discarded. Key (diatonicSet something coercable diatonicSet, length == 1 | length == length(x)) input Key used parser, deparser, transposer. transposeArgs (list) transposeArgs can list arguments passed special call transpose. parseArgs (list) parseArgs can list arguments passed pitch parser. inPlace (logical, length == 1) argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lilypond.html","id":"basic-pitch-arguments","dir":"Reference","previous_headings":"","what":"Basic pitch arguments","title":"Lilypond pitch representation — lilypond","text":"pitch function standard arguments control details output. important generic simple arguments, allow control type pitch information returned.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lilypond.html","id":"generic-vs-specific","dir":"Reference","previous_headings":"","what":"Generic vs Specific","title":"Lilypond pitch representation — lilypond","text":"generic = TRUE, specific pitch information (accidentals qualities) omitted output. alternative way controlling functionality, can use specific argument, specific == !generic. case atonal functions, \"generic\" version pitch output: example, semits('c#', generic = TRUE) return 0, \"generic\" version C# C, corresponds 0. However, note generic version pitch follows key, semits('c#', generic = TRUE, Key = ':') return 1!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lilypond.html","id":"simple-vs-compound","dir":"Reference","previous_headings":"","what":"Simple vs Compound","title":"Lilypond pitch representation — lilypond","text":"simple = TRUE, compound pitch information (octave contour) omitted output. alternative way controlling functionality, can use compound argument ,compound == !simple. actually one way might want divide compound intervals simple octave parts. example, might like call output -M2 (descending major 2nd) +m7 (ascending minor 7th octave ). functionality can controlled octave.round argument: see pitch deparsing documentation.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lilypond.html","id":"key","dir":"Reference","previous_headings":"","what":"Key","title":"Lilypond pitch representation — lilypond","text":"Key argument must diatonicSet, something can parsed one. Key argument passed parser, deparser, transpose---unless alternate Key passed transposeArgs parseArgs. Various deparsing options use Key argument; example, use implicitSpecies (see advanced parsing section) dependent Key. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function---means, cases, need explicitly anything Key argument! (want happen, need explicitly specify Key argument, Key = NULL.)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lilypond.html","id":"parse-arguments","dir":"Reference","previous_headings":"","what":"Parse arguments","title":"Lilypond pitch representation — lilypond","text":"parseArgs argument must list() (named) arguments passed input parser. example, input representation uses \"X\" represent double sharps, specify kern('CX5', parseArgs = list(doublesharp = 'X')) get correct result (\"cc##\"). convenient shorthand, \"syntactic sugar,\" can specify parseArgs alternate way: Simply input parse(args...) unnamed argument pitch function. example, can get exact result typing kern('CX5', parse(doublesharp = 'X')).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lilypond.html","id":"transpose-arguments","dir":"Reference","previous_headings":"","what":"Transpose arguments","title":"Lilypond pitch representation — lilypond","text":"transposeArgs argument must list() (named) arguments passed internal call transpose(), allowing us easily transpose pitch information. example, type kern(c('C', 'D', 'E'), transposeArgs = list(= 'M9')) can get output c('d', 'e', 'f#'). possible transpose args : (tonalInterval, length == 1 | length == (x)) (diatonicSet, length == 1 | length == (x))  (diatonicSet, length == 1 | length == (x)) real (logical, length == 1) transposition real tonal? relative (logical, length == 1) key-wise transposition based relative parallel keys? convenient shorthand, \"syntactic sugar,\" can specify transposeArgs alternate way: Simply input transpose(args...) unnamed argument pitch function. example, can get exact result typing kern(c('C', 'D', 'E'), transpose(= 'M9')).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lilypond.html","id":"transposing-by-interval","dir":"Reference","previous_headings":"","what":"Transposing by interval","title":"Lilypond pitch representation — lilypond","text":"calling transpose() directly, argument can anything coercable tonalInterval, output transposed amount. real = FALSE, tonal transposition (within Key) performed. details transposition behavior, check transpose() docs.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lilypond.html","id":"transposing-by-key","dir":"Reference","previous_headings":"","what":"Transposing by key","title":"Lilypond pitch representation — lilypond","text":"Another way transposing specifying input (\"\") key output (\"\") key. default, Key argument passed transpose , nothing actually happens. Thus, specify either key key, transposition happen /key Key. course, specify transposition happen keys specify. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function. specify key, Key field passed transpose key, result, pitches input transposed whatever keys target () key! real relative arguments give special control key-wise transposition works, check transpose() docs details!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lilypond.html","id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Lilypond pitch representation — lilypond","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/localDuration.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate overall duration of a group — localDuration","title":"Calculate overall duration of a group — localDuration","text":"localDuration() calculates \"overall\" duration within groups input vector. hell mean? Usually, used find duration record humdrum file.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/localDuration.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate overall duration of a group — localDuration","text":"","code":"localDuration(   x,   choose = min,   deparser = duration,   ...,   Exclusive = NULL,   parseArgs = list(),   groupby = list() )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/localDuration.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate overall duration of a group — localDuration","text":"x input vector, parsed duration information using rhythm parser. choose function, takes vector numeric returns single numeric value. Defaults min; max, median, mode might reasonable alternatives. deparser rhythm function generate output representation. parseArgs list arguments pass rhythm parser. groupBy list vectors, length x, used group x .","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/localDuration.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate overall duration of a group — localDuration","text":"way rhythm time typically encoded humdrum format, \"overall\" duration record determined shortest duration record, . , file like : \"local\" duration record (**duration): Note records length zero (1%0), missing duration information. localDuration() begins call duration() input argument x---parseArgs() argument can used pass arguments parser (Exclusive argument passed well). localDuration() groups durations based unique combinations values groupby argument, must list vectors length x. default, minimum duration within group returned, recycled necassary match input length. choose argument can set another function, desired. example, use localDuration(x, choose = max) find maximum duration group. groupby argument empty (default) durations returned unchanged, except NA durations set 0. Luckily, localDuration() used inside ().humdrumR expression, groupby = list(File, Record) automatically passed (can overridden explicitely setting argument). means (humData, localDuration(Token)) automatically calculate minimum duration record. Note , localDuration() follows default behavior duration() treating grace-notes duration 0. want use duration(s) grace notes, specify graceDurations = TRUE. output representation can controlled using deparser argument, defaulting duration(). example, deparser = recip return output **recip format. ... arguments passed deparser.","code":"**kern  **kern     **silbe     4c      8g        Hum-      .      8f           _      !       !    !melisma       8b      8f       -drum     8c      8e           _     2d      4a         da-      .       .           .      .      4g         -ta     G;      g;         ooh     *-      *-          *- **kern  **kern     **silbe   -> 1%0     4c      8g        Hum-   -> 8      .      8f           _   -> 8      !       !    !melisma   -> 1%0     8b      8f       -drum   -> 8     8c      8e           _   -> 8     2d      4a         da-   -> 4      .       .           .   -> 1%0      .      4g         -ta   -> 4     G;      g;         ooh   -> 1%0     *-      *-          *-"},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/measure.html","id":null,"dir":"Reference","previous_headings":"","what":"Measure — measure","title":"Measure — measure","text":"Takes sequence rhythmic offsets regular irregular beat unit, counts many beats passed, offset attack nearest beat.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/measure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Measure — measure","text":"","code":"measure(   soi,   beat = rational(1L),   start = as(0, class(dur)),   phase = rational(0L),   Bar = NULL )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/meter.html","id":null,"dir":"Reference","previous_headings":"","what":"Meter class — meter","title":"Meter class — meter","text":"Takes sequence rhythmic offsets regular irregular beat unit, counts many beats passed, offset attack nearest beat.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/meter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Meter class — meter","text":"","code":"measure(   soi,   beat = rational(1L),   start = as(0, class(dur)),   phase = rational(0L),   Bar = NULL )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/metric.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate metric positions from duration data. — metric","title":"Calculate metric positions from duration data. — metric","text":"Calculate metric positions duration data.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/metric.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate metric positions from duration data. — metric","text":"","code":"metric(ioi, meter = duple(5), ..., remainderSubdivides = TRUE)"},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/mint.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate melodic intervals — mint","title":"Calculate melodic intervals — mint","text":"mint calculates melodic intervals vector, across spine/paths humdrumR data object. vector interpreted ordered sequence notes, forming \"melody,\" intervals successive pitches calculated.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/mint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate melodic intervals — mint","text":"","code":"mint(   x,   lag = 1,   deparser = interval,   initial = kern,   bracket = TRUE,   classify = FALSE,   ...,   parseArgs = list(),   Exclusive = NULL,   Key = NULL,   boundaries = list() )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/mint.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate melodic intervals — mint","text":"Input vector x parsed pitch information. (Parsing arguments can passed via parseArgs list, parse(...) sugar. Key Exclusive also passed parser.) parsed pitch vector copied lagged using lag(), pairs cross boundaries ignored. melodic intervals \"deparsed\" standard representation; default, intervals() representation used, can set deparser argument pitch function. However, alternative deparser commonly used (intervals()) semits(). lag argument controls far apart melody intervals calculated. instance, lag 2 calculate intervals every note vector. Positive lags calculate approaching intervals: token represents interval current note previous note. Negative lags calculate departing intervals: token reprseents interval current note next note. Note passing directed = FALSE deparser, undirected (absolute value) melodic intervals can returned.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/mint.html","id":"initial-value-padding","dir":"Reference","previous_headings":"","what":"Initial value padding","title":"Calculate melodic intervals — mint","text":"output mint necessarily padded abs(lag) undefined intervals beginning (positive lag) end (negative lag). initial argument controls initial values presented. initial function, \"initial\" pitches parsed \"absolutely\" relative middle-C; case, initial another pitch function deparse pitches. default kern() function. bracket == TRUE, initial values surrounded [], easier distinguish actual melodic intervals. initial atomic value, value used padder; atomic (vector) initial must length abs(lag). example, set initial = 'start' label locations character string 'start'. initial NULL, initial values simply padded NA.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/mint.html","id":"interval-classification","dir":"Reference","previous_headings":"","what":"Interval classification","title":"Calculate melodic intervals — mint","text":"classify argument set TRUE, intervals classified either \"Unison\", \"Step\", \"Skip\", \"Leap\". Alternatively, skips can interpreted leaps setting skips = FALSE. (Note classification work deparser = interval, default). default, intervals categorized tonally, meaning interval tonal steps used basis classification. example, augmented 2nd step, diminished 3rd skip/leap. means augmented diminished unisons marked \"Unison\" well! However, directed = TRUE, augmented/diminished unisons marked + - indicate direction, whereas perfect unisons never marked +/-. Alternatively, may choose categorize intervals atonally setting atonal = TRUE. , intervals categorized based semitone (enharmonic) intervals: D# Eb classified .","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/mint.html","id":"boundaries","dir":"Reference","previous_headings":"","what":"Boundaries","title":"Calculate melodic intervals — mint","text":"many cases want perform lagged calculations vector, across certain boundaries. example, vector includes data multiple pieces, want calculate melodic intervals pieces, within pieces. boundaries argument indicates one, , grouping vectors, break x (input) argument groups. boundaries vectors given, change vector indicates boundary. Value pairs cross groups treated beginning. Basically, using boundaries essentially identical using tapply(x, boundaries, laggedFunction, ...), except generally faster number groups large. common use case humdrum data, looking \"melodies\" within spines. , want boundaries = list(File, Spine, Path ). fact, humdrumR () calls automatically feed three fields boundaries arguments certain functions: mint, hint, delta, sigma, lag, ditto. use delta call (), automatically calculate delta \"melodic\" way, within spine path file. However, wanted, instance, calculate differences across spines (like harmonic intervals) manually set boundaries = list(File, Record).","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/octave.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract octave — octave","title":"Extract octave — octave","text":"Extract octave","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/octave.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract octave — octave","text":"","code":"octave(   x,   ...,   octave.relative = FALSE,   Key = NULL,   parseArgs = list(),   inPlace = FALSE )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/octave.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract octave — octave","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). Key (diatonicSet something coercable diatonicSet, length == 1 | length == length(x)) input Key used parser, deparser, transposer. parseArgs (list) parseArgs can list arguments passed pitch parser. inPlace (logical, length == 1) argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/partialMatching.html","id":null,"dir":"Reference","previous_headings":"","what":"Partial matching — partialMatching","title":"Partial matching — partialMatching","text":"R useful functionality called \"partial matching,\" can match incomplete character string variable name list options. achieved using base-R function pmatch(), many R functions make use , many humdrumR functions.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/partialMatching.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Partial matching — partialMatching","text":"example, say data.frame (call df) three columns: \"Number\", \"Letter\", \"Date\":  want access Number column, programming languages require write least df$Number. However, R give correct field even write df$Numb, df$Num, even df$N. partial matching! matching happens left--right, long get beginning variable right, work. course, partial matching works point string matches unambiguously. example, added Dare column df, df$D df$Da return NULL ambiguous. need write least Dar Dat get Dare Date columns respectively.","code":"df <- data.frame(Number = 1:2, Letter = c('A', 'B'), Date = c(\"January\", \"February\"))"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pc.html","id":null,"dir":"Reference","previous_headings":"","what":"Representation of atonal pitch classes — pc","title":"Representation of atonal pitch classes — pc","text":"encoded humdrum **pc interpretation.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Representation of atonal pitch classes — pc","text":"","code":"pc(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   Key = NULL,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Representation of atonal pitch classes — pc","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). generic (logical, length == 1) generic = TRUE \"specific\" pitch information (accidentals qualites) discarded. simple (logical, length == 1) simple = TRUE \"compound\" pitch information (octave/contour) discarded. Key (diatonicSet something coercable diatonicSet, length == 1 | length == length(x)) input Key used parser, deparser, transposer. transposeArgs (list) transposeArgs can list arguments passed special call transpose. parseArgs (list) parseArgs can list arguments passed pitch parser. inPlace (logical, length == 1) argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ). ten (character, length == 1) shorthand-symbol \"10.\" Defaults \"\". NULL, \"10\" used shorthand. eleven (character, length == 1) shorthand-symbol \"11.\" Defaults \"B\". NULL, \"11\" used shorthand.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pc.html","id":"basic-pitch-arguments","dir":"Reference","previous_headings":"","what":"Basic pitch arguments","title":"Representation of atonal pitch classes — pc","text":"pitch function standard arguments control details output. important generic simple arguments, allow control type pitch information returned.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pc.html","id":"generic-vs-specific","dir":"Reference","previous_headings":"","what":"Generic vs Specific","title":"Representation of atonal pitch classes — pc","text":"generic = TRUE, specific pitch information (accidentals qualities) omitted output. alternative way controlling functionality, can use specific argument, specific == !generic. case atonal functions, \"generic\" version pitch output: example, semits('c#', generic = TRUE) return 0, \"generic\" version C# C, corresponds 0. However, note generic version pitch follows key, semits('c#', generic = TRUE, Key = ':') return 1!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pc.html","id":"simple-vs-compound","dir":"Reference","previous_headings":"","what":"Simple vs Compound","title":"Representation of atonal pitch classes — pc","text":"simple = TRUE, compound pitch information (octave contour) omitted output. alternative way controlling functionality, can use compound argument ,compound == !simple. actually one way might want divide compound intervals simple octave parts. example, might like call output -M2 (descending major 2nd) +m7 (ascending minor 7th octave ). functionality can controlled octave.round argument: see pitch deparsing documentation.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pc.html","id":"key","dir":"Reference","previous_headings":"","what":"Key","title":"Representation of atonal pitch classes — pc","text":"Key argument must diatonicSet, something can parsed one. Key argument passed parser, deparser, transpose---unless alternate Key passed transposeArgs parseArgs. Various deparsing options use Key argument; example, use implicitSpecies (see advanced parsing section) dependent Key. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function---means, cases, need explicitly anything Key argument! (want happen, need explicitly specify Key argument, Key = NULL.)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pc.html","id":"parse-arguments","dir":"Reference","previous_headings":"","what":"Parse arguments","title":"Representation of atonal pitch classes — pc","text":"parseArgs argument must list() (named) arguments passed input parser. example, input representation uses \"X\" represent double sharps, specify kern('CX5', parseArgs = list(doublesharp = 'X')) get correct result (\"cc##\"). convenient shorthand, \"syntactic sugar,\" can specify parseArgs alternate way: Simply input parse(args...) unnamed argument pitch function. example, can get exact result typing kern('CX5', parse(doublesharp = 'X')).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pc.html","id":"transpose-arguments","dir":"Reference","previous_headings":"","what":"Transpose arguments","title":"Representation of atonal pitch classes — pc","text":"transposeArgs argument must list() (named) arguments passed internal call transpose(), allowing us easily transpose pitch information. example, type kern(c('C', 'D', 'E'), transposeArgs = list(= 'M9')) can get output c('d', 'e', 'f#'). possible transpose args : (tonalInterval, length == 1 | length == (x)) (diatonicSet, length == 1 | length == (x))  (diatonicSet, length == 1 | length == (x)) real (logical, length == 1) transposition real tonal? relative (logical, length == 1) key-wise transposition based relative parallel keys? convenient shorthand, \"syntactic sugar,\" can specify transposeArgs alternate way: Simply input transpose(args...) unnamed argument pitch function. example, can get exact result typing kern(c('C', 'D', 'E'), transpose(= 'M9')).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pc.html","id":"transposing-by-interval","dir":"Reference","previous_headings":"","what":"Transposing by interval","title":"Representation of atonal pitch classes — pc","text":"calling transpose() directly, argument can anything coercable tonalInterval, output transposed amount. real = FALSE, tonal transposition (within Key) performed. details transposition behavior, check transpose() docs.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pc.html","id":"transposing-by-key","dir":"Reference","previous_headings":"","what":"Transposing by key","title":"Representation of atonal pitch classes — pc","text":"Another way transposing specifying input (\"\") key output (\"\") key. default, Key argument passed transpose , nothing actually happens. Thus, specify either key key, transposition happen /key Key. course, specify transposition happen keys specify. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function. specify key, Key field passed transpose key, result, pitches input transposed whatever keys target () key! real relative arguments give special control key-wise transposition works, check transpose() docs details!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pc.html","id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Representation of atonal pitch classes — pc","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitch.html","id":null,"dir":"Reference","previous_headings":"","what":"Scientific pitch representation — pitch","title":"Scientific pitch representation — pitch","text":"Scientific pitch standard approach representing pitch traditional Western music.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scientific pitch representation — pitch","text":"","code":"pitch(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   Key = NULL,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scientific pitch representation — pitch","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). generic (logical, length == 1) generic = TRUE \"specific\" pitch information (accidentals qualites) discarded. simple (logical, length == 1) simple = TRUE \"compound\" pitch information (octave/contour) discarded. Key (diatonicSet something coercable diatonicSet, length == 1 | length == length(x)) input Key used parser, deparser, transposer. transposeArgs (list) transposeArgs can list arguments passed special call transpose. parseArgs (list) parseArgs can list arguments passed pitch parser. inPlace (logical, length == 1) argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitch.html","id":"basic-pitch-arguments","dir":"Reference","previous_headings":"","what":"Basic pitch arguments","title":"Scientific pitch representation — pitch","text":"pitch function standard arguments control details output. important generic simple arguments, allow control type pitch information returned.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitch.html","id":"generic-vs-specific","dir":"Reference","previous_headings":"","what":"Generic vs Specific","title":"Scientific pitch representation — pitch","text":"generic = TRUE, specific pitch information (accidentals qualities) omitted output. alternative way controlling functionality, can use specific argument, specific == !generic. case atonal functions, \"generic\" version pitch output: example, semits('c#', generic = TRUE) return 0, \"generic\" version C# C, corresponds 0. However, note generic version pitch follows key, semits('c#', generic = TRUE, Key = ':') return 1!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitch.html","id":"simple-vs-compound","dir":"Reference","previous_headings":"","what":"Simple vs Compound","title":"Scientific pitch representation — pitch","text":"simple = TRUE, compound pitch information (octave contour) omitted output. alternative way controlling functionality, can use compound argument ,compound == !simple. actually one way might want divide compound intervals simple octave parts. example, might like call output -M2 (descending major 2nd) +m7 (ascending minor 7th octave ). functionality can controlled octave.round argument: see pitch deparsing documentation.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitch.html","id":"key","dir":"Reference","previous_headings":"","what":"Key","title":"Scientific pitch representation — pitch","text":"Key argument must diatonicSet, something can parsed one. Key argument passed parser, deparser, transpose---unless alternate Key passed transposeArgs parseArgs. Various deparsing options use Key argument; example, use implicitSpecies (see advanced parsing section) dependent Key. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function---means, cases, need explicitly anything Key argument! (want happen, need explicitly specify Key argument, Key = NULL.)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitch.html","id":"parse-arguments","dir":"Reference","previous_headings":"","what":"Parse arguments","title":"Scientific pitch representation — pitch","text":"parseArgs argument must list() (named) arguments passed input parser. example, input representation uses \"X\" represent double sharps, specify kern('CX5', parseArgs = list(doublesharp = 'X')) get correct result (\"cc##\"). convenient shorthand, \"syntactic sugar,\" can specify parseArgs alternate way: Simply input parse(args...) unnamed argument pitch function. example, can get exact result typing kern('CX5', parse(doublesharp = 'X')).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitch.html","id":"transpose-arguments","dir":"Reference","previous_headings":"","what":"Transpose arguments","title":"Scientific pitch representation — pitch","text":"transposeArgs argument must list() (named) arguments passed internal call transpose(), allowing us easily transpose pitch information. example, type kern(c('C', 'D', 'E'), transposeArgs = list(= 'M9')) can get output c('d', 'e', 'f#'). possible transpose args : (tonalInterval, length == 1 | length == (x)) (diatonicSet, length == 1 | length == (x))  (diatonicSet, length == 1 | length == (x)) real (logical, length == 1) transposition real tonal? relative (logical, length == 1) key-wise transposition based relative parallel keys? convenient shorthand, \"syntactic sugar,\" can specify transposeArgs alternate way: Simply input transpose(args...) unnamed argument pitch function. example, can get exact result typing kern(c('C', 'D', 'E'), transpose(= 'M9')).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitch.html","id":"transposing-by-interval","dir":"Reference","previous_headings":"","what":"Transposing by interval","title":"Scientific pitch representation — pitch","text":"calling transpose() directly, argument can anything coercable tonalInterval, output transposed amount. real = FALSE, tonal transposition (within Key) performed. details transposition behavior, check transpose() docs.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitch.html","id":"transposing-by-key","dir":"Reference","previous_headings":"","what":"Transposing by key","title":"Scientific pitch representation — pitch","text":"Another way transposing specifying input (\"\") key output (\"\") key. default, Key argument passed transpose , nothing actually happens. Thus, specify either key key, transposition happen /key Key. course, specify transposition happen keys specify. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function. specify key, Key field passed transpose key, result, pitches input transposed whatever keys target () key! real relative arguments give special control key-wise transposition works, check transpose() docs details!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitch.html","id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Scientific pitch representation — pitch","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html","id":null,"dir":"Reference","previous_headings":"","what":"Generating (","title":"Generating (","text":"humdrumR includes easy--use system generating variety tonal (atonal) pitch representations, can flexibly modified users. \"hood\" humdrumR represents tonal pitch information using underlying representation, typically extracted input data using pitch parser. representation can \"deparsed\" variety predefined output formats (like **kern), new formats create!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generating (","text":"Deparsing second step pitch function processing pipeline: Input representation |> Parsing |> Intermediate (tonalInterval) representation |> Transformation  |> Deparsing (DEPARSING ARGS GO ) |> Output representation Various pitch representations like **kern, **solfa, **semits can generated using predefined pitch functions like kern() semits(), solfa() respectively. functions use common deparsing framework, specified using different combinations arguments deparser. modifying \"deparsing\" arguments, can exercise fine control want pitch information represented output.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html","id":"basic-pitch-arguments","dir":"Reference","previous_headings":"","what":"Basic pitch arguments","title":"Generating (","text":"pitch function standard arguments control details output. important generic simple arguments, allow control type pitch information returned.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html","id":"generic-vs-specific","dir":"Reference","previous_headings":"","what":"Generic vs Specific","title":"Generating (","text":"generic = TRUE, specific pitch information (accidentals qualities) omitted output. alternative way controlling functionality, can use specific argument, specific == !generic. case atonal functions, \"generic\" version pitch output: example, semits('c#', generic = TRUE) return 0, \"generic\" version C# C, corresponds 0. However, note generic version pitch follows key, semits('c#', generic = TRUE, Key = ':') return 1!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html","id":"simple-vs-compound","dir":"Reference","previous_headings":"","what":"Simple vs Compound","title":"Generating (","text":"simple = TRUE, compound pitch information (octave contour) omitted output. alternative way controlling functionality, can use compound argument ,compound == !simple. actually one way might want divide compound intervals simple octave parts. example, might like call output -M2 (descending major 2nd) +m7 (ascending minor 7th octave ). functionality can controlled octave.round argument: see pitch deparsing documentation.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html","id":"key","dir":"Reference","previous_headings":"","what":"Key","title":"Generating (","text":"Key argument must diatonicSet, something can parsed one. Key argument passed parser, deparser, transpose---unless alternate Key passed transposeArgs parseArgs. Various deparsing options use Key argument; example, use implicitSpecies (see advanced parsing section) dependent Key. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function---means, cases, need explicitly anything Key argument! (want happen, need explicitly specify Key argument, Key = NULL.)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html","id":"parse-arguments","dir":"Reference","previous_headings":"","what":"Parse arguments","title":"Generating (","text":"parseArgs argument must list() (named) arguments passed input parser. example, input representation uses \"X\" represent double sharps, specify kern('CX5', parseArgs = list(doublesharp = 'X')) get correct result (\"cc##\"). convenient shorthand, \"syntactic sugar,\" can specify parseArgs alternate way: Simply input parse(args...) unnamed argument pitch function. example, can get exact result typing kern('CX5', parse(doublesharp = 'X')).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html","id":"transpose-arguments","dir":"Reference","previous_headings":"","what":"Transpose arguments","title":"Generating (","text":"transposeArgs argument must list() (named) arguments passed internal call transpose(), allowing us easily transpose pitch information. example, type kern(c('C', 'D', 'E'), transposeArgs = list(= 'M9')) can get output c('d', 'e', 'f#'). possible transpose args : (tonalInterval, length == 1 | length == (x)) (diatonicSet, length == 1 | length == (x))  (diatonicSet, length == 1 | length == (x)) real (logical, length == 1) transposition real tonal? relative (logical, length == 1) key-wise transposition based relative parallel keys? convenient shorthand, \"syntactic sugar,\" can specify transposeArgs alternate way: Simply input transpose(args...) unnamed argument pitch function. example, can get exact result typing kern(c('C', 'D', 'E'), transpose(= 'M9')).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html","id":"transposing-by-interval","dir":"Reference","previous_headings":"","what":"Transposing by interval","title":"Generating (","text":"calling transpose() directly, argument can anything coercable tonalInterval, output transposed amount. real = FALSE, tonal transposition (within Key) performed. details transposition behavior, check transpose() docs.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html","id":"transposing-by-key","dir":"Reference","previous_headings":"","what":"Transposing by key","title":"Generating (","text":"Another way transposing specifying input (\"\") key output (\"\") key. default, Key argument passed transpose , nothing actually happens. Thus, specify either key key, transposition happen /key Key. course, specify transposition happen keys specify. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function. specify key, Key field passed transpose key, result, pitches input transposed whatever keys target () key! real relative arguments give special control key-wise transposition works, check transpose() docs details!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html","id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Generating (","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html","id":"deparsing-arguments","dir":"Reference","previous_headings":"","what":"Deparsing arguments","title":"Generating (","text":"following \"advanced\" deparsing arguments available (read details ): Steps step.labels step.signed Species (accidentals qualities) qualities specifier.maximum Accidentals natural, flat, sharp, doubleflat, doublesharp Qualities perfect, major, minor, augment, diminish Implicit vs Explicit Species implicitSpecies absoluteSpecies explicitNaturals cautionary memory, memoryWindows Octave octave.integer , , octave.offset octave.round octave.relative, octave.absolute String parsing parts sep Note deparsing arguments similar (sometimes identical) parallel parsing arguments. \"advanced\" arguments can used directly pitch function: example, kern(x, qualities = TRUE). humdrumR pitch functions associated default deparsing arguments. example, use kern(), flat set (default) \"-\". However, wanted print **kern-like pitch data, except different flat symbol, like \"_\", modify deparser: kern('Eb5', flat = \"_\"). overrides default value **kern, output \"ee_\" instead \"ee-\".","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html","id":"steps","dir":"Reference","previous_headings":"","what":"Steps","title":"Generating (","text":"representations \"tonal\" pitch information include representation diatonic steps. can control deparser writes diatonic steps using step.labels argument. step.labels argument must atomic vector unique values, length positive multiple seven. Examples step.labels arguments currently used humdrumR pitch functions include: step.labels = c('', 'B', 'C', 'D', 'E', 'F', 'G') step.labels = c('', 'II', 'III', 'IV', 'V', 'VI', 'VII') step.labels = c('d', 'r', 'm', 'f', 's', 'l', 't') step.labels NULL, steps assumed printed integers, including negative integers representing downward steps. also step.signed (logical, length == 1) argument: step.signed = TRUE, lowercase versions step.labels interpreted negative (downward) steps uppercase versions step.labels interpreted positive (upwards) steps. option used, example, default kern() helmholtz() parsers.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html","id":"species","dir":"Reference","previous_headings":"","what":"Species","title":"Generating (","text":"tonal pitch representations, \"specific\" versions tonal pitches---tonal \"species\"---indicated \"specifiers\": either accidentals qualities. qualities (logical, length == 1) argument indicates whether accidentals used (qualities = FALSE) qualities (qualities = TRUE). specifiers can repeated number times, like \"triple sharps\" \"doubly augmented\"; specifier.maximum (integer, length == 1) argument sets maximum limit number specifiers write. example, force triple sharps (\"###\") double sharps (\"##\") deparse just \"#\", specifying specifier.maximum = 1L.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html","id":"accidentals","dir":"Reference","previous_headings":"","what":"Accidentals","title":"Generating (","text":"qualities = FALSE deparser print accidentals three types: naturals, flats, sharps. natural, flat, /sharp (character, length == 1) arguments can used indicate accidentals printed output. example, set kern('Eb5', flat = 'flat') get output \"eeflat\". Examples accidental argument combinations currently used humdrumR pitch functions include: (flat = \"b\", sharp = \"#\") ->  pitch() (flat = \"-\", sharp = \"#\") ->  kern() (flat = \"es\", sharp = \"\") -> lilypond() (flat = \"-\", sharp = \"+\") -> degree() doubleflat, doublesharp (character, length == 1) arguments NULL default, can set special symbol wanted represent two sharps flats. example, modify pitch() use special double sharp symbol: pitch(\"f##\", doublesharp = \"x\") output \"Fx4\". printing naturals controlled natural argument. However, default, humdrumR deparsers printing naturals. can force naturals print setting explicitNaturals (logical, length == 1) argument TRUE. exact behavior explicitNaturals depends implicitSpecies, absoluteSpecies, Key argument (details ).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html","id":"qualities","dir":"Reference","previous_headings":"","what":"Qualities","title":"Generating (","text":"qualities = TRUE deparser print qualities, five types: perfect, minor, major, augmented, diminished. perfect, major, minor, diminish, /augment (character, length == 1) arguments can used indicate qualities printed output. (Note: talking interval/degree qualities , chord qualities!) example, can write interval(c(\"g-\", \"f#\"), augment = 'aug', diminish = 'dim') output c(\"+dim5\", \"+aug4\"). Examples quality argument combinations currently used humdrumR pitch functions include: parse(major = \"M\", minor = \"m\", perfect = \"P\", diminish = \"d\", augment = \"\") parse(diminish = \"o\", augment = \"+\")","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html","id":"implicit-vs-explicit-species","dir":"Reference","previous_headings":"","what":"Implicit vs Explicit Species","title":"Generating (","text":"musical data, specifiers (e.g., accidentals qualities) explicitly indicated; instead, must infer species pitch context---like key signature!.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html","id":"from-the-key","dir":"Reference","previous_headings":"","what":"From the Key","title":"Generating (","text":"important argument implicitSpecies (logical, length == 1): implicitSpecies = TRUE, species input without explicit species indicated interpreted using Key. example, kern('C', Key = ':', parse(implicitSpecies = TRUE)) parsed \"C#\" C sharp major. kern('C', Key = ':', parse(implicitSpecies = TRUE)) parsed \"C\" C natural minor. kern('C', Key = '-:', parse(implicitSpecies = TRUE)) parsed \"C-\" C flat -flat minor. default, input already specifiers, interpreted absolutely---overriding \"implicit\" Key---, even implicitSpecies = TRUE. Thus, major: kern(\"C#\", Key = ':', parse(implicitSpecies = TRUE)) parsed \"C#\". \"#\" unnecessary. kern(\"Cn\", Key = ':', parse(implicitSpecies = TRUE)) parsed \"C\". \"n\" overrides Key. kern(\"C#\", Key = ':', parse(implicitSpecies = TRUE)) parsed \"C#\". \"#\" overrides Key. However! can also change behavior setting absoluteSpecies (logical, length == 1) argument FALSE. , specifiers input interpreted \"top \" key accidental: kern(\"C#\", Key = ':', parse(implicitSpecies = TRUE, absoluteSpecies = FALSE)) parsed \"C##\". \"#\" input added \"#\" Key, resulting double sharp! unusual behavior, absolute pitch representations like **kern. However, use scale chord degrees, absoluteSpecies = FALSE might appropriate. example, reading figured bass key E minor, \"b7\" figure E bass interpreted double flat (diminished) 7th (Db E)! data encoded, use absoluteSpecies = FALSE.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html","id":"memory","dir":"Reference","previous_headings":"","what":"Memory","title":"Generating (","text":"musical data, assume accidental note \"stays effect\" scale step next bar, different accidental replaces . Fortunately, humdrumR parser (tonalInterval()) also knows parse data encoded \"memory\" way. memory = TRUE, accidental (quality) input note \"remembered\" previous appearances scale step. example, kern(c(\"D#\", \"E\", \"D\", \"E\", \"Dn\", \"C\", \"D\"), parse(memory = TRUE)) parsed c(\"D#\", \"E\", \"D#\", \"E\", \"D\", \"C\", \"D\") want \"memory\" last specific time windows (like bars), can also specify memoryWindows argument. memoryWindows must atomic vector length input (x argument). unique value within memoryWindows vector treated \"window\" within memory operates. common use case pass Bar field humdrumR dataset memoryWindows! memory memoryWindows argument work whatever values implicitSpecies absoluteSpecies specified! Though examples use accidentals, arguments effect parsing qualities (qualities = TRUE).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html","id":"octave","dir":"Reference","previous_headings":"","what":"Octave","title":"Generating (","text":"final piece information encoded () pitch representations indication \"compound pitch\"--- incorporating octave information. humdrumR octaves always defined terms scale steps: two notes scale degree/letter name always octave. mainly comes regards Cb B#: Cb4 semitone ; B#3 enharmonically middle-C.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html","id":"integer-octaves","dir":"Reference","previous_headings":"","what":"Integer Octaves","title":"Generating (","text":"simplest way octave information can encoded integer value, Scientific Pitch. need parse integer-encoded octaves, set octave.integer (logical, length == 1) argument TRUE. default, humdrumR considers \"central\" octave (octave == 0) octave , equivalently, unison. However, different octave used central octave, can specify octave.offset (integer, length == 1) argument. illustrate, default Scientific Pitch parser used arguments: kern('C5', parse(octave.integer = TRUE, octave.offset = 4) Returns \"cc\" (octave middle C).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html","id":"non-integer-octave-markers","dir":"Reference","previous_headings":"","what":"Non-integer Octave Markers","title":"Generating (","text":"octave.integer = FALSE, humdrumR parser instead looks three possible symbols indicate octave information. symbols controlled using , , (character, length == 1) arguments. symbol, symbol, interpreted \"central\" octave; repeating strings symbols indicate increasing positive () negative () octaves. example, lilypond notation, , represents lower octaves, ' (single apostrophe) represents upper octaves. default lilypond() parser uses arguments: pitch(c(\"c\", \"c\", \"c'\"), parse(octave.integer = FALSE, = \"'\", = \",\", octave.offset = 1)) Returns c(\"C2\", \"C3\", \"C4\"). (Note lilypond makes octave  central octave, using octave.offset = 1.)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html","id":"octave-rounding-","dir":"Reference","previous_headings":"","what":"Octave \"Rounding\"","title":"Generating (","text":"situations, pitch data might interpret \"groupby\" octaves little differently. absolute pitch representations (e.g., kern(), pitch()), \"boundary\" one octave next B (degree 7) C (degree 1). However, example, working data representing intervals, might think \"octave\" spanning range -P4 (G) +P4 (f). case, \"octave boundary\" centered around unison (), rather starting middle-C/unison. data represented way, use octave.round argument; octave.round must rounding function, either round, floor, ceiling, trunc, expand. functions indicate interpret simple pitches \"rounding\" nearest C/unison. default behavior pitch representations octave.round = floor: scale step rounded downwards nearest C. B associated C 7 steps . , hand, octave.round = round, scale-steps \"rounded\" closest C, B associated closer C . Indeed, octave.round = round gets us -P4 <-> +P4 behavior mentioned earlier! working parsing intervals, octave.round option allows control \"simple part\" (less octave) compound interval represented. example, might think ascending major 12th ascending octave plus ascending perfect 5th: ** +P8 + P5**. encode interval two ascending octaves minus perfect fourth: + P15 - P4. following table illustrates different octave.round arguments \"partition\" compound intervals simple parts octaves: Notice , octave.floor used, simple intervals represented ascending. parsing \"absolute\" pitch representations, octave.round option allows control octave notes associated . following table illustrates:","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html","id":"absolute-or-relative-contour-octave","dir":"Reference","previous_headings":"","what":"Absolute or Relative (contour) Octave","title":"Generating (","text":"notation encoding schemes, \"octave\" note interpreted relative previous note, rather absolute reference. prominent system Lilypond's relative octave entry style. style often used combination scale degree representations---RS200 corpus. example, data set might say Re Mi vSo La Ti , \"v\" indicating jump . activate relative-octave parsing, set octave.relative = TRUE---alternatively, can use octave.absolute = FALSE, equivalent. relative-octave data, assume octave indications indicate shift relative previous note. usually used combination octave markers like \"^\" () \"v\" (). Different combinations octave.round allow us parse different behaviors: octave.round = round, marker (marker) indicates note pitch closest previous pitch. Octave markers indicate alterations assumption. always, based scale steps, semitones! fourth \"closer\" fifth, regardless quality: C F# ascending C Gb descending! ascending diminished 5th written C ^Gb---= ^. octave.round = floor, marker (marker) indicates note octave previous pitch. Octave markers indicate alterations assumption. setting, going C B always requires mark.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html","id":"string-parsing","dir":"Reference","previous_headings":"","what":"String Parsing","title":"Generating (","text":"addition three types musical parsing considerations reviewed (steps, species, octaves), also general string-parsing issues can consider/control.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html","id":"parts-and-order","dir":"Reference","previous_headings":"","what":"Parts and Order","title":"Generating (","text":"far () discussed various ways tonal pitch information (step, species, octave) can encoded, humdrumR parser can modified handle different options. However, two general parsing issues/options consider: information encoded, order? parts argument can specifyied indicate . parts argument must character vector length 1--3. characters must partial match either \"step\", \"species\", \"octave\". presense strings parts vector indicate information parsed. order strings indicates order pieces pitch information encoded input strings. illustrate, imagine input data identical standard interval representation---e.g., M2 P5---except quality appears step---e.g., 2M 5P. call interval(c(\"2M\", \"5P\"), parse(parts = c(\"step\", \"species\"))) sure enough get correct parse! One final string-parsing argument sep, indicates character string separating pitch information components: common case comma space. example, use parse command like : kern(\"E flat 5\", parse(flat = \"flat\", sep = \" \")).","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchFunctions.html","id":null,"dir":"Reference","previous_headings":"","what":"Translate between pitch representations. — pitchFunctions","title":"Translate between pitch representations. — pitchFunctions","text":"functions can used extract \"translate,\" otherwise modify, data representing pitch information. functions :","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchFunctions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Translate between pitch representations. — pitchFunctions","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). generic (logical, length == 1) generic = TRUE \"specific\" pitch information (accidentals qualites) discarded. simple (logical, length == 1) simple = TRUE \"compound\" pitch information (octave/contour) discarded. Key (diatonicSet something coercable diatonicSet, length == 1 | length == length(x)) input Key used parser, deparser, transposer. parseArgs (list) parseArgs can list arguments passed pitch parser. transposeArgs (list) transposeArgs can list arguments passed special call transpose. inPlace (logical, length == 1) argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchFunctions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Translate between pitch representations. — pitchFunctions","text":"NULL inputs (x argument) return NULL output. Otherwise, returns vector/matrix length/dimension x. NA values input x propagated output.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchFunctions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Translate between pitch representations. — pitchFunctions","text":"Tonal pitch representations Absolute pitch representations kern() pitch() lilypond() helmholtz() tonh() (German-style notation) Relative pitch representations interval() solfa() (relative-solfege) solfg() (French-style fixed-solfege) degree() (absolute scale degrees) deg() (melodic scale degrees) bhatk() (hindustani swara) Partial pitch representations step() accidental() quality() octave() Atonal pitch representations Musical pitch representations semits() midi() cents() pc() (pitch classes) Physical pitch representations freq() pitch functions work similar ways, similar arguments functionality. function takes input pitch representation (can anything) outputs pitch representation. example, kern() takes input representation outputs **kern (pitch) data. Underneath hood, full processing function looks like : Input representation (e.g., **pitch **semits) |> Parsing (done tonalInterval()) |> Intermediate (tonalInterval) representation |> Transformation (e.g., transpose()) |> Deparsing |> Output representation (e.g. **kern **solfa) read details parsing step, read . read details \"deparsing\" step, read . read details specific function, click links list , type ?func R command line: example, ?kern.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html","id":null,"dir":"Reference","previous_headings":"","what":"Parsing pitch information — pitchParsing","title":"Parsing pitch information — pitchParsing","text":"humdrumR includes easy--use powerful system parsing pitch information: various basic pitch representations (including numeric character-string representations) can \"parsed\"---read interpreted humdrumR. part, parsing automatically happens \"behind scenes\" whenever use humdrumR pitch function, like kern() semit(), solfa().","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parsing pitch information — pitchParsing","text":"","code":"tonalInterval(...)  # S3 method for tonalInterval tonalInterval(x, ...)  # S3 method for logical tonalInterval(x, ...)  # S3 method for `NULL` tonalInterval(x, ...)  # S3 method for numeric tonalInterval(x, ..., Exclusive = NULL, multiDispatch = FALSE)  # S3 method for character tonalInterval(x, ..., Exclusive = NULL, multiDispatch = FALSE)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parsing pitch information — pitchParsing","text":"Exclusive (character,  length == 1 | length == length(x)) str (character numeric) input vector. Key (diatonicSet something coercable diatonicSet, length == 1 | length == length(x)) input Key used interpret pitch representations. example, use implicitSpecies (see advanced parsing section) dependent Key. output tonalInterval output within key: thus, tonalInterval('C#', Key = \":\") returns tint representing Major 3rd, C# major third major.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parsing pitch information — pitchParsing","text":"underlying parser used humdrumR pitch functions can called explicitly using function tonalInterval(). tonalInterval parser attempt parse input information tonalInterval object---back-end pitch representation probably need care ! use one main pitch functions, like kern() semits(), input parsed tonalInterval object, immediately deparsed representation asked (e.g., **kern **semits). Thus, underlying pipeline humdrumR pitch functions looks something like: Input representation (e.g., **pitch **semits) |> Parsing (done tonalInterval()) |> Intermediate (tonalInterval) representation |> Deparsing |> Output representation (e.g. **kern **solfa) documentation talks parsing step. overview \"deparsing\" process, look . learn \"deparsing\" specific representations, start go straight docs specific functions--- example, call ?kern learn kern().","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html","id":"dispatch","dir":"Reference","previous_headings":"","what":"Dispatch","title":"Parsing pitch information — pitchParsing","text":"pitch parser (tonalInterval) generic function, meaning can accepts variety inputs automatically \"dispatches\" appropriate method parsing input. R's standard S3 system used dispatch either numeric character-string input: Generally, numeric (integer) inputs interpreted various atonal pitch representations character strings interpreted various tonal pitch representations. Given either character string number, humdrumR uses either regular-expression matching humdrum exclusive interpretation matching dispatch specific parsing methods.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html","id":"tonal-parsing-character-string-inputs-","dir":"Reference","previous_headings":"","what":"Tonal Parsing (character-string inputs)","title":"Parsing pitch information — pitchParsing","text":"Since humdrum data inherently string-based, powerful part humdrumR pitch-parser system parsing pitch (mostly tonal) information character strings. (includes character tokens pitch information embedded alongside information; Details .) pitch parser (tonalInterval) uses combination regular-expressions exclusive interpretations decide parse input string. twelve regular-expression patterns pitch tonalInterval knows parse automatically:","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html","id":"exclusive-dispatch","dir":"Reference","previous_headings":"","what":"Exclusive Dispatch","title":"Parsing pitch information — pitchParsing","text":"call tonalInterval (pitch function) character-string vector, non-NULL Exclusive argument, Exclusive argument used choose input interpretation want, based \"Exclusive\" column table . example, kern(x, Exclusive = 'solfa') force parser interpret x **solfa data. Similarly, solfa(x, Exclusive = 'kern') force parser interpret x **kern data. use pitch function within special call withinHumdrum, humdrumR automatically pass Exclusive field humdrum data function---means, cases, need explicitly anything Exclusive argument! (want happen, need explicitly specify Exclusive argument, Exclusive = NULL.)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html","id":"regex-dispatch","dir":"Reference","previous_headings":"","what":"Regex Dispatch","title":"Parsing pitch information — pitchParsing","text":"call tonalInterval (pitch function) character-string vector, Exclusive argument missing NULL, humdrumR instead use regular-expression patterns select known interpretation. example, pitch('') automatically recognize '' solfege, interpret data accordingly (output G4). one matches, humdrumR use longest match, tie, pick based order table (topmost first). match, tonalInterval (pitch function) return NA values. Remember, Exclusive specified, overrides regex-based dispatch, means pitch('', Exclusive = 'kern') return NA, '' interpreted **kern value.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html","id":"-in-place-parsing","dir":"Reference","previous_headings":"","what":"\"In place\" parsing","title":"Parsing pitch information — pitchParsing","text":"lots humdrum data, character strings encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find , using appropriate known regular expressions. Various pitch parsing functions option keep original \"extra\" data, using inPlace argument.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html","id":"advanced-tonal-parsing-options","dir":"Reference","previous_headings":"","what":"Advanced Tonal Parsing Options","title":"Parsing pitch information — pitchParsing","text":"eleven tonal representations listed parsed common intesrface. using \"advanced\" parsing arguments, can tweak parsing done, accommodate even input representations! means controlling behavior tonalInterval(), second step pipeline: Input representation |> Parsing (done tonalInterval(PARSE ARGS GO !)) |> Intermediate (tonalInterval) representation |> Deparsing |> Output representation Note arguments similar identical parallel \"advanced\" deparsing arguments used various pitch functions. following \"advanced\" parsing arguments available (read details ): Steps step.labels step.signed Species (accidentals qualities) qualities specifier.maximum Accidentals natural, flat, sharp, doubleflat, doublesharp Qualities perfect, major, minor, augment, diminish Implicit vs Explicit Species implicitSpecies absoluteSpecies memory, memoryWindows Octave octave.integer , , octave.offset octave.round octave.relative, octave.absolute String parsing parts sep \"advanced\" arguments can used directly pitch function, call tonalInterval . use tonalInterval just specify directly arguments: example, tonalInterval(x, qualities = TRUE). use pitch functions, can either... Put parseArgs argument: kern(x, parseArgs = list(qualities = TRUE)) use \"syntactic sugar\" short-hand form: kern(x, parse(qualities = TRUE)) known Exclusive/Regex-dispatch combo (see table ) associated default parsing arguments. example, set Exclusive = 'kern' just use data look like **kern, flat argument set \"-\", However, , example, input data looked like **kern except used different flat symbol, like \"_\", modify parser: kern(\"EE_\", parse(flat = \"_\")) overrides default value **kern---notice, also updates **kern regular expression accordingly, works exactly standard kern() function.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html","id":"steps","dir":"Reference","previous_headings":"","what":"Steps","title":"Parsing pitch information — pitchParsing","text":"representation \"tonal\" pitch information include representation diatonic steps. can control parser reads diatonic steps pitch representation using step.labels argument. step.labels argument must atomic vector unique values, length positive multiple seven. Examples step.labels arguments currently used preset humdrumR pitch parsers include: parse(step.labels = c('', 'B', 'C', 'D', 'E', 'F', 'G')) --- (**Tonh) parse(step.labels = c('d', 'r', 'm', 'f', 's', 'l', 't')) --- (**solfa) parse(step.labels = c('', 'II', 'III', 'IV', 'V', 'VI', 'VII')) --- (roman numerals) step.labels NULL, steps assumed represented integers, including negative integers representing downward steps. also step.signed (logical, length == 1) argument: step.signed = TRUE, lowercase versions step.labels interpreted negative (downward) steps uppercase versions step.labels interpreted positive (upwards) steps. option used, example, default kern() helmholtz() parsers.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html","id":"species","dir":"Reference","previous_headings":"","what":"Species","title":"Parsing pitch information — pitchParsing","text":"tonal pitch representations, \"specific\" versions tonal pitches---tonal \"species\"---indicated \"specifiers\": either accidentals qualities. qualities (logical, length == 1) argument indicates whether accidentals used (qualities = FALSE) qualities (qualities = TRUE). specifiers can repeated number times, like \"triple sharps\" \"doubly augmented\"; specifier.maximum (integer, length == 1) argument sets maximum limit number specifiers read. example, force triple sharps (\"###\") double sharps (\"##\") parse just \"#\", specifying specifier.maximum = 1L.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html","id":"accidentals","dir":"Reference","previous_headings":"","what":"Accidentals","title":"Parsing pitch information — pitchParsing","text":"qualities = FALSE parser look accidentals input, recognizing three types: naturals, flats, sharps. natural, flat, /sharp (character, length == 1) arguments can used indicate accidentals represented input. example, input strings look like c(\"Eflat\", \"C\"), set argument flat = \"flat\". Examples accidental argument combinations currently used preset humdrumR pitch parsers include: parse(flat = \"b\", sharp = \"#\") -> **pitch parse(flat = \"-\", sharp = \"#\") -> **kern parse(flat = \"-\", sharp = \"+\") -> **degree doubleflat, doublesharp (character, length == 1) arguments NULL default, can set special symbol used represent two sharps flats. example, might input represents double sharps \"x\". call kern(\"Fx\", parse(doublesharp = \"x\")) output \"F##\".","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html","id":"qualities","dir":"Reference","previous_headings":"","what":"Qualities","title":"Parsing pitch information — pitchParsing","text":"qualities = TRUE parser look qualities input, recognizing five types: perfect, minor, major, augmented, diminished. perfect, major, minor, diminish, /augment (character, length == 1) arguments can used indicate qualities represented input. (Note: talking interval/degree qualities , chord qualities!) example, input strings look like c(\"maj3\", \"p4\"), set arguments major = \"maj\" perfect = \"p\". Examples quality argument combinations currently used humdrumR pitch functions include: parse(major = \"M\", minor = \"m\", perfect = \"P\", diminish = \"d\", augment = \"\") parse(diminish = \"o\", augment = \"+\")","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html","id":"implicit-vs-explicit-species","dir":"Reference","previous_headings":"","what":"Implicit vs Explicit Species","title":"Parsing pitch information — pitchParsing","text":"musical data, specifiers (e.g., accidentals qualities) explicitly indicated; instead, must infer species pitch context---like key signature!.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html","id":"from-the-key","dir":"Reference","previous_headings":"","what":"From the Key","title":"Parsing pitch information — pitchParsing","text":"important argument implicitSpecies (logical, length == 1): implicitSpecies = TRUE, species input without explicit species indicated interpreted using Key. example, kern('C', Key = ':', parse(implicitSpecies = TRUE)) parsed \"C#\" C sharp major. kern('C', Key = ':', parse(implicitSpecies = TRUE)) parsed \"C\" C natural minor. kern('C', Key = '-:', parse(implicitSpecies = TRUE)) parsed \"C-\" C flat -flat minor. default, input already specifiers, interpreted absolutely---overriding \"implicit\" Key---, even implicitSpecies = TRUE. Thus, major: kern(\"C#\", Key = ':', parse(implicitSpecies = TRUE)) parsed \"C#\". \"#\" unnecessary. kern(\"Cn\", Key = ':', parse(implicitSpecies = TRUE)) parsed \"C\". \"n\" overrides Key. kern(\"C#\", Key = ':', parse(implicitSpecies = TRUE)) parsed \"C#\". \"#\" overrides Key. However! can also change behavior setting absoluteSpecies (logical, length == 1) argument FALSE. , specifiers input interpreted \"top \" key accidental: kern(\"C#\", Key = ':', parse(implicitSpecies = TRUE, absoluteSpecies = FALSE)) parsed \"C##\". \"#\" input added \"#\" Key, resulting double sharp! unusual behavior, absolute pitch representations like **kern. However, use scale chord degrees, absoluteSpecies = FALSE might appropriate. example, reading figured bass key E minor, \"b7\" figure E bass interpreted double flat (diminished) 7th (Db E)! data encoded, use absoluteSpecies = FALSE.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html","id":"memory","dir":"Reference","previous_headings":"","what":"Memory","title":"Parsing pitch information — pitchParsing","text":"musical data, assume accidental note \"stays effect\" scale step next bar, different accidental replaces . Fortunately, humdrumR parser (tonalInterval()) also knows parse data encoded \"memory\" way. memory = TRUE, accidental (quality) input note \"remembered\" previous appearances scale step. example, kern(c(\"D#\", \"E\", \"D\", \"E\", \"Dn\", \"C\", \"D\"), parse(memory = TRUE)) parsed c(\"D#\", \"E\", \"D#\", \"E\", \"D\", \"C\", \"D\") want \"memory\" last specific time windows (like bars), can also specify memoryWindows argument. memoryWindows must atomic vector length input (x argument). unique value within memoryWindows vector treated \"window\" within memory operates. common use case pass Bar field humdrumR dataset memoryWindows! memory memoryWindows argument work whatever values implicitSpecies absoluteSpecies specified! Though examples use accidentals, arguments effect parsing qualities (qualities = TRUE).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html","id":"octave","dir":"Reference","previous_headings":"","what":"Octave","title":"Parsing pitch information — pitchParsing","text":"final piece information encoded () pitch representations indication \"compound pitch\"--- incorporating octave information. humdrumR octaves always defined terms scale steps: two notes scale degree/letter name always octave. mainly comes regards Cb B#: Cb4 semitone ; B#3 enharmonically middle-C.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html","id":"integer-octaves","dir":"Reference","previous_headings":"","what":"Integer Octaves","title":"Parsing pitch information — pitchParsing","text":"simplest way octave information can encoded integer value, Scientific Pitch. need parse integer-encoded octaves, set octave.integer (logical, length == 1) argument TRUE. default, humdrumR considers \"central\" octave (octave == 0) octave , equivalently, unison. However, different octave used central octave, can specify octave.offset (integer, length == 1) argument. illustrate, default Scientific Pitch parser used arguments: kern('C5', parse(octave.integer = TRUE, octave.offset = 4) Returns \"cc\" (octave middle C).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html","id":"non-integer-octave-markers","dir":"Reference","previous_headings":"","what":"Non-integer Octave Markers","title":"Parsing pitch information — pitchParsing","text":"octave.integer = FALSE, humdrumR parser instead looks three possible symbols indicate octave information. symbols controlled using , , (character, length == 1) arguments. symbol, symbol, interpreted \"central\" octave; repeating strings symbols indicate increasing positive () negative () octaves. example, lilypond notation, , represents lower octaves, ' (single apostrophe) represents upper octaves. default lilypond() parser uses arguments: pitch(c(\"c\", \"c\", \"c'\"), parse(octave.integer = FALSE, = \"'\", = \",\", octave.offset = 1)) Returns c(\"C2\", \"C3\", \"C4\"). (Note lilypond makes octave  central octave, using octave.offset = 1.)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html","id":"octave-rounding-","dir":"Reference","previous_headings":"","what":"Octave \"Rounding\"","title":"Parsing pitch information — pitchParsing","text":"situations, pitch data might interpret \"boundaries\" octaves little differently. absolute pitch representations (e.g., kern(), pitch()), \"boundary\" one octave next B (degree 7) C (degree 1). However, example, working data representing intervals, might think \"octave\" spanning range -P4 (G) +P4 (f). case, \"octave boundary\" centered around unison (), rather starting middle-C/unison. data represented way, use octave.round argument; octave.round must rounding function, either round, floor, ceiling, trunc, expand. functions indicate interpret simple pitches \"rounding\" nearest C/unison. default behavior pitch representations octave.round = floor: scale step rounded downwards nearest C. B associated C 7 steps . , hand, octave.round = round, scale-steps \"rounded\" closest C, B associated closer C . Indeed, octave.round = round gets us -P4 <-> +P4 behavior mentioned earlier! working parsing intervals, octave.round option allows control \"simple part\" (less octave) compound interval represented. example, might think ascending major 12th ascending octave plus ascending perfect 5th: ** +P8 + P5**. encode interval two ascending octaves minus perfect fourth: + P15 - P4. following table illustrates different octave.round arguments \"partition\" compound intervals simple parts octaves: Notice , octave.floor used, simple intervals represented ascending. parsing \"absolute\" pitch representations, octave.round option allows control octave notes associated . following table illustrates:","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html","id":"absolute-or-relative-contour-octave","dir":"Reference","previous_headings":"","what":"Absolute or Relative (contour) Octave","title":"Parsing pitch information — pitchParsing","text":"notation encoding schemes, \"octave\" note interpreted relative previous note, rather absolute reference. prominent system Lilypond's relative octave entry style. style often used combination scale degree representations---RS200 corpus. example, data set might say Re Mi vSo La Ti , \"v\" indicating jump . activate relative-octave parsing, set octave.relative = TRUE---alternatively, can use octave.absolute = FALSE, equivalent. relative-octave data, assume octave indications indicate shift relative previous note. usually used combination octave markers like \"^\" () \"v\" (). Different combinations octave.round allow us parse different behaviors: octave.round = round, marker (marker) indicates note pitch closest previous pitch. Octave markers indicate alterations assumption. always, based scale steps, semitones! fourth \"closer\" fifth, regardless quality: C F# ascending C Gb descending! ascending diminished 5th written C ^Gb---= ^. octave.round = floor, marker (marker) indicates note octave previous pitch. Octave markers indicate alterations assumption. setting, going C B always requires mark.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html","id":"string-parsing","dir":"Reference","previous_headings":"","what":"String Parsing","title":"Parsing pitch information — pitchParsing","text":"addition three types musical parsing considerations reviewed (steps, species, octaves), also general string-parsing issues can consider/control.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html","id":"parts-and-order","dir":"Reference","previous_headings":"","what":"Parts and Order","title":"Parsing pitch information — pitchParsing","text":"far () discussed various ways tonal pitch information (step, species, octave) can encoded, humdrumR parser can modified handle different options. However, two general parsing issues/options consider: information encoded, order? parts argument can specifyied indicate . parts argument must character vector length 1--3. characters must partial match either \"step\", \"species\", \"octave\". presense strings parts vector indicate information parsed. order strings indicates order pieces pitch information encoded input strings. illustrate, imagine input data identical standard interval representation---e.g., M2 P5---except quality appears step---e.g., 2M 5P. call interval(c(\"2M\", \"5P\"), parse(parts = c(\"step\", \"species\"))) sure enough get correct parse! One final string-parsing argument sep, indicates character string separating pitch information components: common case comma space. example, use parse command like : kern(\"E flat 5\", parse(flat = \"flat\", sep = \" \")).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html","id":"atonal-parsing-numeric-inputs-","dir":"Reference","previous_headings":"","what":"Atonal Parsing (numeric inputs)","title":"Parsing pitch information — pitchParsing","text":"humdrumR pitch parser (tonalInterval()) interpret numeric inputs atonal pitch information. default, numbers interpreted semitones. However, parses midi(), cents(),  frequencies also defined. Dispatch different parsers controlled Exclusive argument.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html","id":"enharmonic-interpretation","dir":"Reference","previous_headings":"","what":"Enharmonic Interpretation","title":"Parsing pitch information — pitchParsing","text":"converting atonal representation tonal one, must decide interpret tonality input---specifically, enharmonic spelling notes use.  humdrumR numeric parser interprets atonal pitches \"enharmonic window\" 12 steps line--fifths. position window set enharmonic.center (integer, length == 1) argument. default, enharmonic.center = 0, creates window -5 (b2) +6) (#4). prefer #1 instead b2, set enharmonic.center = 1. flats, set enharmonic.center = -1. sharps, set enharmonic.center = 4. enharmonic.center argument work translating pitch representation, like kern(). However, present table terms scale degrees atonal -> enharmonic calculation centered key. , Key argument specified, \"enharmonic window\" centered around key. translating kern Key = F#:, output range Gn B#. want , set Key = NULL.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html","id":"melodic-interpretation-of-chromatic-notes","dir":"Reference","previous_headings":"","what":"Melodic Interpretation of Chromatic Notes","title":"Parsing pitch information — pitchParsing","text":"common chromatic notes melodic passages labeled based melodic contour: .e., ascending chromatic notes labeled sharp descending chromatic notes labeled flat. behavior can engaged setting accidental.melodic (logical, length == 1) argument. accidental.melodic = TRUE, input first centered enharmonic window (), places chromatic alteration proceeds upwards non-chromatic note altered (necessary) sharp, vice verse descending notes flats. example, kern(0:2) returns c(\"c\", \"d-\", \"d\"), kern(0:2, parse(accidental.melodic = TRUE)) returns c(\"c\", \"c#\", \"d\").","code":""},{"path":[]},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/plotRhythm.html","id":null,"dir":"Reference","previous_headings":"","what":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------\nPlotting rhythmic symbols in R base graphics — plotRhythm","title":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------\nPlotting rhythmic symbols in R base graphics — plotRhythm","text":"------------------------------------------->             NEEDS DOCUMENTATION             <------------------------------------------- Plotting rhythmic symbols R base graphics","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/plotRhythm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------\nPlotting rhythmic symbols in R base graphics — plotRhythm","text":"","code":"plotRhythm(x, y, notes, ...)  # S3 method for default plotRhythm(x, y, notes, ...)  # S3 method for rhythmInterval plotRhythm(x, y, notes, ...)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/quality.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract quality from pitch — quality","title":"Extract quality from pitch — quality","text":"Extract quality pitch","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/quality.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract quality from pitch — quality","text":"","code":"quality(x, ..., Key = NULL, parseArgs = list(), inPlace = FALSE)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/quality.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract quality from pitch — quality","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). Key (diatonicSet something coercable diatonicSet, length == 1 | length == length(x)) input Key used parser, deparser, transposer. parseArgs (list) parseArgs can list arguments passed pitch parser. inPlace (logical, length == 1) argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rational.html","id":null,"dir":"Reference","previous_headings":"","what":"Rational numbers — rational","title":"Rational numbers — rational","text":"R built rational number representation; humdrumR defines one.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rational.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rational numbers — rational","text":"","code":"rational(numerator, denominator = 1L)  e1 %R% e2  numerator(x)  denominator(x)  # S4 method for rational numerator(x)  # S4 method for rational denominator(x)  is.rational(x)  # S4 method for rational is.numeric(x)  # S4 method for rational order(   x,   ...,   na.last = TRUE,   decreasing = FALSE,   method = c(\"auto\", \"shell\", \"radix\") )  # S4 method for rational,rational Compare(e1, e2)  # S4 method for rational,ANY Compare(e1, e2)  # S4 method for ANY,rational Compare(e1, e2)  # S4 method for rational Summary(x)  # S4 method for rational prod(x, ..., na.rm = FALSE)  # S4 method for rational abs(x)  # S4 method for rational sign(x)  # S4 method for rational max(x, ..., na.rm = FALSE)  # S4 method for rational min(x, ..., na.rm = FALSE)  # S4 method for rational mean(x)  # S4 method for rational sum(x, ..., na.rm = FALSE)  # S4 method for rational cumsum(x)  as.rational(x, ...)  # S4 method for rational as.rational(x)  # S4 method for matrix as.rational(x)  # S4 method for integer as.rational(x)  # S4 method for numeric as.rational(x)  # S4 method for logical as.rational(x)  # S4 method for character as.rational(x, sep = \"/|%\")  fraction(numerator, denominator, sep = \"/\")  as.fraction(x, sep = \"/\")"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rational.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rational numbers — rational","text":"Using rational numbers, can represent numbers like 1/3 without numeric inaccuracies. words, \\(1/3 * 3 = 3\\), never \\(.999999999\\). hand, rational numbers start numerators demoninators large, can run integer overflow problems. assume rational numbers using context music analysis relatively simple; can safely use numbers without numeric inaccuracy. fraction class (associated constructor) represents rational numbers character strings. Unlike rational, fraction class numeric thus arithmetic. However, fraction can converted /rational.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/readHumdrum.html","id":null,"dir":"Reference","previous_headings":"","what":"Find and read humdrum files into R — knownInterpretations","title":"Find and read humdrum files into R — knownInterpretations","text":"functions find valid humdrum files local machine read humdrumR.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/readHumdrum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find and read humdrum files into R — knownInterpretations","text":"","code":"knownInterpretations  findHumdrum(   ...,   contains = NULL,   recursive = FALSE,   allowDuplicates = FALSE,   verbose = FALSE )  readHumdrum(   ...,   recursive = FALSE,   contains = NULL,   allowDuplicates = FALSE,   verbose = FALSE,   tandems = \"known\",   reference = \"all\" )"},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/readHumdrum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find and read humdrum files into R — knownInterpretations","text":"... character: One patterns used identify files read. details: see \"REpath-patterns\" section . contains character. !.null(contains), contains argument treated regular expressions: files contain matches regular expressions read. Thus, readHumdrum('.*krn$', contains = \"EEE\") read kern files contain matches \"EE\"---kern E two octaves middle C (lower). recursive logical: TRUE, final part search pattern (.e., file search) searched recursively sub directories. allowDuplicates logical length one, indicating happen multiple search patterns match files. allowDuplicates = TRUE, files read multiple times, grouped respective corpora Label field. allowDuplicates = FALSE, redundant files read corpus first pattern match. verbose logical: TRUE, names matching files printed parsing begins. useful check make sure reading wrong files! tandems character. argument controls , , tandem interpretations parsed fields. default value \"known\". reference character. argument controls , , reference records parsed fields. default value \"\".","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/readHumdrum.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find and read humdrum files into R — knownInterpretations","text":"findHumdrum work finding reading text files R. readHumdrum utilizes findHumdrum read files, parses create humdrum table build humdrumR data object around table.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/readHumdrum.html","id":"repath-patterns","dir":"Reference","previous_headings":"","what":"REpath-patterns","title":"Find and read humdrum files into R — knownInterpretations","text":"\"REpath-patterns\" specified using ... arguments. combination, ... arguments used search file paths. part search path specify (\"dirpart/dirpart/filepart\", etc) matched regular expressions directories/files disc. Thus, can say things like findHumdrum(\"../^.*/.*krn$\"), match kern files directory beginning capital \"\" directory current working directory. conveniance, can break path across multiple arguments instead using delimited strings: example, code findHumdrum(\"..\", \"^.*\", \".*krn$\") give identical result previous example (findHumdrum(\"../^.*/,*krn$\")). useful searching one pattern (see next paragraph) directory. want search one pattern, can input character vector: instance, readHumdrum(c(\"mozart\", \"beethoven\")---command search filenames containing \"mozart\" \"beethoven.\" works directories : readHumdrum(c(\"Mozart\", \"Beethoven\"), \".*krn$\") look kern files directories containing \"Mozart\" \"Beethoven.\" patterns named, names show identifying patterns [humdrumR][humdrumR] object's Label field. Unnamed patterns simply labeled numbers. refer files matched regex patterns \"subcorpora\" total corpus. Normal (system appropriate) conventions (.e., directories separated \"/\", '~' beginning indicate home, \"..\" indicate directory working directory, etc.) followed. pattern contains solo dot followed file sep---e.g., \"./\", \"x/./y\"---treated current directory, regular expression. pattern contains two dots---e.g., \"../\"---treated directory , regular expression. want create regular expression match directory, use \".*/\". regex pattern \"\" matches file (changed \".*\"). specifiy ... argument, findHumdrum (readHumdrum) default \".*\" well. Thus, readHumdrum() read humdrum files working directory. (two files different directories share name, unique name created file appending names directories occupy, recursively names unique.) single humdrum file multiple pieces ---meaning spine paths close *-, open **---parsed separately. distinguished Piece field. multi-piece files, Piece File identical.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/readHumdrum.html","id":"validity","dir":"Reference","previous_headings":"","what":"Validity","title":"Find and read humdrum files into R — knownInterpretations","text":"findHumdrum readHumdrum automatically ignore non-text files. , files contain humdrum syntax errors (checked validateHumdrum()) automatically skipped. want see specifically errors occurred, call validateHumdrum() directly use errorReport.path argument.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/readHumdrum.html","id":"tandem-interpretations","dir":"Reference","previous_headings":"","what":"Tandem Interpretations","title":"Find and read humdrum files into R — knownInterpretations","text":"tandem interpretations humdrum dataset summarized humdrum table's Tandem field, described detail . addition, certain \"known\" tandem interpretations parsed fields automatically. example, *clefG4 \"*clefF2 parsed Clef data, *k[b-] parsed KeySignature. \"known\" tandem interpretations humdrumR recognizes encoded built-table called knownInterpretations. interpretation humdrumR name (\"Clef\", \"TimeSignature\", etc.) well regular expression associated . tandems argument readHumdrum controls tandem interpretations parsed fields. can helpful either save processing time memory parsing interpretations need, parse interpretations humdrumR recognize. default value tandems argument \"known\". tandems argument contains \"known\" tandem interpretations built-knownInterpretations table parsed. Users may specify different interpretations parse two ways: character strings matching one name values Name column knownInterpretations. instance, specify tandems = c('Clef', 'TimeSignature'), clef (e.g., \"*clefG2\"), time signature (e.g., \"*M3/4\") intepretations parsed. character string(s) tandem exactly match one names knownInterpretations$Name, treated regular expressions used match tandem interpretations data. allows users parse non-standard tandem interpretations humdrumR already know . values tandems named, names used resulting fields. matches given interpretation found, field created interpretation. tandems = NULL, tandem interpretations parsed.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/readHumdrum.html","id":"reference-records","dir":"Reference","previous_headings":"","what":"Reference Records","title":"Find and read humdrum files into R — knownInterpretations","text":"default (reference = \"\"), humdrumR reads reference records data. reference code record (e.g, \"OTL\", \"!!!OTL: xxx\") used name associated field. (reference record reference code (.e., lacks colon), field called \"Unkeyed.\") large datasets many reference records, reference data can actually make large portion humdrum table, eat lot memory. cases, might want read () reference records---can instead read reference records planning use analyses (). reference = NULL, reference records parsed. Otherwise, character values reference treated reference codes matching reference records parsed. instance, readHumdrum(_, reference = \"OTL\") parse OTL reference records. values reference named, names used name associated fields. Thus, specifing reference = c(Title = 'OTL'), can use \"OTL\" reference records populate field called \"Title\". one reference records reference code, either explicitely numbered (e.g., \"!!!COM1:\", \"!!!COM2:\") read rather making two fields, single field created (\"COM\" ) multiple values separated \";\".","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/readHumdrum.html","id":"spines-and-paths","dir":"Reference","previous_headings":"","what":"Spines and Paths","title":"Find and read humdrum files into R — knownInterpretations","text":"humdrum syntax, data placed \"spines,\" \"columns\" spreadsheet. \"column\" refers tab-delineated group values. \"Spines\" can single column, may (time) split multiple columns, can turn split , using \"*^\" interpretation token. reverse can happen well, two columns merging single column, using \"v\" token. means , humdrum data first glance looks like simple two-dimensional table, actually flexible tree structure. spines split merge, total number columns can change piece, creating \"ragged\" edge. Another similar issue corpus humdrum files may varying numbers spines/columns, pieces. (\"Global\" comment/reference records also special case, always single value, even interspersed multi-column local records.) readHumdrum assumes slightly strict version humdrum syntax: spines appear beginning file (headed exclusive interpretations like \"**kern\") can never merge . Thus, humdrum file read humdrumR must end fewer columns starts. Spine merges (\"*v\") can happen within spine paths originally split spine. extra-strict specification spine paths humdrum syntax , fortunately, something informally followed humdrum datasets. strict spine-path definition makes everything work fairly simply: Within piece, spines appear beginning piece \"true\" spines throughout piece, numbered left right, starting 1L. local token, value Spine field integer indicating \"true\" spines belongs ---global tokens NA value Spine field, belong spine. spine path splits (\"*^\") main spines form spine paths. Every spine's paths numbered Path field, right left, starting 0L. spine splits 0Ls Path field.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/readHumdrum.html","id":"result","dir":"Reference","previous_headings":"","what":"Result","title":"Find and read humdrum files into R — knownInterpretations","text":"findHumdrum returns \"fileFrame\" (data.table), listing file names, patterns match, directories found , raw text content files. readHumdrum returns fully parsed humdrumR object.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/readHumdrum.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find and read humdrum files into R — knownInterpretations","text":"","code":"readHumdrum() # loads all valid humdrum files in the current directory. #> Finding and reading files... #> \tREpath-pattern '.*' matches 123 text files in 1 directory. #> 123 files read from disk. #> Validating 123 files... #> 27,106 errors in 123 files... #> zero valid files. #> NULL  readHumdrum(\".*krn$\") # loads all files ending with \"krn\" in the currect directory #> Finding and reading files... #> \tREpath-pattern '.*krn$' matches 0 text files in 1 directory. #> Zero files read from disk. #> No files to validate. #> NULL  readHumdrum(\"^Composers$/^Be|^Mo/.*/^Joined$/.*krn$\")  #> Finding and reading files... #> \tREpath-pattern '^Composers$/^Be|^Mo/.*/^Joined$/.*krn$' matches 0 text files in 0 directories. #> Zero files read from disk. #> No files to validate. #> NULL # Goes inside the directory \"Composers\". # Inside \"Composers\" looks for directories that start with \"Be\" or \"Mo\". # If there are any \"Be|Mo\" matching directories within \"Composers\", matches all directories within them. # Within these directories, looks for directories called \"Joined\". # If there are any directories called \"Joined\", loads all files (if any) that end with \"krn\".  readHumdrum(\"^Composers$\", \"^Be|^Mo\", \".*\", \"^Joined$\", \".*krn$\") #> Finding and reading files... #> \tREpath-pattern '^Composers$/^Be|^Mo/.*/^Joined$/.*krn$' matches 0 text files in 0 directories. #> Zero files read from disk. #> No files to validate. #> NULL # exactly the same as the previous!  readHumdrum(\"^Composers$\", c(Beethoven = \"^Be\", Mozart = \"^Mo\"), \".*\", \"^Joined$\", \".*krn$\")  #> Finding and reading files... #> \tREpath-pattern Beethoven = '^Composers$/^Be/.*/^Joined$/.*krn$' matches 0 text files in 0 directories.\tREpath-pattern Mozart = '^Composers$/^Mo/.*/^Joined$/.*krn$' matches 0 text files in 0 directories. #> Zero files read from disk. #> No files to validate. #> NULL # exactly the same as the previous, except now the two matching patterns (\"^Be\", or \"^Mo\") will be grouped # in the Label field as \"Beethoven\" and \"Mozart\" respectively."},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/reference.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize reference records in a humdrumR corpus — reference","title":"Summarize reference records in a humdrumR corpus — reference","text":"reference used tabulate reference records present humdrumR corpus. reference one humdrumR's basic corpus summary functions.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/reference.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize reference records in a humdrumR corpus — reference","text":"","code":"reference(x, ...)  reference('OTL')  reference(humdata)  # S3 method for humReference [(refTable, i, j, drop = FALSE)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/reference.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize reference records in a humdrumR corpus — reference","text":"x character string (look reference code) humdrumR object. drop drop = TRUE, normal data.table returned instead humReference table. numeric, selects rows index. character, string matched regular expression filenames corpus. j numeric selects columns index. character, partially matched column names (reference codes).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/reference.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summarize reference records in a humdrumR corpus — reference","text":"reference can used look information common reference codes: supply reference code character string reference check known reference codes print information matching codes (one). instance, reference('OTL') returns description standard humdrum !!!OTL reference record (original title metadata). applied humdrumR corpus reference returns special data.frame called humReference table. humReference table one column reference code appears corpus. Since reference records can long print one screen, humdrum files can multiple type reference code, humReference table normally prints number type reference record appear file. However, one type reference code present humReference table, complete reference records code printed file. Likewise, one file present table, file's complete reference records printed. Thus, want see actual reference records, try indexing humReference table one column row (see ). humReference table one row file corpus. Rows labeled file name. addition, humReference object printed, three different summary totals printed reference code: indicates many files corpus contain least one example code. Sum indicates total number reference code appear corpus, including multiple appearances one file (like multiple \"!!!COM\" records). Unique tabulates number unique token corpus, code. corpus two unique composers (encoded \"!!!COM\"), Unique total 2. assumes tokens exactly identical, including white space; \"!!!COM: J.S. Bach\" \"!!!COM: JS Bach\" counted two unique reference records.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/reference.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize reference records in a humdrumR corpus — reference","text":"","code":"reference('COM') #>  #> (Authorship Information) #>  #> \t!!!COM  =  Composer's name #>  #> \tExamples: #> \t\t\tx!!COM: Chopin, Fryderyk; Chopin, Frederick #> \t\t\tx!!COM1: Composer, A.  #> \t\t\tx!!COM2: Composer, B. #>   reference(humData)[ , 'COM'] #> Error in reference(humData): object 'humData' not found  reference(humData)[3, ] #> Error in reference(humData): object 'humData' not found"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/regexConstruction.html","id":null,"dir":"Reference","previous_headings":"","what":"Making Regular Expressions — regexConstruction","title":"Making Regular Expressions — regexConstruction","text":"humdrumR includes helpful functions creating new regular expressions work stringr package.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/regexConstruction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Making Regular Expressions — regexConstruction","text":"","code":"captureRE(strs, n = \"\")  captureUniq(strs, zero = TRUE)  orRE(...)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/regexConstruction.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Making Regular Expressions — regexConstruction","text":"captureRE take character vector collapse \"capture group.\" n argument can used append number tag, instance '*' (zero ) group. .e., captureRE(c(\"\", \"b\", \"c\"), '*') output \"[abc]*\". captureUniq make similar capture group captureRE, expression makes sure 1 character repeats. instance, captureUniq(c('', 'b','c')) return \"([abc])\\\\1*\"---expression match \"aaa\" \"bb\" \"aabb\".","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rhythmDecompose.html","id":null,"dir":"Reference","previous_headings":"","what":"Decompose durations in terms of other durations — rhythmDecompose","title":"Decompose durations in terms of other durations — rhythmDecompose","text":"Decompose durations terms durations","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rhythmDecompose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Decompose durations in terms of other durations — rhythmDecompose","text":"","code":"rhythmDecompose(rhythmInterval, into = rint(c(1, 2, 4, 8, 16, 32)))"},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rhythmFunctions.html","id":null,"dir":"Reference","previous_headings":"","what":"Manipulate pitch data — rhythmFunctions","title":"Manipulate pitch data — rhythmFunctions","text":"Manipulate pitch data","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rhythmFunctions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Manipulate pitch data — rhythmFunctions","text":"","code":"recip(   x,   ...,   Exclusive = NULL,   parseArgs = list(),   timeArgs = list(),   graceDurations = FALSE,   inPlace = FALSE,   memoize = TRUE,   deparse = TRUE )  duration(   x,   ...,   Exclusive = NULL,   parseArgs = list(),   timeArgs = list(),   graceDurations = FALSE,   inPlace = FALSE,   memoize = TRUE,   deparse = TRUE )"},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rhythmInterval.html","id":null,"dir":"Reference","previous_headings":"","what":"parse rhythmic information — rhythmInterval","title":"parse rhythmic information — rhythmInterval","text":"parse rhythmic information","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rhythmInterval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"parse rhythmic information — rhythmInterval","text":"","code":"rhythmInterval(x, ...)  # S3 method for default rhythmInterval(x, ...)  # S3 method for numeric rhythmInterval(x, ...)  # S3 method for integer rhythmInterval(x, ...)  # S3 method for `NULL` rhythmInterval(x, ...)  # S3 method for character rhythmInterval(x, ..., Exclusive = NULL, multiDispatch = FALSE)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/romanKey.html","id":null,"dir":"Reference","previous_headings":"","what":"Roman numeral key areas — romanKey","title":"Roman numeral key areas — romanKey","text":"Roman numeral key areas","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/romanKey.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Roman numeral key areas — romanKey","text":"","code":"romanKey(x, ..., Key = NULL, parseArgs = list())"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/romanNumerals.html","id":null,"dir":"Reference","previous_headings":"","what":"Roman Numeral — romanNumerals","title":"Roman Numeral — romanNumerals","text":"Roman numerals can calculated diatonicSets (keys) tertian sets (chords). later case standard meaning \"roman numeral.\" However, former case used well, instance represent modulation schemes analyses classical music. instance, modulate -V, vi/V. importantly, many \"roman numerals\" harmonic analyses implicitely combine tertian diatonic roman numerals: \"applied\" roman numerals. Given roman numeral like \"V65/V\", \"V65\" represents chord \"/V\" represents key.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/segments.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify contiguous segments of data in a vector — segments","title":"Identify contiguous segments of data in a vector — segments","text":"segments changes extremely useful functions finding contiguous \"segments\" indicated vector.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/segments.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify contiguous segments of data in a vector — segments","text":"","code":"segments(..., first = TRUE, any = TRUE, reverse = FALSE)  changes(..., first = TRUE, value = FALSE, any = TRUE, reverse = FALSE)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/segments.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify contiguous segments of data in a vector — segments","text":"... list atomic vectors. vectors differ length, recycled match length longest vector. first (logical, length == 1) first index (last index reverse == TRUE) marked \"change.\" (logical, length == 1) TRUE, change input vector marked change. FALSE, changes must occur input vectors marked change. reverse (logical, length == 1) TRUE function excecuted backwards input vector(s). value (logical, length == 1) TRUE, input values changes occur returned matrix, row matching change column containing value associated input vector.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/segments.html","id":"changes","dir":"Reference","previous_headings":"","what":"Changes","title":"Identify contiguous segments of data in a vector — segments","text":"changes takes input vector finds indices value x[] != x[-1]---.e., value one index \"changed\" since last index. default, changes returns logical vector length input, TRUE indices change occured. first argument indicates whether first index (== 1) marked TRUE. changes can accept one input vector. argument set TRUE (default), change input marked change (TRUE) output. == FALSE, changes must happen vectors marked output. Finally, reverse argument reverses behavior changes, checkig instead x[] != x[+ 1].","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/segments.html","id":"values","dir":"Reference","previous_headings":"","what":"Values","title":"Identify contiguous segments of data in a vector — segments","text":"default, values input vector(s) change occurs placed matrix put values attribute logical output. However, value argument set TRUE, values returned.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/segments.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Identify contiguous segments of data in a vector — segments","text":"segments builds changes function. segments function takes logical input cummulatively tallies TRUE value vector, left right (right left, reverse == TRUE). Thus, input c(TRUE, FALSE, TRUE, FALSE, FALSE, TRUE, TRUE, FALSE) return c(1, 1, 2, 2, 2, 3, 4, 4). creates contiguous blocks values can used groupby argument call within.humdrumR(), similar functions like base::tapply(). input vector(s) segments logical, first fed changes create logical input.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/segments.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify contiguous segments of data in a vector — segments","text":"","code":"segments(letters %~% '[aeiou]') #>  [1] 1 1 1 1 2 2 2 2 3 3 3 3 3 3 4 4 4 4 4 4 5 5 5 5 5 5  changes(c(1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4),          c(1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3),         any = TRUE) #>  [1]  TRUE FALSE FALSE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE FALSE FALSE #> attr(,\"values\") #>    [,1] [,2] #> 1     1    1 #> 4     2    1 #> 5     2    2 #> 7     3    2 #> 9     3    3 #> 10    4    3 # result is T,F,F,T,T,F,T,F,T,T,F,F"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/semits.html","id":null,"dir":"Reference","previous_headings":"","what":"Atonal pitch representations — semits","title":"Atonal pitch representations — semits","text":"function translates pitch information basic atonal pitch values: midi semits map pitches standard 12-tone-equal-temperament semitone (integer) values. semits 0 (zero) middle-C (unison). contrast, MIDI pitch values output midi place middle-C/unison 60. cents returns cents, one hundredth semitone.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/semits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Atonal pitch representations — semits","text":"","code":"semits(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   Key = NULL,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )  midi(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   Key = NULL,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )  cents(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   Key = NULL,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE,   tonalHarmonic = 2^(19/12) )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/semits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Atonal pitch representations — semits","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). generic (logical, length == 1) generic = TRUE \"specific\" pitch information (accidentals qualites) discarded. simple (logical, length == 1) simple = TRUE \"compound\" pitch information (octave/contour) discarded. Key (diatonicSet something coercable diatonicSet, length == 1 | length == length(x)) input Key used parser, deparser, transposer. transposeArgs (list) transposeArgs can list arguments passed special call transpose. parseArgs (list) parseArgs can list arguments passed pitch parser. inPlace (logical, length == 1) argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ). tonalHarmonic (numeric, length == 1) frequency \"tonal harmonic\" (perfect 10th) tuned ? default, value 2^(19/12), 12-tone equal-temperament10th. Pythagorean tuning, set tonalHarmonic = 3.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/semits.html","id":"cents","dir":"Reference","previous_headings":"","what":"Cents","title":"Atonal pitch representations — semits","text":"default, output cents simply semits(x) * 100. However, tonalHarmonic value can modified cents produce cent-values alternate tunings. example, cents('g', tonalHarmonic = 3) returns 701.955000865387, \"pure\" third harmonic (3) 1.955 sharper equal-temperment. Thus, whereas midi semits return integers, cents always returns real-number (double) values. TonalIntervals parsed frequencies might also arbitrary cent deviations. example, cents(440 * 10/9, Exclusive = 'freq') returns 1082.404---correspond \"minor tone\" =440.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/semits.html","id":"basic-pitch-arguments","dir":"Reference","previous_headings":"","what":"Basic pitch arguments","title":"Atonal pitch representations — semits","text":"pitch function standard arguments control details output. important generic simple arguments, allow control type pitch information returned.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/semits.html","id":"generic-vs-specific","dir":"Reference","previous_headings":"","what":"Generic vs Specific","title":"Atonal pitch representations — semits","text":"generic = TRUE, specific pitch information (accidentals qualities) omitted output. alternative way controlling functionality, can use specific argument, specific == !generic. case atonal functions, \"generic\" version pitch output: example, semits('c#', generic = TRUE) return 0, \"generic\" version C# C, corresponds 0. However, note generic version pitch follows key, semits('c#', generic = TRUE, Key = ':') return 1!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/semits.html","id":"simple-vs-compound","dir":"Reference","previous_headings":"","what":"Simple vs Compound","title":"Atonal pitch representations — semits","text":"simple = TRUE, compound pitch information (octave contour) omitted output. alternative way controlling functionality, can use compound argument ,compound == !simple. actually one way might want divide compound intervals simple octave parts. example, might like call output -M2 (descending major 2nd) +m7 (ascending minor 7th octave ). functionality can controlled octave.round argument: see pitch deparsing documentation.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/semits.html","id":"key","dir":"Reference","previous_headings":"","what":"Key","title":"Atonal pitch representations — semits","text":"Key argument must diatonicSet, something can parsed one. Key argument passed parser, deparser, transpose---unless alternate Key passed transposeArgs parseArgs. Various deparsing options use Key argument; example, use implicitSpecies (see advanced parsing section) dependent Key. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function---means, cases, need explicitly anything Key argument! (want happen, need explicitly specify Key argument, Key = NULL.)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/semits.html","id":"parse-arguments","dir":"Reference","previous_headings":"","what":"Parse arguments","title":"Atonal pitch representations — semits","text":"parseArgs argument must list() (named) arguments passed input parser. example, input representation uses \"X\" represent double sharps, specify kern('CX5', parseArgs = list(doublesharp = 'X')) get correct result (\"cc##\"). convenient shorthand, \"syntactic sugar,\" can specify parseArgs alternate way: Simply input parse(args...) unnamed argument pitch function. example, can get exact result typing kern('CX5', parse(doublesharp = 'X')).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/semits.html","id":"transpose-arguments","dir":"Reference","previous_headings":"","what":"Transpose arguments","title":"Atonal pitch representations — semits","text":"transposeArgs argument must list() (named) arguments passed internal call transpose(), allowing us easily transpose pitch information. example, type kern(c('C', 'D', 'E'), transposeArgs = list(= 'M9')) can get output c('d', 'e', 'f#'). possible transpose args : (tonalInterval, length == 1 | length == (x)) (diatonicSet, length == 1 | length == (x))  (diatonicSet, length == 1 | length == (x)) real (logical, length == 1) transposition real tonal? relative (logical, length == 1) key-wise transposition based relative parallel keys? convenient shorthand, \"syntactic sugar,\" can specify transposeArgs alternate way: Simply input transpose(args...) unnamed argument pitch function. example, can get exact result typing kern(c('C', 'D', 'E'), transpose(= 'M9')).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/semits.html","id":"transposing-by-interval","dir":"Reference","previous_headings":"","what":"Transposing by interval","title":"Atonal pitch representations — semits","text":"calling transpose() directly, argument can anything coercable tonalInterval, output transposed amount. real = FALSE, tonal transposition (within Key) performed. details transposition behavior, check transpose() docs.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/semits.html","id":"transposing-by-key","dir":"Reference","previous_headings":"","what":"Transposing by key","title":"Atonal pitch representations — semits","text":"Another way transposing specifying input (\"\") key output (\"\") key. default, Key argument passed transpose , nothing actually happens. Thus, specify either key key, transposition happen /key Key. course, specify transposition happen keys specify. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function. specify key, Key field passed transpose key, result, pitches input transposed whatever keys target () key! real relative arguments give special control key-wise transposition works, check transpose() docs details!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/semits.html","id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Atonal pitch representations — semits","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/sigma.html","id":null,"dir":"Reference","previous_headings":"","what":"Cumulative sum of numeric vector — sigma","title":"Cumulative sum of numeric vector — sigma","text":"Calculate sequential cummulative sum values numeric vectors.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/sigma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cumulative sum of numeric vector — sigma","text":"","code":"sigma(x, lag, skip = is.na, init, groupby = list(), ...)  # S3 method for default sigma(   x,   lag = 1,   skip = is.na,   init = 0,   groupby = list(),   orderby = list(),   ... )  # S3 method for matrix sigma(x, margin = 2L, ...)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/sigma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cumulative sum of numeric vector — sigma","text":"x (numeric vector.) NULL values returned NULL. lag (Non-zero integer.) lag use. (See Greater lags section, .) skip (function.) must function can applied x returns logical vector length. TRUE values skipped calculations. default, skip function .na, NA values input (x argument) skipped. skipped values returned output vector. init (Atomic value class x, length(init) <= lag.) NA values beginning (end right == TRUE) filled values summing. groupby (vector length x, list vectors) Differences calculated across groups indicated groupby vector(s). orderby (vector length x, list vectors) Differences x calculated based order orderby vector(s), determined base::order(). right (single logical value) init padding \"right\" (end vector)? default, right == FALSE init padding beginning output.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/sigma.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cumulative sum of numeric vector — sigma","text":"sigma similar base-R cumsum(). However, sigma favored humdrumR use : groupby argument, automatically used humdrumR () commands constrain differences within files/spines/paths humdrum data. Using groupby argument function (details ) generally faster using groupby argument withinHumdrum(). (can) automatically skip NA () values. sigma also init argument can used ensure full invertability delta(). See \"Invertability\" section . applied matrix, sigma applied separately column, unless margin set 1 (rows) , higher-dimensional array, higher value.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/sigma.html","id":"invertability","dir":"Reference","previous_headings":"","what":"Invertability","title":"Cumulative sum of numeric vector — sigma","text":"sigma delta functions inverses , meaning right arguments set, sigma(delta(x)) == x delta(sigma(x)) == x. words, two functions \"reverse\" . key init argument needs set 0, arguments (lag, skip, groupby, etc.) need match. actually,  sigma(delta(x, init = 0, ...)) == x delta(sigma(x), init = 0)) == x. take differences values (delta(x)), resulting differences tell us fully reconstruct original unless know \"start\" (constant offset). example, delta(c(5, 7, 5, 6)) == c(NA, 2, -2, 1) know input goes 2, back 2, 1, starting value (first 5) lost. call sigma , get: sigma(c(NA, 2, -2, 1)) == c(0, 2,0, 1) get right contour, offset constant 5. call delta(x, init = 0) necessary constant (first value) kept beginning vector delta(c(5, 7, 5, 6), init = 0) == c(5, 2, -2, 1) sigma gets want, full invertability: sigma(delta(c(5, 7, 5, 6), init = 0)) == c(5, 7, 5, 6) Alternatively, specify necessary constant init argument sigma: sigma(delta(c(5, 7, 5, 6)), init = 5) == c(5, 7, 5, 6) init arguments two functions complementary. Currently, right argument delta complement sigma, invertability holds true right = FALSE (default).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/sigma.html","id":"greater-lags","dir":"Reference","previous_headings":"","what":"Greater lags","title":"Cumulative sum of numeric vector — sigma","text":"behavior sigma abs(lag) > 1 easiest understand inverse behavior delta(abs(lag) > 1), intuitive. (sigma inverse delta(), see Invertability section ). Generally, abs(lag) > 1, x grouped indices modulo lag, cumulative sum calculated separately set modulo indices. example, consider lag == 2 following input: cumulative sum 1 0 modulo-index groups : Index 1: cumsum(c(1,2,5)) == c(1, 3, 8). Index 0: cumsum(c(3,2)) == c(3, 5) Interleaved back order, result c(1,3,3,5,8). may clear, sure enough delta(c(1, 3, 3, 5, 8), lag = 2, init = 0) returns original c(1,3,2,2,5) vector! , understanding delta(..., lag = n) easier sigma(..., lag = n) (see Invtertability section .)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/sigma.html","id":"negative-lag","dir":"Reference","previous_headings":"","what":"Negative lag","title":"Cumulative sum of numeric vector — sigma","text":"lag negative, output equivalent positive lag, except sign reversed (output * -1). behavior easiest understand inverse behavior delta(lag < 0), intuitive. (sigma inverse delta(), see Invertability section ).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/sigma.html","id":"grouping","dir":"Reference","previous_headings":"","what":"Grouping","title":"Cumulative sum of numeric vector — sigma","text":"many cases want perform lagged calculations vector, across certain boundaries. example, vector includes data multiple pieces, want calculate melodic intervals pieces, within pieces. groupby argument indicates one, , grouping vectors, break x (input) argument groups. groupby vectors given, change vector indicates boundary. Value pairs cross groups treated beginning. Basically, using groupby argument function similar identical using tapply(x, groupby, laggedFunction, ...) using groupby expession call ().humdrumR. However, using groupby argument directly usually much faster, specially optimized functions. common use case humdrum data, looking \"melodies\" within spines. , want groupby = list(File, Spine, Path). fact, humdrumR () calls automatically feed three fields groupby arguments certain functions: mint, delta, sigma, lag, ditto. use delta call (), automatically calculate delta \"melodic\" way, within spine path file. However, wanted, instance, calculate differences across spines (like harmonic intervals) manually set groupby = list(File, Record).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/sigma.html","id":"order","dir":"Reference","previous_headings":"","what":"Order","title":"Cumulative sum of numeric vector — sigma","text":"performing lagged calculations, typically assume order values input vector (x) order want \"lag\" across. E.g., first element \"\" second element, \"\" third element, etc. [Humdrum tables][humTable] always ordered File > Piece > Spine > Path > Record > Stop. Thus, lagged calculations across fields humtable , default, \"melodic\": next element next element spine path. example, consider data: default order tokens (Token field) b c d e f. wanted instead lag across tokens harmonically (across records) need specifiy different order example, say orderby = list(File, Record, Spine)---lagged function interpret Token field d b e c f. another example, note Stop comes last order. consider happens stops data:","code":"**kern  **kern a       d b       e c       f *-      *- **kern  **kern a       d b D     e g c A     f a *-      *- ```  The default ordering here (`File > Spine > Record > Stop`) \"sees\" this in the order `a b D c A d e g f a`. That may or may not be what you want! If we wanted, we could reorder such that `Stop` takes precedence over `Record`: `orderby = list(File, Spine, Stop, Record)`. The resulting order would be `a b c d e f D G g a`.       [humTable]: R:humTable"},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/signature.html","id":null,"dir":"Reference","previous_headings":"","what":"Humdrum key signature — signature","title":"Humdrum key signature — signature","text":"Humdrum key signature","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/signature.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Humdrum key signature — signature","text":"","code":"signature(x, ..., Key = NULL, parseArgs = list())"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/silbeFormat.html","id":null,"dir":"Reference","previous_headings":"","what":"silbeFormat — silbeFormat","title":"silbeFormat — silbeFormat","text":"Check formatting lyrics correct, -'s right places (.e., denote start end syllable)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/silbeFormat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"silbeFormat — silbeFormat","text":"","code":"silbeFormat(cVector)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/silbeFormat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"silbeFormat — silbeFormat","text":"cVector data checked improper formatting (now, please read spine dataframe 1 column)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/silbeFormat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"silbeFormat — silbeFormat","text":"\"Formatted properly.\" lyrics formatted properly, else print error message corrections.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/silbeFormat.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"silbeFormat — silbeFormat","text":"function might detect multiple inconsistencies/errors given value particular index, help user determine exact issue(s) transcription.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfa.html","id":null,"dir":"Reference","previous_headings":"","what":"Relative-do Solfege representation — solfa","title":"Relative-do Solfege representation — solfa","text":"Relative-Solfege representation","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relative-do Solfege representation — solfa","text":"","code":"solfa(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   Key = NULL,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfa.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relative-do Solfege representation — solfa","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). generic (logical, length == 1) generic = TRUE \"specific\" pitch information (accidentals qualites) discarded. simple (logical, length == 1) simple = TRUE \"compound\" pitch information (octave/contour) discarded. Key (diatonicSet something coercable diatonicSet, length == 1 | length == length(x)) input Key used parser, deparser, transposer. transposeArgs (list) transposeArgs can list arguments passed special call transpose. parseArgs (list) parseArgs can list arguments passed pitch parser. inPlace (logical, length == 1) argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfa.html","id":"basic-pitch-arguments","dir":"Reference","previous_headings":"","what":"Basic pitch arguments","title":"Relative-do Solfege representation — solfa","text":"pitch function standard arguments control details output. important generic simple arguments, allow control type pitch information returned.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfa.html","id":"generic-vs-specific","dir":"Reference","previous_headings":"","what":"Generic vs Specific","title":"Relative-do Solfege representation — solfa","text":"generic = TRUE, specific pitch information (accidentals qualities) omitted output. alternative way controlling functionality, can use specific argument, specific == !generic. case atonal functions, \"generic\" version pitch output: example, semits('c#', generic = TRUE) return 0, \"generic\" version C# C, corresponds 0. However, note generic version pitch follows key, semits('c#', generic = TRUE, Key = ':') return 1!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfa.html","id":"simple-vs-compound","dir":"Reference","previous_headings":"","what":"Simple vs Compound","title":"Relative-do Solfege representation — solfa","text":"simple = TRUE, compound pitch information (octave contour) omitted output. alternative way controlling functionality, can use compound argument ,compound == !simple. actually one way might want divide compound intervals simple octave parts. example, might like call output -M2 (descending major 2nd) +m7 (ascending minor 7th octave ). functionality can controlled octave.round argument: see pitch deparsing documentation.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfa.html","id":"key","dir":"Reference","previous_headings":"","what":"Key","title":"Relative-do Solfege representation — solfa","text":"Key argument must diatonicSet, something can parsed one. Key argument passed parser, deparser, transpose---unless alternate Key passed transposeArgs parseArgs. Various deparsing options use Key argument; example, use implicitSpecies (see advanced parsing section) dependent Key. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function---means, cases, need explicitly anything Key argument! (want happen, need explicitly specify Key argument, Key = NULL.)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfa.html","id":"parse-arguments","dir":"Reference","previous_headings":"","what":"Parse arguments","title":"Relative-do Solfege representation — solfa","text":"parseArgs argument must list() (named) arguments passed input parser. example, input representation uses \"X\" represent double sharps, specify kern('CX5', parseArgs = list(doublesharp = 'X')) get correct result (\"cc##\"). convenient shorthand, \"syntactic sugar,\" can specify parseArgs alternate way: Simply input parse(args...) unnamed argument pitch function. example, can get exact result typing kern('CX5', parse(doublesharp = 'X')).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfa.html","id":"transpose-arguments","dir":"Reference","previous_headings":"","what":"Transpose arguments","title":"Relative-do Solfege representation — solfa","text":"transposeArgs argument must list() (named) arguments passed internal call transpose(), allowing us easily transpose pitch information. example, type kern(c('C', 'D', 'E'), transposeArgs = list(= 'M9')) can get output c('d', 'e', 'f#'). possible transpose args : (tonalInterval, length == 1 | length == (x)) (diatonicSet, length == 1 | length == (x))  (diatonicSet, length == 1 | length == (x)) real (logical, length == 1) transposition real tonal? relative (logical, length == 1) key-wise transposition based relative parallel keys? convenient shorthand, \"syntactic sugar,\" can specify transposeArgs alternate way: Simply input transpose(args...) unnamed argument pitch function. example, can get exact result typing kern(c('C', 'D', 'E'), transpose(= 'M9')).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfa.html","id":"transposing-by-interval","dir":"Reference","previous_headings":"","what":"Transposing by interval","title":"Relative-do Solfege representation — solfa","text":"calling transpose() directly, argument can anything coercable tonalInterval, output transposed amount. real = FALSE, tonal transposition (within Key) performed. details transposition behavior, check transpose() docs.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfa.html","id":"transposing-by-key","dir":"Reference","previous_headings":"","what":"Transposing by key","title":"Relative-do Solfege representation — solfa","text":"Another way transposing specifying input (\"\") key output (\"\") key. default, Key argument passed transpose , nothing actually happens. Thus, specify either key key, transposition happen /key Key. course, specify transposition happen keys specify. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function. specify key, Key field passed transpose key, result, pitches input transposed whatever keys target () key! real relative arguments give special control key-wise transposition works, check transpose() docs details!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfa.html","id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Relative-do Solfege representation — solfa","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfg.html","id":null,"dir":"Reference","previous_headings":"","what":"Fixed-do Solfege representation — solfg","title":"Fixed-do Solfege representation — solfg","text":"Based common French system notating pitches, encoded humdrum **solfg interpretation.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fixed-do Solfege representation — solfg","text":"","code":"solfg(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   Key = NULL,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fixed-do Solfege representation — solfg","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). generic (logical, length == 1) generic = TRUE \"specific\" pitch information (accidentals qualites) discarded. simple (logical, length == 1) simple = TRUE \"compound\" pitch information (octave/contour) discarded. Key (diatonicSet something coercable diatonicSet, length == 1 | length == length(x)) input Key used parser, deparser, transposer. transposeArgs (list) transposeArgs can list arguments passed special call transpose. parseArgs (list) parseArgs can list arguments passed pitch parser. inPlace (logical, length == 1) argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfg.html","id":"basic-pitch-arguments","dir":"Reference","previous_headings":"","what":"Basic pitch arguments","title":"Fixed-do Solfege representation — solfg","text":"pitch function standard arguments control details output. important generic simple arguments, allow control type pitch information returned.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfg.html","id":"generic-vs-specific","dir":"Reference","previous_headings":"","what":"Generic vs Specific","title":"Fixed-do Solfege representation — solfg","text":"generic = TRUE, specific pitch information (accidentals qualities) omitted output. alternative way controlling functionality, can use specific argument, specific == !generic. case atonal functions, \"generic\" version pitch output: example, semits('c#', generic = TRUE) return 0, \"generic\" version C# C, corresponds 0. However, note generic version pitch follows key, semits('c#', generic = TRUE, Key = ':') return 1!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfg.html","id":"simple-vs-compound","dir":"Reference","previous_headings":"","what":"Simple vs Compound","title":"Fixed-do Solfege representation — solfg","text":"simple = TRUE, compound pitch information (octave contour) omitted output. alternative way controlling functionality, can use compound argument ,compound == !simple. actually one way might want divide compound intervals simple octave parts. example, might like call output -M2 (descending major 2nd) +m7 (ascending minor 7th octave ). functionality can controlled octave.round argument: see pitch deparsing documentation.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfg.html","id":"key","dir":"Reference","previous_headings":"","what":"Key","title":"Fixed-do Solfege representation — solfg","text":"Key argument must diatonicSet, something can parsed one. Key argument passed parser, deparser, transpose---unless alternate Key passed transposeArgs parseArgs. Various deparsing options use Key argument; example, use implicitSpecies (see advanced parsing section) dependent Key. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function---means, cases, need explicitly anything Key argument! (want happen, need explicitly specify Key argument, Key = NULL.)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfg.html","id":"parse-arguments","dir":"Reference","previous_headings":"","what":"Parse arguments","title":"Fixed-do Solfege representation — solfg","text":"parseArgs argument must list() (named) arguments passed input parser. example, input representation uses \"X\" represent double sharps, specify kern('CX5', parseArgs = list(doublesharp = 'X')) get correct result (\"cc##\"). convenient shorthand, \"syntactic sugar,\" can specify parseArgs alternate way: Simply input parse(args...) unnamed argument pitch function. example, can get exact result typing kern('CX5', parse(doublesharp = 'X')).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfg.html","id":"transpose-arguments","dir":"Reference","previous_headings":"","what":"Transpose arguments","title":"Fixed-do Solfege representation — solfg","text":"transposeArgs argument must list() (named) arguments passed internal call transpose(), allowing us easily transpose pitch information. example, type kern(c('C', 'D', 'E'), transposeArgs = list(= 'M9')) can get output c('d', 'e', 'f#'). possible transpose args : (tonalInterval, length == 1 | length == (x)) (diatonicSet, length == 1 | length == (x))  (diatonicSet, length == 1 | length == (x)) real (logical, length == 1) transposition real tonal? relative (logical, length == 1) key-wise transposition based relative parallel keys? convenient shorthand, \"syntactic sugar,\" can specify transposeArgs alternate way: Simply input transpose(args...) unnamed argument pitch function. example, can get exact result typing kern(c('C', 'D', 'E'), transpose(= 'M9')).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfg.html","id":"transposing-by-interval","dir":"Reference","previous_headings":"","what":"Transposing by interval","title":"Fixed-do Solfege representation — solfg","text":"calling transpose() directly, argument can anything coercable tonalInterval, output transposed amount. real = FALSE, tonal transposition (within Key) performed. details transposition behavior, check transpose() docs.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfg.html","id":"transposing-by-key","dir":"Reference","previous_headings":"","what":"Transposing by key","title":"Fixed-do Solfege representation — solfg","text":"Another way transposing specifying input (\"\") key output (\"\") key. default, Key argument passed transpose , nothing actually happens. Thus, specify either key key, transposition happen /key Key. course, specify transposition happen keys specify. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function. specify key, Key field passed transpose key, result, pitches input transposed whatever keys target () key! real relative arguments give special control key-wise transposition works, check transpose() docs details!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfg.html","id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Fixed-do Solfege representation — solfg","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/spines.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize spines in humdrum dataset. — spines","title":"Summarize spines in humdrum dataset. — spines","text":"spines tabulates spines spine paths within files humdrumR corpus. spines one humdrumR's basic corpus summary functions.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/spines.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize spines in humdrum dataset. — spines","text":"","code":"spines(humdrumR, drop = FALSE)  # S3 method for humSpines [(spineTable, i, drop = FALSE)  # S3 method for humSpines print(spineTable, showEach = TRUE)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/spines.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize spines in humdrum dataset. — spines","text":"humdrumR humdrumR object drop drop = TRUE, normal data.table returned instead humSpine table. numeric, selects rows index. character, string matched regular expression filenames corpus.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/spines.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summarize spines in humdrum dataset. — spines","text":"spines returns special data.frame called humSpines table. humSpines table five columns information file: Spines number spines. Paths total number spine paths. number spines contain spine paths. *^ total number spine splits (\"*^\"). *v total number spine joins (\"*v\"). humSpine table prints command line, \"tallies\" unique combinations spines paths files also printed.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/step.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract scale step — step","title":"Extract scale step — step","text":"Extract scale step","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/step.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract scale step — step","text":"","code":"step(x, ..., simple = FALSE, Key = NULL, parseArgs = list(), inPlace = FALSE)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/step.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract scale step — step","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). simple (logical, length == 1) simple = TRUE \"compound\" pitch information (octave/contour) discarded. Key (diatonicSet something coercable diatonicSet, length == 1 | length == length(x)) input Key used parser, deparser, transposer. parseArgs (list) parseArgs can list arguments passed pitch parser. inPlace (logical, length == 1) argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/struct.html","id":null,"dir":"Reference","previous_headings":"","what":"struct — struct","title":"struct — struct","text":"Virtual class help create atomic-vector-like composite data objects.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/struct.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"struct — struct","text":"","code":"is.struct(x)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/struct.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"struct — struct","text":"humdrumR defines number S4 classes , underneath surface, composite data types made collections base-R atomic vectors, stuck together. \"vectorized\" nature R's atomic types one R's key strengths, humdrumR try ) mostly use standard atomic types B) make new types define act much like atomic vectors possible. struct virtual S4 class serves purpose: creating composite atomic vectors act (mostly) like base-R atomic vectors. \"virtual class\" structs really exist independent objects, struct class defines (abstractly) necessarry methods treat collection atomic vectors single vector/matrix-like object---simply make new subclass inherit struct taken care . (, specify contains = \"struct\" call setClass.) Important humdrumR classes inherit struct include: tonal intervals diatonicSet tertianSet rational() warned, R's S4 object-system limited regard: really define S4 classes act fully like R atomics, many features hard-coded R replicated. important limitation struct may encounter , though struct classes work (ok) data.frames, data.tables tibbles either work give strange behaviors put structs .","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/struct.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"struct — struct","text":"dim Either NULL non-negative integer-vector length == 2L, representing number rows columns respectively. Dimensions can zero. rownames Either NULL integer/character-vector length either ) dim == NULL, length struct B) dim != NULL, number rows struct. colnames Either NULL (must NULL dim == NULL) integer/character-vector length equal number columns struct.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/struct.html","id":"behavior","dir":"Reference","previous_headings":"","what":"Behavior","title":"struct — struct","text":"struct subclasses (.e., classes inherit struct) behave similarly normal R atomic vectors/matrices. However, differ respects, mostly ways intended avoid quirky behaviors R matrices: general, distinction dimensionless vectors dimensioned vectors (matrices) slightly weaker structs normal R atomic vectors/matrices. importantly, dimensioned structs drop dimensions various common operations (c, [], etc.), way base-R matrices . general, easier interact multi-column (matrix-)struct way dimensionless (vector-)struct. example, struct dimensions length(struct) == nrow(struct), instead length(matrix) == nrow(matrix) * ncol(matrix)---.e., \"height\" struct (number rows) length. Another big difference behaviors c: c always cause structs lose dimensions c can used concatinated multi-column structs, even mixes dimensionless dimensioned structs: struct arguments c dimensions, structs concatinated via call rbind, dimensionless vectors coerced 1-column matrices. course, (resulting) number columns must error occur! differences: structs can either dimensions (dim(struct) == NULL) two dimensions. Higher dimensional structs supported (yet). rowSums colSums coerce dimensionless struct column matrix. structs always throw error try index index value greater length/nrow struct. different atomic vectors, pad vector length index give---sometimes useful quirky behavior. structs two dimensions cartesian indexing argument. cartesian = TRUE, j arguments treated cartesian coordinates. (behavior can achieved base R matrices (structs) inputing matrix two columns.)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/struct.html","id":"requirements","dir":"Reference","previous_headings":"","what":"Requirements","title":"struct — struct","text":"work, struct makes assumptions class. class must one slots vectors, length. struct's indexing method cause vectors indexed one. define new subclass struct, inherit validObject method assures elements dimension. Thus, writing validObject method (using setValidity) just worry specifically validity information slots, slots length.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/struct.html","id":"initialize","dir":"Reference","previous_headings":"","what":"Initialize","title":"struct — struct","text":"initialize method automatically makes slots length predefined structs. want make specialized initialize method, can still take advantage inherited method using callNextMethod beginning method.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/struct.html","id":"predefined-methods","dir":"Reference","previous_headings":"","what":"Predefined methods","title":"struct — struct","text":"main purpose struct virtual class defines many basic methods need manipulate subclass objects. importantly, indexing methods fully defined (mimic base-R atomic vector/matrix indexing), well basic \"structural\" methods like (col/row)names, dim, length, ncol, nrow, etc. addition: define > >=, < <= automatically defined. define .character subclass, show format methods automatically defined. , default arithmetic methods addition, subtraction, (scalar-integer) multiplication, negation (-x) defined. default addition behavior numeric (base::integer base::numeric) slot subclasses added together. Thus, struct1 + struct2 extract numeric/integer slot struct, add together create new struct result. -struct negate numeric fields, subtraction simply defined adding negation. Since scalar multiplication defined, two structs multiplied, struct can multiplied integer (numeric fields multiplied integer(s)). definitions work subclass, need create , specific, method!","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/struct.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"struct — struct","text":"","code":"setClass('mynewsubclass', contains = 'struct', slots = c(X= 'numeric', Y = 'numeric'))  test <- new('mynewsubclass', X = 1:10, Y = 10:1)  # all of these should work: test[1:5] #> mynewsubclass[ , ] #> [1] 1,10 2,9  3,8  4,7  5,6  rev(test)  == test #>  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE cbind(test, test) #> mynewsubclass #>       [,1] [,2] #>  [1,] 1,10 1,10 #>  [2,] 2,9  2,9  #>  [3,] 3,8  3,8  #>  [4,] 4,7  4,7  #>  [5,] 5,6  5,6  #>  [6,] 6,5  6,5  #>  [7,] 7,4  7,4  #>  [8,] 8,3  8,3  #>  [9,] 9,2  9,2  #> [10,] 10,1 10,1 c(test, test) #> mynewsubclass[ , ] #>  [1] 1,10 2,9  3,8  4,7  5,6  6,5  7,4  8,3  9,2  10,1 1,10 2,9  3,8  4,7  5,6  #> [16] 6,5  7,4  8,3  9,2  10,1 test * 3 #> mynewsubclass[ , ] #>  [1] 3,30  6,27  9,24  12,21 15,18 18,15 21,12 24,9  27,6  30,3  test - test #> mynewsubclass[ , ] #>  [1] 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/subset.humdrumR.html","id":null,"dir":"Reference","previous_headings":"","what":"Filter humdrum data — subset.humdrumR","title":"Filter humdrum data — subset.humdrumR","text":"subset.humdrumR command used filter humdrumR corpus. standard indexing operators ([] [[]]) actually work calling subset --hood; can read indexing options . However, using subset directly can accomplish much sophisticated filtering commands indexing methods.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/subset.humdrumR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filter humdrum data — subset.humdrumR","text":"","code":"# S3 method for humdrumR subset(x, ...)  clearFilter(humdrumR)  removeEmptyFiles(humdrumR)  removeEmptySpines(humdrumR)  removeEmptyPaths(humdrumR)  removeEmptyRecords(humdrumR)  removeEmptyStops(humdrumR)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/subset.humdrumR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filter humdrum data — subset.humdrumR","text":"x humdrumR data object. ... Arbitrary expressions passed ()---\"within\" expression(s) must evaluate full-length logical values. humdrumR humdrumR data object.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/subset.humdrumR.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Filter humdrum data — subset.humdrumR","text":"subset.humdrumR used similar manner withinHumdrum, taking number \"within expressions\" arguments. fact, expression arguments passed directly internal call withinHumdrum, control expressions (like subset) can used well. requirement expressions/functions fed subset.humdrumR must predicate expressions return logical (TRUE/FALSE) vector. returned vector must also length input data (number rows humdrum table). (can use fill expression want \"expand\" shorter outputs filtering purposes.)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/subset.humdrumR.html","id":"filter-field","dir":"Reference","previous_headings":"","what":"Filter field","title":"Filter humdrum data — subset.humdrumR","text":"using subset, humdrumR necessarily delete data filter . Rather, logical field humdrum table called Filter. subset.humdrumR updates humdrum table's Filter field using logical (|) existing Filter field negation predicate: Filter | !Predicate. HumdrumR functions (mostly) ignore data points Filter == TRUE, treating like NULL data. example, print filtered humdrumR see filtered data points turned null data (.), calls withinHumdrum ignore filtered data. means can, recover filtered data calling clearFilter dataset. cases might filter large parts data, leave bunch empty null data points (\".\"). want remove filtered data points, can call removeEmptyFiles, removeEmptySpines, removeEmptyPaths, removeEmptyRecords, removeEmptyStops. functions go piece/spine/path/record check data region null filtered (.e., Null == TRUE | Filter == TRUE); , data removed. can remove data null (within region) otherwise humdrum syntax broken. default, subset.humdrumR automatically calls removeEmptyFiles end. However, can stop specifying  removeEmptyFiles = FALSE.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/subset.humdrumR.html","id":"renumbering","dir":"Reference","previous_headings":"","what":"Renumbering","title":"Filter humdrum data — subset.humdrumR","text":"filtered files removed corpus (using removeEmptyFiles removeEmptySpines, combination subset) File /Spine fields renumbered represented remaining regions, starting 1. example, corpus 10 files remove first file (File == 1), remaining files renumbered 2:10 1:9. Spine renumbering works , except done independently within file.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tertian.html","id":null,"dir":"Reference","previous_headings":"","what":"Tertian quality chord representation — tertian","title":"Tertian quality chord representation — tertian","text":"functions generic form tertian harmony representation, commonly used music theory. representation, root chord indicated **kern, followed one quality indicators, like \"CMM\" (C major seventh).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tertian.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tertian quality chord representation — tertian","text":"","code":"tertian(   x,   ...,   Key = NULL,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tertian.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tertian quality chord representation — tertian","text":"first quality root indicates quality triad. Subsequent qualities, present, indicate quality 7th, 9th, 11th, 13th respectively. examples: M: major triad Mm: dominant-seventh chord MM: major-seventh chord Mmm: dominant-seventh--flat-9 chord. oo: fully-diminished-seventh chord. Missing extensions can indicated position using .. example, E-Mm.P indicates E-flat dominant-11th chord 9th. Missing members triad can indicated specifying either 5 3 immediately root, quality indicators. example, C5M indicates C major chord 3rd, G3mm indicates G-minor-seventh chord missing 5th. default quality indicators P (perfect), M (major), m (minor), o (diminished), + (augmented), can overridden calls respective arguments: example, tertian('Cdim', diminish = 'd').","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tertian.html","id":"inversions","dir":"Reference","previous_headings":"","what":"Inversions","title":"Tertian quality chord representation — tertian","text":"Inversions indicated slash notation, scale degree right slash. example, first-inversion major chord /3.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tertianSet.html","id":null,"dir":"Reference","previous_headings":"","what":"Tertian set — tertianSet","title":"Tertian set — tertianSet","text":"tertianSet one humdrumR's types tonal data, representing Western tertian harmonies. tertianSet subclass diatonicSet (thence, struct).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tertianSet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tertian set — tertianSet","text":"","code":"tertianSet(...)  tset(   root = 0L,   signature = 0L,   alterations = 0L,   cardinality = 3L,   extension = NULL,   inversion = 0L )  is.tertianSet(x)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tertianSet.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tertian set — tertianSet","text":"structural addition, compared diatonicSet, Extensions slot. slot indicates tertian chord members active chord. seven possible chord members: root, third, fifth, seventh, ninth, eleventh, thirteenth. Every possible combination seven degrees represented single integer, corresponding 7-bit representation /offs seven degrees reverse order (13, 11, 9, 7, 5, 3, 1). example, integer 15 corresponds seventh chord: binary, 15 0001111. initial three zeros indicate 13th, 11th, 9th part harmony, four ones indicate root, third, fifth, seventh part harmony. Ultimately, adding removing chord degree harmony can achieved adding power two associated degree: Root: \\(\\pm 1\\) Third: \\(\\pm 2\\) Fifth: \\(\\pm 4\\) Seventh: \\(\\pm 8\\) Ninth: \\(\\pm 16\\) Eleventh: \\(\\pm 32\\) Thirteenth: \\(\\pm 64\\) tertianSet many specific methods defined reading/writing harmonic information.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tertianSetS4.html","id":null,"dir":"Reference","previous_headings":"","what":"Tertian set — tertianSetS4","title":"Tertian set — tertianSetS4","text":"tertianSet one humdrumR's types tonal data, representing Western tertian harmonies. tertianSet subclass diatonicSet (thence, struct).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tertianSetS4.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tertian set — tertianSetS4","text":"","code":"tset(   root = 0L,   signature = 0L,   alterations = 0L,   cardinality = 3L,   extension = NULL,   inversion = 0L )  is.tertianSet(x)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tertianSetS4.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tertian set — tertianSetS4","text":"structural addition, compared diatonicSet, Extensions slot. slot indicates tertian chord members active chord. seven possible chord members: root, third, fifth, seventh, ninth, eleventh, thirteenth. Every possible combination seven degrees represented single integer, corresponding 7-bit representation /offs seven degrees reverse order (13, 11, 9, 7, 5, 3, 1). example, integer 15 corresponds seventh chord: binary, 15 0001111. initial three zeros indicate 13th, 11th, 9th part harmony, four ones indicate root, third, fifth, seventh part harmony. Ultimately, adding removing chord degree harmony can achieved adding power two associated degree: Root: \\(\\pm 1\\) Third: \\(\\pm 2\\) Fifth: \\(\\pm 4\\) Seventh: \\(\\pm 8\\) Ninth: \\(\\pm 16\\) Eleventh: \\(\\pm 32\\) Thirteenth: \\(\\pm 64\\) tertianSet many specific methods defined reading/writing harmonic information.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/time.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic time transformations — time","title":"Basic time transformations — time","text":"Basic time transformations","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/time.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic time transformations — time","text":"","code":"bpm2ms(bpm)  ms2bpm(ms)  seconds(x, bpm)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/timeline.html","id":null,"dir":"Reference","previous_headings":"","what":"Onset/Offset interval since beginning. — timeline","title":"Onset/Offset interval since beginning. — timeline","text":"Refers duration rhythmic time elapsed since starting point (usually, beginning piece). music21 described \"offsets\"---however, prefer reserve words \"onset\" \"offset\" refer beginning (attacK) end (release) rhythmic events. SOI() takes vector numbers representing durations (numeric values) cummulatively sums starting value. Unlike sigma(), SOI() returns timestamp onset rhythmic duration offset. SOI() interprets first duration starting zero---different value specified start argument.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/timeline.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Onset/Offset interval since beginning. — timeline","text":"","code":"timeline(durations, start = 0, groupby = list())  timestamp(durations, BPM = \"MM60\", minutes = FALSE, ...)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/timeline.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Onset/Offset interval since beginning. — timeline","text":"durations vector numeric values representing durations. start duration value (coerced class durations), offset begins.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/timeline.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Onset/Offset interval since beginning. — timeline","text":"S3 object class \"rhythmOffset\", essentially data.frame two columns---Onset Offset--- numeric values class input durations argument.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonalIntervalS4.html","id":null,"dir":"Reference","previous_headings":"","what":"Representation of tonal pitch information — tonalIntervalS4","title":"Representation of tonal pitch information — tonalIntervalS4","text":"tonalInterval core tonal pitch representation humdrumR. tonalInterval abstract representation tonal pitch, can translated /standard \"concrete\" pitch representations: solfege, scientific pitch, semitones, frequencies, scale degrees, intervals, etc. part, users need interact tonalIntervals directly---rather, tonalIntervals work behind scene numerous humdrumR pitch functions. See pitch functions pitch parsing documentation details tonalIntervals used humdrumR.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonalIntervalS4.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Representation of tonal pitch information — tonalIntervalS4","text":"","code":"tint(   octave,   LO5th = 0L,   cent = numeric(length(octave)),   partition = FALSE,   Key = NULL,   octave.round = floor )  is.tonalInterval(x)  order.tonalInterval(   x,   ...,   na.last = TRUE,   decreasing = FALSE,   method = c(\"auto\", \"shell\", \"radix\") )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonalIntervalS4.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Representation of tonal pitch information — tonalIntervalS4","text":"Octave integers representing octave offset. Fifth integers representing \"line--fifths\" value. Cent numeric values representing cents (1200th octave). tonalInterval S4 subclass humdrumR's virtual class struct, inherits lot useful \"vector-like\" behaviors/functionality.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonalIntervalS4.html","id":"creating-tonal-intervals","dir":"Reference","previous_headings":"","what":"Creating tonal intervals","title":"Representation of tonal pitch information — tonalIntervalS4","text":"Generally, tonalIntervals created using tonalInterval() function, various methods. tonalInterval function primarily parser, documented elsewhere, interprets various input representations generates tonalInterval S4 objects (documented ). Alternatively, constructor function tint can used directly create tonalInterval objects. three arguments tint correspond three slots: octave, LO5th (Fifth), cent. inputs coerced match length. octave argument can left blank, case appropriate octave automatically computed place interval octave . default, .character method, thus (via struct) show method, tonalIntervals call interval(). Thus, return tonalInterval command line see **interval representation printed.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonalIntervalS4.html","id":"predefined-intervals-","dir":"Reference","previous_headings":"","what":"Predefined Intervals:","title":"Representation of tonal pitch information — tonalIntervalS4","text":"humdrumR automatically exports bunch tonalIntervals, named musical interval representation. Every generic interval 1 15 combined every interval quality dd (doubly diminished), d (diminished), m (minor), M (major), (augumented) AA (doubly augmented). Thus, loading humdrumR, can type things like M3 + M3 get A5. addition, variables unison (= P1 = tint(0, 0)) pythagorean.comma (= d2 = tint(-19,12)) exported well.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonalIntervalS4.html","id":"arithmetic-","dir":"Reference","previous_headings":"","what":"Arithmetic:","title":"Representation of tonal pitch information — tonalIntervalS4","text":"Technically, tonalIntervals examples algebraic modules integers. means certain arithmetic operations defined tonalIntervals can called using standard arithmetic operators (+, -, etc.): Addition: tonalIntervals can added together, acting exactly expect (.e., \\(M3 + m3 = P5\\)). Subtraction: tonalIntervals can subtracted just added. Also, can negated single - operator (like -M3). Multiplication: tonalIntervals can multiplied together. However, scalar (integer) multiplication defined: thus, tonalIntervals can multiplied integers create new tonalIntervals: e.g., \\(M2 * 3 = A4\\). Division: natural inverse scale multiplication, Euclidean division defined tonalIntervals---.e., division /whole (integer) pieces, often leftover \"remainders\" (modulo). R, Euclidean division achieved %/% operator---/---, associated %% used remainder/modulo. Two tonalIntervals can divided produced integer; Conversely, tonalInterval can divided integer produce tonalInterval. Take note way humdrumR defines Euclidean division based tonal space---.e., line--fifths---frequency atonal-semitone space. example, augmented-fourth divided major-second 3L, diminished-fifth divided major-second 3L---d5 %/% M2 equals -3L remainder P8 (plus octave)! division algorithm works applying standard Euclidean division @Fifth slot (line--fifths tonal space), shifting @Octave value remainder match appropriate octave. attempt addition tonalInterval non-tonalInterval atomic vector (e.g., integer, character), humdrumR attempt coerce input tonalInterval, using tonalInterval() parser, math output answer original format (non-tonalInterval) format. instance, M3 + 2 interpret 2 two semitones add major-second major-third, resulting 6 semitones. \"-place\" parsing/deparsing used, \"extra\" characters input passed . example, M3 + 4.ee- return 4.gg.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonalIntervalS4.html","id":"relational-operators","dir":"Reference","previous_headings":"","what":"Relational Operators","title":"Representation of tonal pitch information — tonalIntervalS4","text":"tonalIntervals can compared using standard relational operations---==, !=, >, >=, etc. Two tonalIntervals equal (according ==) slots (Octave, Fifth, Cent) exactly identical. Thus, enharmonic notes (like C# Db) equal. contrast, ordinal comparisons (e.g., >, <=) tonalIntervals based semitone (equal temperament) size, enharmonicity irrelevant. Thus, m3 >= A2 A2 >= m3 TRUE, even though m3 == A2 .","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonalIntervalS4.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Representation of tonal pitch information — tonalIntervalS4","text":"","code":"M3 <- tint(   , 4L)  M2 <- tint(   , 2L) M9 <- tint(-1L, 2L)  M9 - M2  #> tonalInterval[ , ] #> [1] +P15 # = octave M9 - 2L #> [1] 24 # = 12  M3 %/% M2  #> [1] 2 # = 2  \"cc#]\" + M6 #> [1] \"aa#]\" # = \"aa#]\"  ###  cMajor <- sort(tint( , -1:5)) eMajor <- cMajor + M3 eMajor + 2L  #> [1]  6  8 10 11 13 15 17 # 6 8 10 11 13 15 17  eMajor[4:5] - P8 #> tonalInterval[ , ] #> [1] -m3 -m2 # = -m3 -m2"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonalTransformations.html","id":null,"dir":"Reference","previous_headings":"","what":"Invert or transpose tonal intervals. — tonalTransformations","title":"Invert or transpose tonal intervals. — tonalTransformations","text":"Invert transpose tonal intervals.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonalTransformations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Invert or transpose tonal intervals. — tonalTransformations","text":"","code":"invert(tint, around, Key, ...)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonh.html","id":null,"dir":"Reference","previous_headings":"","what":"German-style pitch notation. — tonh","title":"German-style pitch notation. — tonh","text":"Based common German system notating pitches, encoded humdrum **Tonh interpretation.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonh.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"German-style pitch notation. — tonh","text":"","code":"tonh(   x,   ...,   generic = FALSE,   simple = FALSE,   octave.relative = FALSE,   Key = NULL,   transposeArgs = list(),   parseArgs = list(),   inPlace = FALSE )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonh.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"German-style pitch notation. — tonh","text":"x (atomic vector) x argument can (atomic) vector, tonalInterval, NULL. ... arguments passed pitch deparser. also two hidden (advanced) argumens can specify: memoize deparse (see details ). generic (logical, length == 1) generic = TRUE \"specific\" pitch information (accidentals qualites) discarded. simple (logical, length == 1) simple = TRUE \"compound\" pitch information (octave/contour) discarded. Key (diatonicSet something coercable diatonicSet, length == 1 | length == length(x)) input Key used parser, deparser, transposer. transposeArgs (list) transposeArgs can list arguments passed special call transpose. parseArgs (list) parseArgs can list arguments passed pitch parser. inPlace (logical, length == 1) argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ). S S = TRUE, E-flat (Ees) written just \"S\", -flat (Aes) written \"\".","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonh.html","id":"basic-pitch-arguments","dir":"Reference","previous_headings":"","what":"Basic pitch arguments","title":"German-style pitch notation. — tonh","text":"pitch function standard arguments control details output. important generic simple arguments, allow control type pitch information returned.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonh.html","id":"generic-vs-specific","dir":"Reference","previous_headings":"","what":"Generic vs Specific","title":"German-style pitch notation. — tonh","text":"generic = TRUE, specific pitch information (accidentals qualities) omitted output. alternative way controlling functionality, can use specific argument, specific == !generic. case atonal functions, \"generic\" version pitch output: example, semits('c#', generic = TRUE) return 0, \"generic\" version C# C, corresponds 0. However, note generic version pitch follows key, semits('c#', generic = TRUE, Key = ':') return 1!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonh.html","id":"simple-vs-compound","dir":"Reference","previous_headings":"","what":"Simple vs Compound","title":"German-style pitch notation. — tonh","text":"simple = TRUE, compound pitch information (octave contour) omitted output. alternative way controlling functionality, can use compound argument ,compound == !simple. actually one way might want divide compound intervals simple octave parts. example, might like call output -M2 (descending major 2nd) +m7 (ascending minor 7th octave ). functionality can controlled octave.round argument: see pitch deparsing documentation.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonh.html","id":"key","dir":"Reference","previous_headings":"","what":"Key","title":"German-style pitch notation. — tonh","text":"Key argument must diatonicSet, something can parsed one. Key argument passed parser, deparser, transpose---unless alternate Key passed transposeArgs parseArgs. Various deparsing options use Key argument; example, use implicitSpecies (see advanced parsing section) dependent Key. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function---means, cases, need explicitly anything Key argument! (want happen, need explicitly specify Key argument, Key = NULL.)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonh.html","id":"parse-arguments","dir":"Reference","previous_headings":"","what":"Parse arguments","title":"German-style pitch notation. — tonh","text":"parseArgs argument must list() (named) arguments passed input parser. example, input representation uses \"X\" represent double sharps, specify kern('CX5', parseArgs = list(doublesharp = 'X')) get correct result (\"cc##\"). convenient shorthand, \"syntactic sugar,\" can specify parseArgs alternate way: Simply input parse(args...) unnamed argument pitch function. example, can get exact result typing kern('CX5', parse(doublesharp = 'X')).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonh.html","id":"transpose-arguments","dir":"Reference","previous_headings":"","what":"Transpose arguments","title":"German-style pitch notation. — tonh","text":"transposeArgs argument must list() (named) arguments passed internal call transpose(), allowing us easily transpose pitch information. example, type kern(c('C', 'D', 'E'), transposeArgs = list(= 'M9')) can get output c('d', 'e', 'f#'). possible transpose args : (tonalInterval, length == 1 | length == (x)) (diatonicSet, length == 1 | length == (x))  (diatonicSet, length == 1 | length == (x)) real (logical, length == 1) transposition real tonal? relative (logical, length == 1) key-wise transposition based relative parallel keys? convenient shorthand, \"syntactic sugar,\" can specify transposeArgs alternate way: Simply input transpose(args...) unnamed argument pitch function. example, can get exact result typing kern(c('C', 'D', 'E'), transpose(= 'M9')).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonh.html","id":"transposing-by-interval","dir":"Reference","previous_headings":"","what":"Transposing by interval","title":"German-style pitch notation. — tonh","text":"calling transpose() directly, argument can anything coercable tonalInterval, output transposed amount. real = FALSE, tonal transposition (within Key) performed. details transposition behavior, check transpose() docs.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonh.html","id":"transposing-by-key","dir":"Reference","previous_headings":"","what":"Transposing by key","title":"German-style pitch notation. — tonh","text":"Another way transposing specifying input (\"\") key output (\"\") key. default, Key argument passed transpose , nothing actually happens. Thus, specify either key key, transposition happen /key Key. course, specify transposition happen keys specify. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function. specify key, Key field passed transpose key, result, pitches input transposed whatever keys target () key! real relative arguments give special control key-wise transposition works, check transpose() docs details!","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonh.html","id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"German-style pitch notation. — tonh","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/transpose.html","id":null,"dir":"Reference","previous_headings":"","what":"Transpose pitches and keys — transpose","title":"Transpose pitches and keys — transpose","text":"function transposes pitches keys various intervals target keys. Inside box, inputs transpositions take place tonalIntervals diatonicSets, numeric character string representation pitches can transposed well. function incorporated directly tonalTransform, thence, pitch translation functions, probably call directly often.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/transpose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transpose pitches and keys — transpose","text":"","code":"transpose(x, by, Key, to, real, relative, ...)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/transpose.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transpose pitches and keys — transpose","text":"x input pitch(es) transpose. tonalInterval something intepretable tonalInterval. tonalInterval something intepretable tonalInterval. input x transposed interval. Key diatonicSet something intepretable diatonicSet. tonal /transpositions, \"\" key. value NULL, defaults C major. diatonicSet something intepretable diatonicSet. input x transposed key. real logical. TRUE (default), transposition real. FALSE, transposition tonal. relative logical. TRUE transposition relative. FALSE (default), transposition parallel.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/transpose.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Transpose pitches and keys — transpose","text":"two distinct types transposition (real tonal). also two different approaches specifying transpositions: \"\" \"\". \"\" transpositions can also either parallel relative.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/transpose.html","id":"types-of-transposition","dir":"Reference","previous_headings":"","what":"Types of Transposition","title":"Transpose pitches and keys — transpose","text":"two different types transposition: real transposition tonal transposition. real transposition, inputs transposed specific interval. example, pitches {C D E F G} transposed major second {C D E F# G}. tonal transposition, inputs transposed generic intervals, within key. example, sequence {C D E F G}, key C major, translated generic second {D E F G }. choose real tonal transposition, use real argument: real = TRUE real transposition, real = FALSE tonal transposition.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/transpose.html","id":"alterations","dir":"Reference","previous_headings":"","what":"Alterations","title":"Transpose pitches and keys — transpose","text":"Tonal transposition complicated presence alterations input pitches. instance, given pitches {C F# G D# E}`` key C major, tonally transposed second, within C major? one obvious, correct answer answer, can easily identified. algorithm implemented humdrumR` follows: Alterations/accidentals input identified. (case, F# D#). generic pitches transposed within key, resulting {D G E F}. Alterations input added output unless resulting pitches interpreted comma call tintPartion, given enharmonic wrap value (default 12). example, adding first accidental results {G#} comma. However, second accidental results {E#} comma away natural {F}. Thus, accidental added output, resulting {E}, {E#}. resulting output {D G# E F}. size enharmonicWrap effectively determines extreme accidentals allowed. default value, 12, assures output notes enharmonically equivalent notes key. illustrate, sequence {C F# G D# E, B- - G C# D, B D- C} transposed tonally within C major seven possible generic intervals, enharmonicWrap = 12:","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/transpose.html","id":"specifying-transpositions","dir":"Reference","previous_headings":"","what":"Specifying Transpositions","title":"Transpose pitches and keys — transpose","text":"two approaches specifying transpositions, arguments. argument must interval, input translated interval. interval specific real = FALSE, input treated generic interval, tranposition takes place within key indicated Key argument. argument translates input desired key. example, input key E major want transposed G major, say = '*E:'. real = TRUE, input simply translated root key, exact intervals. real = FALSE, input translated root new key, intervals changed match new key well. either case, result depends input's key , indicated standard Key argument. Key arguments like \"\" key. Key = NULL, input key interpreted C major. Consider input notes {D B C # B, D C# D E D} key G major. specify = e:, real = TRUE, output {B G# F## G#, B # B C# B}. (Notice even though key minor, output still clearly E major). specify = e:, real = FALSE, output instead {B G F# G, B # B C B}. Building previous example, consider input key matters well. use input notes ({D B C # B, D C# D E D}) input Key C major, : specify = e:, real = TRUE, output {F# D# E C## D#, F# E# F# G# F#}. specify = e:, real = FALSE, output instead {F# D E C# D, F# E F# G F#}. specified, transposition applied first, followed transposition. real = FALSE, transposition happens within key, Key key.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/transpose.html","id":"relative-vs-parallel","dir":"Reference","previous_headings":"","what":"Relative vs Parallel","title":"Transpose pitches and keys — transpose","text":"transposing , diferent approaches determining relationship \"\" key (Key argument) \"\" key (argument). think \"parallel\" relationships keys, match roots keys regardless modes. instance, C major C minor parallel keys. instead think \"relative\" relationships keys, match modes keys, roots. instance, C major minor relative keys. similar distinction \"la-based minor\" solfege (relative) vs \"fixed-\" solfege (parallel). transposing using argument, relative = FALSE input key (Key argument) transposed match root argument. example, input key G minor `` key C major, output transposed G minor. However, relative = TRUEthe input key transposed match mode thetokey: G minor input C majortowould translated minor, parallel minor thetokey. theKey(key) andto` (key) arguments mode, parallel relative transpositions .","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/transpose.html","id":"special-operators-","dir":"Reference","previous_headings":"","what":"Special Operators +-","title":"Transpose pitches and keys — transpose","text":"note, real transposition interval can achieved concisely using + - operators, long least one side operators actual tonalInterval object. humdrumR preassigns common tonalIntervals objects global environment. Thus, can type commands like \"c#\" + M2 get d#, c(\"C4\", \"E4\", \"C5\") - m6 get \"E3\" \"G#3\" \"E4\".","code":""},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/unfoldStops.html","id":null,"dir":"Reference","previous_headings":"","what":"","title":"","text":"record/spine/path locations different numbers stops different fields, function spreads data smaller fields multiple stops.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/unfoldStops.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"","text":"","code":"unfoldStops(humdrumR, fromFields = fields(humdrumR, \"D\")$Name)"},{"path":[]},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/validateHumdrum.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate humdrum files — validateHumdrum","title":"Validate humdrum files — validateHumdrum","text":"function checks files local machine violations humdrum syntax. Detailed error reports can generated, pointing specific problematic records files.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/validateHumdrum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate humdrum files — validateHumdrum","text":"","code":"validateHumdrum(..., errorReport.path = NULL)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/validateHumdrum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate humdrum files — validateHumdrum","text":"... character: Arguments passed findHumdrum() identify files local machine test humdrum validity. mainly used pass regex file-path search patterns, may also used pass recursive /contains arguments findHumdrum(). errorReport.path (character, length == 1) directory path write error report files. NULL (default), error report files written.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/validateHumdrum.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Validate humdrum files — validateHumdrum","text":"violations general humdrum syntax identified. example, missing exclusive interpretations, *- spine enders, null data tokens. validateHumdrum function check ill-formed data content---example, **kern spine containing token \"Lsharp\" rejected. Note validateHumdrum quite picky details! \"Hanging white space,\" even global records, marked invalid files! validateHumdrum called manner readHumdrum(), providing one regex search patterns match files machine. (..., recursive, contains arguments simply passed findHumdrum().) called, validateHumdrum prints basic messages informing result file matching validity testing. function also returns (invisibly) findHumdrum() \"file info\" data.table, additional Valid Errors columns: Valid column logical, TRUE valid humdrum files. Error column list data.tables, describing syntax errors files . Error data.tables one row error file (), three columns: Filepath: file name. Record: record contains error. Message: description error.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/validateHumdrum.html","id":"error-reports","dir":"Reference","previous_headings":"","what":"Error reports","title":"Validate humdrum files — validateHumdrum","text":"desired, contents validateHumdrum can written files. useful, can print errors tagged right alongside original raw data. write error report, set errorReport.path argument non-NULL string, pointing directory path machine. directory exist, R (attempt ) create . errorReport.path directory, complete error report(s) files (returned \"fileFrame\", see ) written single file named 'humdrumR_syntaxErrorReport_DATE.txt' (date coming Sys.Date).  addition, sub directory called AnnotatedFilesis created. directory, copies files contain errors written, with_errorAnnotations` appended names. file, individual errors directly indicated record occur. output looks like :","code":"| The original records from the input file                                              | appear on the right side. Error message for record three printed here. | Exactly as they did                                              | in the input file."},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html","id":null,"dir":"Reference","previous_headings":"","what":"with(in)Humdrum — withinHumdrum","title":"with(in)Humdrum — withinHumdrum","text":"Evaluate arbitrary expressions using fields within humdrumR data, employing split/apply/combine, windowing, analysis options.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"with(in)Humdrum — withinHumdrum","text":"","code":"# S3 method for humdrumR with(data, ..., dataTypes = \"D\", drop = TRUE, variables = list())  # S3 method for humdrumR within(data, ..., dataTypes = \"D\", variables = list())"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"with(in)Humdrum — withinHumdrum","text":"data [humdrumR][humdrumRclass] data object. ... number expressions evaluate. Unnamed expressions interpreted \"main\" within-expressions. Possible evaluation control arguments include , subset, windows. evaluation options can achieved recycle side arguments. dataTypes string vector characters drawn c(\"D\", \"d\", \"\", \"L\", \"M\",\"G\"). characters  correspond types humdrum records: Data, null data, Interpretations, Measures, Local comments, Global comments respectively. expression evaluated data drawn specified record types (defaults \"D\"). drop argument conceptually similar drop argument R matrices. drop = TRUE, output .humdrumR simplified much possible (trying return \"raw\" vector, list, table, etc. within ). drop = FALSE, result always data.table. default value (drop = TRUE) usually want intuitive, complex code, can helpful set drop = FALSE output consistent. variables named list values, interpolated within-expression(s) wherever variable name matches named list.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"with(in)Humdrum — withinHumdrum","text":"within.humdrumR  new humdrumR data object. .humdrumR, whatever value returned expression , drop = TRUE, data.table.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html","id":"overview","dir":"Reference","previous_headings":"","what":"Overview","title":"with(in)Humdrum — withinHumdrum","text":"functions primary means working humdrumR data. analogous base-R within methods data.frames. Specifically allow evaluate arbitrary expressions using fields humdrumR data object. means can drop \"inside\" humdrumR data object run whatever commands want using fields humdrum data table, keeping data safely \"encapsulated\" within humdrum object---least, want pull . difference .humdrumR within.humdrumR analogous difference base::() base::within(). .humdrumR evaluates expression(s) simply returns result evaluation. within.humdrumR evaluates expression(s) inserts results back humdrumR object, generating new fields called ResultX (see details). addition, within offer number powerful options make working humdrum data easier: evaluation control arguments can used control expressions evaluated. can evaluate expressions... subset data using subset... either ignoring rest data evaluating different expression part. Separately different subsets data, recombined (split-apply-combine) using . Across windows data (e.g., ngrams, rolling windows). produces plot, particular plotting parameters, /without returning anything using sidefx. \"Fill\" short results match original field size using fill. certain record types (defaulting data records) using dataTypes. arguments specified named arguments /within calls. Even though formal arguments, partially matched, write grou instead groupby, get error! cases, can specify one type control argument (details ).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html","id":"expression-evaluation","dir":"Reference","previous_headings":"","what":"Expression evaluation","title":"with(in)Humdrum — withinHumdrum","text":"\"expression\" legal bit R code, like 2 + 2 x - mean(x). call /within.humdrumR must least one expression evaluate. refer \"within-expressions.\" expressions passed /within.humdrumR unnamed arguments: example, (humData, myExpressionHere). Within expressions evaluated within humdrumR object's humdrum table, means expression can refer fields humdrumR object name (Record, Token, File, etc.) just like variables. Since fields humdrum object vectors length, within expressions easily (generally ) vectorized. Note within-expression value evaluated data-points/records match type indicated dataTypes argument. default, non-null data tokens (\"D\") used. multiple within-expressions provided, expression evaluated order (left right). expression can refer results last expression (.), variables defined previous expressions. number special syntactic sugars can used within expressions. . placeholder. Side effects Recycled (\"filled\") results Lagged vectors etc. explained .","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html","id":"the-placeholder","dir":"Reference","previous_headings":"","what":"The . placeholder","title":"with(in)Humdrum — withinHumdrum","text":". variable can used special placeholder within expressions. first within expression, . interpreted humdrumR object's current active expression. multiple within expressions given, beyond first expression,  . refers result previous expression. example, Token active expression, : return result :","code":"with(humData, nchar(.), mean(.), .^2) with(humData, mean(nchar(Token))^2)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html","id":"side-effects-","dir":"Reference","previous_headings":"","what":"Side effects:","title":"with(in)Humdrum — withinHumdrum","text":"cases, want evaluate within-expression \"side effect\"; means expression something want (\"side effect\") actually evaluate (return) result want. common \"side effect\" creating plot. examples might printing text console using base::cat() base::print(), writing file. Side effects can achieved naming expression sidefx fx---usual, arguments can partially matched, side also works, commonly used. Side-effect expressions executed, result () ignored. means call something like newData <- within(humData, side = plot(x)), plot made result (newData) identical humData. Side-effects can also used combination within expressions. result ignored, fed next expression .. example command creates histogram nchar(Token) also returns mean nchar(Token). (Note variables explicitly assigned side call visible later calls, confusing, !)","code":"with(humData, nchar(Token), side = hist(.), mean(.))"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html","id":"recycling-filling-results-","dir":"Reference","previous_headings":"","what":"Recycling (\"filling\") results:","title":"with(in)Humdrum — withinHumdrum","text":"result within expression may shorter input vectors (humtable fields). However, calls within.humdrumR particular, like return single number recycle \"fill\" original data field. words, like output (result) expression repeated matches length input field(s). manually using base::rep() function, /within.humdrumR provide syntactic sugar : can name expression recycle fill (partially matched), cause result recycled. take yourExpression(field, ...) wrap rep(yourExpression(field, ...), length.= length(field)).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html","id":"lagged-vectors","dir":"Reference","previous_headings":"","what":"Lagged vectors","title":"with(in)Humdrum — withinHumdrum","text":"often want work \"lagged\" vectors data. example, want look relationship vector previous values vector---e.g., vector offset \"lagged\" one index. humdrumR lag() function useful , gives us several options lagging vectors, always keeping length vectorization never hindered. within.humdrumR give us convenient short cut using lag. within-expression, vector can indexed integer argument named lag (case insensitive), causing lagged integer. (vector indexed lag = 0 returns unchanged vector.) example, following two calls : lag index multiple values indexed object appears within higher function call, lag inserted separate argument call. Thus, two calls also : lag() function groupby argument, /within.humdrumR automatically feed fields list(File, Spine, Path). default \"melodic\" behavior music. like turn , need override adding groupby argument lagged index, like Token[lag = 1, groupby = list(...)]. Using lagged vectors, since vectorized, fastest (computationally) easiest way working n-grams. example, want create character-string 5-grams data, call: Note , since /within.humdrumR passes groupby = list(File, Spine, Path) lag(), true \"melodic\" n-grams, created within spine-paths within file.","code":"with(humData, Token[lag = 1]) with(humData, lag(Token, 1)) with(humData, table(Token[lag = 1:2])  with(humData, table(lag(Token, 1), lag(Token, 2)) with(humData, paste(Token[lag = 0:5], sep = '-'))"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html","id":"results","dir":"Reference","previous_headings":"","what":"Results","title":"with(in)Humdrum — withinHumdrum","text":"difference .humdrumR within.humdrumR results evaluated within-expression(s).","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html","id":"within","dir":"Reference","previous_headings":"","what":"Within","title":"with(in)Humdrum — withinHumdrum","text":"calls within.humdrumR, result final within-expression inserted back [humtable][humdrum table]. results atomic vectors, though lists can also placed fields. results shorter input fields humtable padded null values fill length input. Non-vector results (objects) tables put lists, treated like list. result, data/record-types indicated dataTypes argument also returned padded null values. explicitly name result within-expression, put new field labeled ResultX, X lowest number \"ResultX\" fields already taken. can explicitly name result field top-level assignment expression. example, within(data, Semits <- semits(Token)) put result semits(Token) new field called Semits. fact, assign results multiple within-expressions, result length last result put new field. Thus, can create multiple new fields single call: example, creates two new fields, Semits Recip. (explained , second within-expression also refer Semits variable created previous expression.)","code":"within(humData,         Semits <- semits(Token),        Recip <- recip(Token))"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html","id":"with","dir":"Reference","previous_headings":"","what":"With","title":"with(in)Humdrum — withinHumdrum","text":"calls .humdrumR, result simply returned . want want get humdrumR object drop back \"normal\" R, often last stages analysis. .humdrumR drop argument, defaults TRUE. drop = FALSE, result returned data.table(). column names results table generated described previous section: .e., defaulting ResultX allowing explicit naming one explicit assignments within-expressions. addition, subset groupby arguments used, columns included indicate value evaluated subset/groupby factor row.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html","id":"partitioning-data","dir":"Reference","previous_headings":"","what":"Partitioning data","title":"with(in)Humdrum — withinHumdrum","text":"groupby (e.g., ) subset expression control arguments evaluate within-expressions within specific subsets data. subset argument can used evaluate within-expression within subset data. groupby argument breaks data groups, evaluating within-expression(s) separately within group. results grouped evaluations returned list () recombined original data within---form \"split-apply-combine\" routine key R data analysis. subset groupby arguments arbitrary expressions evaluated within [humdrum table][humTable], can (usually ) refer fields table. /within.humdrumR call can include zero, one, subset /groupby arguments, including combinations . one subset/groupy argument included, evaluated order (left right), recursively: one evaluated within partition(s) established previous expression. normal within expression(s) , evaluated within partition(s) established last  subset/groupby argument. \"Advanced\" partitioning section explores detail.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html","id":"apply-in-subset-","dir":"Reference","previous_headings":"","what":"Apply in subset:","title":"with(in)Humdrum — withinHumdrum","text":"subset argument arbitrary expression identifies subset humdrum data. subset expressions must evaluate single logical vector, subset result, short, automatically recycled full length [humdrum table][humTable]. within expression(s) evaluated subset argument(s) return TRUE. call , result evaluated subset == TRUE returned. However, call within, must decide rest data: complement subset. default, within pads returned values null data ever subset == FALSE (complement). , example, run command within(humData, kern(Token), subset = Spine == 1) new field created within filled kern data Spine == 1, remaining spines () null. want explicitly control put complement part new field, can specifying alternate within-expression(s) evaluate subset == FALSE. must named complement, aliases rest otherwise ([partially matched][partialMatching]). complement expression can specified combination subset argument, must addition normal within-expression. idea evaluate \"normal\" within-expression subset == TRUE, else specify evaluate complement expression. results Complement expressions always recycled fill whole complement (see \"recycle\") common use case complement expression use within expression change data one spine return data unchanged spines. example, specify within(humData, kern(Token), subset = Spine == 1, complement = Token). Spine 1 () kern applied . However, instead return new field null values spine(s), call return original (unaltered) values Token field spines.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html","id":"group-by-","dir":"Reference","previous_headings":"","what":"Group by:","title":"with(in)Humdrum — withinHumdrum","text":"groupby expression (use short) partitions data exhaustively (possibly non-contiguous) groups, evaluates within-expression(s) separately within group. works similarly argument [data.table][data.table]s, INDEX argument [base][tapply], INDICES argument [base][]. groupby expression must evaluate, within humdrumR data object, vector (list vectors equal length) group data . unique combination values across vectors becomes one group. commonly, groupby expression(s) simply field(s) data: instance, apply function [base][table] Token field separately file humdrumR data. However, can also use complex expressions like evaluate expression two groups, one either spine number three less record number even, another group opposite true. groupby expression evaluates list grouping vectors, within expressions evaluated across every combination categories across vectors. Thus, apply table Token across spine file.","code":"with(humdata,      table(Token),      by = File) with(humdata,      table(Token),       by = Spine > 3 | Record \\%\\% 2 == 0) with(humdata,       table(Token),      by = list(File, Spine))"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html","id":"advanced-partitioning-","dir":"Reference","previous_headings":"","what":"Advanced partitioning:","title":"with(in)Humdrum — withinHumdrum","text":"multiple groupby subset expressions, combinations two, specified, evaluated recursively, order left right. subset specified groupby, subset expression evaluated within groupby group groupby specified subset, grouping expression evaluated subset == TRUE. Thus, specify","code":"within(humdata,          sd(Semits),          by = File,           subset = Semits > mean(Semits)) ```  the standard deviation of the `semits` field will be calculated in each file, but only where the `semits` field is greater than the mean `semits` value *within that file*. Contrast this with this call:  ``` within(humdata,          sd(Semits)          subset = Semits > mean(Semits),           by = File)  ```  wherein the standard deviation of `semits` is, again, calculated for each file, but this time wherever the `semits` field is greater than the mean value *across all the data*.   [humTable]: R:humTable [humTable]: R:humTable [complement]: R:complement [partialMatching]: R:partialMatching [data.table]: R:data.table [tapply]: R:tapply [by]: R:by [table]: R:table"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html","id":"windowing-data","dir":"Reference","previous_headings":"","what":"Windowing data","title":"with(in)Humdrum — withinHumdrum","text":"XXXX","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html","id":"plotting-parameters","dir":"Reference","previous_headings":"","what":"Plotting parameters","title":"with(in)Humdrum — withinHumdrum","text":"mentioned , plots within-expressions (often) called using sidefx argument name. plotting, /within.humdrumR also allows specify plotting options inline, without make separate call par(). par() argument can specified providing named list graphics keyword. example, can set plot margins mar argument: best part /within.humdrumR reset par previous state done. can also use syntactic sugar, graphics(parargs = ...):","code":"within(data,         side = plot(sort(table(Token))),         graphics = list(mar = c(4, 4, 4, 4))) within(data,        side = plot(sort(nchar(Token))),        graphics(mar = c(4, 4, 4, 4)))"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html","id":"splatting","dir":"Reference","previous_headings":"","what":"Splatting","title":"with(in)Humdrum — withinHumdrum","text":"(\"Splatting\" refers feeding function list/vector arguments.) Sometimes want divide data pieces (l\\'partition option), rather applying expression piece, want feed separate pieces separate arguments function. /within.humdrumR can use syntactic sugar just . can index field call splat argument, must Field %% x. example, call, Token field divided two groups, one Spine == 1 Spine == 2; first group (Spine == 1) used first argument list, second group (Spine == 2) second argument. Thus, within translates previous expression :","code":"within(humdata, list(Token[splat = Spine %in% 1:2])) within(humdata,        list(Token[Spine == 1], Token[Spine == 2]))"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html","id":"n-grams","dir":"Reference","previous_headings":"","what":"N grams","title":"with(in)Humdrum — withinHumdrum","text":"XXXX","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html","id":"advanced-scripting","dir":"Reference","previous_headings":"","what":"Advanced scripting","title":"with(in)Humdrum — withinHumdrum","text":".humdrumR within.humdrumR use non-standard evaluation expressions. useful command line script running one command time. However, want advanced scripting non-standard evaluation can problem. example, loop list within-expressions reuse common combination coor arguments many times. Fortunately, R formula, way capturing (\"quoting\") expressions concrete object can manipulate. Better yet, /within.humdrumR interpret formulae passed arguments. Basically, right-hand side formula interpreted expression evaluate. formula passed unnamed argument /within, left-hand side formula () treated argument name. name formula argument left-hand side, left-hand side ignored. approach allows us , ~table(Token) ~ Spine variables, allowing us things like: can even make lists loop :","code":"with(humdrumR, table(Token), by = Spine) with(humdrumR, ~table(Token), by ~ Spine) tabler <- ~table(.) byspine <- by ~ Spine  with(humData, tabler, byspine) bys <- list(~ Spine, ~ File, ~ COM)  for (b in bys) with(humData, table(.), by = b)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html","id":"variables","dir":"Reference","previous_headings":"","what":"Variables","title":"with(in)Humdrum — withinHumdrum","text":"Another useful scripting option include free variables within-expressions, can fed using variables argument. variables must named list. Variables within-expression match name variables list value interpolated. allows us, example, run commands like: time called, N .^N replaced current value n.","code":"nums <- c(2, 3, 4, 5) expression <- ~.^N  for (n in nums) with(humData, expression, variables = list(N = n))"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/wort.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract words from syllables — wort","title":"Extract words from syllables — wort","text":"Transform humdrumR's syllabic form lyrics complete words, row contain either one word null data token.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/wort.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract words from syllables — wort","text":"","code":"wort(silbe, nullTokens = TRUE, keepSilbe = FALSE, indices = FALSE)"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/wort.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract words from syllables — wort","text":"nullTokens Boolean expression determines whether null tokens replace empty spaces syllables moved combine others make word. Default TRUE keepSilbe Boolean expression determines whether user wants save silbe format output case needed back translation later uses. Default FALSE indices Boolean expression determines whether linguistics version word printed. Default FALSE. data data transformed (character vector)","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/wort.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract words from syllables — wort","text":"transformed data","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/writeHumdrum.html","id":null,"dir":"Reference","previous_headings":"","what":"Write humdrumR data to humdrum files — writeHumdrum","title":"Write humdrumR data to humdrum files — writeHumdrum","text":"writeHumdrum writes humdrumR data humdrum-syntax text files. current active expression evaluated generate humdrum output data. written output match printout printing data R terminal.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/writeHumdrum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write humdrumR data to humdrum files — writeHumdrum","text":"","code":"writeHumdrum(   humdrumR,   prefix = \"humdrumR_\",   renamer = force,   affix = \"\",   extension = NULL,   directory = NULL,   overwrite = FALSE,   verbose = FALSE,   EMD = paste0(\"Edited in humdrumR \", packageVersion(\"humdrumR\"), \" on \", Sys.Date()) )"},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/writeHumdrum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write humdrumR data to humdrum files — writeHumdrum","text":"humdrumR humdrumR data object. prefix (character, length == 1L) character string prepended file name. renamer function. Must accept character vector return new atomic vector length. affix (character, length == 1L) character string appended file name (extension). directory (character, length == 1L) directory write files . NULL, files written directory (directories) read . overwrite (logical, length == 1) FALSE, writeHumdrum refuse overwrite files. TRUE, writeHumdrum overwrite files, additional prompt user. verbose (logical, length == 1) TRUE, new output file name printed console writing happens. EMD (character, length == 1) string write new !!!EMD: record file. NULL, appended.","code":""},{"path":"https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/writeHumdrum.html","id":"file-names","dir":"Reference","previous_headings":"","what":"File names","title":"Write humdrumR data to humdrum files — writeHumdrum","text":"main option control writeHumdrum files write . writeHumdrum uses original names files, read readHumdrum, basis new file names. default, writeHumdrum refuse overwrite original files---overwriting allowed specify overwrite == TRUE respond \"y\" prompt. writeHumdrum generates new file names modifying original read file names. renamer argument must function takes original names input character vector (excluding directory path file extension) returns new character vector length (default R's identity function force). running renamer, character-string affix prefix arguments appended/prepended renamed names. (affix affixed extension.) Finally, extension argument can used specify different file extension. directory argument indicates file path write files. directory exist, created. directory NULL, files written original input directory (directories). EMD argument specifies character string put new !!!EMD reference record end file. EMD records keep track modifications humdrum data. default behavior print string indicating humdrumR version number date. EMD set NULL, appended files.","code":""}]
