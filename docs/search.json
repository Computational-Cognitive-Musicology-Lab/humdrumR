[{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Context.html"],"id":"groupby","dir":"Articles","previous_headings":"","what":"Groupby","title":"Contextualizing data","text":"conventionally “R-style” way look data context using R/humdrum\\(_{\\mathbb{R}}\\)’s various “group ” options. functionality described elsewhere, example Working Data article, within.humdrumR() man page. Group-functionality isn’t necessarily connected temporal context: can, instance, group together data instrument ensemble, across songs dataset—useful, non-temporal-context. want use groupby get temporal context, good options:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Context.html"],"id":"group-by-record","dir":"Articles","previous_headings":"Groupby","what":"Group by Record","title":"Contextualizing data","text":"humdrum\\(_{\\mathbb{R}}\\) data Record field, indicating data points occur time. Using within.humdrumR()’s groupby argument, can perform calculations grouped record. Let’s load trusty Bach-chorale data: Let’s count many new note onsets (rests) occur record data, tabulate results. ’ll look tokens don’t contain r (rest), using regular-expression match %~% 'r' negating bang (!). records new notes four voices—surprising choral music—one onset next common case. Note include File groupby argument (e.g., = list(File, Record)). ? piece/file data set repeats record numbers—wouldn’t want count 17th record 3rd chorale together 17th record 7th chorale, example.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Context.html"],"id":"group-by-bar","dir":"Articles","previous_headings":"Groupby","what":"Group by Bar","title":"Contextualizing data","text":"humdrum data includes bar lines, indicated =. humdrum\\(_{\\mathbb{R}}\\) reads data (?readHumdrumR) data, look barlines, count file, put count field called Bar (?fields). can use data group data bar. Remember, data set = tokens, Bar field nothing useless 0s. wanted know lowest note bar music . Let’s first extract semits() data, easy get lowest value: can now group within bars, get minimum, tabulate . highest lowest-note--bar . analysis, might want save lowest-note new field. Let’s use within.humdrumR’s fill = option duplicate low note throughout bar: , example, subtract bar’s lowest note note:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Context.html"],"id":"group-by-beat","dir":"Articles","previous_headings":"Groupby","what":"Group by Beat","title":"Contextualizing data","text":"Another useful contextual group beat. automatic “beat” field data, ’ll need make —obviously, need ti data rhythmic information encoded (like **kern **recip). can use count() function count beats data. count quarter-notes setting beat = '4'; alternatively, data includes time-signature interpretations (like *M3/4) use TimeSignature field get tactus meter. Let’s try later save result new field, ’ll call Beat (anything else want). can now group beat. Maybe want know range notes beat:  Note: data includes spine paths, ’ll want set within(mydata, count(Token), expandPaths = TRUE, ...). Count (similar functions, like timeline()) won’t work correctly without paths expanded (?expandPaths).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Context.html"],"id":"contextual-windows","dir":"Articles","previous_headings":"","what":"Contextual Windows","title":"Contextualizing data","text":"use groupby/, data exhaustively partitioned non-overlapping groups; groups also necessarily ordered—explicitely used (temporally) ordered groups like list(File, Record) want temporal context. contrast, context() function, used combination .humdrumR(), gives us much flexible control context want data. context() takes input vector treats ordered sequence information. identifies arbitrary contextual windows data, based criteria. windows created context() always sequentially ordered, aren’t necessarily exhaustive (data might fall window), can overlap (data falls multiple windows). way use context() telling “open” (begin) “close” (end) contextual windows, using open close arguments. Context can use many criteria open/close windows. following sections, layout just examples; ’ll use chorale data , well built-Beethoven variation data: examples, ’ll use within.humdrumR() run command paste(Token, collapse = '-'). simplest/fastest way see context() !","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Context.html"],"id":"regular-windows","dir":"Articles","previous_headings":"Contextual Windows","what":"Regular windows","title":"Contextualizing data","text":"cases, simply want progress data open/close windows regular locations. can using hop() function. (hop() humdrum\\(_{\\mathbb{R}}\\) function similar R’s base seq() function; however, hop() special features , importantly, gets special treatment context()). Maybe want open four-note window every note: Cool, ’ve got overlapping four-note windows, running throught spine! ?","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Context.html"],"id":"regular-open","dir":"Articles","previous_headings":"Contextual Windows > Regular windows","what":"Regular Open","title":"Contextualizing data","text":"first argument context() open argument; give open set indices (natural numbers) open windows data. hop() simply generates sequence numbers “along” input data—default, “hop size” 1, can change . example: use hop() inside context(), automatically knows input vector . now check : saying hop(2), windows open every index. don’t want four-note windows overlap , set hop(4): Note argument can vector hop-sizes, cause hop() generate sequence irregular hops! can also use hop()’s arguments control first/last windows occur, etc. using , can refer another special variable—end—context() interpret last index. , example, say hop(= 5, = end - 5).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Context.html"],"id":"fixed-close","dir":"Articles","previous_headings":"Contextual Windows > Regular windows","what":"Fixed Close","title":"Contextualizing data","text":"hop() telling context() open windows; telling close windows? second argument context() close argument. Like open, close argument set natural-number indices. However, cool thing close argument can refer open argument. rather manually figuring index go open (don’t try, multiple spines etc. make confusing), simply say open + 3. want five-note windows, can say open + 4. want window simply close next opening? can close argument refer nextopen variable. instead saying open + 3 say nextopen - 1L! Now ’ll get exhaustive windows matter open windows. example, can change hop size still get exhaustive windows! also close windows nextopen - 2 nextopen + 1—whatever want!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Context.html"],"id":"flip-it-around","dir":"Articles","previous_headings":"Contextual Windows > Regular windows","what":"Flip it around","title":"Contextualizing data","text":"don’t define open first, close refer open—can also opposite! ’ve got exact result telling window closes hop along regularly (every four indices) open argument refer closing indices (close - 3). open argument can also refer prevclose (previous close). Notice output windows still “placed” align opening—can set alignLeft = FALSE call within.humdrumR(), want output align close: Note regular windows creating examples N-grams. Humdrum\\(_{\\mathbb{R}}\\) also defines another approach defining N-grams generally faster using context()—alternative approach described last section article.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Context.html"],"id":"irregular-windows","dir":"Articles","previous_headings":"Contextual Windows","what":"Irregular Windows","title":"Contextualizing data","text":"regular windows created previous section useful, context() can lot . can tell context() open, close, windows based arbitrary criteria! example, let’s say want open window time leading tone occurs, stay open next tonic. , let’s get solfa() data Solfa field: Alright, easy thing give context()’s open/close arguments character strings, matched regular expressions active field: Pretty cool! wait, something seems odd; one outputs \"ti--fa-re---fa--la-re--fa-mi-re-di-re-ti-\". doesn’t window close hits first “”? context()s treatment overlapping windows, controlled overlap argument. default, overlap = 'paired', means context() attempts pair open next unused close—reason don’t close first “” \"ti--fa-re---fa--la-re--fa-mi-re-di-re-ti-\", “” already close previous window. analysis, might want try overlap = 'none': argument, new window open current window closed. Another option allow multiple windows close place (.e., “”). can achieved setting overlap = 'edge': lot wrap head around, one! many ways define/control contextual windows defined, ’s often difficult decide want particular analysis. can read context() documentation examples, simply play around! following sections layout examples, just illustrate possibilities.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Context.html"],"id":"more-criteria","dir":"Articles","previous_headings":"Contextual Windows > Irregular Windows","what":"More criteria","title":"Contextualizing data","text":"want windows close tonic (), long-durations? Let’s extract duration information new field: now something like : Notice , close expression complicated now, explictely say Solfa == '' instead using shortcut just providing single string.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Context.html"],"id":"open-until-nextprevious","dir":"Articles","previous_headings":"Contextual Windows > Irregular Windows","what":"Open until next/previous","title":"Contextualizing data","text":"can use learned nextopen nextclose variables make windows open/close matches. example, windows close every time fermata (\";\" token **kern) data, open immediately fermata: issue : first fermata data doesn’t get paired anything, “previous close” . happen whenever use nextopen prevclose! can fix explicitely adding opening window 1: using | () command context(), saying open window 1 prevclose + 1. working nextopen might want use special end argument (available inside context()), last index input vector.0","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Context.html"],"id":"semi-fixed-windows","dir":"Articles","previous_headings":"Contextual Windows > Irregular Windows","what":"Semi-fixed windows","title":"Contextualizing data","text":"cases, might want windows open (close) fixed interval, close based something irregular. can easily combining ’ve already learned. example, open window every third index, close see fermata. ’ll want use overlap = 'edge' .","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Context.html"],"id":"slurs","dir":"Articles","previous_headings":"Contextual Windows > Irregular Windows","what":"Slurs","title":"Contextualizing data","text":"common case contextual information musical scores slurs, used indicate articulation (e.g., bowing) phrasing information. **kern, slurs indicated parentheses, like ( ). see examples, let’s load built-Beethoven variation dataset remove multi-stops (make much complicated). can see parentheses used indicate slurs piano parts. Let’s say want get length slurred groups: slurts 2, 3, 4 notes. one 13! wonder ? File 9, records 46–59. Sure enough! Ok, want collapse (paste()) slurred notes together, like ’ve throughout article? worked…lost unslurred notes. can keep tokens adding complement argument within.humdrumR()—works complement subset inside within.humdrumR() (see Working humdrum data article). Basically, indices active field aren’t captured windows, complement. want keep original tokens , just pass complement = Token.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Context.html"],"id":"slurs-with-multi-stops","dir":"Articles","previous_headings":"Contextual Windows > Irregular Windows > Slurs","what":"Slurs with multi-stops","title":"Contextualizing data","text":"last section took easy way remove multi-stops (chords) played piano. Can analyze slurs without ? Let’s load data , keep multi-stop tokens: looks like slurs always written first stop, even though probably interpreted (pianist) encompassing whole chord. can simply throw subset argument within.humdrumR(), context() command: slurs collapsed () first stop, stops simply left .","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Context.html"],"id":"nested-windows","dir":"Articles","previous_headings":"Contextual Windows > Irregular Windows","what":"Nested windows","title":"Contextualizing data","text":"cases, might contextual windows “nested” inside . example, slurs sheet music might overlap represent fine gradiations articulation. context() funciton can handle nested windows setting overlap = 'nested'. example file can experiment : ’ve got nested slurs. Let’s try context(..., overlap = 'nested'): good! get windows, including nested ones. (Look result differs set overlap = 'paired'.) want topmost bottommost slurs? Use depth argument: depth one non-zero integers, indicating deeply nested want windows . depth = 1 “top” (unnested) layer, 2 next-nested, etc. can also use negative numbers start nested work backwards: -1 deeply nested layer, -2 second-deeply nested, etc. Finally, can specify one depths making depth vector, like depth = c(1,2).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Context.html"],"id":"n-grams","dir":"Articles","previous_headings":"","what":"N-grams","title":"Contextualizing data","text":"previous section, saw context() function can used (inside within.humdrumR()) create n-grams (much ). Humdrum\\(_{\\mathbb{R}}\\) also offers different, lag-based, approach n-gram analyses. main advante approach can much faster applying context()—large datasets, might find context() takes . lag-based approach fully vectorized context() makes extremely fast, also less general purpose. Depending n-grams, context() may way works—basically, want apply expression separately every n-gram, need use context(). idea lag-based n-grams can demonstrated quite simply using letters vector (built R) lag(n) command. lag(n) command “shifts” vector n indices: happened ? give cbind() function three separate arguments: 1) normal letters vector; 2) letters lagged 1; 3) letters lagged 3. three arguments bound together three-column matrix. can thing paste(): made three-grams! approach, used fully-vectorized functions extremely fast, even large datasets.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Context.html"],"id":"lag-within-humdrumr","dir":"Articles","previous_headings":"N-grams","what":"Lag within humdrumR","title":"Contextualizing data","text":"/within.humdrumR() functions allow create lagged vectors special, concise way. Let’s work chorales, using just simple kern() data: using /within.humdrumR(), instead writing lag(x, n = 1), can write x[lag = 1]. paste field (like Kern) lagged like : can use negative positive lags, depending want n-grams line : important point! /within.humdrumR() automatically group lagged data list(File, Spine, Path), n-grams won’t cross end one file/spine beginning next, etc. paste() isn’t vectoried function might want apply lagged data. Another common example table(): get transition matrix!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Context.html"],"id":"larger-n","dir":"Articles","previous_headings":"N-grams","what":"Larger N","title":"Contextualizing data","text":"functions accept unlimited arguments (...), like paste(), table(), can easily extend principle create longer n-grams: ’s even better way! Simply give lag argument vector lags! fact, lag = 0 spits unlagged vector, can single index command: Let’s create 10-grams, see frequent 10-grams : ’s want! lagged n-grams, first last n-grams get “padded” NA values. ’ll just need get rid : still doesn’t seem right, ? Actually, right: 10 chorales, 10-gram pitch patterns occur ! Let’s try 5-gram instead: Now see couple n-grams (like ‘d e d c b’) occur often.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Filtering.html"],"id":"indexing","dir":"Articles","previous_headings":"","what":"Indexing","title":"Filtering humdrum data","text":"simplest, common, way filter data indexing, common approach programming selecting subsets data. R, use square brackets, [], index various data objects, including basic atomic vectors, data.tables, lists. example, using brackets can extract subsets vector: Watch ! R actually two different ways indexing: can use single pair matches brackets ([ ]) double pair ([[ ]]). want primer two types indexing used normal R objects, check R primer—really don’t need getting humdrum\\(_{\\mathbb{R}}\\), might want eventually. can use single-bracket [] double-bracket [[]] commands index humdrum\\(_{\\mathbb{R}}\\) data objects. single-brackets used index whole pieces data. double-brackets used index “within” pieces data. Either type bracket can accept either numeric character vectors index .","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Filtering.html"],"id":"single-bracket-indexing","dir":"Articles","previous_headings":"Indexing","what":"Single-bracket indexing","title":"Filtering humdrum data","text":"single-brackets used index whole pieces data. dataset 19 files, want look files, ’d use single-brackets [].","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Filtering.html"],"id":"numeric-indices-for-single-brackets","dir":"Articles","previous_headings":"Indexing > Single-bracket indexing","what":"Numeric indices (for single-brackets)","title":"Filtering humdrum data","text":"give numeric value single-bracket index command, number select ith file dataset. example, want look fifth chorale, can call: can also give command vector numbers: might want use R sequence command, :, select range numbers:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Filtering.html"],"id":"character-indices-for-single-brackets","dir":"Articles","previous_headings":"Indexing > Single-bracket indexing","what":"Character indices (for single-brackets)","title":"Filtering humdrum data","text":"supply humdrum\\(_{\\mathbb{R}}\\) object single-bracket index character string, Humdrum\\(_{\\mathbb{R}}\\) treat string regular expression return files contain match expression data token—even one. example, might interested files use flat notes. Since **kern represents flats “-”, can simply write: Look , five ten chorales contain least one flat. chorales zero flats. Notice still get whole files returned us!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Filtering.html"],"id":"double-bracket-indexing","dir":"Articles","previous_headings":"Indexing","what":"Double-bracket indexing","title":"Filtering humdrum data","text":"double-brackets used index within pieces data. Specifically, want work certain spines records within pieces. double-brackets apply filters separately file dataset. double-bracket indexing, can provide two separate arguments, either individually together: first argument index records within file. j second argument, index spines within file. want use j (spine) argument , put comma , indicate skipping . also good practice clear put comma , actually needed. Basically, commands look like : chorales[[, ]] (records) chorales[[  , j]] (spines) chorales[[, j]] (records spines)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Filtering.html"],"id":"numeric-indices-for-double-brackets","dir":"Articles","previous_headings":"Indexing > Double-bracket indexing","what":"Numeric indices (for double-brackets)","title":"Filtering humdrum data","text":"Numeric values j can given double-bracket humdrum\\(_{\\mathbb{R}}\\) index commands. , number simply matched record numbers file. example, extract first fifty records file : j, number matched spines file (left right). wanted second spine file, ’d write: give indices larger number records spines file, file dropped. example, call get three files back, seven files don’t records 150! (Notice humdrum\\(_{\\mathbb{R}}\\) won’t remove Exclusive interpretation spine spine closing (*-) records…since break humdrum syntax.)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Filtering.html"],"id":"character-indices-for-double-brackets","dir":"Articles","previous_headings":"Indexing > Double-bracket indexing","what":"Character indices (for double-brackets)","title":"Filtering humdrum data","text":"Character string values j can also given double-bracket humdrum\\(_{\\mathbb{R}}\\) index commands. Humdrum\\(_{\\mathbb{R}}\\) treat string regular expression return records () spines (j) match expression data token—even one. example, let’s () say interesting studying flats. Since **kern represents flats “-”, can find records contain flat calling: single-bracket search flats (previous section) get five files back, five chorales contain flats . However, now see records don’t contain flat completely stripped away, leaving (handful) records least one flat. thing j (spines) looks like get one spine five files. single spines simply ever spine file contained flat. couple things notice! first file, now spine 1 old spine 2, can tell instrument interpretation *Itenor. However, look last five files see *Ibass—new spine 1 actually original spine 1 file. wait, ’s ! dig look files returned us (aren’t shown default), see now third file actually flats four spines, four spines still ! cases may find renumbering spines per file basis confusing, want keep track original spine numbers. Fortunately, option might helpful, learn : try specifying removeEmpty = FALSE:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Filtering.html"],"id":"negative-numeric-indices","dir":"Articles","previous_headings":"Indexing","what":"Negative numeric indices","title":"Filtering humdrum data","text":"nifty feature R supply negative numbers indexer, R remove numbers. works humdrum\\(_{\\mathbb{R}}\\) , want files except first file, write: want spines except fourth spine, write want remove first 20 records file: (, humdrum\\(_{\\mathbb{R}}\\) won’t remove Exclusive interpretation spine spine closing (*-) records…since break humdrum syntax.)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Filtering.html"],"id":"general-filtering","dir":"Articles","previous_headings":"","what":"General Filtering","title":"Filtering humdrum data","text":"indexing commands (previous sections) get far. want precise filtering, use subset method humdrum\\(_{\\mathbb{R}}\\) data. subset.humdrumR works exactly like within.humdrumR. However, expression(s) give must evaluate logical vector (TRUE FALSE) length input. (get error otherwise.) subset.humdrumR take logical result filter data matches FALSE. can reproduce functionality [] [[]] indexing operators (previous section) using subset: , now can filter based arbitrary criteria want. example, extract tokens odd numbered spines odd numbered records even numbered spines even numbered records. ’ll use Rs modulo command %% separate even odd numbers (odd %% 2 == 1, even %% 2 == 0). ever want ? Probably . However, returning flats, study, lets grab flat notes: Woh, ’re seeing couple B flats files! , know lot flats fourth file (losing files flats):","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Filtering.html"],"id":"subseting-by-group","dir":"Articles","previous_headings":"General Filtering","what":"Subseting by Group","title":"Filtering humdrum data","text":"Since subset.humdrumR makes use [within.humdrumR], can use within.humdrumR’s special options, including group . can useful way get context searches. example, let’s say want find flats , want see whole bar music contains flat. can grouping Bar field (File field). ’ll want say “within bar, flats, return TRUE whole bar, else return FALSE whole bar.” can use function get match, fill option copy result whole bar. enough context ? Maybe group bars even-odd pairs:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Filtering.html"],"id":"removing-vs-filtering","dir":"Articles","previous_headings":"General Filtering","what":"Removing vs Filtering","title":"Filtering humdrum data","text":"probably noticed , unlike indexing commands [] [[]], subset doesn’t seem actually remove data filter . say still four spines, spines 2–4 just emptied. correct. subset actually mark filtered data Filter field humdrum table. Humdrum\\(_{\\mathbb{R}}\\) ignores data automatically. ? several reasons: clear example [[ , j]] indexing flats (): simply removed spines flats hard tell spine result. Many filters break humdrum syntax data simply removed. removed tokens don’t contain flats, result humdrum data holes . possible undo filters, using clearFilter command. (Try .) ’ve done filtering subset, want get rid empty parts data, can using commands removeEmptyFiles, removeEmptySpines, removeEmptyRecords, removeEmptyStops, removeEmptyPaths. using commands, make sure 1) explicitly want remove 2) humdrum syntax broken, whole records/spines/paths/files removed. spines example: records:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/GettingStarted.html"],"id":"quick-start","dir":"Articles","previous_headings":"","what":"Quick Start","title":"Getting started with humdrumR","text":"Let’s just dive right ! First, make sure humdrum\\(_{\\mathbb{R}}\\) installed: install humdrumR. Open R session load humdrum\\(_{\\mathbb{R}}\\) library using command library(humdrumR)—now ready rock! Humdrum\\(_{\\mathbb{R}}\\) comes packaged small number humdrum data files just play around . files stored directory computer installed humdrum\\(_{\\mathbb{R}}\\), subfolder called “HumdrumData”. can move R session folder using R’s “set working directory command”: setwd(humdrumRroot). ’re humdrumR directory, can use base R dir function see humdrum data available . looks like six folders humdrum data available . Using dir , can look inside one: let’s start ‘BachChorales’ folder. ten files folder, named “chor001.krn”, “chor002.krn”, etc. simple plain humdrum text files, using **kern interpretation represent ten chorales J.S. Bach. Take minute find files computer’s finder/explorer open simple text editor. One core philosophies humdrum\\(_{\\mathbb{R}}\\) maintain direct, transparent relationship symbolic data—always take time look data! can also within Rstudio’s “Files” pane—fact, Rstudio make things extra easy can (within Files pane) click “” > “Go Working Directory” quickly find files.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/GettingStarted.html"],"id":"reading-humdrum-data","dir":"Articles","previous_headings":"Quick Start","what":"Reading humdrum data","title":"Getting started with humdrumR","text":"Now ’ve found humdrum data look , let’s read humdrum\\(_{\\mathbb{R}}\\). can using humdrum\\(_{\\mathbb{R}}\\)’s readHumdrum command. Try : command two things: readHumdrum function read “chor001.krn” file R create humdrum\\(_{\\mathbb{R}}\\) data object . new object saved variable called chor1. (name ‘chor1’ just name chose—welcome give different name want.) ’ve created chor1 object (whatever chose call ), can take quick look just typing name command line pressing enter: (R, enter something command line, R “prints” read.) print-see shows name file, contents file, stuff “Data fields” learn soon. Cool! Still, looking single humdrum file really exciting. whole point using computers working large amounts data. Luckily, humdrum\\(_{\\mathbb{R}}\\) makes easy. Check next command: Notice ’ve changed instead writing 'chor001.krn', wrote 'chor0'. feed string 'chor0' readHumdrum, won’t just look file called “chor0”; read file folder whose name contains substring “chor0”—case ten files! Try printing new chorales object see different. Wow! ’ve now got “humdrumR corpus ten files”—’s nothing: readHumdrum work just well reading hundreds thousands files! Notice print humdrum\\(_{\\mathbb{R}}\\) object, humdrum\\(_{\\mathbb{R}}\\) shows beginning first file end last file, well telling many files total. readHumdrum number cool options can read detail humdrumR read/write tutorial.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/GettingStarted.html"],"id":"the-data-model","dir":"Articles","previous_headings":"","what":"The Data Model","title":"Getting started with humdrumR","text":"really make use humdrum\\(_{\\mathbb{R}}\\), need understand bit humdrum data represented humdrum\\(_{\\mathbb{R}}\\) package: humdrum\\(_{\\mathbb{R}}\\) “data model.” essential thing understand maps humdrum data syntax R data.table.  fully understand , start least basic understanding humdrum syntax! Read syntax humdrum.org check vignette topic.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/GettingStarted.html"],"id":"data-frames","dir":"Articles","previous_headings":"The Data Model","what":"data.frames","title":"Getting started with humdrumR","text":"Data.frames essential R. data.frame simply two-dimensional table named columns. column either vector list values, length. Humdrum\\(_{\\mathbb{R}}\\) makes use popular extension base-R data.frames, data.table. humdrum\\(_{\\mathbb{R}}\\), every single, individual token collection humdrum-syntax text files given row data.frame. example, consider simple, humdrum-syntax file: file contains nineteen individual tokens. illustrate, ’ll print file, token bracketed < >: happens humdrum\\(_{\\mathbb{R}}\\) reads file? (file bundled humdrum\\(_{\\mathbb{R}}\\) \"humdrumRroot/examples\" directory.) see thing saw earlier, reading real humdrum data \"HumdrumData\" folder. ’s hood? see , can use getHumtab function extract underlying humdrum table: Look , data.table nineteen rows! One row every token. case, humdrum data table (“humtable”) twenty-four columns! columns : humdrum\\(_{\\mathbb{R}}\\), refer columns fields. learn fields humdrum\\(_{\\mathbb{R}}\\) object, better call fields command directly original humdrum\\(_{\\mathbb{R}}\\) object: see twenty-four fields (humtable columns), divided five types fields: Data fields Structure fields Interpretation fields Form fields Reference fields (good place read details columns means humdrum table documentation can get calling ?humTable.) Let’s go back Bach chorales dataset loaded earlier (saved chorales): chorales corpus 44 fields!—fields example1, additional ones. additional fields interpretation reference records didn’t appear toy example1.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/GettingStarted.html"],"id":"main-fields","dir":"Articles","previous_headings":"The Data Model > data.frames","what":"Main Fields","title":"Getting started with humdrumR","text":"important fields always present humdrum\\(_{\\mathbb{R}}\\) humtable 1) Token field contains original character tokens read humdrum data; 2) “Structural” fields tell us original humdrum data token came . “Structural” fields allow humdrum\\(_{\\mathbb{R}}\\) (re)construct original humdrum data—translating humdrum-table (data.table) plain-text humdrum syntax. can inspect field humdrum\\(_{\\mathbb{R}}\\) data using $ operator: Just call humdrum\\(_{\\mathbb{R}}\\) data object $ name field. Using , can see content structural fields ! important Spine, Record, (Record) Type, File(name) fields. “record types” : \"G\": global comment (including reference records) \"L\": local comment \"\": interpretation \"M\": measure (.e., barlines) \"D\": (non-null) data token \"d\": null data token (\".\")","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/GettingStarted.html"],"id":"stops","dir":"Articles","previous_headings":"The Data Model > data.frames","what":"Stops","title":"Getting started with humdrumR","text":"humdrum syntax, multiple tokens can placed “place” (.e., record, spine) simply separating spaces. (commonly used represent chords **kern data.) humdrum\\(_{\\mathbb{R}}\\), call “Stops”—always, every humdrum token, including stops, get row humdrum\\(_{\\mathbb{R}}\\) humtable. Thus, need Stop field tell us stop token came ! much data, /tokens simply Stop == 1 (first position), one tokens record/spine, numbered ascending one: Let’s look example make sense ! file chords second spine: individual note tokens separated spaces. Let’s inspect humtable: can see note chords gets row, numbered 1, 2, 3 Stop field!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/GettingStarted.html"],"id":"paths","dir":"Articles","previous_headings":"The Data Model > data.frames","what":"Paths","title":"Getting started with humdrumR","text":"humdrum data contains “spine paths”—places single spine splits two. humdrum\\(_{\\mathbb{R}}\\) treats spine paths “subspines” main spine split , one numbered Path field. starting path (leftmost) numbered path 0—datasets spine paths, Path field zeros. paths numbered higher integers. Let’s look simple example: complex example: Notice humdrum\\(_{\\mathbb{R}}\\) prints paths way readable reading humdrum syntax directly: paths “shifted” columns align. option function .matrix.humdrumR().","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/GettingStarted.html"],"id":"doing-stuff","dir":"Articles","previous_headings":"","what":"Doing Stuff!","title":"Getting started with humdrumR","text":"Ok, ’ve now seen read inspect humdrum\\(_{\\mathbb{R}}\\) data. ’ve also got idea humdrum data looks like surface: humdrum table. can ? create humdrum\\(_{\\mathbb{R}}\\) corpus object, using readHumdrum, object encapsulates humdrum-table (data.table) object, data really stored. ’ve already seen can extract humdrum table directly using getHumtab—already R pro, might just want extract table work directly. However, humdrum\\(_{\\mathbb{R}}\\) object give us convenient ways working table. example, ’ve already seen print humdrum\\(_{\\mathbb{R}}\\) objects, print humdrum syntax, easier read complex humdrum table! humdrum\\(_{\\mathbb{R}}\\) ! main thing humdrum\\(_{\\mathbb{R}}\\) allow us work fields humdrum-tables way convenient powerful. First, create special R “expressions” refer humdrum-table’s fields. instance, can write things like: Spine + File nchar(Token) paste0(Token, Record) However, can tell humdrum\\(_{\\mathbb{R}}\\) evaluate expressions using fields humdrum tables. simplest way using within() function, takes humdrum\\(_{\\mathbb{R}}\\) object expression right side. expression evaluated, result put back place humdrum data! ’ll also notice printout, new Data field, called Result1—default name humdrum\\(_{\\mathbb{R}}\\) assigns new fields create. want, can pick names using <- within within call. instance, lets use humdrum\\(_{\\mathbb{R}}\\)’s semits function (see humdrum pitch vignette) calculate semitone value pitch chorales: worked! Lets , save result new field, call Semits—course, give name want, just let called Result1 want! now new Data field humdrum table, called Semits. Meanwhile, original Token field still , safely unchanged! Just like , can use $ operator look fields: Whats , can use Semits field just like field:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/GettingStarted.html"],"id":"counting-stuff","dir":"Articles","previous_headings":"Doing Stuff!","what":"Counting stuff","title":"Getting started with humdrumR","text":"basic step computational musicology …counting things! R fantastic, simple function tabulating (counting) elements vectors: function table(). Using , can easily count happens data: get count every unique data token dataset. ’s little messy. Let’s use humdrum\\(_{\\mathbb{R}}\\)’s kern() function extract just simple pitch information, tabulate instead: Much easier read…plot even better. R good basic function called barplot():  Remember Semits field made earlier? Maybe ’d like see histogram values—let’s use R’s hist() function:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/GettingStarted.html"],"id":"what-next","dir":"Articles","previous_headings":"","what":"What next?","title":"Getting started with humdrumR","text":"’ve gotten started, much learn! keep learning check articles humdrumR webpage. want continue along path ’ve started , next articles check probably Getting know data, Filtering humdrum data, Working humdrum data. Since musicological analysis involves pitch rhythm, ’ll probably want learn relevant ideas Pitch tonality Rhythm meter articles. humdrum data working complex—e.g., including multiple different exclusive interpretations, spine paths, multi-stops—’ll probably find need check Shaping humdrum data article, give tools deal complex humdrum data sets.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/HumdrumSyntax.html"],"id":"structure-vs-content","dir":"Articles","previous_headings":"","what":"Structure vs Content","title":"The humdrum syntax","text":"humdrum syntax lays simple structure encoding data, says nothing content. information encoded, information represented flexible. flexibility, structure humdrum data—humdrum syntax—always , makes easy work ! fill content humdrum files, define “interpretations. Interpretations schemes represent information characters. sounds complicated/scary, can simple! instance, wanted encode drum beats humdrum invent simple scheme encoding drum beats : Kick drum = “K” Snare drum = “S” Hi-Hat = “H” treat newline text file sixteenth-note tick (read humdrum “timebase” ) start encoding. thing need make conform humdrum syntax name : call overarching interpretations like “exclusive interpretations”, prefixed **. call **drums ’d ready create humdrum data!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/HumdrumSyntax.html"],"id":"syntax","dir":"Articles","previous_headings":"","what":"Syntax","title":"The humdrum syntax","text":"humdrum syntax , first glance, nothing simple, tab-delineated spread sheet. (“tab-delineated” just means columns spreadsheet separated TABs.) basic idea, extra features learn! Let’s take look basic humdrum file:  file can broken different types information like :  file two columns data, separated tabs. However, special terminology use: “columns” humdrum file called spines. line, row, file called record.  twenty records two spines file. character-string, located spine/record position, called token. Examples tokens file include *M4/4, 4A, =1, !Suspension.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/HumdrumSyntax.html"],"id":"global-vs-local","dir":"Articles","previous_headings":"Syntax","what":"Global vs Local","title":"The humdrum syntax","text":"’ll notice two records file (1 10) don’t seem two columns. Indeed, called “global” records—don’t belong particular column, whole row/file. image illustrates two spines file don’t include records 1 10:  real data :","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/HumdrumSyntax.html"],"id":"time","dir":"Articles","previous_headings":"Syntax","what":"Time","title":"The humdrum syntax","text":"one fundamental assumption regarding humdrum syntax encodes information: travel downward file (top bottom) encoding information order occurs time. true data records—interpretation comment records associated moment time first data record occurs . Information appears record (within one spine, different spines) assumed happen time.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/HumdrumSyntax.html"],"id":"record-types","dir":"Articles","previous_headings":"Syntax","what":"Record Types","title":"The humdrum syntax","text":"humdrum syntax recognizes four broad types records, five sub-types: Exclusive (**) Tandem (*) Reference (!!!) Global (!!) Local (!) Barlines (=) Data know type record ’re dealing looking first character token. tokens single record must type—can’t interpretation token comment token line. result, can refer type token, type whole record, tokens within record always type.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/HumdrumSyntax.html"],"id":"interpretations","dir":"Articles","previous_headings":"Syntax > Record Types","what":"Interpretations","title":"The humdrum syntax","text":"token starts *, interpretation token. Two stars ** indicates exclusive interpretation. Every spine must start exclusive interpretation, can one. exclusive interpretation spine tells us type information encoded spine, whole spine. instance, **drums interpretation invented exclusive interpretation. examples ’re using , exclusive interpretation spines **kern, widely used humdrum interpretation, used encode music notation. Note humdrum file can different exclusive interpretations spine—don’t , example. read various humdrum interpretations defined, check humdrum.org.  token starts one *, called tandem interpretation. Tandem interpretations tell us specific, localized information interpret data. can different, overlapping tandem interpretations within spine. example, *C:, *Ibass, *M4/4, *M3/4, tandem interpretations. *C: used **kern indicate key C major. *Ibass indicates instrument associated spine (bass voice). *M4/4 *M3/4 indicate 4/4 3/4 meter respectively. last case brings something important tandem interpretations: tandem interpretation applied subsequent data points, unless cancelled replaced another tandem interpretation type. Thus, humdrum file indicates 4/4 time starting record 5, switches 3/4 time record 13. However, *M4/4 record 4 doesn’t replace *C: record 3, different types tandem interpretations. One special token *- token. token indicates spine ends. *- missing end—one every spine—invalid humdrum file!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/HumdrumSyntax.html"],"id":"comments","dir":"Articles","previous_headings":"Syntax > Record Types","what":"Comments","title":"The humdrum syntax","text":"token begins !, comment token. Comments used freely include comments data. global comments (!!) associated spine—apply whole file point appear—local comments (!) specific particular spine. example, !! Ritardando global comment, !Suspension local comment, specific second spine.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/HumdrumSyntax.html"],"id":"reference-records","dir":"Articles","previous_headings":"Syntax > Record Types > Comments","what":"Reference Records","title":"The humdrum syntax","text":"one final type comment: reference records. Reference records global comments placed beginning end file. Reference records encode global metadata entire file: things like composed piece title piece . Reference records specific “reference codes,” usually three digits, come !!!, followed colon, whatever content record . instance, code !!!OTL: refers original title piece. Learn various standard humdrum reference records .","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Intervals.html"],"id":"intervals","dir":"Articles","previous_headings":"","what":"Intervals","title":"Rhythm and Pitch Intervals","text":"pitch time perceived relatively: relationship two points. Thus represent , conceptually, interval—difference. case pitch, interval two frequencies (abstractly, “tonal” interval circle--fifths). case rhythm, interval two time points—two onsets, onset offset. humdrumR, abstract intervals represented tonalInterval rhythmInterval objects, respectively. concretize abstract intervals, must establish relative . reference? actually multiple, useful ways can represent information. Since intervals relative, always implicit reference—origin, zero. tonalIntervals origin unison interval. rhythmIntervals origin zero. tonalIntervals rhythmIntervals constitute constitute algebraic module integers (module \\(\\mathbb{Z}\\)), appropriate arithmetic operations fully defined humdrumR. Since intervals can added/subtracted, interval can thought combination (addition) intervals. humdrumR, often “partition” interval combination useful sub-intervals.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Intervals.html"],"id":"serial-and-fixed-reference","dir":"Articles","previous_headings":"Intervals","what":"Serial and Fixed Reference","title":"Rhythm and Pitch Intervals","text":"Vectors humdrumR intervals can represented two fundamental ways: serial reference representation fixed reference representation. illustrate, use two examples, one rhythmic, one pitched: major scale “tag-line” rhythm 3+3+3+3+2+2","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Intervals.html"],"id":"fixed-reference","dir":"Articles","previous_headings":"Intervals > Serial and Fixed Reference","what":"Fixed reference","title":"Rhythm and Pitch Intervals","text":"fixed-reference representation, intervals interpreted relative fixed point (implicitly 0). Fixed-reference representations major scale (using semitones) tag-line rhythm follows: Note representation quite commonly used musicians, various forms, pitch. contrast, fixed-reference representations commonly used musicians rhythm. However, used contexts, essentially represent “time beginning” piece: Thus, timestamps/timelines DAWs “offsets” music21 examples fixed-reference representations time.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Intervals.html"],"id":"serial-reference","dir":"Articles","previous_headings":"Intervals > Serial and Fixed Reference","what":"Serial reference","title":"Rhythm and Pitch Intervals","text":"alternative representation serial-reference representation, interval measured relative previous one. Thus, data point represents local change (\\(\\Delta\\)) parameter. lossless (explained ) first element serial data vector measured relative implicit reference (0). Serial representations tag-line major scale follows: representations also fairly intuitive musicians—representing “melodic intervals”—music notation sequencers represent pitch. contrast, serial-reference representation rhythm normative: traditional music notation note values serial-reference representation.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Intervals.html"],"id":"transformations-interval-calculus","dir":"Articles","previous_headings":"Intervals > Serial and Fixed Reference","what":"Transformations (“Interval Calculus”)","title":"Rhythm and Pitch Intervals","text":"Since addition defined intervals fixed-reference serial-reference representations can translated . serial-reference representation can calculated pairwise differences elements fixed-reference data, first reference element appended beginning. Conversely, fixed-reference representation can calculated cumulative sum serial-reference data. Thus: humdrumR, refer two transformations delta (\\(\\Delta\\)) sigma (\\(\\Sigma\\)), differences sums respecticely. humdrumR, note relationship fixed- serial-reference representations analogous relationship function derivative. fixed-reference representation represents sequence independent values function (serial) index position. serial-reference representation represents sequence differences adjacent elements index—much fixed representation changes index. (Since first element serial-reference representation relative fixed (implicit) reference, normal one--many relationship derivatives functions removed, lossless one--one relationship maintained.) two transformations thus inverses : \\(x = sigma(delta(x))\\) \\(x = delta(sigma(x))\\). Derivative/Integral relationship Major Scale Derivative/Integral relationship Tagline Rhythm","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Intervals.html"],"id":"dynamic-reference","dir":"Articles","previous_headings":"Intervals","what":"Dynamic Reference","title":"Rhythm and Pitch Intervals","text":"Since intervals additive, another possibilty use one vector intervals reference point second vector intervals. allows us create dynamic reference points. examples Figured Bass: bass voice texture encoded (serial/reference reprsentation) voices represented relative bass voice. Chord Tones: abstract “root” chord progression represented one vector, vectors representing “chord tones” (root, 3rd, 5th, 7th, etc.) relative chord root. Scale degrees: tonic key used dynamic reference, notes calculated relative tonic. Figured Bass Calculating dynamic reference intervals lossless complete information reference intervals maintained. instance, keep track serial fixed intervals bass voice. , keep track local key (usually using fixed interval “C”).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/KeysAndChord.html"],"id":"diatonic-sets","dir":"Articles","previous_headings":"","what":"Diatonic Sets","title":"Diatonic and tertian sets in humdrumR","text":"mentioned Pitch Tonality vignette, normative diatonic key consists set seven consecutive pitch chroma Line Fifths. diatonic set can ordered either line--fifths position: “scale-order,” corresponds steps \\(+2\\) (\\(-5\\)) modulo 7.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/KeysAndChord.html"],"id":"tertian-sets","dir":"Articles","previous_headings":"","what":"Tertian Sets","title":"Diatonic and tertian sets in humdrumR","text":"set seven notes diatonic key can reimagined chord—set notes played time. Specifically, full seven-note diatonic chord referred 13th chord. However, chords used tonal music subsets full diatonic set, particular three-note triads. viewing diatonic set chord, traditionally order set sequence ascending thirds, corresponding intervals \\(+4\\) line--fifths, modulo 7. tertian steps usually wrapped octave, resulting steps 9, 11, 13, instead 2, 4, 6. \\(2^7=\\) 128 possible subsets can formed full diatonic set. , seven possibilities built consecutive tertian steps theoretically privileged : .e., \\(\\{\\{1\\}, \\{1,3\\}, \\{1,3,5\\}, \\{1,3,5,7\\}, \\{1,3,5,7,9\\}, \\{1,3,5,7,9,11\\}, \\{1,3,5,7,9,11,13\\}\\}\\). possible sets fairly commonplace Western theory well: \\(\\{1,5, 11\\}\\) (“sus4”), \\(\\{1,3,5,9\\}\\) (“add9”), \\(\\{1,3,5,13\\}\\) (“add6”), etc.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/KeysAndChord.html"],"id":"concrete-representations","dir":"Articles","previous_headings":"Tertian Sets","what":"Concrete Representations","title":"Diatonic and tertian sets in humdrumR","text":"numerous ways tertian sets notes traditionally notated annotated character strings. Unfortunately, systems always rigorously consistent logical, convenient shorthands common chords lead ambiguity, /practices rooted traditional practices little relevance. Humdrum\\(_{\\mathbb{R}}\\) aims provide general approach make reading/writing chord annotations many forms possible. chord representation consists set least one following elements: root note. bass note. subset tertian steps present. Qualities chord steps, relative implicit explicit key. Traditional chord notation symbols often conflate merge various elements various ways, numerous common shorthands. particular, common diatonic triads—abstractly different combinations qualities 3rd 5th—represented various shorthands.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/KeysAndChord.html"],"id":"section","dir":"Articles","previous_headings":"","what":"Diatonic and tertian sets in humdrumR","title":"Diatonic and tertian sets in humdrumR","text":"Chord symbols tonal chroma practice often used indicate bass note part ostensible chord. instance, C7/Ab. consist form, unique symbol appended indicate one four unique triad types: major, minor, diminished, augmented. However, cases, major assumed default, can ommitted. cases, either major minor symbol ommited, case root symbol used indicate major minor. (cases, case root symbol also matched diminished (lower) augmented (major) symbols).) Roman numerals 7ths 753 7, 653 65, 643 43, 642 42 2 9ths 9753: 1111100 7653: 1111001 6543: 1110011 6432: 1100111 7642: 1001111 11ths 11","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Overview.html"],"id":"what-is-humdrum_mathbbr","dir":"Articles","previous_headings":"","what":"What is humdrum\\(_{\\mathbb{R}}\\)?","title":"Overview of humdrumR","text":"Humdrum\\(_{\\mathbb{R}}\\) R package—“library” preexisting code [R programming language](https://en.wikipedia.org/wiki/R_(programming_language). Humdrum\\(_{\\mathbb{R}}\\) code provides tools visualization, manipulation, analysis humdrum data. Note: name package pronounced hum-drum-ARRRRR, last syllable emphasized pirate fashion. name always typeset \\(h\\mu m_{\\mathbb{R}}^{\\Delta r \\mu m}\\). Failure pronounce typeset \\(h\\mu m_{\\mathbb{R}}^{\\Delta r \\mu m}\\) correctly void warranty.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Overview.html"],"id":"what-is-humdrum","dir":"Articles","previous_headings":"What is humdrum\\(_{\\mathbb{R}}\\)?","what":"What is humdrum?","title":"Overview of humdrumR","text":"Humdrum system computational musicology developed David Huron. Humdrum “universe” includes two parts: data format called humdrum syntax musicological software system called humdrum toolkit, humdrum\\(_{\\mathbb{R}}\\) meant modernized replacement original humdrum toolkit, leveraging power R give us unprecedented power manipulate analyze humdrum data using concise, expressive syntax. humdrum\\(_{\\mathbb{R}}\\) mainly used manipulate analyze data encoded humdrum syntax /humdrum interpretations like “**kern”. humdrum syntax incredibly flexible, powerful, scheme encoding musical data. Tens thousands musical scores (musical data) encoded humdrum syntax, many available online repositories KernScores. humdrum syntax vignette gives detailed introduction data format.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Overview.html"],"id":"what-is-r","dir":"Articles","previous_headings":"What is humdrum\\(_{\\mathbb{R}}\\)?","what":"What is R?","title":"Overview of humdrumR","text":"R programming language, designed ground statistical computing data analysis. R many features make ideal data analysis, particularly research analysis background programming. R primer introduces core concepts R programming.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Overview.html"],"id":"what-can-humdrum_mathbbr-do","dir":"Articles","previous_headings":"","what":"What can humdrum\\(_{\\mathbb{R}}\\) do?","title":"Overview of humdrumR","text":"Humdrum\\(_{\\mathbb{R}}\\) provides number tools working humdrum data generally, musicological analysis. package seven main components:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Overview.html"],"id":"representing-humdrum-in-r","dir":"Articles","previous_headings":"What can humdrum\\(_{\\mathbb{R}}\\) do?","what":"Representing humdrum in R","title":"Overview of humdrumR","text":"represent humdrum data R, humdrum\\(_{\\mathbb{R}}\\) defines special data type—humdrumR class—call “humdrumR objects” throughout documentation. important part humdrumR object “humdrum table” contains. can read humdrum-syntax data represented getting started humdrumR vignette.  details, read humdrumR class humdrum table; humdrum\\(_{\\mathbb{R}}\\) installed loaded, can read directly R session typing ?humdrumR-class ?humTable.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Overview.html"],"id":"reading-and-writing-humdrum-data","dir":"Articles","previous_headings":"What can humdrum\\(_{\\mathbb{R}}\\) do?","what":"Reading and writing humdrum data","title":"Overview of humdrumR","text":"create humdrumR data objects, humdrum\\(_{\\mathbb{R}}\\) includes humdrum data parser, finds humdrum data local machine, reads R, creates humdrumR object data. Reading writing data vignette best place learm works. can get details readHumdrum() writeHumdrum() documentation; humdrum\\(_{\\mathbb{R}}\\) installed loaded, can read directly R session typing ?readHumdrum ?writeHumdrum.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Overview.html"],"id":"shaping-humdrum-data","dir":"Articles","previous_headings":"What can humdrum\\(_{\\mathbb{R}}\\) do?","what":"Shaping humdrum data","title":"Overview of humdrumR","text":"’ve imported humdrum data R, next step often organize prepare data. ’ll often want pick specific subsets data, rearrange data representations easier work . Humdrum\\(_{\\mathbb{R}}\\) gives us number powerful tools “shaping data”: Shaping humdrum data Filtering humdrum data vignettes best places learn processes. can find details subsetting data subset.humdrumR() indexHumdrum documentation; humdrum\\(_{\\mathbb{R}}\\) installed loaded, can read directly R session typing ?subset.humdrumR ?indexHumdrum.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Overview.html"],"id":"working-with-humdrum-data","dir":"Articles","previous_headings":"What can humdrum\\(_{\\mathbb{R}}\\) do?","what":"Working with humdrum data","title":"Overview of humdrumR","text":"Humdrum\\(_{\\mathbb{R}}\\) makes easy manipulate, modify, analyze humdrum data. Working humdrum data vignette gives overview functionality. can find details withinHumdrum documentation; humdrum\\(_{\\mathbb{R}}\\) installed loaded, can read directly R session typing ?withinHumdrum.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Overview.html"],"id":"pitch","dir":"Articles","previous_headings":"What can humdrum\\(_{\\mathbb{R}}\\) do?","what":"Pitch","title":"Overview of humdrumR","text":"Humdrum\\(_{\\mathbb{R}}\\) defines tools manipulating numerous representations pitch tonality, including diatonic keys tertian harmonies. Pitch tonality vignette explains work pitch data humdrum\\(_{\\mathbb{R}}\\). can find details humdrumPitch documentation; humdrum\\(_{\\mathbb{R}}\\) installed loaded, can read directly R session typing ?humdrumPitch.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Overview.html"],"id":"rhythm","dir":"Articles","previous_headings":"What can humdrum\\(_{\\mathbb{R}}\\) do?","what":"Rhythm","title":"Overview of humdrumR","text":"Humdrum\\(_{\\mathbb{R}}\\) defines tools manipulating numerous representations rhythm, timing, meter. Rhythm meter vignette explains work rhythmic information humdrum\\(_{\\mathbb{R}}\\). can find details humdrumRhythm documentation; humdrum\\(_{\\mathbb{R}}\\) installed loaded, can read directly R session typing ?humdrumRhythm.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Overview.html"],"id":"development","dir":"Articles","previous_headings":"What can humdrum\\(_{\\mathbb{R}}\\) do?","what":"Development","title":"Overview of humdrumR","text":"facilitate development new functions work humdrum tokens—simple character strings packed information—, humdrum\\(_{\\mathbb{R}}\\) provides several useful development tools, including struct data type useful API call regular-expression dispatch system, makes easy dispatch different methods based matches regular expressions.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/PitchAndTonality.html"],"id":"pitches-and-intervals","dir":"Articles","previous_headings":"","what":"Pitches and Intervals","title":"Pitch and tonality in humdrumR","text":"Humdrum\\(_{\\mathbb{R}}\\) defines suite “pitch functions,” like kern(), solfa(), interval(), semits(). functions work essentially way: take input argument output pitch information particular format. example, let’s take little bit **kern data: Notice data rhythmic information (4., 8, 4, 2.) pitch information (c, d, e, g). happens give data “pitch functions”?: function correctly reads **kern pitch information, ignoring rhythm information, outputs pitch information different format. allows us “translate” different ways representing pitch information. want keep non-pitch (rhythm) information, use inPlace argument: cool thing functions can read function’s output. can things like: complete list basic pitch functions : kern pitch lilypond helmholtz tonh (German-style notation) interval solfa (relative-solfege) solfg (French-style fixed-solfege) degree (absolute scale degrees) deg (melodic scale degrees) bhatk (hindustani swara) step accidental quality octave semits midi cents pc (pitch classes) freq one functions represents different way representing equivalent pitch information.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/PitchAndTonality.html"],"id":"documentation","dir":"Articles","previous_headings":"Pitches and Intervals","what":"Documentation","title":"Pitch and tonality in humdrumR","text":"global documentation pitch functions can seen calling ?pitchFunctions. can also call documentation individual function, like ?kern.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/PitchAndTonality.html"],"id":"scale-degree","dir":"Articles","previous_headings":"Pitches and Intervals","what":"Scale degree","title":"Pitch and tonality in humdrumR","text":"pitch representations encode scale degree, depends key. can use Key argument control pitch functions interpet key—either translating degrees absolute pitches, vice versa. Pass Key argument humdrum key interpretation, like c: (c minor) -: (-flat major). Key argument vectorized (see R primer don’t know means!); means can actually read information different/changing keys.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/PitchAndTonality.html"],"id":"working-with-pitch-representations","dir":"Articles","previous_headings":"Pitches and Intervals","what":"Working with pitch representations","title":"Pitch and tonality in humdrumR","text":"Let’s look using pitch functions real data. Let’s load humdrum\\(_{\\mathbb{R}}\\)’s built-Bach chorales: chorales full **kern data (default) Token field, can easily parsed/translated. Maybe ’d like convert **kern semitones: , instance, make histogram semitone values:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/PitchAndTonality.html"],"id":"keys","dir":"Articles","previous_headings":"Pitches and Intervals > Working with pitch representations","what":"Keys","title":"Pitch and tonality in humdrumR","text":"chorale dataset key information built-Key field. use pitch function () within(), automatically pass Key field Key argument function! means apply solfa(), get correct scale degrees, given keys data:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/PitchAndTonality.html"],"id":"rests","dir":"Articles","previous_headings":"Pitches and Intervals","what":"Rests","title":"Pitch and tonality in humdrumR","text":"**kern data, like chorales, includes rests, indicated r place pitch. happens pitch function sees rest data? Let’s see: rest token, output null (NA) value. fact, token input fails parse pitch return NA/.. example,","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/PitchAndTonality.html"],"id":"pitch-arguments","dir":"Articles","previous_headings":"","what":"Pitch arguments","title":"Pitch and tonality in humdrumR","text":"Since “pitch functions” sort task, share number common arguments. complete list pitch arguments can found ?pitchParsing ?pitchDeparsing man pages, important ones described :","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/PitchAndTonality.html"],"id":"generic-vs-specific-pitch","dir":"Articles","previous_headings":"Pitch arguments","what":"Generic vs Specific pitch","title":"Pitch and tonality in humdrumR","text":"pitch functions accept logical (TRUE FALSE) generic specific arguments. generic == TRUE, generic pitch information returned. affects different pitch representations different ways: representations like kern(), pitch() lilypond(), accidentals included generic output; intervals(), interval quality removed; solfa, scale degree four “fa”, never “fi” (sharp four). specific argument simply opposite generic, choice indicating genric = TRUE specific = FALSE—equivalent. code:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/PitchAndTonality.html"],"id":"simple-vs-compound-pitch","dir":"Articles","previous_headings":"Pitch arguments","what":"Simple vs Compound pitch","title":"Pitch and tonality in humdrumR","text":"pitch functions accept logical (TRUE FALSE) simple compound arguments. simple == TRUE, octave information stripped output, leaving “simple” pitch information. affects different pitch representations different ways: pitch() degree(), octave number removed. lilypond() helmholtz(), octave marks ' , removed. solfa() deg(), contour indicators (explanation ) v ^ removed. interval(), steps 1–7 reterned (.e., 10ths). compound argument simply opposite simple, choice indicating simple = TRUE compound = FALSE—equivalent. code:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/PitchAndTonality.html"],"id":"working-with-pitch-arguments","dir":"Articles","previous_headings":"Pitch arguments","what":"Working with pitch arguments","title":"Pitch and tonality in humdrumR","text":"generic simple arguments useful want tabulate pitch classes, example:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/PitchAndTonality.html"],"id":"transposition","dir":"Articles","previous_headings":"Pitch arguments","what":"Transposition","title":"Pitch and tonality in humdrumR","text":"humdrum\\(_{\\mathbb{R}}\\)’s pitch functions built-transposition functionality. can use functionality passing arguments transpose() call, inside pitch function call, like example using argument: Another option transpose key. can pass transpose() command argument. Let’s say music major ’d like transpose C major: Key argument kern() indicates key music coming , argument tranpose() indicates transpose . Since /within calls automatically use Key information data set, makes easy , say, transpose **kern tokens data C major:  looks exactly like calling solfa() :","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/PitchAndTonality.html"],"id":"melodic-intervals","dir":"Articles","previous_headings":"Melody and Harmony","what":"Melodic Intervals","title":"Pitch and tonality in humdrumR","text":"want calculate melodic intervals part score? purpose mint() (melodic intervals) command. can use mint() pitch data: use mint() /within call humdrum\\(_{\\mathbb{R}}\\) dataobject, mint() automatically called within spine/path file (accomplished using groupby argument mint()): mint() number special options, can read manual checking ?mint. now, ’ll just show classify argument, can used classify output intervals either Unison, Step, Skip, Leap:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/PitchAndTonality.html"],"id":"harmonic-intervals","dir":"Articles","previous_headings":"Melody and Harmony","what":"Harmonic intervals","title":"Pitch and tonality in humdrumR","text":"parallel mint() hint() (harmonic intervals) command. hint() works just like mint() except calculates intervals left right record file: special trick use lag argument calculate harmonic intervals relation spine. example, can caculate harmonic intervals voice bass voice like : , harmonic intervals soprano like : Check “Logical lags” section ?hint manual details.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html"],"id":"basic-commands","dir":"Articles","previous_headings":"","what":"Basic Commands","title":"An R primer for humdrumR users","text":"R code made “expressions” like 2 + 2, sqrt(2), (x - mean(x))^2. can see, can create intuitive arithmetic expressions, like 5 / 2 3 * 3. However, common elements R expressions “calls” functions. “function” R pre-built bit code something. functions take one input arguments, “return” kind output. example, function sqrt() takes number input argument, “returns” square root number. “call” function, write function’s name, followed parentheses (()). input arguments function must go inside parentheses, separated commas one. examples common functions “called” zero input arguments: Different functions different arguments recognize, specific names. example, function log() takes two arguments, called x base. functions can take number arguments, name. can learn function, including arguments accepts, typing ?functionName command line; example, ?sqrt ?mean. see argument called ..., tells function can take number arguments. can explicitly “name” function arguments want putting argname = argument calls: example, say log(10, base = 2). Named arguments useful creating data, like vectors data.frames (see ).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html"],"id":"pipes","dir":"Articles","previous_headings":"Basic Commands","what":"Pipes","title":"An R primer for humdrumR users","text":"Complex expressions might involve large number function calls, can get tiresome read (write). example, something like calls four functions! expression like bit tricky read, can really easy make mistake put wrong number parentheses. alternative, R gives us option calling functions “pipe.” way works use “pipe” command |>, takes input left “pipes” function call right. example, can rewrite previous command : Much better! make things even cleaner, R understand spread expressions across multiple lines, putting new line |>, function argument:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html"],"id":"variables","dir":"Articles","previous_headings":"Basic Commands","what":"Variables","title":"An R primer for humdrumR users","text":"coding R, ’ll often want “save” data objects can reuse . “assigning” something (often result function) “variable”. done using assignment operators, either <- ->. variable name can combination upper lowercase letters. Let’s calculate square-root two save variable: can reuse value many times want: can also assign left right, using ->. useful combination pipes: Note variable names can also include _, ., numeric digits, long aren’t beginning name. example, X1 my_name valid names—2X.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html"],"id":"basic-data-structures","dir":"Articles","previous_headings":"","what":"Basic Data Structures","title":"An R primer for humdrumR users","text":"R, two fundamental data structures used time: “atomic” vectors data.frames","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html"],"id":"vectors","dir":"Articles","previous_headings":"Basic Data Structures","what":"Vectors","title":"An R primer for humdrumR users","text":"R, basic units—atoms, —information called “atomic” vectors. three basic atomic data types: Examples: 3, 4.2, -13, 254.30 Examples: \"note\", \"\", \", dear, female dear\" Examples: TRUE, FALSE might wondering, calling basic atoms “vectors”? Well, R, basic atomic data types always considered collection ordered values. ordered collections called vectors. simple examples , vector single value, just looks like one value—single values like often called “scalars”. However, R doesn’t really distinguish scalars (single values) vectors (multiple values)—everything always vector. (Still, sometimes refer length-1 vectors scalars.) make vector scratch R, use c(), : example, ’ve created five vectors. numeric vector length 3. character vector length four (composers). logical vector length 2. ’s right, c(32.3) 32.3 thing—vector length 1. Notice vectors can’t mix--match different data types; makes sense vector single type thing. means commands like c(3, \"\") actually create character vector, 3 forced character (\"3\").","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html"],"id":"vectorization","dir":"Articles","previous_headings":"Basic Data Structures > Vectors","what":"Vectorization","title":"An R primer for humdrumR users","text":"everything vector time useful, allows us think use collections data single thing. give , say, ten thousand numbers, don’t worry manipulating ten thousand things: rather, just work one thing: vector, happens length 10,000. R, call vectorization—generally, R humdrum\\(_{\\mathbb{R}}\\) constantly taking advantage vectorization make lives super easy! example vectorization, watch : created two numeric vectors: first eight numbers Fibonacci sequence single number 2 multiplied together! Notice entire Fibonacci vector multiplied two! don’t worry multiplying number vector, ’s done us. two ideal circumstances working vectors. length. One vector length 1, isn’t. first case, work multiple vectors length, value vector “lined” values vector. , example, add two vectors together, “lined ” pair numbers added: second case, one vectors length-1 (“scalar”). case, scalar value paired value longer vector (Fibonacci example ). happens vectors longer one, length? Well, R generally attempt “recycle” shorter vector—means repeat — necessary match length longer vector. shorter vector evenly divides longer vector, generally won’t problem: division perfect, R still “recycle” shorter vector, ’ll get warning: see warning message R us? “longer object length multiple shorter object length” ’s R telling us ’ve got obvious mismatch lengths vectors. Generally, best work vectors length /scalar values (length-1 vectors), can avoid worrying exactly R “recycling” values. brings us …","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html"],"id":"factors","dir":"Articles","previous_headings":"Basic Data Structures > Vectors","what":"Factors","title":"An R primer for humdrumR users","text":"Factors useful modification character vectors, keep track possible values (“levels”) expect data, even levels missing vector. mainly useful counting data table(). example, let’s consider built-R object called letters: happens call table() letters?: Every letter appears table, duh! randomly sample handful letters table result? Notice letters table appear output. E.g., letter never appears sample, doesn’t get counted. Let’s try something new: sampling, call command factor() letters: Ah! Now table includes possible letters, even though many appear 0 times. work? Well factor() function looks character vector outputs new “factor” vector. factor vector acts just like character vector, except remembers unique values, “levels”, vector: Even remove values factor vector, vector “remember” levels. factor also remember order levels, can make tables ordered way want . can access, set, levels factor using using levels() function, levels argument factor() function . Maybe want tabulate letters, put vowels first: Note character string contains values don’t include levels, value show NA resulting factor, may see warnigns like “invalid factor level, NA generated.”","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html"],"id":"data-frames","dir":"Articles","previous_headings":"Basic Data Structures","what":"Data frames","title":"An R primer for humdrumR users","text":"Data frames heart soul R. data.frame simply collection vectors length—ideal vectorized operations! vectors data.frame arranged columns two dimension table. Let’s make data frame, feeding vectors [data.frame()] function: Notice columns/vectors can different type, problem. Also notice, column name; can inspect names using colnames() function. change : Finally, ’s also possible assign column name want creating data frame: Remember, vectors data.frame must length. tried make data.frame vectors don’t match length, ’ll get error “arguments imply differing number rows.” one exception can call data.frame scalar single values, automatically recycled match length vectors.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html"],"id":"with-and-within-you","dir":"Articles","previous_headings":"Basic Data Structures > Data frames","what":"With and Within You","title":"An R primer for humdrumR users","text":"often want access columns/vectors held data frame. can several ways. One approach $ operator, combined name column want. example, can get Letters column data frame made using df$Letters. Often, ’ll want write code uses bunch different columns data.frame—fact, main thing time R! avoid writing df$ , can use () function. () allows us drop “inside” data.frame, R commands can “see” columns variables:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html"],"id":"missing-data","dir":"Articles","previous_headings":"Basic Data Structures","what":"Missing Data","title":"An R primer for humdrumR users","text":"Sometimes ’ll encounter data points irrelevant, meaningless, “applicable.” cases, may relevant data “missing.” R provides two distinct ways represent missing/irrelevant data: NULL NA. NULL special R object/variable, used represent something totally missing empty. NULL length (length(NULL) == 0) value. indexed. Many functions give error passed NULL. NA quite different NULL. atomic vector can NA value () indices—fact, can vectors NA values. NA values still “values” vector, used indicate values missing problematic. Passing vector NA values functions lead error, though ’ll often get warning message instead. example, consider happens apply command .numeric() following strings: Four strings vector converted numbers without problem, string \"apple\" makes sense number. R ? converts three strings numbers, just like .numeric() supposed , \"apple\" string appears NA outut. also get warning message: NAs introduced coercion. might see warning sometimes, now know means! happen tried applying different function onto vector NA? sqrt() function problem taking square-roots three numbers, simply “propogates” NA value input output. “propogation” missing values useful feature R: makes sure keep track data missing, keeping vectors original lengths.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html"],"id":"common-functions","dir":"Articles","previous_headings":"","what":"Common Functions","title":"An R primer for humdrumR users","text":"getwd() — Get R’s current working directory. setwd() — Set R’s working directory. summary() — Summarize contents R object.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html"],"id":"vector-functions","dir":"Articles","previous_headings":"Common Functions","what":"Vector functions","title":"An R primer for humdrumR users","text":"set decreasing = TRUE decreasing order. rev() — Reverse order vector. rep() — Repeat vector. unique() — Returns unique values vector. x %% y — elements vector x appear vector y? length() — long vector (list())? Provide n argument natural number control \\(N\\).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html"],"id":"sequences-and-indices","dir":"Articles","previous_headings":"Common Functions > Vector functions","what":"Sequences and Indices","title":"An R primer for humdrumR users","text":"example, 1:10 makes vector integers one ten. seq() — Create arbitrary sequences numbers. example, (c(TRUE, FALSE, TRUE)) returns c(1,3).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html"],"id":"string-functions","dir":"Articles","previous_headings":"Common Functions","what":"String functions","title":"An R primer for humdrumR users","text":"paste() — Paste together multiple character strings. nchar() — Counts many characters string character vector.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html"],"id":"arithmetic","dir":"Articles","previous_headings":"Common Functions > Math","what":"Arithmetic","title":"An R primer for humdrumR users","text":"x + y — Addition; \\(x + y\\). x - y — Subtraction; \\(x - y\\). -x — Negation; \\(-x\\). x * y — Multiplication; \\(xy\\) Use parentheses things like x^(1/3); \\(x^{\\frac{1}{3}}\\). x / y — Real division; \\(\\frac{x}{y}\\). E.g., whole-number division remainder. E.g., remainder whole-number division. diff(c(5, 3)) 3 - 5.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html"],"id":"other-math-functions","dir":"Articles","previous_headings":"Common Functions > Math","what":"Other Math functions","title":"An R primer for humdrumR users","text":"sqrt(x) — Square-root numbers; \\(\\sqrt{x}\\). abs(x) — Absolute value numbers; \\(|x|\\) round(x) — Round number nearest integer; \\(\\lfloor x \\rceil\\) log(x) — Log number (natural log default); \\(\\log(x)\\) sign(x) — Sign (1, -1, 0) x; \\(\\text{sgn}\\ x\\)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html"],"id":"distribution-and-tendency-functions","dir":"Articles","previous_headings":"Common Functions > Math","what":"Distribution and Tendency Functions","title":"An R primer for humdrumR users","text":"sum(x) — sum numeric vector. max(x) — maximum value numeric vector. min(x) — minimum value numeric vector. get size range, use diff(range(x)). mean(x) — arithmetic mean numeric vector. median(x) — median numeric vector. quantile(x) — distribution quantiles numeric vector.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html"],"id":"randomization-functions","dir":"Articles","previous_headings":"Common Functions","what":"Randomization functions","title":"An R primer for humdrumR users","text":"sample() — Takes random sample vector. Can also used randomize order vector.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html"],"id":"analysis-functions","dir":"Articles","previous_headings":"Common Functions","what":"Analysis Functions","title":"An R primer for humdrumR users","text":"using humdrum\\(_{\\mathbb{R}}\\), use similar [tally()] instead!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html"],"id":"useful-tricks","dir":"Articles","previous_headings":"","what":"Useful tricks","title":"An R primer for humdrumR users","text":"sum((1:100) > 55) sum(letters %% c('', 'e', '', 'o', 'u')) mean((1:100) > 55) sum(letters %% c('', 'e', '', 'o', 'u'))","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html"],"id":"making-your-own-functions","dir":"Articles","previous_headings":"","what":"Making your own functions","title":"An R primer for humdrumR users","text":"make function R, use function keyword, like : example, let’s make function subtracts mean vector numbers. ’ll one argument, ’ll call numbers. ’ve created function, assigned name myfunc, just like assignment. Let’s try : Notice last expression function definition value gets “returned” function. feeling lazy, can also define function using less keystrokes using command \\() instead function(). example,","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RPrimer.html"],"id":"common-errors-and-warnings","dir":"Articles","previous_headings":"","what":"Common Errors and Warnings","title":"An R primer for humdrumR users","text":"TBA","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/ReadWrite.html"],"id":"reading-humdrum-data","dir":"Articles","previous_headings":"","what":"Reading humdrum data","title":"Reading and writing data","text":"readHumdrum function gateway humdrum\\(_{\\mathbb{R}}\\): function use read humdrum data, encoded humdrum-syntax text files, R.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/ReadWrite.html"],"id":"practice-data","dir":"Articles","previous_headings":"Reading humdrum data","what":"Practice Data","title":"Reading and writing data","text":"following examples, make use small number raw humdrum data files included humdrum\\(_{\\mathbb{R}}\\). access files, need navigate directory computer installed humdrum\\(_{\\mathbb{R}}\\)—fortunately, humdrum\\(_{\\mathbb{R}}\\) records directory computer variable called humdrumRroot. load humdrum\\(_{\\mathbb{R}}\\) library, just need set R “working directory” location using command setwd. humdrum data stored subdirectory called “HumdrumData”—can look contents directory using dir(recursive = TRUE): can see, six directories containing total fifty-one files.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/ReadWrite.html"],"id":"targeting-files","dir":"Articles","previous_headings":"Reading humdrum data","what":"Targeting files","title":"Reading and writing data","text":"use readHumdrum call function one () character-string arguments. (function documentation (?readHumdrum), ’ll see arguments called ...—R, ... means number arguments.) arguments interpreted regular expressions, matched directories files system. call “REpath-patterns,” short Regular Expression directory-path patterns. example, uses REpath-pattern \"HumdrumData/BachChorales/chor.*.krn\" match files ‘HumdrumData/BachChorales’ directory whose name matches regular expression chor.*.krn. can see, REpath-pattern includes directory (folder) paths (relative absolute)—using operating system’s appropriate delimiter (“\" windows,”/” everybody else)—pattern matching file paths. directory also treated regular expression, possibly matching multiple directories. Let’s break : humdrum\\(_{\\mathbb{R}}\\) splits REpath-pattern input string three parts: \"HumdrumData\", \"BachChorales\", \"chor.*.krn\", treats three regular expressions. first two expressions used match directories, last expression used match files. , readHumdrum('HumdrumData/BeethovenVariations/.*.krn') matches files “.krn” extension “BeethovenVariations” directories readHumdrum('HumdrumData/MozartVariations/.*.krn') matches files “MozartVariations” directories, command readHumdrum('HumdrumData/.*Variations/.*.krn') match kern files directories! careful: since directory/file name always treated like regular expression, can sometimes specify something general intend. instance, command readHumdrum('MyFolder/.*') match files folder called “MyFolder,” also match folders names “MyFolder_Also”, “ThisIsMyFolder.” want sure match exactly one one directory/file, use “^” “$” regular-expression markers explicitly mark beginning end pattern: command readHumdrum('^MyFolder$/.*') read files one directory “MyFolder.” read test files can enter: Note: Since humdrum\\(_{\\mathbb{R}}\\) can read files multiple directories , possible two files file name, different directories matched. happens, humdrum\\(_{\\mathbb{R}}\\) identifies file enough ’s directory path make sure unique.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/ReadWrite.html"],"id":"multi-argument-approach","dir":"Articles","previous_headings":"Reading humdrum data > Targeting files","what":"Multi-Argument Approach","title":"Reading and writing data","text":"Earlier mentioned can one RE-path patterns. one? Well, can divided RE-path patterns across multiple arguments (left right): Instead writing readHumdrum(\"HumdrumData/BachChorales/chor.*.krn\"), can write readHumdrum(\"HumdrumData\", \"BachChorales\", \"chor.*.krn\"). Thus two approaches identical. ’s advantage approach? ’ll see next section.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/ReadWrite.html"],"id":"multiple-patterns","dir":"Articles","previous_headings":"Reading humdrum data > Targeting files","what":"Multiple Patterns","title":"Reading and writing data","text":"Sometimes, expressing files want single regular expression possible. Luckily, readHumdrum can accept many separate patterns want, just group vector. Instead writing readHumdrum('HumdrumData/.*Variations/.*.krn'), explicit write ’ve used c command create vector two REpath-patterns. However, lot (bug-prone) typing…combine multiple patterns Multi-Argument Approach ?: get result! work exactly? ’ve fed three arguments readHumdrum. first last arguments (\"HumdrumData\" \".*.krn\") length one. However, middle argument (\"...Variations\") length two. readHumdrum concatenates three arguments together, making two separate REpath-patterns: Note: possible write multiple patterns match () files. argument multipleInstances = FALSE, unique file read (first matching pattern). multipleInstances = TRUE, file(s) can read .","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/ReadWrite.html"],"id":"pattern-names","dir":"Articles","previous_headings":"Reading humdrum data > Targeting files > Multiple Patterns","what":"Pattern Names","title":"Reading and writing data","text":"Whenever specific one REpath-pattern, humdrum\\(_{\\mathbb{R}}\\) gives names can access Label field resulting humdrum\\(_{\\mathbb{R}}\\) data object. can choose labels giving names patterns multi-pattern vectors: Thus, write two separate patterns matched read names \"Rap\" \"Rock\" associated resulting Label field. feature useful working multiple heterogeneous datasets want able apply analyses/parsing one data subsets.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/ReadWrite.html"],"id":"contains","dir":"Articles","previous_headings":"Reading humdrum data > Targeting files","what":"Contains","title":"Reading and writing data","text":"Sometimes want read humdrum files contain particular data. instance, might want read files minor key. One option read files corpus filter files don’t want (see humdrumR filtering vignette learn . However, cases, can save lot time effort filter files want parsing . contains argument readHumdrum can used just way! contains argument must character vector—character string treated regular expression, files contain matches regular expressions read. Thus, read pieces minor keys writing: (regular expression matches standard humdrum tandem interpretations minor keys.)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/ReadWrite.html"],"id":"finding-files","dir":"Articles","previous_headings":"Reading humdrum data","what":"Finding Files","title":"Reading and writing data","text":"readHumdrum interprets REpath-patterns finds files using helper function findHumdrum. sure humdrum files , pattern want use find , might start using findHumdrum. findHumdrum takes input readHumdrum, doesn’t fully parse input humdrum\\(_{\\mathbb{R}}\\). Instead, returns data.table containing matching filenames () raw file content. use verbose = TRUE option either findHumdrum readHumdrum, complete list matches files printed. useful check reading files intend read.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/ReadWrite.html"],"id":"validation","dir":"Articles","previous_headings":"Reading humdrum data > Finding Files","what":"Validation","title":"Reading and writing data","text":"findHumdrum(), extension readHumdrum(), smart functions ignore non-humdrum files matched pattern. Non-text files (like .pdf .jpg) ignored. Whats , text files fail conform humdrum syntax read either. see message checks files “valid humdrum,” tell many () text files read. trying read file think valid humdrum readHumdrum() won’t read , use validateHumdrum() see detailed report problem. Humdrum\\(_{\\mathbb{R}}\\) won’t read files humdrum-syntax violations, even relatively minor ones. see problems validateHumdrum() finding data, ’ll need fix can use humdrum\\(_{\\mathbb{R}}\\) data. Check [validateHumdrum][reference/validateHumdrum.html] documentation learn humdrum\\(_{\\mathbb{R}}\\)’s data validation tools, can used identify errors humdrum data. Note validateHumdrum() automatically check humdrum data encoded correctly makes sense, just structurally sound, accordance humdrum syntax.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/ReadWrite.html"],"id":"reading","dir":"Articles","previous_headings":"Reading humdrum data","what":"Reading","title":"Reading and writing data","text":", actually happens run readHumdrum? now, ’ve seen readHumdrum prints messages describing process. First, files match search patterns () identified, text read R. Next, files checked see valid humdrum files. files parsed—.e., translated humdrum\\(_{\\mathbb{R}}\\)’s data.table backend. step takes longest far, includes parsing humdrum files’ data tokens, interpretations, reference records, (worst ) spine paths. Indeed, reading humdrum data spine paths take significantly longer reading pathless data. save time, can potentially use tandems reference arguments (see “Parsing Metadata” ).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/ReadWrite.html"],"id":"parsing-metadata","dir":"Articles","previous_headings":"Reading humdrum data","what":"Parsing Metadata","title":"Reading and writing data","text":"default, humdrum\\(_{\\mathbb{R}}\\) parses metadata humdrum files reads. includes true global metadata files, encoded humdrum reference records, well local tandem interpretations.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/ReadWrite.html"],"id":"reference-records","dir":"Articles","previous_headings":"Reading humdrum data > Parsing Metadata","what":"Reference Records","title":"Reading and writing data","text":"default, humdrum\\(_{\\mathbb{R}}\\) parses reference records files reads, creating unique field reference key. (one instance given key, combined string separated semicolons.) lot unique reference keys dataset, can end taking lot memory humdrum table. cases, might find useful limit readHumdrum parsing reference records actually going use. can accomplished quite easily reference argument. reference argument defaults \"\", means reference records parsed. However, reference can also character vector reference codes. Thus, parse COM reference record piece. can use rename reference fields like—case, COM reference records parsed saved field called Composer instead COM. don’t want parse reference records, specify reference = NULL.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/ReadWrite.html"],"id":"tandem-interpretations","dir":"Articles","previous_headings":"Reading humdrum data > Parsing Metadata","what":"Tandem Interpretations","title":"Reading and writing data","text":"Tandem interpretations used humdrum data represent “local,” real-time metainformation associated specific spines—review humdrum syntax vignette details. Humdrum\\(_{\\mathbb{R}}\\) can read arbitrary tandem interpretations humdrum data. However, non-standard interpretations used, humdrum\\(_{\\mathbb{R}}\\) way knowing parse . default, humdrum\\(_{\\mathbb{R}}\\) always reads tandem interpretations field called Tandem. field tabulates tandem interpretations far appeared spine order, concatenating single comma-delimited, recent distant. instance, Tandem field spine parsed , interpretations pile longer longer string piece progresses. Notice \"D:\" \"C:\" interpretations get piled separately, just like interpretation, even though tandem class, \"D:\" supersede \"C:\". ? Well, general way know arbitrary tandem interpretations class. create humdrum data new interpretations , humdrum\\(_{\\mathbb{R}}\\) doesn’t know parse , just pile like Tandem field. Fortunately, humdrum\\(_{\\mathbb{R}}\\) know parse many standard tandem interpretations. run command see currently ten classes tandem interpretations humdrumR recognizes, associated regular expression. Thus, really apply readHumdrum file recognize tokens \"C:\" \"D:\" match known regular expression Key tandem interpretation, parse field called Key, look like: Likewise, ’d get TimeSignature BPM fields.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/ReadWrite.html"],"id":"custom-tandems","dir":"Articles","previous_headings":"Reading humdrum data > Parsing Metadata > Tandem Interpretations","what":"Custom Tandems","title":"Reading and writing data","text":"readHumdrum tandems argument allows us take control tandem interpretation parsing process. tandems character vector, defaulting known, parses known interpretations fields (following knownInterpretations table). can use tandems two ways. 1.) can remove \"known\" vector specify Name specific tandem interpretations want parse. instance, write tandem = \"Clef\", Clef pattern knownInterpretations table parsed, (others). 2.) character string tandems \"known\" exact match Name knownInterpretations, instead treated regular expression match new tandem interpretation class. instance, tandems = \"[Aa]pple|[Bb]anana\" match “*Apple”, “*apple”, “*Banana”, “*banana,” parsing four patterns field (called [Aa]pple|[Bb]anana]). give field name writing tandems = c(Fruit = \"[Aa]pple|[Bb]anana\"). (fact, can rename known interpretations well, instance writing tandems = c(Meter = \"TimeSignature\".) tandems = NULL, tandem interpretations parsed —can used shorten parsing time.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Reshaping.html"],"id":"filtering-data","dir":"Articles","previous_headings":"","what":"Filtering Data","title":"Shaping humdrum data","text":"first step might remove data don’t need. article, ’ll show common, basic, ways might filter data. details humdrum\\(_{\\mathbb{R}}\\) filtering functionality, check data filtering article.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Reshaping.html"],"id":"indexing","dir":"Articles","previous_headings":"Filtering Data","what":"Indexing","title":"Shaping humdrum data","text":"example, studying tonality, might simply want ignore lyric data. easiest way index spines don’t want, either using numeric indices exclusive interpretation:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Reshaping.html"],"id":"parsing-token","dir":"Articles","previous_headings":"Filtering Data","what":"Parsing Token","title":"Shaping humdrum data","text":"file, **kern spines example file include rhythmic data (**recip) pitch data. just studying tonality, extract just pitch information Token field, save new field. example, can use kern extract pitch information Token, put new field—let’s call Pitch. new Pitch field, can still access original Token field. can see easily setting “active” field back Token:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Reshaping.html"],"id":"splittingseparating-data","dir":"Articles","previous_headings":"","what":"Splitting/Separating Data","title":"Shaping humdrum data","text":"Humdrum data often packs multiple pieces information compact, concise, readable tokens. classic example, course, **kern often includes rhythm, pitch, phrasing, beaming, pitch ornamentation information! tokens great reading/writing, analyzing, typically want separate information want.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Reshaping.html"],"id":"pitch-and-rhythm","dir":"Articles","previous_headings":"Splitting/Separating Data","what":"Pitch and Rhythm","title":"Shaping humdrum data","text":"’ve seen, **kern spines example file include rhythmic data (**recip) pitch data. cases, might want access pieces information, separately. can separate applying different functions Token field, saving output new fields. example, uses pitch function extract pitch information saves new field call Pitch uses recip function extract rhythm information saves new field call Rhythm. (course, choose different names new fields, instead Pitch Rhythm.) can use either new fields, , call within.humdrumR, make active fields see print:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Reshaping.html"],"id":"pastingaligning","dir":"Articles","previous_headings":"","what":"Pasting/Aligning","title":"Shaping humdrum data","text":"next step might align/combine information currently separated. many humdrum\\(_{\\mathbb{R}}\\) datasets, multiple pieces information spread across multiple spines, cases, across spine paths stops. , given research question, need think multiple pieces information describing single data point, ’ll reshape data. example, example file **silbe (lyric) spines associate syllable exactly one note adjacent **kern spines.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Reshaping.html"],"id":"folding-data","dir":"Articles","previous_headings":"Pasting/Aligning","what":"Folding Data","title":"Shaping humdrum data","text":"powerful approach aligning separated data “folding” information new field using family “folding functions.” Folding means taking information one spine, path, stop, moving new data field “top ” another spine. means taking, example, data Spine 2 putting new field Spine 1.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Reshaping.html"],"id":"lyrics","dir":"Articles","previous_headings":"Pasting/Aligning > Folding Data > Folding Spines","what":"Lyrics","title":"Shaping humdrum data","text":"example, want align notes **kern spines syllables **silbe spine. can directly using foldHumdrum: use fold argument indicate spine fold, onto argument indicate spine move onto. Notice second spine disappeared, now new field called Result1, first (onto) spine, containing data old Spine 2. **silbe spines like : datasets, might different numbers **kern/**silbe spines different files within dataset. Though foldHumdrum can handle case, usually easier use special foldExclusive function, folds based exclusive interpretation. Just specify fold onto arguments character strings matching names exclusive interpretations file: Notice foldExclusive automatically folded **sible spines onto respective **kern spines, new field name.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Reshaping.html"],"id":"harmonic-interval","dir":"Articles","previous_headings":"Pasting/Aligning > Folding Data > Folding Spines","what":"Harmonic Interval","title":"Shaping humdrum data","text":"Let’s consider another common use case “folding” humdrum data. Lots humdrum files multiple spines **kern. cases, research question lead us think note, across spines, individual data points. However, research question concerns harmonic intervals (combinations pitches happening time) might think record multiple pitches single data observation. case, might want fold kern data one spine, top another! can using foldHumdrum well: now cross tabulate two spines data:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Reshaping.html"],"id":"harmony-spreading-data","dir":"Articles","previous_headings":"Pasting/Aligning > Folding Data > Folding Spines","what":"Harmony (Spreading Data)","title":"Shaping humdrum data","text":"another common use case, might one spine data actually describes happening entire record data. example, example’s **harm spine. chords indicated spine associated pitches , either, **kern spines. Luckily, foldHumdrum foldExclusive given onto spines fold spines, fold spine duplicated fill one target spines: harm spine copied new field “top ” **kern spines!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Reshaping.html"],"id":"folding-stops-and-paths","dir":"Articles","previous_headings":"Pasting/Aligning > Folding Data","what":"Folding Stops and Paths","title":"Shaping humdrum data","text":"Though spines common structure humdrum data might need “fold,” can also fold structures. course, depends questions trying ask data! Consider example, multi-stop chords **kern spine: default, humdrum\\(_{\\mathbb{R}}\\) treats token (note) stop separate data observation, row humdrum table. studying harmony, might want align stops “top” , different fields. Try foldStops function! working spine paths, often less obvious interpret different paths terms data observations, want fold , can using foldPaths: Note foldPaths something little bit different: wherever “folding” path null (non-existent) copies data base path. means get two complete copies melody, identical spine path, different different paths. get one melody (Token field) going 4c 4d 4e 4d 2c 2B another melody (new Token_Path field) going 4c 4d 4e 4f 2g 2g. option can used folding functions well, setting argument fillFromField == TRUE.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Reshaping.html"],"id":"folding-grace-notes","dir":"Articles","previous_headings":"Pasting/Aligning > Folding Data","what":"Folding Grace Notes","title":"Shaping humdrum data","text":"functionality hasn’t implemented yet. Bug us !","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Reshaping.html"],"id":"other-folding","dir":"Articles","previous_headings":"Pasting/Aligning > Folding Data","what":"Other Folding","title":"Shaping humdrum data","text":"Using foldHumdrum, also possible fold data structures. obvious example, folding consecutive records bars top . ’m sure want ! , use argument foldHumdrum.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Reshaping.html"],"id":"collapsing-data","dir":"Articles","previous_headings":"Pasting/Aligning","what":"Collapsing Data","title":"Shaping humdrum data","text":"TBA","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RhythmAndMeter.html"],"id":"durations","dir":"Articles","previous_headings":"","what":"Durations","title":"Time, rhythm, and meter in humdrumR","text":"fundamental unit rhythm “duration”—span time. Humdrum\\(_{\\mathbb{R}}\\) defines suite rhythm functions, notably recip() duration(). functions work essentially way: take input argument output rhythm (duration) information particular format. example, Notice functions recognize rhythm part input tokens, ignoring non-rhythm (pitch) information. want keep non-rhythm part tokens, use inPlace argument: cool thing functions can read function’s output. can things like: complete list basic pitch functions : recip (reciprocal note values) notehead (traditional note-value symbols) duration (Whole notes) quarters (quarter notes/crotchets) dur (durations time) seconds ms (milliseconds)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RhythmAndMeter.html"],"id":"documentation","dir":"Articles","previous_headings":"Durations","what":"Documentation","title":"Time, rhythm, and meter in humdrumR","text":"global documentation rhythm functions can seen calling ?rhythmFunctions. can also call documentation individual function, like ?recip.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RhythmAndMeter.html"],"id":"rhythm-arguments","dir":"Articles","previous_headings":"Durations","what":"Rhythm Arguments","title":"Time, rhythm, and meter in humdrumR","text":"rhythm functions previous section shared arguments understand: scale parse(unit).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RhythmAndMeter.html"],"id":"scale-and-unit","dir":"Articles","previous_headings":"Durations","what":"Scale and Unit","title":"Time, rhythm, and meter in humdrumR","text":"scale parse(unit) arguments conceptually different, can used acheive similar transformations, can easy confuse . scale argument easiest understand: simply (re)scales output duration function. like augment durations? Perhaps doubling length? Simply specify scale = 2. maybe ’d like diminish durations, cutting thirds? unit argument can passed rhythm input parser adding argument parse(unit = ...) call. Rather transforming output, argument controls parser interprets input unit. useful numeric values. might get bunch duration values numbers, like c(1, 1.5, 2, 1, 0.5, 1). unit numbers counting? default, humdrum\\(_{\\mathbb{R}}\\) treats whole notes, 0.5 half note, right? However, might prefer think numbers units quarter notes—common approach. Let’s look output change: can see, achieve difference output using scale argument (scale = 1/4), unit argument little bit different way thinking .","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RhythmAndMeter.html"],"id":"ioi","dir":"Articles","previous_headings":"Durations > Special Cases","what":"IOI","title":"Time, rhythm, and meter in humdrumR","text":"**kern data, durations correspond rests music, rather notes, indicated \"r\". many analyses, want ignore rests just consider durations (timespans) notes, ignoring presence rests. called inter-onset-intervals, IOIs. ioi() function can used convert duration data includes rests, IOIs. example: ? duration rest append duration previous non-rest (). first 8g becomes 4g 4d# becomes 4.d#. Rests replaced null tokens (\".\"). last note even NA, onsets create inter-onset-interval. last step makes conceptual sense, may want! Maybe ’d like interval last onset end data? , specify finalOnset = TRUE: used call () within(), ioi() automatically applied within Files/Spines/Paths.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RhythmAndMeter.html"],"id":"ties","dir":"Articles","previous_headings":"Durations > Special Cases","what":"Ties","title":"Time, rhythm, and meter in humdrumR","text":"similar case inter-onset-intervals ties. **kern, [, _, ] tokens used indicate groups durations actually played single, longer duration. untie() function automatically sum durations tied notes: tie tokens removed, tied-notes replaced null tokens (\".\").","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RhythmAndMeter.html"],"id":"timeline","dir":"Articles","previous_headings":"","what":"Timeline","title":"Time, rhythm, and meter in humdrumR","text":"Traditional musical scores, humdrum data, encode rhythmic information duration, like worked previous section. However, often want think musical events happening, relative fixed reference: usually, relative beginning piece. can compute timeline sequences duration values, using timeline() function. Let’s say melody like: Let’s look timeline melody: first note (4c) occurs zero (beginning) timeline; last note (2c) lands 3.5 whole-notes later; etc. combine call semits() (check [Pitch Tonality][PitchAndTonality.html] guide) can even make plot melody:  timeline() function extra special functionality working actual humdrum datasets using () within(). automatically (unless told ) calculate timelines separately within File/Spine/Path dataset, ignoring multiple stops. example:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RhythmAndMeter.html"],"id":"controlling-the-start","dir":"Articles","previous_headings":"Timeline","what":"Controlling the Start","title":"Time, rhythm, and meter in humdrumR","text":"’ll notice timelines start zero, makes sense course. cases, might want timeline start different value. example, “Row Row Row Boat” round, ’d want second entrance round start second measure. can start argument timeline:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RhythmAndMeter.html"],"id":"pickups","dir":"Articles","previous_headings":"Timeline > Controlling the Start","what":"Pickups","title":"Time, rhythm, and meter in humdrumR","text":"pickup argument gives us another option control timeline starts. many datasets, first events music anacrusis “pick ”; ’d generally like timeline start pickup. make happen, pickup argument can passed logical vector length input (x): TRUE values beginning vector considered pickup; Thus, first FALSE value pickup vector chosen start th timeline. example, let’s say melody first two notes pickup. Since can see pickup duration .25 (quarte-note), use start argument : Now 0 downbeat, events start negative timeline! logical pickup argument, : might seem less intuitive! However, approach can useful working actual humdrumR datasets. many humdrum datasets, pickup measures indicated barlines labeled =0 =-. humdrum\\(_{\\mathbb{R}}\\) reads file, counts barlines creates field called Bar, numbers pickup measures zero (negative numbers, one). means pickups Bar < 1. , Bach chorales: Now 0 timelines corresponds first downbeat spine, file. key advantage work even different pieces corpus pickups different lengths, even pickup.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RhythmAndMeter.html"],"id":"timestamp","dir":"Articles","previous_headings":"Timeline > Controlling the Start","what":"Timestamp","title":"Time, rhythm, and meter in humdrumR","text":"timestamp() function special variant timeline() outputs timeline clock-time, using dur() format. order timestamp() needs know tempo: default, () within() pass BPM field humdrum data (one) timestamp(). BPM argument provided, default 60 bpm.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RhythmAndMeter.html"],"id":"counting-beats","dir":"Articles","previous_headings":"","what":"Counting Beats","title":"Time, rhythm, and meter in humdrumR","text":"Ok, timeline() gives us timeline whole-note units, giving fractional (decimal) output. Often music, want know many beats ellapsed given time, rather exact time position. , use count(), beat argument. default beat whole-note, count() count whole note : Let’s try quarter-notes instead: count() even work irregular beat patterns, must entered list. example, meter 7/8 often played three beats, last beat longer first two: pattern line 4 4 4.. count() can count irregular beats! handy counting subdivisions swing time!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RhythmAndMeter.html"],"id":"subposition","dir":"Articles","previous_headings":"Counting Beats","what":"Subposition","title":"Time, rhythm, and meter in humdrumR","text":"counterpart count() subpos(). count beats, notes don’t actually land beat, somewhere “inside” beat—words, beats. subpos() tell us far beat attack ; unit whole-notes, unless pass scale argument change scale. Let’s look last examples , using subpos():","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RhythmAndMeter.html"],"id":"meter","dir":"Articles","previous_headings":"","what":"Meter","title":"Time, rhythm, and meter in humdrumR","text":"count() subpos() commands great want count single beat/measure unit. take things next level(s), need consider musical meter. point view humdrum\\(_{\\mathbb{R}}\\), “meter” set multiple “beat levels” occuring time, “lower” (faster/shorter) levels nested inside “higher” (slower/longer) levels. R Hm defines number useful tools applying metric analyses rhythmic data.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/RhythmAndMeter.html"],"id":"metric-levels","dir":"Articles","previous_headings":"Meter","what":"Metric levels","title":"Time, rhythm, and meter in humdrumR","text":"first thing might want , take sequence rhythm durations, identify metric level onset lands . , use metlev(): default, metlev() assuming duple meter us—basically 4/4 time—eight eighth-notes make one measure 4/4. first onset lands downbeat, coinciding highest level meter (defined default)—highest level beat whole-note, output \"1\" ([recip()] notation whole-note). Every odd eighth-note falls eigth-note beat level, labeled \"8\". 4/4 beats 2 4 (back beats) fall quarter-note level, labeled \"4\". Finally, beat 3 half-note level (\"2\"). prefer levels simply numbered highest lowest, use metlev(..., value = FALSE): whole-note level 1 (case) eighth-note level 4.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Summary.html"],"id":"summarizing-structure","dir":"Articles","previous_headings":"","what":"Summarizing Structure","title":"Getting to know your data","text":"basic information ’ll want humdrum dataset “big” —much data ? Printing humdrumR object command line always tell many files data: can also call length() get number. census() function, however, gives us much detail size data, telling us many records, tokens, characters : corpus contains, total, 4,738 1,300. (unique) column tells us many unique Tokens per file (overall, bottom). (per token) column indicates average number characters file, overall. Notice census() defaults counting records/tokens. want count data tokens, specify census(chorales, dataTypes = 'D').","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Summary.html"],"id":"spines-and-interpretations","dir":"Articles","previous_headings":"Summarizing Structure","what":"Spines and Interpretations","title":"Getting to know your data","text":"work humdrum data, really need know many spines (spine paths) present data, interpretations present. spines() interpretations() functions give us just information! toy dataset 10 chorales, output spines() pretty boring: chorales four spines, spine paths. interpretations() output also boring, see 10 files four **kern exclusive interpretations; However, interpretations() also tells tandem interpretations recognizes—case, tempo, key, instrument, time signature information. chorales dataset structurally homogeneous, generally good thing—’s much easier analyze sort data! However, humdrum datasets heterogeneous, spines() interpretations() come handy. Let’s switch another one pre-packaged corpora, Beethoven/Mozart variations (see read/write): Now see something interesting. , files four spines, eleven files include spine paths (\"9 1 path\" \"2 2 paths\"). Let’s check output interpretations(): Ah, time see file **function **harm spine, well two **kern spines. fact, “Tallies” bottom tells us 20 files exclusive interpretations (order), humdrum\\(_{\\mathbb{R}}\\) labels {}: **function, **harm, **kern, **kern.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Summary.html"],"id":"summarizing-metadata","dir":"Articles","previous_headings":"","what":"Summarizing Metadata","title":"Getting to know your data","text":"Another question ask dataset kind meta data encoded data’s reference records. function reference() answers question us: see ten chorale files , example COM CDT reference records, two OTL@@EN record. sure codes mean? can also call reference() character-string reference code: see actual reference records , can index result call reference() column row. example, see ODT@@DE records: see reference records third file:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Summary.html"],"id":"summarizing-data","dir":"Articles","previous_headings":"","what":"Summarizing Data","title":"Getting to know your data","text":"next thing , getting started humdrum\\(_{\\mathbb{R}}\\) data analysis, get sense data content . tokens data actually contain? R’s unique(), table(), sort() functions perfect . ’ll need use .humdrumR() function apply commands data’s Token field—fully explained working data article. Let’s get unique values, sorted: Unlike unique(), table() count unique value, can sort see common tokens: Now get sense content dataset—case, lot different (unique) tokens!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/Summary.html"],"id":"digging-into-details","dir":"Articles","previous_headings":"Summarizing Data","what":"Digging into Details","title":"Getting to know your data","text":"point ’re starting get better picture content dataset. don’t get hasty—’s good idea dig little get confident really know data. call interpretations() told us expect **kern data, representing musical “notes” (pitch rhythm). probably expected see things like 4. (dotted quarter note) f# (F sharp middle-C). X 4dnX? Js Ls ;s? can look **kern definition, point , probably didn’t know took look! might think know ’s data…get unpleasantly surprised. especially true less mature (newer) datasets, DEFINITELY CONTAIN ERRORS. see lot ; tokens output. look , ’ll learn “pause signs”, used represent fermatas. many tokens fermatas? Let’s use %~% operator, allows us search matches (regular expression) pattern vector. case, want search \";\" Token. %~% returns logical value (TRUE FALSE), can sum() get count TRUEs: 256 ; tokens data. use within instead (get rid sum()), can see fermatas appear: Ah, see fermatas tend happen time across four spines. Good know!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/WorkingWithData.html"],"id":"with-and-within-you","dir":"Articles","previous_headings":"","what":"With and within you","title":"Working with humdrum data","text":"key functions working humdrum\\(_{\\mathbb{R}}\\) data objects within. functions allow get “inside” data. Basically, call /within, data fields within data become available , .","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/WorkingWithData.html"],"id":"with","dir":"Articles","previous_headings":"With and within you","what":"With","title":"Working with humdrum data","text":"Let’s start . call humdrum\\(_{\\mathbb{R}}\\) data object first argument. second argument can arbitrary R expression like, can use fields humdrum data. “expression” just valid bit R code; example, 2 + 2, c(1, 2, 3), (x - mean(x))^2, nchar(letters) |> mean() examples expressions. “arbitrary R expression” just fancy way saying R code want. execute R command, R “evaluates” expression(s) returns results. starting point, lets tabulate tokens dataset. first load humdrum data, original data tokens always put field called Token. use awesome built-R function, table, tabulate unique tokens Token field. However, can’t access Token field directly; just write expression table(Token) ’ll get error—R able “find”, say “Error: object 'Token' found.” Instead, use enter data, R can “see” Token (data fields): worked! However, ’s lot unique tokens data, kind mess. Let’s take page pitch vignette extract just pitch information using kern function: Much better! Notice whole expression kern(Token) |> table() executed within data. expressions can get complicated want. Let’s add call sort: Ah, now can clearly see top 10 common notes data e, , g, d, b, B, , f#, c, E. last step might make plot. ’ll use built tail function grab top (last) 10, built-barplot function.  Notice writing big complex expression like ’s helpful spread expression across multiple lines. |> (pipe) operator great place .","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/WorkingWithData.html"],"id":"within","dir":"Articles","previous_headings":"With and within you","what":"Within","title":"Working with humdrum data","text":"many cases, want apply functions humdrum data, keep humdrum/humdrum\\(_{\\mathbb{R}}\\) structure place. within . just returns ever output commands , within (attempt ) put results commands “back inside” humdrum\\(_{\\mathbb{R}}\\) data object, new field. example, let’s say want translate kern data different pitch representation, like scientific pitch. can pitch command. use … just get notes! Let’s try within instead: Now get humdrum\\(_{\\mathbb{R}}\\) data back, Token data transformed **kern **pitch. Notice, now two “Data fields” listed bottom: Token (original data) Result1—default name new fields produced within, yes, get higher numbers keep making new fields. “Result1” informative, ’s actually good idea give new fields specific names. can assigning expressions within:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/WorkingWithData.html"],"id":"withwithin-subsets","dir":"Articles","previous_headings":"","what":"With/Within Subsets","title":"Working with humdrum data","text":"real power within functions, comes additional “control” arguments can pass. Two prominent examples allow automatically work subsets data: subset arguments. can indicate subset, multiple subsets, expressions evaluated separately within subset.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/WorkingWithData.html"],"id":"with-subset","dir":"Articles","previous_headings":"With/Within Subsets","what":"With Subset","title":"Working with humdrum data","text":"subset argument indicates subset data evaluate “within.” subset argument must expression evaluates logical vector (TRUE FALSE). main command evaluated wherever subset expression evaluates TRUE. Let’s try tabling example. Maybe want table tokens first spine: see low notes, ’d expect bass voice. , let’s tabulate even-numbered bars: datasets measures indicated (= tokens), Bar field integers counting bars within piece. want even numbers, can ask Bar modulo 2 zero?: Bar %% 2 == 0. use subset argument within, parts data don’t match within expression returned null: Notice, new Pitch field NULL spine except spine 1.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/WorkingWithData.html"],"id":"or-else","dir":"Articles","previous_headings":"With/Within Subsets > With Subset","what":"Or else…","title":"Working with humdrum data","text":"many cases using subset ’d like something , least keep, “” part data—complement subset. can expressing “complement” expression. idea say “evaluate X Y true, otherwise evaluate instead.” easiest understand use within example . Maybe want calculate simple pitch first spine, leave spines unchanged: pattern, comp = Token quite common.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/WorkingWithData.html"],"id":"with-subgroups","dir":"Articles","previous_headings":"With/Within Subsets","what":"With Subgroups","title":"Working with humdrum data","text":"keyword arguments short “group .” can indicate field data group data —main call applied separately group, groups returned. Let’s try tabling example. Let’s group data spine, tabulate spine data (voice) separately! get four different tables, one spine. want make multiple plots, can just add barplot like .  Let’s try something slightly different: Since four spines represent bass, tenor, alto, soprano voices (order) ’d expect average pitch spine significantly different. Let’s convert pitch data semitones (using semits) add call base-R function mean: Watch Oops, didn’t work! ’s Token data rests, like 4r. semits function doesn’t know read 4r returns NA value. Don’t worry, easy fix, good lesson data analysis general R particular. always need keep mind data “missing” Applicable (NA). R math functions option ignore missing data setting na.rm = TRUE (NA remove): ’s expected! course, might prefer plot.  Notice something differently ! don’t want make separate plot group-calculation—just single number spine. want make plot four numbers, put barplot call (outside) call. Notice can also control labels barplot using names.arg argument. Maybe want inspect whole histogram pitches voice. can use base-R hist function; Since want histogram spine, want put hist “inside” call :  Pro tips: setting xlim (x-limit) argument, make sure four barplots cover ranges pitches, comparable. also set main argument (figure title) using Instrument field, gives us names instrument. ’s right, can refer /fields humdrum data! (datasets tandem interpretation, wouldn’t always work.)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/WorkingWithData.html"],"id":"advanced-grouping","dir":"Articles","previous_headings":"With/Within Subsets > With Subgroups","what":"Advanced Grouping","title":"Working with humdrum data","text":"can group data arbitrary grouping data. fact keyword argument can complex expression, long output length input. example, maybe ’d like reproduce histograms, lumping male (bass/tenor) female (alto/soprano) voices together.  expression Spine < 3 returns FALSE spines 1 2 (bass tenor) TRUE spines 3 4. two categories (FALSE TRUE) used group data.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/articles/WorkingWithData.html"],"id":"recycling-results","dir":"Articles","previous_headings":"With/Within Subsets","what":"Recycling results","title":"Working with humdrum data","text":"cases, ’d like perform command within data might output smaller vector input, including single value, still want reconstruct data fully. R, usually called “recycling”—.e., repeating value matches certain length. using within, can cause results recycled full field length using recycle argument expression. useful want group something, fill group value: command ? looks every bar file finds lowest note, “fills” notes bar , single, note. calculate harmonic interval bar’s bass note:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/authors.html"],"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Nathaniel Condit-Schultz. Author, maintainer. Claire Arthur. Author.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/authors.html"],"id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Condit-Schultz N, Arthur C (2019). “humdrumR: New Take Old Approach Computational Musicology.” Proceedings International Society Music Information Retrieval, 715–722. doi:10.5281/zenodo.3527910, https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html"],"id":"humdrum_mathbbr","dir":"","previous_headings":"","what":"humdrumR","title":"humdrumR","text":"Welcome main website humdrumℝ!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html"],"id":"what-is-humdrum_mathbbr","dir":"","previous_headings":"","what":"What is humdrumℝ?","title":"humdrumR","text":"Humdrumℝ R package: “library” preexisting code R programming language. Humdrumℝ code provides tools visualization, manipulation, analysis data formatted humdrum syntax. Note: name package pronounced hum-drum-ARRRRR, last syllable emphasized pirate fashion. name always typeset hμmℝΔrμm. Failure pronounce typeset hμmℝΔrμm correctly void warranty.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html"],"id":"what-is-humdrum","dir":"","previous_headings":"What is humdrumℝ?","what":"What is humdrum?","title":"humdrumR","text":"Humdrum system computational musicology developed David Huron. Humdrum “universe” includes two parts: data format called humdrum syntax musicological software system called humdrum toolkit. Humdrumℝ meant modernized replacement original humdrum toolkit, leveraging power R give us unprecedented power manipulate analyze humdrum data using concise, expressive syntax. Humdrumℝ mainly used manipulate analyze data encoded humdrum syntax /humdrum interpretations like **kern. humdrum syntax incredibly flexible, powerful, scheme encoding musical data. Tens thousands musical scores (musical data) encoded humdrum syntax, many available online repositories KernScores. humdrum syntax vignette gives detailed introduction data format.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html"],"id":"what-is-r","dir":"","previous_headings":"What is humdrumℝ?","what":"What is R?","title":"humdrumR","text":"R programming language, designed ground statistical computing data analysis. R many features make ideal data analysis, particularly research analysis background programming. R primer introduces core concepts R programming.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html"],"id":"what-can-humdrum_mathbbr-do","dir":"","previous_headings":"","what":"What can humdrumℝ do?","title":"humdrumR","text":"Humdrumℝ provides number tools working humdrum data generally, musicological analysis. Humdrumℝ seven main things:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html"],"id":"represent-humdrum-data-in-r","dir":"","previous_headings":"What can humdrumℝ do?","what":"Represent humdrum data in R","title":"humdrumR","text":"represent humdrum data R, humdrumℝ defines special data type—humdrumR class—call “humdrumR objects” throughout documentation. important part humdrumR object “humdrum table” contains. can read humdrum-syntax data represented getting started humdrumR vignette.  details, read humdrumR class humdrum table; humdrumℝ installed loaded, can read directly R session typing ?humdrumR-class ?humTable.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html"],"id":"read-and-write-humdrum-data","dir":"","previous_headings":"What can humdrumℝ do?","what":"Read and write humdrum data","title":"humdrumR","text":"create humdrumR data objects, humdrumℝ includes humdrum data parser, finds humdrum data local machine, reads R, creates humdrumR object data. Reading writing data vignette best place realm works. can get details readHumdrum() writeHumdrum() documentation; humdrumℝ installed loaded, can read directly R session typing ?readHumdrum ?writeHumdrum.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html"],"id":"reshape-humdrum-data","dir":"","previous_headings":"What can humdrumℝ do?","what":"“Reshape” humdrum data","title":"humdrumR","text":"’ve imported humdrum data R, next step often organize prepare data. ’ll often want pick specific subsets data, rearrange data representations easier work . Humdrumℝ gives us number powerful tools “shaping data”: Shaping humdrum data Filtering humdrum data vignettes best places learn processes. can find details sub-setting data subset.humdrumR() indexHumdrum documentation; humdrumℝ installed loaded, can read directly R session typing ?subset.humdrumR ?indexHumdrum.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html"],"id":"analyze-humdrum-data","dir":"","previous_headings":"What can humdrumℝ do?","what":"Analyze humdrum data","title":"humdrumR","text":"Humdrumℝ makes easy manipulate, modify, analyze humdrum data. Working humdrum data vignette gives overview functionality. can find details withinHumdrum documentation; humdrumℝ installed loaded, can read directly R session typing ?withinHumdrum.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html"],"id":"manipulate-musical-pitch-information","dir":"","previous_headings":"What can humdrumℝ do?","what":"Manipulate (musical) pitch information","title":"humdrumR","text":"Humdrumℝ defines tools manipulating numerous representations pitch tonality, including diatonic keys tertian harmonies. Pitch tonality vignette explains work pitch data humdrumℝ. can find details humdrumPitch documentation; humdrumℝ installed loaded, can read directly R session typing ?humdrumPitch.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html"],"id":"manipulate-musical-rhythm-information","dir":"","previous_headings":"What can humdrumℝ do?","what":"Manipulate (musical) rhythm information","title":"humdrumR","text":"Humdrumℝ defines tools manipulating numerous representations rhythm, timing, meter. Rhythm meter vignette explains work rhythmic information humdrumℝ. can find details humdrumRhythm documentation; humdrumℝ installed loaded, can read directly R session typing ?humdrumRhythm.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html"],"id":"develop-new-humdrum-tools","dir":"","previous_headings":"What can humdrumℝ do?","what":"Develop new humdrum tools","title":"humdrumR","text":"facilitate development new functions work humdrum tokens—simple character strings packed information—, Humdrumℝ provides several useful development tools, including struct data type useful API call regular-expression dispatch system, makes easy dispatch different methods based matches regular expressions.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html"],"id":"installing-r","dir":"","previous_headings":"Installing humdrumℝ","what":"Installing R","title":"humdrumR","text":"use humdrumℝ, ’ll first need install R, version 4.1 later. highly recommend install Integrated Development Environment RStudio well! link—Installing R RStudio—good starting place.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html"],"id":"installing-humdrum_mathbbr-1","dir":"","previous_headings":"Installing humdrumℝ","what":"Installing humdrumℝ","title":"humdrumR","text":"Humdrumℝ yet available standard R package repository, CRAN, (now) can installed github repository. install latest version (master branch) humdrumℝ, ’ll first need install R package devtools—devtools used creating maintaining R packages. Luckily, devtools CRAN, open R session machine type: successfully installed devtools, now ready use install humdrumℝ straight github. R session, type:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html"],"id":"humdrum_mathbbr-source","dir":"","previous_headings":"Installing humdrumℝ > Installing humdrumℝ","what":"Humdrumℝ source","title":"humdrumR","text":"Another option—useful, want inspect, contribute , humdrumℝ source code—actually download humdrumℝ package source github install directly. ’ll first need install git. git installed computer, can download humdrumℝ repository clicking “Clone download” github page. Alternatively, can use git directly: navigate directory machine ’d like save package source type: ’ve done , can install source computer using devtools: Open R session use setwd move working directory inside repository just downloaded (.e., cloned). , type downloaded RStudio, can make humdrumℝ RStudio “Project” local computer, enables useful features. RStudio, click “New Project > Existing Directory” option select directory downloaded repository. project created, can install local copy humdrumℝ clicking “Install Restart” RStudio’s “Build” pane. ’ve completed installation humdrumℝ can used simply calling:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html"],"id":"updating-humdrum_mathbbr","dir":"","previous_headings":"Installing humdrumℝ","what":"Updating humdrumℝ","title":"humdrumR","text":"Humdrumℝ active development, new features added, documentation updated, bugs fixed weekly basis. recommend keep date newest version humdrumℝ. Luckily, can easily update latest version simply running devtools::install_github() command R session. However, already loaded humdrumRℝ library R session—using library(humdrumR)—’ll need “detach” old version new version work. can either 1) quitting R studio opening , 2) going RStudio’s package panel unchecking humdrumR, 3) running command detach(\"package:humdrumR\", unload = TRUE). installed humdrumℝ source using git clone command, can’t simply run clone . Instead, navigate package directory run git pull origin main. “pull” latest changes local machine. can rerun devtools::install().","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/index.html"],"id":"learning-humdrum_mathbbr","dir":"","previous_headings":"","what":"Learning humdrumℝ","title":"humdrumR","text":"learn use humdrumℝ “Articles” list top page best place start—particular, Getting started humdrumR article! Documentation specific functions general topics can found “Reference” section. humdrumℝ installed, can also access documentation directly R sessions. R command line, use ? operator name function topic see documentation:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/LO5th.html"],"dir":"Reference","previous_headings":"","what":"Line of Fifths — LO5th","title":"Line of Fifths — LO5th","text":"function LO5th S3-generic function methods extract \"line--fifths\" value various pitch objects representations.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/LO5th.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Line of Fifths — LO5th","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/LO5th.html"],"id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Line of Fifths — LO5th","text":"Returns integer vector array, matching input.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/LO5th.html"],"id":"the-line-of-fifths","dir":"Reference","previous_headings":"","what":"The Line of Fifths","title":"Line of Fifths — LO5th","text":"Every interval Western music associated integer line fifths: Bb = m7 = -2 F =  P4  = -1 C =  P1 = 0 G =  P5 = 1 D =  M2 = 2 =  M6 = 3 E =  M3 = 4 B =  M7 = 5 F# = A4 = 6 etc. natural notes (C) major scale---also call generic intervals---fall range -1:5. fact, diatonic key block seven consecutive numbers line--fifths: example, Eb major -4:2. \"Sharps\" \"flats\" represent +7 -7 line--fifths respectively.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/REparser.html"],"dir":"Reference","previous_headings":"","what":"Parse String Using Regular expressions — REparser","title":"Parse String Using Regular expressions — REparser","text":"Takes input string parses sequence regular expressions.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/REparser.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse String Using Regular expressions — REparser","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/REparser.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parse String Using Regular expressions — REparser","text":"exhaustive TRUE, string must exhaustively broken matching regular expressions. Superfluous (non-match) characters begginning, end, bettween matches, result NA returned. ------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/RegexFind.html"],"dir":"Reference","previous_headings":"","what":"Match strings against regular expression — RegexFind","title":"Match strings against regular expression — RegexFind","text":"functions give concise way search regular expressions character vectors. \"infix\" functions, meaning write function two arguments: myvector %~% regex.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/RegexFind.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match strings against regular expression — RegexFind","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/RegexFind.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Match strings against regular expression — RegexFind","text":"x character vector search . Must character. regex One regular expressions. Must character. one regex supplied, matches regexes returned. (See \"Multiple regexes\" section.)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/RegexFind.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Match strings against regular expression — RegexFind","text":"version function returns different type information regex matches () input vector: %~l%: returns logical (TRUE/FALSE) indicating x matches. %~%: returns integer indicating indices matches x. %~n%: returns integer indicating number (count) matches string. %~m%: returns character string matched string . Returns NA match. basic function (%~%) %~l%. also negative versions l functions: giving strings match given regular expression. %!~%, %!~l%, %!~%. functions simply syntactic sugar existing R regular expression matching functions: %~l%: base::grepl() %~%: base::grep() %~n%: stringi::stri_count_regex() %~m%: stringi::stri_extract_first_regex()","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/RegexFind.html"],"id":"multiple-regexes","dir":"Reference","previous_headings":"","what":"Multiple regexes","title":"Match strings against regular expression — RegexFind","text":"one regex supplied, %~l% %~% return indices regexes match. case %~n%, matching regex counted separately, summed. case %~m%, matches () pasted together, including multiple matches string.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/accidental.html"],"dir":"Reference","previous_headings":"","what":"Extract accidental from pitch. — accidental","title":"Extract accidental from pitch. — accidental","text":"Use want extract accidentals pitch data, discarding octave step information. Set explicitNaturals = FALSE want explicit naturals.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/accidental.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract accidental from pitch. — accidental","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/accidental.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract accidental from pitch. — accidental","text":"x Input data parse pitch information. x argument can (atomic) vector, tonalInterval, NULL. ... Arguments passed pitch deparser. also two hidden (advanced) arguments can specify: memoize deparse (see details ). generic \"specific\" pitch information (accidentals qualites) discarded? Defaults FALSE. Must singleton logical value: /switch. simple \"compound\" pitch information (octave/contour) discarded? Defaults FALSE. Must singleton logical value: /switch. Key input Key used parser, deparser, transposer. Defaults NULL. Must diatonicSet something coercable diatonicSet; must either length 1 length(x) transposeArgs optional list arguments passed special transpose() call. Defaults empty list(). Must list named arguments transpose(). parseArgs optional list arguments passed pitch parser. Defaults empty list(). Must list named arguments pitch parser. inPlace non-pitch information retained output string. Defaults FALSE. Must singleton  logical value: /switch. argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/accidental.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract accidental from pitch. — accidental","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/bhatk.html"],"dir":"Reference","previous_headings":"","what":"Swara representation — bhatk","title":"Swara representation — bhatk","text":"Swara syllabes used represent scale degrees hindustani music---like solfege.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/bhatk.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Swara representation — bhatk","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/bhatk.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Swara representation — bhatk","text":"x Input data parse pitch information. x argument can (atomic) vector, tonalInterval, NULL. ... Arguments passed pitch deparser. also two hidden (advanced) arguments can specify: memoize deparse (see details ). generic \"specific\" pitch information (accidentals qualites) discarded? Defaults FALSE. Must singleton logical value: /switch. simple \"compound\" pitch information (octave/contour) discarded? Defaults FALSE. Must singleton logical value: /switch. Key input Key used parser, deparser, transposer. Defaults NULL. Must diatonicSet something coercable diatonicSet; must either length 1 length(x) transposeArgs optional list arguments passed special transpose() call. Defaults empty list(). Must list named arguments transpose(). parseArgs optional list arguments passed pitch parser. Defaults empty list(). Must list named arguments pitch parser. inPlace non-pitch information retained output string. Defaults FALSE. Must singleton  logical value: /switch. argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/bhatk.html"],"id":"basic-pitch-arguments","dir":"Reference","previous_headings":"","what":"Basic pitch arguments","title":"Swara representation — bhatk","text":"pitch function standard arguments control details output. important generic simple arguments, allow control type pitch information returned.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/bhatk.html"],"id":"generic-vs-specific","dir":"Reference","previous_headings":"","what":"Generic vs Specific","title":"Swara representation — bhatk","text":"generic = TRUE, specific pitch information (accidentals qualities) omitted output. alternative way controlling functionality, can use specific argument, specific == !generic. case atonal functions, \"generic\" version pitch output: example, semits('c#', generic = TRUE) return 0, \"generic\" version C# C, corresponds 0. However, note generic version pitch follows key, semits('c#', generic = TRUE, Key = ':') return 1!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/bhatk.html"],"id":"simple-vs-compound","dir":"Reference","previous_headings":"","what":"Simple vs Compound","title":"Swara representation — bhatk","text":"simple = TRUE, compound pitch information (octave contour) omitted output. alternative way controlling functionality, can use compound argument ,compound == !simple. actually one way might want divide compound intervals simple octave parts. example, might like call output -M2 (descending major 2nd) +m7 (ascending minor 7th octave ). functionality can controlled octave.round argument: see pitch deparsing documentation.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/bhatk.html"],"id":"key","dir":"Reference","previous_headings":"","what":"Key","title":"Swara representation — bhatk","text":"Key argument must diatonicSet, something can parsed one. Key argument passed parser, deparser, transpose---unless alternate Key passed transposeArgs parseArgs. Various deparsing options use Key argument; example, use implicitSpecies (see advanced parsing section) dependent Key. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function---means, cases, need explicitly anything Key argument! (want happen, need explicitly specify Key argument, Key = NULL.)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/bhatk.html"],"id":"parse-arguments","dir":"Reference","previous_headings":"","what":"Parse arguments","title":"Swara representation — bhatk","text":"parseArgs argument must list() (named) arguments passed input parser. example, input representation uses \"X\" represent double sharps, specify kern('CX5', parseArgs = list(doublesharp = 'X')) get correct result (\"cc##\"). convenient shorthand, \"syntactic sugar,\" can specify parseArgs alternate way: Simply input parse(args...) unnamed argument pitch function. example, can get exact result typing kern('CX5', parse(doublesharp = 'X')).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/bhatk.html"],"id":"transpose-arguments","dir":"Reference","previous_headings":"","what":"Transpose arguments","title":"Swara representation — bhatk","text":"transposeArgs argument must list() (named) arguments passed internal call transpose(), allowing us easily transpose pitch information. example, type kern(c('C', 'D', 'E'), transposeArgs = list(= 'M9')) can get output c('d', 'e', 'f#'). possible transpose args : (tonalInterval, length == 1 | length == (x)) (diatonicSet, length == 1 | length == (x))  (diatonicSet, length == 1 | length == (x)) real (logical, length == 1) transposition real tonal? relative (logical, length == 1) key-wise transposition based relative parallel keys? convenient shorthand, \"syntactic sugar,\" can specify transposeArgs alternate way: Simply input transpose(args...) unnamed argument pitch function. example, can get exact result typing kern(c('C', 'D', 'E'), transpose(= 'M9')).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/bhatk.html"],"id":"transposing-by-interval","dir":"Reference","previous_headings":"","what":"Transposing by interval","title":"Swara representation — bhatk","text":"calling transpose() directly, argument can anything coercable tonalInterval, output transposed amount. real = FALSE, tonal transposition (within Key) performed. details transposition behavior, check transpose() docs.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/bhatk.html"],"id":"transposing-by-key","dir":"Reference","previous_headings":"","what":"Transposing by key","title":"Swara representation — bhatk","text":"Another way transposing specifying input (\"\") key output (\"\") key. default, Key argument passed transpose , nothing actually happens. Thus, specify either key key, transposition happen /key Key. course, specify transposition happen keys specify. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function. specify key, Key field passed transpose key, result, pitches input transposed whatever keys target () key! real relative arguments give special control key-wise transposition works, check transpose() docs details!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/bhatk.html"],"id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Swara representation — bhatk","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/bhatk.html"],"id":"pitch-gamut-levels","dir":"Reference","previous_headings":"","what":"Pitch-Gamut Levels","title":"Swara representation — bhatk","text":"table() automatically generate factor levels pitch data using gamut() function. makes sure tabulated data sorted logical order, includes missing pitches. simple/complex  generic/specific arguments automatically passed gamut(); additional arguments can passed gamut using gamutArgs = list(...), syntactic sugar gamut(...). (Read gamut() docs explanation gamut generation.) feature used control table layout pitch data, well assure consistent tables grouping data. inPlace = TRUE special tabulation occur.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/bhatk.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Swara representation — bhatk","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/bpm2sec.html"],"dir":"Reference","previous_headings":"","what":"Translate between durations and tempos — bpm2sec","title":"Translate between durations and tempos — bpm2sec","text":"Functions translating durations (seconds) tempos---expressed BPM (beats-per-minute). \"beats\" beats-per-minute specified using unit argument; unit defaults .25 (quarter-note), conventional.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/bpm2sec.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Translate between durations and tempos — bpm2sec","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/bpm2sec.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Translate between durations and tempos — bpm2sec","text":"BPM tempo. Defaults 60. Must number character string format \"MM120\" (120 bpm). default, ().humdrumR passes BPM field, present. unit \"Beat\" BPM. Defaults quarter-note. Must value can interpreted rhythmic duration.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/bpm2sec.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Translate between durations and tempos — bpm2sec","text":"pairs functions involving ms (milliseconds) sec (seconds), identical except change scale seconds milliseconds.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/census.html"],"dir":"Reference","previous_headings":"","what":"Tabulate records and tokens in a humdrumR corpus — census","title":"Tabulate records and tokens in a humdrumR corpus — census","text":"census tabulates raw \"size\" humdrumR corpus, including total number records tokens. census one humdrumR's basic corpus summary functions.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/census.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tabulate records and tokens in a humdrumR corpus — census","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/census.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tabulate records and tokens in a humdrumR corpus — census","text":"humdrumR HumdrumR data. Must humdrumR data object. dataTypes types humdrum records include census. Defaults \"GLIMDd\". Must character. Legal values 'G', 'L', '', 'M', 'D', 'd' combination (e.g., \"LIM\"). (see humdrum table documentation Fields section explanation.). arbitrary expression indicates group data. Defaults Piece (humdrumR data field). removeEmpty Whether include zero tokens. Defaults FALSE Must singleton logical value: /switch. set TRUE, groups zero tokens included humCensus table. drop Whether return normal data.table humCensus table. Defaults FALSE. Must singleton logical value: /switch. drop = TRUE, normal data.table returned instead humCensus table. Index rows. numeric, selects rows index. character, string matched  regular expression \"-group\" names.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/census.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tabulate records and tokens in a humdrumR corpus — census","text":"census returns special data.frame called humCensus table. humCensus table five columns information: Records total number records. Tokens total number tokens. (unique) number unique tokens Characters total number characters. (includes humdrum control characters like * !!.) (per token) simply Characters / Tokens, indicating mean length token. default, census tabulates data within pieces corpus, piece tabulated row humCensus table. Rows labeled file name. humCensus object printed, totals across pieces printed well---(unique) (per token) values calculated across pieces well, summed. argument can used tabulate data across divisions data (see next section).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/census.html"],"id":"tabulate-by-other-groups","dir":"Reference","previous_headings":"","what":"Tabulate \"by\" other groups","title":"Tabulate records and tokens in a humdrumR corpus — census","text":"argument census indicates groupings data tabulate within, grouping across pieces corpus default. can arbitrary expression evaluated inside humdrum table, like groupby argument /within call. expression must full length humdrum table.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/census.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tabulate records and tokens in a humdrumR corpus — census","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/chord.html"],"dir":"Reference","previous_headings":"","what":"","title":"","text":"function outputs generic \"jazz\" chord symbol representation tonal harmony.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/chord.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/chord.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"","text":"x atomic vector. x argument can (atomic) vectors Key diatonic key used parser, deparser, transposer. Defaults NULL, interpreted C major. Must diatonicSet something coercable diatonicSet; must either length 1 length(x). transposeArgs optional list arguments passed transpose() call. Defaults empty list(). Must list named arguments transpose(). parseArgs optional list arguments chord parser. Defaults empty list(). Must list named arguments chord parser. inPlace non-chord information retained output string. Defaults FALSE. Must singleton logical value: /switch.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/chord.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/chordDeparsing.html"],"dir":"Reference","previous_headings":"","what":"Generating (","title":"Generating (","text":"humdrumR includes easy--use system generating variety tertian harmony (chord) representations, can flexibly modified users. \"hood\" humdrumR represents tonal chord information using underlying representation, typically extracted input data using chord parser. representation can \"deparsed\" variety predefined output formats (like **harm), new formats create!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/chordDeparsing.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generating (","text":"Deparsing second step chord function processing pipeline: Input representation |> Parsing |> Intermediate (tertianSet) representation |> Transformation  |> Deparsing (DEPARSING ARGS GO ) |> Output representation Various pitch representations can generated using predefined chord functions like chord() tertian(), roman(). functions use common deparsing framework, specified using different combinations arguments deparser. modifying \"deparsing\" arguments, can exercise fine control want pitch information represented output.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/chordFunctions.html"],"dir":"Reference","previous_headings":"","what":"Parsing and deparsing chord information — chordFunctions","title":"Parsing and deparsing chord information — chordFunctions","text":"functions can used extract \"translate,\" otherwise modify, data representing tertian harmony information. functions :","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/chordFunctions.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parsing and deparsing chord information — chordFunctions","text":"x atomic vector. x argument can (atomic) vectors Key diatonic key used parser, deparser, transposer. Defaults NULL, interpreted C major. Must diatonicSet something coercable diatonicSet; must either length 1 length(x). parseArgs optional list arguments chord parser. Defaults empty list(). Must list named arguments chord parser. transposeArgs optional list arguments passed transpose() call. Defaults empty list(). Must list named arguments transpose(). inPlace non-chord information retained output string. Defaults FALSE. Must singleton logical value: /switch.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/chordFunctions.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parsing and deparsing chord information — chordFunctions","text":"chord() figuredBass() harm() roman() tertian()","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/chordParsing.html"],"dir":"Reference","previous_headings":"","what":"Parsing chord information — chordParsing","title":"Parsing chord information — chordParsing","text":"humdrumR includes easy--use powerful system parsing tertian harmony information: various basic chord representations (including numeric character-string representations) can \"parsed\"---read interpreted humdrumR. part, parsing automatically happens \"behind scenes\" whenever use humdrumR chord function, like harm() roman(), chord().","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/chordParsing.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parsing chord information — chordParsing","text":"","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/collapseHumdrum.html"],"dir":"Reference","previous_headings":"","what":"","title":"","text":"collapseHumdrum allows collapse data field across across groups within data indicated argument. Data \"collapsed\" either pasting data string, putting list. collapseStops, collapsePaths, collapseRecords built-calls collapseHumtab, additional optimizations.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/collapseHumdrum.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/collapseHumdrum.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"","text":"humdrumR HumdrumR data. Must humdrumR data object. Fields collapse data within. Must character. Must character string partially matching name(s) data field(s) humdrumR input. Data collapseField collapsed within fields. collapseField target field humdrumR data collapse. Defaults getActiveFields(humdrumR)[1]. Must single character string. dataTypes types humdrum record(s) collapse. Defaults \"GLIMDd\". Must character. Legal values 'G', 'L', '', 'M', 'D', 'd' combination (e.g., \"LIM\"). (See humdrum table documentation Fields section explanation.) collapseAtomic Whether collapse data character strings. Defaults TRUE. Must singleton logical value: /switch. TRUE, data collapsed single character string. FALSE, data conctanated list. sep separator collapsed strings. Defaults \" \" (space). Must single character string. effect collapseAtomic == TRUE.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/context.html"],"dir":"Reference","previous_headings":"","what":"Create arbitrary ","title":"Create arbitrary ","text":"context() command can used group input data (vectors) arbitrary contextual windows. Unlike contextual-grouping can achieve groupby arguments various functions (expressions ().humdrumR)), context() can produce windows overlap , opposite case, exhaustively divide data. context() generally used special argument ().humdrumR), can also called directly .","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/context.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create arbitrary ","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/context.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create arbitrary ","text":"x Input data group windows. Must atomic vector. open \"open\" (start) windows. Can natural numbers, logical vectors (length x), single character string (interpreted regular expression). May also arbitrary expression returns natural numbers; expression can refer named elements reference, end (last index), close, prevclose (previous close). close \"close\" (end) windows. Can natural numbers, logical vectors (length x), single character string (interpreted regular expression). May also arbitrary expression returns natural numbers; expression can refer named elements reference, end (previous index), open, nextopen (next open). reference Vector(s) use identify window open/closes. Defaults x. Must either atomic vector length x, list()/data.frame vectors, named. overlap overlapping windows treated/created? Defaults 'paired'. Must single character, partially matching either \"paired\", \"nested\", \"edge\", \"none\". depth \"deep\" can windows overlap? Defaults NULL. Must NULL, vector non-zero whole numbers. rightward window alignment/overlap determined left right? Defaults TRUE. Must singleton logical value: /switch. duplicate_indices Can index open/close multiple windows? Defaults TRUE. Must singleton logical value: /switch. min_length, max_length minimum/maximum lengths output windows. Default two infinity (maximum) respectively. Must single, positive whole numbers. inPlace output padded length input? Defaults FALSE. Must singleton logical value: /switch. complement input \"outside\" windows, output? Defaults FALSE. Must singleton logical value: /switch. alignToOpen 'inPlace' output aligned open window? Defaults TRUE. Must singleton logical value: /switch. collapse output windows collapsed single character strings? Defaults TRUE. Must singleton logical value: /switch. sep Separator collapsed output. Defaults comma (\",\"). Must single character string. stripRegex regular expressions matched open/close arguments removed output? Defaults FALSE. Must singleton logical value: /switch. groupby Optional vectors group windows within. Defaults empty list(). Must list(), either empty contains vectors length x. calls /within.humdrumR, groupby passed list(Piece, Spine, Path) default. Windows cross group boundaries.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/context.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create arbitrary ","text":"context() takes input vector (x) divides windows based content reference vector, must length x--- default, x reused reference, windows based input x . complex option, reference can named list() data.frame (nrow == length(x))--- (named) elements reference visible open close arguments (see ). collapse, inPlace, complement arguments windows output. \"complement\" refers elements input vector fall inside indicated windows: complement = FALSE (default), \"outside\" values dropped; complement = TRUE, retained. inPlace = TRUE, windows output vector length input, padded NA needed---otherwise (default), windows returned collapse = TRUE, windows collapsed strings (separed sep), otherwise, list() windows returned.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/context.html"],"id":"defining-windows","dir":"Reference","previous_headings":"","what":"Defining windows","title":"Create arbitrary ","text":"system context() uses define/identify windows data quite sophisticated, can take time master! basic idea must indicate want windows start (\"open\") want end (\"close\"): indicate using open close arguments. arguments simple indicate indices input vector; example, want window open 4th 11th indices, close 15th 24th index, can write (using built-letters vector practice):   quite trivial. However, open close arguments can actually arbitary expressions number special tricks, including refering . example, either argument includes call hop(), hop() automatically applied along input vector. Consider example:   example, hop() command generates open indices every odd number 1 25. close argument references open indices, adds 3 --- result pairs like 1:4, 2:5, 3:6, 4:7, etc. give hop() different arguments (like ), can modify process. fact, use default value hop() (1), can use approach create standard N-grams. minimum maximum length windows can controlled using min_length max_length arguments. can also indicate open/closes providing logical vectors (length x). mentioned , reference named list() data.frame(), open close refer elements reference. useful want open/close windows reference multiple vectors:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/context.html"],"id":"regular-expressions","dir":"Reference","previous_headings":"","what":"Regular Expressions","title":"Create arbitrary ","text":"either open close provided character string, string treated regular expression matched reference vector. exaple, make windows alphabet starting ending vowel:   (Notice can use alignToOpen argument change output aligned.) stripRegex = TRUE (default), matching open close regular expressions removed output. can useful character/tokens used indicate windows longer needed windowing done.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/context.html"],"id":"special-references","dir":"Reference","previous_headings":"","what":"Special References","title":"Create arbitrary ","text":"open close arguments special behaviors. like windows close right next window opens? can making close argument refer next open, referring nextopen object:   Conversely, open can refer prevclose close:   Notice called context(letters, open = '[aeiou]', close = nextopen - 1L), window opening \"u\" returned. \"nextopen\" open close . can instead provide context() alternative, using | ():   know exactly long input vector ? Refer end object:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/context.html"],"id":"nested-windows","dir":"Reference","previous_headings":"","what":"Nested Windows","title":"Create arbitrary ","text":"common use case context() analyzing phrases indicated music. **kern, phrases indicated opening (() close ()) parentheses, can capture regular expressions open close. example:   Perfect. However, nested phrasing indicators?   want! default, context() \"pairs\" open next close, often makes sense. case, want different behavior. can get want specifying overlap = 'nested':   Now context aligns open corresponding close nesting level. interested highest (lowest) level nesting? Use depth argument, can non-zero integers: highest level 1, \"deeper\" levels incrementing .   can also use negative depth specify deepest levels outward. example, case  depth == -1 get us deepest level:   depth NULL (default), depths returned.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/context.html"],"id":"controlling-overlap","dir":"Reference","previous_headings":"","what":"Controlling Overlap","title":"Create arbitrary ","text":"options controlling windows can, , overlap. Perhaps like look every melodic phrase moving (dominant) (tonic).   output probably want. , context() (default) pairs opening next close already paird. case, means third getting pairs third , even though another ! might want try either \"edge\" \"none\" options overlap argument:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/context.html"],"id":"repeated-indices","dir":"Reference","previous_headings":"","what":"Repeated Indices","title":"Create arbitrary ","text":"Note duplicates_indices = TRUE (default) open close arguments can incorporate repeated indices, including multiple matches regular expression index. useful , example, nested phrases:   cases, might want turn duplicate_indices = FALSE.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/context.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create arbitrary ","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/count.html"],"dir":"Reference","previous_headings":"","what":"Count beats or measures — count","title":"Count beats or measures — count","text":"count() function takes vector rhythmic duration values counts (musical sense) number beats (measures) occurred since starting point, associating rhythmic onsets beat. subpos() function paired count(), computing far (rhythmic time) onset associated beat; subpos() returns 0, means onset beat. Finally, onbeat() simply convenient shorthand subpos() == 0, returning logical vector indicating onsets fall beat.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/count.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count beats or measures — count","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/count.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count beats or measures — count","text":"dur input vector rhythmic durations. Must character numeric vector. parsed using rhythmInterval(); Wherever input parsed duration, element treated duration zero. beat size \"beat\" (measure) count. Defaults whole-note (one measure 4/4 time). Must character numeric vector, list vectors; must singleton length dur. parsed duration using rhythmInterval(); input parsed duration, output NA. start number start counting . Must single whole-number value (either numeric integer). phase phase offset onsets beats. Defaults 0. Must character numeric vector; must length 1 length dur; duration phase must smaller smallest duration value beat. parsed duration using rhythmInterval(); input parsed duration, error occurs. pickup Indicates leading values input pickups, . Defaults NULL. Must NULL, logical vector length dur. offBeats -beat onsets numbered output, NA? Defaults TRUE. Must single logical value: /switch. groupby Optional vectors group count within. Defaults empty list(). Must list(), either empty contains vectors length dur. function -record timeline, groupby list must include named Piece Record vectors. Luckily, automatically passed ().humdrumR, need worry !","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/count.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Count beats or measures — count","text":"many basic use cases, using count() essentially using floor(timeline()). However, count() gives us additional options add musicological power compared timeline(). (count() also starts 1 0, timeline() .) first beat input vector assigned value start argument, defaults start = 1L. 'zeroth' count, first beat occurs instant starting time---.e., first onset input vector. Every rhythmic onset associated one beat, multiple onsets may occur within beat---thus output count() assigns (rounds) onset previous beat onset. However, offBeats = FALSE, onsets land beat counted, offbeat values returning NA. phase controls offbeat onsets associated nearby beats. phase parsed rhythmic value must rhythmic values smaller smallest beat value. phase argument shifts \"boundary\" beats backwards, beat onset. default, phase = 0 beat-association boundary lands beat: onsets beat \"belong\" beat. phase = '8', beat boundary pushed back capture one eighth-note beat . can used , example, associate last 3/8s measure next measure (like pick ups); achieved command like count(dur, beat = '1', phase = 3/8).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/count.html"],"id":"-beats-","dir":"Reference","previous_headings":"","what":"\"Beats\"","title":"Count beats or measures — count","text":"beat argument used indicate size beat want count. default beat whole note, equivalent measure M4/4 time. beat argument uses rhythm parser, can understand beat values input variety formats: thus, specify quarter-note beats either beat = '4' beat = 0.25. parser also understands parse (full) duration time signature: example, beat = 'M3/4' use dotted-half-note beat ('2.').","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/count.html"],"id":"changing-meter","dir":"Reference","previous_headings":"","what":"Changing meter","title":"Count beats or measures — count","text":"data changing meters (either pieces, within pieces), can specify beat argument vector length dur, indicating beat size moment/index. feature easy use dataset includes time signature interpretations, like \"*M4/4\"; interpetations, present, automatically read field called TimeSignature. dataset, can simply pass TimeSignature field beat argument count(), measures piece correctly counted (even changing!): count(x, beat = TimeSignature). Alternatively, can use tactus() command extract tactus beat time signature, like count(x, beat = tactus(TimeSignature)).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/count.html"],"id":"irregular-meter","dir":"Reference","previous_headings":"","what":"Irregular meter","title":"Count beats or measures — count","text":"musical meters consist pattern irregular beats. example, meter M7/8 often realized two \"short\" beats (two eigth-notes ) one \"long\" beat (three eigth-notes), forming 2 + 2 + 3 pattern. want count eighth-note, can simply specify beat = '8' get M7/8 beats counted c(1, 3, 5). However, want count short long beat single unit, must specify desired pattern list beat durations: example, beat = list(c(\"4\", \"4\", \"4.\")). see two cases look like, applied two M7/8 measures straight eighth-notes:   accommodate changing meters, beat argument can still accept list patterns, long list length dur.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/count.html"],"id":"pickups","dir":"Reference","previous_headings":"","what":"Pickups","title":"Count beats or measures — count","text":"Another option pass pickup argument logical vector length input dur. Within piece/group, block TRUE values beginning pickup vector indicate pickup. first index pickup logical FALSE used location beat 1: earlier (pickup == TRUE) points negative counts, counting backwards start. humdrumR, datapoints first barline record (=) labeled Bar == 0 Bar field. Thus, common use pickup argument within(humData, count(Token, pickup = Bar < 1), makes downbeat first complete bar 1 stating point---notes pickup bars give negative counts. Note never 'beat zero'. Beats starting point progress directly -1 1 (start). result, arithmetic math beat \"counts\" can problematic using pickup argument. may better use round(timeline()) cases want much math counts.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/count.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Count beats or measures — count","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/crossEntropy.html"],"dir":"Reference","previous_headings":"","what":"Calculate cross entropy between two distributions — crossEntropy","title":"Calculate cross entropy between two distributions — crossEntropy","text":"TBA","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/crossEntropy.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate cross entropy between two distributions — crossEntropy","text":"","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/crossentropy.html"],"dir":"Reference","previous_headings":"","what":"Calculate cross entropy between two distributions — crossentropy","title":"Calculate cross entropy between two distributions — crossentropy","text":"TBA","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/crossentropy.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate cross entropy between two distributions — crossentropy","text":"","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/degree.html"],"dir":"Reference","previous_headings":"","what":"Tonal scale degree representation (absolute) — degree","title":"Tonal scale degree representation (absolute) — degree","text":"humdrum **degree **deg interpretations represent Western \"scale degrees\" two slightly different formats. **degree representation, octave pitch represented \"absolutely,\" standard octave scheme scientific pitch. **deg representation, octave pitch indicated relative previous pitch--- \"^\" indicates pitch higher previous pitch \"v\" indicates pitch lower previous pitch.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/degree.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tonal scale degree representation (absolute) — degree","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/degree.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tonal scale degree representation (absolute) — degree","text":"x Input data parse pitch information. x argument can (atomic) vector, tonalInterval, NULL. ... Arguments passed pitch deparser. also two hidden (advanced) arguments can specify: memoize deparse (see details ). generic \"specific\" pitch information (accidentals qualites) discarded? Defaults FALSE. Must singleton logical value: /switch. simple \"compound\" pitch information (octave/contour) discarded? Defaults FALSE. Must singleton logical value: /switch. Key input Key used parser, deparser, transposer. Defaults NULL. Must diatonicSet something coercable diatonicSet; must either length 1 length(x) transposeArgs optional list arguments passed special transpose() call. Defaults empty list(). Must list named arguments transpose(). parseArgs optional list arguments passed pitch parser. Defaults empty list(). Must list named arguments pitch parser. inPlace non-pitch information retained output string. Defaults FALSE. Must singleton  logical value: /switch. argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/degree.html"],"id":"basic-pitch-arguments","dir":"Reference","previous_headings":"","what":"Basic pitch arguments","title":"Tonal scale degree representation (absolute) — degree","text":"pitch function standard arguments control details output. important generic simple arguments, allow control type pitch information returned.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/degree.html"],"id":"generic-vs-specific","dir":"Reference","previous_headings":"","what":"Generic vs Specific","title":"Tonal scale degree representation (absolute) — degree","text":"generic = TRUE, specific pitch information (accidentals qualities) omitted output. alternative way controlling functionality, can use specific argument, specific == !generic. case atonal functions, \"generic\" version pitch output: example, semits('c#', generic = TRUE) return 0, \"generic\" version C# C, corresponds 0. However, note generic version pitch follows key, semits('c#', generic = TRUE, Key = ':') return 1!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/degree.html"],"id":"simple-vs-compound","dir":"Reference","previous_headings":"","what":"Simple vs Compound","title":"Tonal scale degree representation (absolute) — degree","text":"simple = TRUE, compound pitch information (octave contour) omitted output. alternative way controlling functionality, can use compound argument ,compound == !simple. actually one way might want divide compound intervals simple octave parts. example, might like call output -M2 (descending major 2nd) +m7 (ascending minor 7th octave ). functionality can controlled octave.round argument: see pitch deparsing documentation.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/degree.html"],"id":"key","dir":"Reference","previous_headings":"","what":"Key","title":"Tonal scale degree representation (absolute) — degree","text":"Key argument must diatonicSet, something can parsed one. Key argument passed parser, deparser, transpose---unless alternate Key passed transposeArgs parseArgs. Various deparsing options use Key argument; example, use implicitSpecies (see advanced parsing section) dependent Key. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function---means, cases, need explicitly anything Key argument! (want happen, need explicitly specify Key argument, Key = NULL.)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/degree.html"],"id":"parse-arguments","dir":"Reference","previous_headings":"","what":"Parse arguments","title":"Tonal scale degree representation (absolute) — degree","text":"parseArgs argument must list() (named) arguments passed input parser. example, input representation uses \"X\" represent double sharps, specify kern('CX5', parseArgs = list(doublesharp = 'X')) get correct result (\"cc##\"). convenient shorthand, \"syntactic sugar,\" can specify parseArgs alternate way: Simply input parse(args...) unnamed argument pitch function. example, can get exact result typing kern('CX5', parse(doublesharp = 'X')).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/degree.html"],"id":"transpose-arguments","dir":"Reference","previous_headings":"","what":"Transpose arguments","title":"Tonal scale degree representation (absolute) — degree","text":"transposeArgs argument must list() (named) arguments passed internal call transpose(), allowing us easily transpose pitch information. example, type kern(c('C', 'D', 'E'), transposeArgs = list(= 'M9')) can get output c('d', 'e', 'f#'). possible transpose args : (tonalInterval, length == 1 | length == (x)) (diatonicSet, length == 1 | length == (x))  (diatonicSet, length == 1 | length == (x)) real (logical, length == 1) transposition real tonal? relative (logical, length == 1) key-wise transposition based relative parallel keys? convenient shorthand, \"syntactic sugar,\" can specify transposeArgs alternate way: Simply input transpose(args...) unnamed argument pitch function. example, can get exact result typing kern(c('C', 'D', 'E'), transpose(= 'M9')).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/degree.html"],"id":"transposing-by-interval","dir":"Reference","previous_headings":"","what":"Transposing by interval","title":"Tonal scale degree representation (absolute) — degree","text":"calling transpose() directly, argument can anything coercable tonalInterval, output transposed amount. real = FALSE, tonal transposition (within Key) performed. details transposition behavior, check transpose() docs.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/degree.html"],"id":"transposing-by-key","dir":"Reference","previous_headings":"","what":"Transposing by key","title":"Tonal scale degree representation (absolute) — degree","text":"Another way transposing specifying input (\"\") key output (\"\") key. default, Key argument passed transpose , nothing actually happens. Thus, specify either key key, transposition happen /key Key. course, specify transposition happen keys specify. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function. specify key, Key field passed transpose key, result, pitches input transposed whatever keys target () key! real relative arguments give special control key-wise transposition works, check transpose() docs details!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/degree.html"],"id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Tonal scale degree representation (absolute) — degree","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/degree.html"],"id":"pitch-gamut-levels","dir":"Reference","previous_headings":"","what":"Pitch-Gamut Levels","title":"Tonal scale degree representation (absolute) — degree","text":"table() automatically generate factor levels pitch data using gamut() function. makes sure tabulated data sorted logical order, includes missing pitches. simple/complex  generic/specific arguments automatically passed gamut(); additional arguments can passed gamut using gamutArgs = list(...), syntactic sugar gamut(...). (Read gamut() docs explanation gamut generation.) feature used control table layout pitch data, well assure consistent tables grouping data. inPlace = TRUE special tabulation occur.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/degree.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tonal scale degree representation (absolute) — degree","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/delta.html"],"dir":"Reference","previous_headings":"","what":"Lagged differences — delta","title":"Lagged differences — delta","text":"Calculate sequential differences values numeric vectors.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/delta.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lagged differences — delta","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/delta.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lagged differences — delta","text":"x input vector. Must atomic numbers. NULL values returned NULL. lag lag use. Defaults 1. Must single natural number. Results look like: x[] - x[- lag]. skip function indicate values skip. Defaults .na. must function can applied x return logical vector length. TRUE values skipped calculations. default, skip function .na, NA values input (x argument) skipped. skipped values returned output vector. init Initial value fill beginning calculation. Defaults 0. class x; length must longer lag. NA values beginning (end right == TRUE) filled values summing. right init padding \"right\" (end vector)? Defaults FALSE. Must singleton logical value: /switch. default, right == FALSE init padding beginning output. groupby group data. Defaults list(). vector list vectors; must length length(x). Differences calculated across groups indicated groupby vector(s). orderby order calculating difference. Defaults list(). vector list vectors; must length length(x). Differences x calculated based order orderby vector(s), determined base::order().","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/delta.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Lagged differences — delta","text":"delta similar base-R diff(). However, delta favored humdrumR use : output always length  input. achieved padding beginning end output with1 NA values (options). groupby argument, automatically used humdrumR () commands constrain differences within pieces/spines/paths humdrum data. groupby approach (details ) generally faster applying commands within groupby groups. (can) automatically skip NA () values. applied matrix, delta applied separately column, unless margin set 1 (rows) , higher-dimensional array, higher value.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/delta.html"],"id":"initial-padding-values","dir":"Reference","previous_headings":"","what":"Initial/padding values","title":"Lagged differences — delta","text":"lagged pair numbers vector summed/subtracted. leaves abs(lag) numbers end nothing pair . example, lag == 1, indices getting subtracted look like : \\(x_1 - x_?\\) \\(x_2 - x_1\\) \\(x_3 - x_2\\) \\(x_4 - x_3\\) \\(x_5 - x_4\\) lag == 3: \\(x_1 - x_?\\) \\(x_2 - x_?\\) \\(x_3 - x_?\\) \\(x_4 - x_1\\) \\(x_5 - x_2\\) init argument (\"initial\") value, values, pair first lag values. default, init NA, since n + NA n - NA , NA, output vector padded NA values. lag == 3 : \\(x_1 - NA\\) \\(x_2 - NA\\) \\(x_3 - NA\\) \\(x_4 - x_1\\) \\(x_5 - x_2\\) However, init argument can 1 abs(lag) numeric values. result, lag==3 : \\(x_1 - init_1\\) \\(x_2 - init_2\\) \\(x_3 - init_3\\) \\(x_4 - x_1\\) \\(x_5 - x_2\\) right == TRUE, init values placed end, like: \\(x_4 - x_1\\) \\(x_5 - x_2\\) \\(init[1] - x_3\\) \\(init[2] - x_4\\) \\(init[3] - x_5\\) init argument functions similarly init argument Reduce().","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/delta.html"],"id":"negative-lag","dir":"Reference","previous_headings":"","what":"Negative lag","title":"Lagged differences — delta","text":"lag negative, differences simply reversed, resulting numbers equivalent positive lag, * -1. \\(x_1 - NA\\) \\(x_2 - x_1\\) \\(x_3 - x_2\\) \\(x_4 - x_3\\) \\(x_5 - x_5\\) \\(NA - x_1\\) \\(x_1 - x_2\\) \\(x_2 - x_3\\) \\(x_3 - x_4\\) \\(x_4 - x_5\\)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/delta.html"],"id":"grouping","dir":"Reference","previous_headings":"","what":"Grouping","title":"Lagged differences — delta","text":"many cases want perform lagged calculations vector, across certain boundaries. example, vector includes data multiple pieces, want calculate melodic intervals pieces, within pieces. groupby argument indicates one, , grouping vectors, break x (input) argument groups. groupby vectors given, change vector indicates boundary. Value pairs cross groups treated beginning. Basically, using groupby argument function similar identical using tapply(x, groupby, laggedFunction, ...) using groupby expession call ().humdrumR. However, using groupby argument directly usually much faster, specially optimized functions. common use case humdrum data, looking \"melodies\" within spines. , want groupby = list(Piece, Spine, Path). fact, humdrumR () calls automatically feed three fields groupby arguments certain functions: mint, delta, sigma, lag, ditto, ioi, untie, hop. use delta call (), automatically calculate delta \"melodic\" way, within spine path piece. However, wanted, instance, calculate differences across spines (like harmonic intervals) manually set groupby = list(Piece, Record).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/delta.html"],"id":"order","dir":"Reference","previous_headings":"","what":"Order","title":"Lagged differences — delta","text":"performing lagged calculations, typically assume order values input vector (x) order want \"lag\" across. E.g., first element \"\" second element, \"\" third element, etc. [Humdrum tables][humTable] always ordered Piece > Piece > Spine > Path > Record > Stop. Thus, lagged calculations across fields humtable , default, \"melodic\": next element next element spine path. example, consider data:   default order tokens (Token field) b c d e f. wanted instead lag across tokens harmonically (across records) need specifiy different order example, say orderby = list(Pice, Record, Spine)---lagged function interpret Token field d b e c f. another example, note Stop comes last order. consider happens stops data:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/delta.html"],"id":"invertability","dir":"Reference","previous_headings":"","what":"Invertability","title":"Lagged differences — delta","text":"sigma delta functions inverses , meaning right arguments set, sigma(delta(x)) == x delta(sigma(x)) == x. words, two functions \"reverse\" . key init argument needs set 0, arguments (lag, skip, groupby, etc.) need match. actually,  sigma(delta(x, init = 0, ...)) == x delta(sigma(x), init = 0)) == x. take differences values (delta(x)), resulting differences tell us fully reconstruct original unless know \"start\" (constant offset). example, delta(c(5, 7, 5, 6)) == c(NA, 2, -2, 1) know input goes 2, back 2, 1, starting value (first 5) lost. call sigma , get: sigma(c(NA, 2, -2, 1)) == c(0, 2,0, 1) get right contour, offset constant 5. call delta(x, init = 0) necessary constant (first value) kept beginning vector delta(c(5, 7, 5, 6), init = 0) == c(5, 2, -2, 1) sigma gets want, full invertability: sigma(delta(c(5, 7, 5, 6), init = 0)) == c(5, 7, 5, 6) Alternatively, specify necessary constant init argument sigma: sigma(delta(c(5, 7, 5, 6)), init = 5) == c(5, 7, 5, 6) init arguments two functions complementary. Currently, right argument delta complement sigma, invertability holds true right = FALSE (default).","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/diatonicSetS4.html"],"dir":"Reference","previous_headings":"","what":"Tonal (diatonic) sets — diatonicSetS4","title":"Tonal (diatonic) sets — diatonicSetS4","text":"diatonicSet one humdrumR's types tonal data, representing Western diatonic keys. part, users need interact diatonicSets directly---rather, diatonicSets work behind scene numerous humdrumR pitch functions. See keyRepresentations keyTransformations documentation details usage functionality Tonality humdrumR vignette detailed explanation theory specifics diatonicSets.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/diatonicSetS4.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tonal (diatonic) sets — diatonicSetS4","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/diatonicSetS4.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tonal (diatonic) sets — diatonicSetS4","text":"diatonicSet S4 subclass humdrumR's virtual class struct, inherits lot useful \"vector-like\" behaviors/functionality. constructor function dset can used create diatonicSets directly. three arguments corespond three slots: root, mode, alteration. inputs coerced match length. root argument attempt coerce character strings tonalIntervals, use LO5th value root. default, .character method, thus (via struct) show method, diatonicSets call key(). Thus, return diatonicSet command line (call print one one), see key interpretation representation printed.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/diatonicSetS4.html"],"id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Tonal (diatonic) sets — diatonicSetS4","text":"Root integers representing root key line--fifths Signature integers representing signature (number accidentals) key. key represented two integers, Root Signature. Root simply tonic note key circle fifths. Signature value circle fifths, indicating diatonic mode. can think Signature value indicating number accidentals, negative numbers flats positive numbers sharps. can also think signature indicating much \"natural key\" (C major) slid line--fifths. traditional diatonic modes Western music occur wherever Signature - Tonic range -5:1: Signature - Tonic = +1 => Lydian Signature - Tonic = +0 => Major (Ionian) Signature - Tonic = -1 => Mixolydian Signature - Tonic = -2 => Dorian Signature - Tonic = -3 => Minor (Aeolian) Signature - Tonic = -5 => Locrian Signature - Tonic = -4 => Phyrgian Note can make diatonicSets Root outside Key. unusual, may result sets predict. Alteration integers representing alterations diatonic set (details ).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/diatonicSetS4.html"],"id":"alterations","dir":"Reference","previous_headings":"","what":"Alterations","title":"Tonal (diatonic) sets — diatonicSetS4","text":"Alteration slots (also integer) can used represent various \"altered\" scales. integer values interpreted seven-trit balanced ternary string. (\"trits\" ternary equivalent binary \"bits.\") Balanced ternary allows three digits, 0 (unaltered degree), 1 (sharpened degree), -1 (flattened degree). seven trits correspond seven scale degrees line--fifth indicated signature---.e., ordered lowest hightest line--fifths, relative root. (instance, Signature == 0, degrees c(-1, 0, 1, 2, 3, 4, 5).) ternary arrangement maps powers three scale degree, Alteration integer: ± 1: raise flatten 7th scale degree. ± 3: raise flatten 3rd scale degree. ± 9: raise flatten 6th scale degree. ± 27: raise flatten 2nd scale degree. ± 81: raise flatten 5th scale degree. ± 243: raise flatten 1st scale degree. ± 749: raise flatten 4th scale degree. example, consider Alteration == 26: balanced ternary representation, decimal integer 26 represented 1 0 0 1 0 -1 0. (words 1 \"27s  place\" -1 \"ones place\"---.e., 27 - 1). represents raised 2nd (27) lowered 7th (-1). Alteration integer allows us concisely represent 2,187 possible combinations raised lowered diatonic scale degrees! However, combined Signature slot, redundancy scale representation. example, melodic minor scale can represented major scale (Signature - Root == 0) lowered third degree (Alteration == -3) minor scale (Signature - Root == -3) raised 6ths 7ths (Alteration == 10). However, though two representations result set line--fifths, might consider conceptually different contexts, consider redundancy acceptable. Another case encoding redundancy Alteration - 1 (flatten 7th) exactly equivalent Signature - 1. Similarly, Alteration + 749 (raise 4th) exactly equivalent Signature + 1. Double-flat double-sharp degrees encodable diatonicSet. However, combination Signature slot, sets double-flat/sharps (like doubly-diminished 7ths) can encoded.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/diatonicSetS4.html"],"id":"arithmetic","dir":"Reference","previous_headings":"","what":"Arithmetic","title":"Tonal (diatonic) sets — diatonicSetS4","text":"Arithmetic diatonicSets defined. However, number useful arithmetic operations diatonicSets data types defined: XXXX Elaborate XXXX Need implement special logic adding Alterations! (Taking account Signature addition.)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/diatonicSetS4.html"],"id":"relational-operators","dir":"Reference","previous_headings":"","what":"Relational Operators","title":"Tonal (diatonic) sets — diatonicSetS4","text":"diatonicSets can compared using standard relational operations ==, !=. Two diatonicSets equal (according ==) slots (Root, Signature, Alteration) exactly identical. Ordinal comparisons (e.g., >, <=) diatonicSets Signature .","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/diatonicSetS4.html"],"id":"coercion","dir":"Reference","previous_headings":"","what":"Coercion","title":"Tonal (diatonic) sets — diatonicSetS4","text":"humdrumR knows coerce several base-R atomic types diatonicSets. can done using function---e.g., (3, \"diatonicSet\")---intuitively using function diatonicSet(). Coercision methods defined integer: interpreted root major key numeric: rounded nearest integer intepreted root major key character: interpreted using humdrumRs regular expression dispatch system, explained fully .","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/ditto.html"],"dir":"Reference","previous_headings":"","what":"Propagate data points to ","title":"Propagate data points to ","text":"ditto function allow \"fill\" null values vector non-null values earlier/later vector. default, \"forward,\" behavior fills null value previous (lower index) non-null value, . reverse argument can used cause \"backward\" filling, next (higher index) non-null value used. input begins (ends reverse == TRUE) null value, initial argument filled instead; defaults NA.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/ditto.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Propagate data points to ","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/ditto.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Propagate data points to ","text":"x vector. list, atomic, matrix, data.frame. null Defines elements needs filled. Defaults function(x) .na(x) | x == \".\". either logical vector (length(x) == length(null)), numeric vector positive indices, function , applied x returns appropriate logical/numeric vector. initial Padder beginning (end, reverse == TRUE) output, needed. Defaults NA. class x; must length 1. reverse Whether excecution order reversed. Defaults FALSE. Must singleton logical value: /switch. reverse == TRUE, \"non-null\" values coped overwrite null values earlier (lower indices) vector. groupby group data. vector list vectors; must length length(x). segment x delineated groupby vector(s) treated separately. margin vector giving dimensions function applied . Defaults 2 (across columns) matrix inputs. Must natural number(s). E.g., matrix 1 indicates rows, 2 indicates columns. x named dimnames, can character vector selecting dimension names. field field ditto? Must single character string. (partially matched) fields x. newField name new (dittoed) field. Defaults field name appended \"_ditto\". Must single character string.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/ditto.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Propagate data points to ","text":"values considered \"null\" can controlled using null argument. null argument can either logical vector length input (x) argument, numeric vector positive indices, function , applied x returns appropriate logical/numeric vector. values x null == FALSE copied forward/backwards replace adjacent vales null == TRUE. default, null function \\(x) .na(x) | x == '.', means NA values string \".\" \"null\", overwritten adjacent values. ditto methods defined data.frames matrices. data.frame method simply applies ditto column data.frame separately. matrices, ditto can applied across columns (margin == 2), rows (margin == 1), dimensions. ditto method humdrumR object simply applies ditto , default, active field; thus ditto(humData) equivalent within(humData, newField <- ditto(.), dataTypes = 'Dd'). field argument can used indicated different field apply . result dittoing saved new field---newField argument can used control name new field.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/ditto.html"],"id":"grouping","dir":"Reference","previous_headings":"","what":"Grouping","title":"Propagate data points to ","text":"many cases want perform lagged calculations vector, across certain boundaries. example, vector includes data multiple pieces, want calculate melodic intervals pieces, within pieces. groupby argument indicates one, , grouping vectors, break x (input) argument groups. groupby vectors given, change vector indicates boundary. Value pairs cross groups treated beginning. Basically, using groupby argument function similar identical using tapply(x, groupby, laggedFunction, ...) using groupby expession call ().humdrumR. However, using groupby argument directly usually much faster, specially optimized functions. common use case humdrum data, looking \"melodies\" within spines. , want groupby = list(Piece, Spine, Path). fact, humdrumR () calls automatically feed three fields groupby arguments certain functions: mint, delta, sigma, lag, ditto, ioi, untie, hop. use delta call (), automatically calculate delta \"melodic\" way, within spine path piece. However, wanted, instance, calculate differences across spines (like harmonic intervals) manually set groupby = list(Piece, Record).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/ditto.html"],"id":"order","dir":"Reference","previous_headings":"","what":"Order","title":"Propagate data points to ","text":"performing lagged calculations, typically assume order values input vector (x) order want \"lag\" across. E.g., first element \"\" second element, \"\" third element, etc. [Humdrum tables][humTable] always ordered Piece > Piece > Spine > Path > Record > Stop. Thus, lagged calculations across fields humtable , default, \"melodic\": next element next element spine path. example, consider data:   default order tokens (Token field) b c d e f. wanted instead lag across tokens harmonically (across records) need specifiy different order example, say orderby = list(Pice, Record, Spine)---lagged function interpret Token field d b e c f. another example, note Stop comes last order. consider happens stops data:","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/draw.html"],"dir":"Reference","previous_headings":"","what":"Visualize data — draw","title":"Visualize data — draw","text":"draw() function humdrumR's goto plotting function. draw() can make variety graphs, depending type data give . part, draw() simply stylish, easy use wrapper around base-R graphics functions plot(), barplot(), hist().","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/draw.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize data — draw","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/draw.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Visualize data — draw","text":"draw() generic function, different plots depending data pass x y arguments. x y numeric: scatter plot. x numeric : histogram. y numeric : quantile plot. x table: barplot. y numeric, x character factor: violin plot. standard arguments base-R plots can used customize plots. See par() full list.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/duple.html"],"dir":"Reference","previous_headings":"","what":"Generate duple meters — duple","title":"Generate duple meters — duple","text":"function generates meter() objects representing duple meters. desired number duple levels controlled nlevels argument. span meter (.e., highest level) indicated measure argument. Finally, tactus argument indicates level (indexe highest lowest) tactus. default arguments build 4/4 meter levels ranging whole-notes sixteenth-notes, quarter-note tactus.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/duple.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate duple meters — duple","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/duple.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate duple meters — duple","text":"nlevels number duple levels. Must singleton, positive natural number measure duration top level meter. Must singleton numeric character value. parsed duration rhythmInterval(); failure parse leads error. tactus level tactus? Must singleton, positive natural number; must less equal nlevels.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/duration.html"],"dir":"Reference","previous_headings":"","what":"Numeric (double) representation of durations — duration","title":"Numeric (double) representation of durations — duration","text":"Output numeric (real number).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/duration.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Numeric (double) representation of durations — duration","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/duration.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Numeric (double) representation of durations — duration","text":"x input  vector. x argument can (atomic) vector, rational (rhythmInterval), NULL. Must parsable rhythm infromation. ... Arguments passed rhythm parser. also two hidden (advanced) arguments can specify: memoize deparse (see details ). parseArgs optional list arguments passed rhythm parser. Defaults empty list(). Must list named arguments rhythm parser. scale numeric rational value used output unit measurement. Defaults rational(1, 1). Must numeric rational. inPlace non-rhythm information retained output string? Defaults FALSE. Must singleton  logical value: /switch. Defaults FALSE. singleton logical value, NA. See \"Grace notes\" section .","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/duration.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Numeric (double) representation of durations — duration","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/entropy.html"],"dir":"Reference","previous_headings":"","what":"Calculate Entropy or Information Content of variables — entropy","title":"Calculate Entropy or Information Content of variables — entropy","text":"Information content entropy fundamental concepts information theory, quantify amount information (\"surprise\") random variable. concepts closely related probability density/mass events: improbable events higher information content. probability observation maps information content; average information content variable entropy. Information content/entropy can calculated discrete probabilities continuous probabilities, humdrumR defines methods calculating .","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/entropy.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Entropy or Information Content of variables — entropy","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/entropy.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Entropy or Information Content of variables — entropy","text":"calculate information content entropy, must assume (estimate) probability distribution. HumdrumR uses R's standard table() density() functions estimate discrte continuous probability distributions respectively. Entropy average information content variable. entropy() function can accept either table() object (discrete variables), density() object (continuous variables). entropy() passed atomic vector, values vector treated observations random variable: numeric vectors, stats::density() function used estimate probability distribution random (continuous) variable, entropy computed density. atomic vectors, table() called tabulate discrete probability mass observed level, entropy computed table. ic() function accepts atomic vectors main (x) argument, must also provided distribution argument. default, distribution argument estimated using density() (numeric input) table() (input).","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/enum.html"],"dir":"Reference","previous_headings":"","what":"Enumerate vector — enum","title":"Enumerate vector — enum","text":"function enumerates values input vector x, counting along length vector 1 length(x).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/enum.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Enumerate vector — enum","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/enum.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Enumerate vector — enum","text":"x input vector enumrate. Must vector (either atomic, list()). inPlace numbers pasted onto original vector? Defaults TRUE. Must singleton logical value: /switch. sep Separator numbers vector. Defaults \":\". Can empty string (\"\"), separator desired.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/enum.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Enumerate vector — enum","text":"inPlace = TRUE (x atomic), original vector returned counts pasted front value, separated sep. inPlace = FALSE, new integer vector returned, identical calling seq_along(x).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/enum.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Enumerate vector — enum","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/expand.html"],"dir":"Reference","previous_headings":"","what":"Expand numbers outwards from zero — expand","title":"Expand numbers outwards from zero — expand","text":"Expand complement base R rounding functions, particularly trunc.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/expand.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expand numbers outwards from zero — expand","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/expand.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Expand numbers outwards from zero — expand","text":"four base R functions---round, ceiling, floor, trunc---follow different logic round real numbers ingegers: round: round nearest integer either direction. floor: round downward towards negative infinity. Negative numbers rounded \"negative\" numbers. ceiling: round upward towards infinity. Negative numbers rounded \"less negative\" numbers. trunc: round \"inward\" towards zero. Negative numbers rounded \"less negative\" numbers, positive numbers still rounded downwards \"less positive\" numbers. Just ceiling compliments floor, humdrumR function expand acts compliment trunc: expand rounds \"outward\" away zero. Negative numbers rounded \"negative\" numbers positive numbers rounded \"positive\" numbers. table explains better words:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/expandPaths.html"],"dir":"Reference","previous_headings":"","what":"Expand paths into new spines — expandPaths","title":"Expand paths into new spines — expandPaths","text":"function takes humdrumR object \"expands\" content spine paths filling content parent path(s).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/expandPaths.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expand paths into new spines — expandPaths","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/expandPaths.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expand paths into new spines — expandPaths","text":"asSpines paths expanded new spines? Defaults TRUE. Must singleton logical value: /switch. TRUE, expanded paths copied new spines (shifting higher spines needed). humdrumR HumdrumR data. Must humdrumR data object.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/expandPaths.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Expand paths into new spines — expandPaths","text":"example, imagine humdrum representation eight-measure piano score, annotator included ossia passage seventh measure. want simply ignore ossia passage, can just specify subset() Path == 0. want study ossia passage, can grab subset() Path == 1. However, want study ossia performed, ossia measure swapped measure 7, still using measures 1-6 8 main path? expandPaths() help us just : expandPaths() copy contents measure 1-6 8 second path , asSpines = TRUE, copy path new spine. can treat new \"full\" path/spine just like path/spine.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/extractTandem.html"],"dir":"Reference","previous_headings":"","what":"Get tandem interpretation information from humdrum data — extractTandem","title":"Get tandem interpretation information from humdrum data — extractTandem","text":"extractTandem extracts tandem interpretations raw Tandem spine humdrumR object.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/extractTandem.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get tandem interpretation information from humdrum data — extractTandem","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/extractTandem.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get tandem interpretation information from humdrum data — extractTandem","text":"Tandem Parsed tandem interpretation data. Must atomic. always Tandem field humdrumR object. regex regular expression match tandem interpretations. Must single character string. include * beginning---* marker tandem interpretations already removed Tandem field.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/extractTandem.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get tandem interpretation information from humdrum data — extractTandem","text":"Every humdrumR object field called Tandem, vector strings accumulates tandem interpretations Spine. record, previous tandems occured spine listed (comma separated), recent appearing first. example, consider file:   Tandem field two spines look like :   Notice \"C:\" erased appearance \"G:\"---naive parser \"know\" \"C:\" \"G:\" related. earlier tandem (\"C:\") just pushed back onto stack. worry, humdrumR data parser recognize many common tandem interpretations (like *C: *G:) automatically parse present---case, put Key field automatically. However, Tandem field retained case data contains novel tandem intepretations humdrumR recognize.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/extractTandem.html"],"id":"extracttandem","dir":"Reference","previous_headings":"","what":"extractTandem","title":"Get tandem interpretation information from humdrum data — extractTandem","text":"data contain novel/unknown tandem interpretations, can use extractTandem function pull Tandem field. first argument extractTandem must Tandem field humdrumR object. second argument (regex) regular expression matched tandem interpretations. token Tandem, recent match () retained. example, wanted manually extract key information Tandem field (humdrumR automatically ), call extractTandem(Tandem, \"[-Ga-g][#-]*:\").","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/figuredBass.html"],"dir":"Reference","previous_headings":"","what":"Figured bass representation of harmony — figuredBass","title":"Figured bass representation of harmony — figuredBass","text":"function outputs figured bass representation tertian harmony.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/figuredBass.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Figured bass representation of harmony — figuredBass","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/figuredBass.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Figured bass representation of harmony — figuredBass","text":"x atomic vector. x argument can (atomic) vectors Key diatonic key used parser, deparser, transposer. Defaults NULL, interpreted C major. Must diatonicSet something coercable diatonicSet; must either length 1 length(x). transposeArgs optional list arguments passed transpose() call. Defaults empty list(). Must list named arguments transpose(). parseArgs optional list arguments chord parser. Defaults empty list(). Must list named arguments chord parser. inPlace non-chord information retained output string. Defaults FALSE. Must singleton logical value: /switch.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/figuredBass.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Figured bass representation of harmony — figuredBass","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/foldExclusive.html"],"dir":"Reference","previous_headings":"","what":"","title":"","text":"foldExclusive() special version foldHumdrum(), \"folds\" spines based exclusive interpretations. instance, can \"fold\" **silbe spines corpus onto respective **kern spines.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/foldExclusive.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/foldExclusive.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"","text":"humdrumR HumdrumR data. Must humdrumR data object. fold, onto exclusive interpretation(s) \"fold\" /. Must non-empty character vectors. onto must single string; may contain multiple exclusive strings. Must specified without ** prefix: \"kern\" \"**kern\".","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/foldExclusive.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"","text":"fold onto arguments (character, length == 1) must match exclusive interpretations humdrumR object input. Within file, mismatches number matching onto fold spines handled \"parallel,\" just like foldHumdrum(). Multi-matching spines matched left--right. matching exclusive interpetation pairs found, unchanged humdrumR object returned warning.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/foldGraceNotes.html"],"dir":"Reference","previous_headings":"","what":"","title":"","text":"\"Fold\" grace notes neighbos","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/foldGraceNotes.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"","text":"","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/foldHumdrum.html"],"dir":"Reference","previous_headings":"","what":"","title":"","text":"Many humdrum datasets encode data across multiple spines, spine-paths, stops. default, humdrumR parses separate spine, spine-path, stop individual data points, taking one row humdrum table. want treat data multiple spines/paths/stops different aspects data easiest reshape data information different humdrumR fields rather separate spines/paths/stops. \"fold\" data one structural location \"top\" data using foldHumdrum.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/foldHumdrum.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/foldHumdrum.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"","text":"humdrumR HumdrumR data. Must humdrumR data object. fold target structure (spine, path, etc.) \"fold\" onto another structural position. Must natural numbers. onto target structure (spine, path, etc.) data \"folded\" onto. Must natural numbers. structural (spine, path, etc.) folded across. Defaults \"Spine\". Must single character string. Valid options \"Spine\", \"Path\", \"Stop\", \"Record\",\"NData\". Piece pieces corpus folded (see \"Piece-Specific Folding\" section, ). Defaults NULL. Must natural numbers; must length length(onto). fromField field \"fold.\" Defaults getActiveFields(humdrumR)[1]. Must character string partially matching name data field humdrumR input. example, \"Tok\" match Token field. field \"folded\" new field. fillFromField content fromField copied unfolded sections? Defaults FALSE foldHumdrum() foldStops(); TRUE foldPaths(). Must singleton logical value: /switch. comes play folding field smaller field. newFieldNames Names use new fields created folding. Defaults NULL. Must character.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/foldHumdrum.html"],"id":"from-where-to-where","dir":"Reference","previous_headings":"","what":"From where to where","title":"","text":"numeric fold onto arguments specify fold /. fold indicates Spine/Path/Stop fold , \"\" Spine/Path/Stop indicated onto. example, specify foldHumdrum(mydata, fold = 2, onto = 1, = 'Spine') spine 2 folded \"top \" spine 1. fold onto targets may overlap. fold onto arguments can vectors length, interpreted parallel: example, combination fold = 1:2 onto = 3:4 map first spine third spine (1 -> 3) second spine 4th spine (2 -> 4). onto targets duplicated, fold spines folded onto multiple new fields: example, combination fold = 1:2 onto = c(3, 3) map first spine second spine two new fields third spine. fold target duplicated, fold spines can copied onto multiple onto spines: example, combination fold = 1 onto = 2:3 map contents first spine onto second third spine, duplicating spine-1 data. lengths fold onto automatically matched, arguments like fold = 1:2 onto = 3 equivalent fold = 1:2, onto = c(3, 3). makes easy things like \"copy four spines onto spine 1\": just write fold = 2:4, onto = 1. specify structural field want fold across, use argument (character, length == 1). default value \"Spine\"; common fold options \"Path\", \"Stop\", though might want use convenient foldPaths() foldStops() functions directly (details ). (may also fold across \"Record\" \"NData\"), advanced/tricky!)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/foldHumdrum.html"],"id":"which-fields","dir":"Reference","previous_headings":"","what":"Which fields","title":"","text":"fromField (character, length == 1) controls field fold spine/path/stop folded new field. fromField argument defaults (first) active field, must match (partially match) field humdrumR argument data set. cases, fold data smaller onto data---instance, spine paths often exist part spine, less data path full spine. cases, can helpful set fillFromField == TRUE, causes missing parts fold filled data field. foldPaths default. resulting new fields automatically named appropriate Results fields. newFieldNames argument (character) can used control output names: one new field created fold. specify many newFieldNames, later names ignored. specify newFieldNames, later names given result names, consistent default behavior.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/foldHumdrum.html"],"id":"piece-specific-folding","dir":"Reference","previous_headings":"","what":"Piece-Specific Folding","title":"","text":"default, \"fold\" carried piece input corpus (humdrumR argument). need specify different folds different pieces, specify Piece argument (numeric, whole number). every piece corpus want apply folds , must specify fold onto arguments parallel vectors Piece argument (even reduendant files). example, specify combinations, Piece one: first spine mapped second spine third spine mapped fourth spine Piece two: first spine mapped second spine fourth spine mapped third spine files corpus included, affected !","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/foldHumdrum.html"],"id":"predefined-folds","dir":"Reference","previous_headings":"","what":"Predefined folds","title":"","text":"convenient foldStops() foldPaths() functions automatically fold stops/paths dataset onto first stop/path, creating new fields named, e.g., Path1, Path2, etc. Another extremely useful function foldExclusive(), automatically folds spines based exclusive interpretation.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/freq.html"],"dir":"Reference","previous_headings":"","what":"Translate pitches to frequency (Hz) — freq","title":"Translate pitches to frequency (Hz) — freq","text":"Translate pitches frequency (Hz)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/freq.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Translate pitches to frequency (Hz) — freq","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/freq.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Translate pitches to frequency (Hz) — freq","text":"x Input data parse pitch information. x argument can (atomic) vector, tonalInterval, NULL. ... Arguments passed pitch deparser. also two hidden (advanced) arguments can specify: memoize deparse (see details ). generic \"specific\" pitch information (accidentals qualites) discarded? Defaults FALSE. Must singleton logical value: /switch. simple \"compound\" pitch information (octave/contour) discarded? Defaults FALSE. Must singleton logical value: /switch. Key input Key used parser, deparser, transposer. Defaults NULL. Must diatonicSet something coercable diatonicSet; must either length 1 length(x) tonalHarmonic frequency \"tonal harmonic\" (perfect 12th). Defaults 2^(19/12), 12-tone-equal-temperament 12th. Must single number. Pythagorean tuning, set tonalHarmonic = 3. frequency.reference reference frequency. Defaults 440. Must single number. transposeArgs optional list arguments passed special transpose() call. Defaults empty list(). Must list named arguments transpose(). parseArgs optional list arguments passed pitch parser. Defaults empty list(). Must list named arguments pitch parser. inPlace non-pitch information retained output string. Defaults FALSE. Must singleton  logical value: /switch. argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ). frequency.reference.note note reference.frequency tuned . Defaults \"\". Can parsable pitch representation; must length 1.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/freq.html"],"id":"basic-pitch-arguments","dir":"Reference","previous_headings":"","what":"Basic pitch arguments","title":"Translate pitches to frequency (Hz) — freq","text":"pitch function standard arguments control details output. important generic simple arguments, allow control type pitch information returned.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/freq.html"],"id":"generic-vs-specific","dir":"Reference","previous_headings":"","what":"Generic vs Specific","title":"Translate pitches to frequency (Hz) — freq","text":"generic = TRUE, specific pitch information (accidentals qualities) omitted output. alternative way controlling functionality, can use specific argument, specific == !generic. case atonal functions, \"generic\" version pitch output: example, semits('c#', generic = TRUE) return 0, \"generic\" version C# C, corresponds 0. However, note generic version pitch follows key, semits('c#', generic = TRUE, Key = ':') return 1!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/freq.html"],"id":"simple-vs-compound","dir":"Reference","previous_headings":"","what":"Simple vs Compound","title":"Translate pitches to frequency (Hz) — freq","text":"simple = TRUE, compound pitch information (octave contour) omitted output. alternative way controlling functionality, can use compound argument ,compound == !simple. actually one way might want divide compound intervals simple octave parts. example, might like call output -M2 (descending major 2nd) +m7 (ascending minor 7th octave ). functionality can controlled octave.round argument: see pitch deparsing documentation.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/freq.html"],"id":"key","dir":"Reference","previous_headings":"","what":"Key","title":"Translate pitches to frequency (Hz) — freq","text":"Key argument must diatonicSet, something can parsed one. Key argument passed parser, deparser, transpose---unless alternate Key passed transposeArgs parseArgs. Various deparsing options use Key argument; example, use implicitSpecies (see advanced parsing section) dependent Key. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function---means, cases, need explicitly anything Key argument! (want happen, need explicitly specify Key argument, Key = NULL.)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/freq.html"],"id":"parse-arguments","dir":"Reference","previous_headings":"","what":"Parse arguments","title":"Translate pitches to frequency (Hz) — freq","text":"parseArgs argument must list() (named) arguments passed input parser. example, input representation uses \"X\" represent double sharps, specify kern('CX5', parseArgs = list(doublesharp = 'X')) get correct result (\"cc##\"). convenient shorthand, \"syntactic sugar,\" can specify parseArgs alternate way: Simply input parse(args...) unnamed argument pitch function. example, can get exact result typing kern('CX5', parse(doublesharp = 'X')).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/freq.html"],"id":"transpose-arguments","dir":"Reference","previous_headings":"","what":"Transpose arguments","title":"Translate pitches to frequency (Hz) — freq","text":"transposeArgs argument must list() (named) arguments passed internal call transpose(), allowing us easily transpose pitch information. example, type kern(c('C', 'D', 'E'), transposeArgs = list(= 'M9')) can get output c('d', 'e', 'f#'). possible transpose args : (tonalInterval, length == 1 | length == (x)) (diatonicSet, length == 1 | length == (x))  (diatonicSet, length == 1 | length == (x)) real (logical, length == 1) transposition real tonal? relative (logical, length == 1) key-wise transposition based relative parallel keys? convenient shorthand, \"syntactic sugar,\" can specify transposeArgs alternate way: Simply input transpose(args...) unnamed argument pitch function. example, can get exact result typing kern(c('C', 'D', 'E'), transpose(= 'M9')).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/freq.html"],"id":"transposing-by-interval","dir":"Reference","previous_headings":"","what":"Transposing by interval","title":"Translate pitches to frequency (Hz) — freq","text":"calling transpose() directly, argument can anything coercable tonalInterval, output transposed amount. real = FALSE, tonal transposition (within Key) performed. details transposition behavior, check transpose() docs.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/freq.html"],"id":"transposing-by-key","dir":"Reference","previous_headings":"","what":"Transposing by key","title":"Translate pitches to frequency (Hz) — freq","text":"Another way transposing specifying input (\"\") key output (\"\") key. default, Key argument passed transpose , nothing actually happens. Thus, specify either key key, transposition happen /key Key. course, specify transposition happen keys specify. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function. specify key, Key field passed transpose key, result, pitches input transposed whatever keys target () key! real relative arguments give special control key-wise transposition works, check transpose() docs details!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/freq.html"],"id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Translate pitches to frequency (Hz) — freq","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/freq.html"],"id":"pitch-gamut-levels","dir":"Reference","previous_headings":"","what":"Pitch-Gamut Levels","title":"Translate pitches to frequency (Hz) — freq","text":"table() automatically generate factor levels pitch data using gamut() function. makes sure tabulated data sorted logical order, includes missing pitches. simple/complex  generic/specific arguments automatically passed gamut(); additional arguments can passed gamut using gamutArgs = list(...), syntactic sugar gamut(...). (Read gamut() docs explanation gamut generation.) feature used control table layout pitch data, well assure consistent tables grouping data. inPlace = TRUE special tabulation occur.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/freq.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Translate pitches to frequency (Hz) — freq","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/gamut.html"],"dir":"Reference","previous_headings":"","what":"Make a pitch gamut — gamut","title":"Make a pitch gamut — gamut","text":"function generates gamut: ordered range notes used music. used generate factor() levels pitch functions. output format gamut controlled deparser argument (function) deparseArgs passed , defaulting kern().","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/gamut.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make a pitch gamut — gamut","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/gamut.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make a pitch gamut — gamut","text":"generic ***gamut include generic intervals? Defaults FALSE. Must singleton logical value: /switch. simple gamut constrained one octave? Defaults FALSE. Must singleton logical value: /switch. reference optional reference vector base gamut . Defaults NULL. Must either NULL, tonalInterval(), integer, character vector. vector parsed pitch. parsed pitch, ignored. deparser pitch function format output. Defaults kern(). Must pitch function.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/gamut.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Make a pitch gamut — gamut","text":"gamut produced based two criteria: range line--fifths include, range octaves include? ranges can controlled directly min.octave, max.octave, min.lof, max.lof arguments, corresponding ranges min.octave:max.octave min.log:max.log respectively. arguments missing (default), ranges default values based simple/compound generic/specific arguments. default ranges : Line--fifths: generic = TRUE, -1:5 (F B) generic = FALSE, -4:7 (Ab C#) Octaves: simple = TRUE, 0:0 (one octave ). simple = FALSE, -1:1. tints argument provide (NULL), tints parsed pitch data line--fifth octave ranges data used set gamut ranges. assures values appear tint always make gamut. However, min.octave, max.octave, min.lof, max.lof present, override ranges tint; can used exclude values, even appear tint.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/grid.html"],"dir":"Reference","previous_headings":"","what":"Drum-machine grid representation of rhythmic durations. — grid","title":"Drum-machine grid representation of rhythmic durations. — grid","text":"functions read write sequencer-like representation rhythm. Rhythms represented either strings vectors \"\"/\"\" values, indicate rhythmic onsets occur regular time grid. example, \"X00X00X0\" c(1, 0, 0, 1, 0, 0, 1, 0).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/grid.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Drum-machine grid representation of rhythmic durations. — grid","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/grid.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Drum-machine grid representation of rhythmic durations. — grid","text":"x input  vector. x argument can (atomic) vector, rational (rhythmInterval), NULL. Must parsable rhythm infromation. ... Argments passed deparser. parseArgs optional list arguments passed rhythm parser. Defaults empty list(). Must list named arguments rhythm parser. scale numeric rational value used output unit measurement. Defaults rational(1, 1). Must numeric rational. inPlace non-rhythm information retained output string? Defaults FALSE. Must singleton  logical value: /switch. Defaults FALSE. singleton logical value, NA. See \"Grace notes\" section . tick unit grid? Defaults sixteenth-note (fromgrid()) tatum() x argument. Must parsed rhythm rhythmInterval(). , represents onsets (attacks) rests grid? Default \"X\" \"O\" respectively. Must singleton atomic values. collapse output collapsed single string per measure? Defaults TRUE. Must singleton logical value: /switch. sep Separator ticks collapsed output. Defaults empty string (separator). Must singleton character string. deparser output representation returned? Defaults recip(). Must function accepts rational() numbers.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/grid.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Drum-machine grid representation of rhythmic durations. — grid","text":"grid() function, fully vectorized rhythm function, translates individual durations grid-representation strings. example, 16th-note grid, dotted eighth-note represented \"XOO\". fromgrid() togrid() functions create/read fuller grid representations, representing whole rhythms : case, length input output .","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/grid.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Drum-machine grid representation of rhythmic durations. — grid","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/harm.html"],"dir":"Reference","previous_headings":"","what":"Roman numeral representations of harmony — harm","title":"Roman numeral representations of harmony — harm","text":"functions output roman numeral representations tertian harmony. **harm representation widely used standard roman numeral notation humdrum data. Unlike traditional roman numerals, **harm indicate inversions figuration, using lowercase letters (, b, c, etc.) instead. roman function however output (relatively) traditional figures. output format roman() similar **harm. main difference inversions indicated using traditional figures , like 653, instead **harm's simpler system (using letters). , example, take input E7/B key major, get:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/harm.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Roman numeral representations of harmony — harm","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/harm.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Roman numeral representations of harmony — harm","text":"x atomic vector. x argument can (atomic) vectors Key diatonic key used parser, deparser, transposer. Defaults NULL, interpreted C major. Must diatonicSet something coercable diatonicSet; must either length 1 length(x). transposeArgs optional list arguments passed transpose() call. Defaults empty list(). Must list named arguments transpose(). parseArgs optional list arguments chord parser. Defaults empty list(). Must list named arguments chord parser. inPlace non-chord information retained output string. Defaults FALSE. Must singleton logical value: /switch.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/harm.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Roman numeral representations of harmony — harm","text":"harm('E7/B', Key = ':') => \"V7c\" roman('E7/B', Key = ':') => \"V643\"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/harm.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Roman numeral representations of harmony — harm","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/helmholtz.html"],"dir":"Reference","previous_headings":"","what":"Helmholtz pitch representation — helmholtz","title":"Helmholtz pitch representation — helmholtz","text":"Helmholtz notation","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/helmholtz.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helmholtz pitch representation — helmholtz","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/helmholtz.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helmholtz pitch representation — helmholtz","text":"x Input data parse pitch information. x argument can (atomic) vector, tonalInterval, NULL. ... Arguments passed pitch deparser. also two hidden (advanced) arguments can specify: memoize deparse (see details ). generic \"specific\" pitch information (accidentals qualites) discarded? Defaults FALSE. Must singleton logical value: /switch. simple \"compound\" pitch information (octave/contour) discarded? Defaults FALSE. Must singleton logical value: /switch. Key input Key used parser, deparser, transposer. Defaults NULL. Must diatonicSet something coercable diatonicSet; must either length 1 length(x) transposeArgs optional list arguments passed special transpose() call. Defaults empty list(). Must list named arguments transpose(). parseArgs optional list arguments passed pitch parser. Defaults empty list(). Must list named arguments pitch parser. inPlace non-pitch information retained output string. Defaults FALSE. Must singleton  logical value: /switch. argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/helmholtz.html"],"id":"basic-pitch-arguments","dir":"Reference","previous_headings":"","what":"Basic pitch arguments","title":"Helmholtz pitch representation — helmholtz","text":"pitch function standard arguments control details output. important generic simple arguments, allow control type pitch information returned.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/helmholtz.html"],"id":"generic-vs-specific","dir":"Reference","previous_headings":"","what":"Generic vs Specific","title":"Helmholtz pitch representation — helmholtz","text":"generic = TRUE, specific pitch information (accidentals qualities) omitted output. alternative way controlling functionality, can use specific argument, specific == !generic. case atonal functions, \"generic\" version pitch output: example, semits('c#', generic = TRUE) return 0, \"generic\" version C# C, corresponds 0. However, note generic version pitch follows key, semits('c#', generic = TRUE, Key = ':') return 1!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/helmholtz.html"],"id":"simple-vs-compound","dir":"Reference","previous_headings":"","what":"Simple vs Compound","title":"Helmholtz pitch representation — helmholtz","text":"simple = TRUE, compound pitch information (octave contour) omitted output. alternative way controlling functionality, can use compound argument ,compound == !simple. actually one way might want divide compound intervals simple octave parts. example, might like call output -M2 (descending major 2nd) +m7 (ascending minor 7th octave ). functionality can controlled octave.round argument: see pitch deparsing documentation.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/helmholtz.html"],"id":"key","dir":"Reference","previous_headings":"","what":"Key","title":"Helmholtz pitch representation — helmholtz","text":"Key argument must diatonicSet, something can parsed one. Key argument passed parser, deparser, transpose---unless alternate Key passed transposeArgs parseArgs. Various deparsing options use Key argument; example, use implicitSpecies (see advanced parsing section) dependent Key. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function---means, cases, need explicitly anything Key argument! (want happen, need explicitly specify Key argument, Key = NULL.)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/helmholtz.html"],"id":"parse-arguments","dir":"Reference","previous_headings":"","what":"Parse arguments","title":"Helmholtz pitch representation — helmholtz","text":"parseArgs argument must list() (named) arguments passed input parser. example, input representation uses \"X\" represent double sharps, specify kern('CX5', parseArgs = list(doublesharp = 'X')) get correct result (\"cc##\"). convenient shorthand, \"syntactic sugar,\" can specify parseArgs alternate way: Simply input parse(args...) unnamed argument pitch function. example, can get exact result typing kern('CX5', parse(doublesharp = 'X')).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/helmholtz.html"],"id":"transpose-arguments","dir":"Reference","previous_headings":"","what":"Transpose arguments","title":"Helmholtz pitch representation — helmholtz","text":"transposeArgs argument must list() (named) arguments passed internal call transpose(), allowing us easily transpose pitch information. example, type kern(c('C', 'D', 'E'), transposeArgs = list(= 'M9')) can get output c('d', 'e', 'f#'). possible transpose args : (tonalInterval, length == 1 | length == (x)) (diatonicSet, length == 1 | length == (x))  (diatonicSet, length == 1 | length == (x)) real (logical, length == 1) transposition real tonal? relative (logical, length == 1) key-wise transposition based relative parallel keys? convenient shorthand, \"syntactic sugar,\" can specify transposeArgs alternate way: Simply input transpose(args...) unnamed argument pitch function. example, can get exact result typing kern(c('C', 'D', 'E'), transpose(= 'M9')).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/helmholtz.html"],"id":"transposing-by-interval","dir":"Reference","previous_headings":"","what":"Transposing by interval","title":"Helmholtz pitch representation — helmholtz","text":"calling transpose() directly, argument can anything coercable tonalInterval, output transposed amount. real = FALSE, tonal transposition (within Key) performed. details transposition behavior, check transpose() docs.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/helmholtz.html"],"id":"transposing-by-key","dir":"Reference","previous_headings":"","what":"Transposing by key","title":"Helmholtz pitch representation — helmholtz","text":"Another way transposing specifying input (\"\") key output (\"\") key. default, Key argument passed transpose , nothing actually happens. Thus, specify either key key, transposition happen /key Key. course, specify transposition happen keys specify. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function. specify key, Key field passed transpose key, result, pitches input transposed whatever keys target () key! real relative arguments give special control key-wise transposition works, check transpose() docs details!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/helmholtz.html"],"id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Helmholtz pitch representation — helmholtz","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/helmholtz.html"],"id":"pitch-gamut-levels","dir":"Reference","previous_headings":"","what":"Pitch-Gamut Levels","title":"Helmholtz pitch representation — helmholtz","text":"table() automatically generate factor levels pitch data using gamut() function. makes sure tabulated data sorted logical order, includes missing pitches. simple/complex  generic/specific arguments automatically passed gamut(); additional arguments can passed gamut using gamutArgs = list(...), syntactic sugar gamut(...). (Read gamut() docs explanation gamut generation.) feature used control table layout pitch data, well assure consistent tables grouping data. inPlace = TRUE special tabulation occur.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/helmholtz.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Helmholtz pitch representation — helmholtz","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/hop.html"],"dir":"Reference","previous_headings":"","what":"Generate regular sequence ","title":"Generate regular sequence ","text":"hop() similar base R's seq(), additional features, including special sugar used humdrumR's context() command. hop() used create customizable sequences indices vector; example, want index every third value vector. useful , used context(), defining start points \"rolling-window\" analyses along vector; \"hop size\" gap start window, defined hop()'s argument.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/hop.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate regular sequence ","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/hop.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate regular sequence ","text":"along.vector want indices \"hop\" along. Must vector (either atomic, list()). pattern \"hops\" use. Defaults 1: returning indices :. Must one whole numbers. sum() must non-zero. start sequence. Defaults 1: starting first index. Must either single natural number, single character string, logical vector length along.. character-string input treated regular expression, matched along.using grepl() generate logical vector. index first TRUE used. end sequence. Defaults NULL. Must either NULL, single natural number, single character string, logical vector length along.. NULL, set last index along.(group groupby). character-string input treated regular expression, matched along.using grepl() generate logical vector. index last TRUE used. value indices returned logical TRUEs? Defaults FALSE. Must singleton logical value; /switch. groupby Optional vectors group hop sequences within. Defaults empty list(). Must list(), either empty contains vectors length along.. calls /within.humdrumR, groupby passed list(Piece, Spine, Path) default.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/hop.html"],"id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate regular sequence ","text":"default, hop() returns integer vector, appropriates indices along.vector. However, two options: logical = TRUE, indices returned logical vector, length along., TRUE values indicating indices. Note ordering output (due mix positive negative values argument) lost. value = TRUE, actual indixed elements along.vector returned: Thus, hop(myvector, ..., value = TRUE) simply myvector[hop(myvector, ...)]. value = TRUE, logical argument ignored.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/hop.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate regular sequence ","text":"hop() similar arguments base::seq(), focused along.argument, vector like generate indices . simply call hop(myvector), output 1:length(myvector). argument can used specify different \"hop\" pattern: = 2 get every index, 1, 3, 5, 7, etc. Unlike base::seq(), hop()'s argument can vector numbers, allowing specify pattern hops. example, = c(2, 3) first hop 2, hop 3, repeat---output 1, 3, 6, 8, 11, 13, etc. pattern can comprised negative numbers, mix negative positive numbers. mixes negative positive numbers, pattern can hop , climbs. example, go two, one, repeat using = c(2,-1). pattern overall (sums) negative, argument must greater argument (see next section); pattern sums zero, error occurs pattern never end! pattern changes directions, possible pattern hop outside bounds vector; happens, outside indices return NA.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/hop.html"],"id":"starting-and-ending","dir":"Reference","previous_headings":"","what":"Starting and Ending","title":"Generate regular sequence ","text":"default, hop() builds indices 1 end along.vector. arguments can used control . Either argument can simply natural number, indicating start end output sequences. (NULL, set length(along.).) alternate approach provide either argument single character string, treated regular expression matched along.,  logical vector length along.. first match/TRUE used index last match/TRUE index. means can say things like = Record == 33 within() call. argument overall (sums) positive, must less . argument overall (sums) negative, must greater . pattern ever actually actual index---perhaps jumping --- output stops pass .","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/hop.html"],"id":"grouping","dir":"Reference","previous_headings":"","what":"Grouping","title":"Generate regular sequence ","text":"many cases want along vectors, across certain boundaries. example, want even numbered indices, can set = 2 = 2. However, vector includes data multiple pieces, pieces odd number data points, \"even\" sequence end hitting odd numbers pieces. get around , groupby argument indicates one, , grouping vectors, break x (input) argument groups. groupby vectors given, change vector indicates boundary. grouped segement along.treated just like separate call hop(); example, = 2, hop sequence start second index group. However, output indices still represent original along.indices. Since hop() usually used context() create rolling windows within musical parts, want typically want apply hop() using groupby = list(Piece, Spine, Path). fact, humdrumR () calls automatically feed three fields groupby arguments hop(). use hop() call (), automatically generate hop sequence \"melodic\" way, within spine path piece.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/hop.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate regular sequence ","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humActive.html"],"dir":"Reference","previous_headings":"","what":"The ","title":"The ","text":"humdrumR objects contain many fields data stored underlying humdrum table; can explicitly access fields using ()Humdrum. explicitly indicate field, humdrumR generally default showing/using objects \"Active expression\".","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humActive.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The ","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humActive.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The ","text":"humdrumR HumdrumR data. Must humdrumR data object. dataTypes types humdrum records include census. Defaults \"d\". Must character. Legal values 'G', 'L', '', 'M', 'D', 'd' combination (e.g., \"LIM\"). (See humdrum table documentation Fields section explanation.) forceAtomic Whether evaluated active field forced/coerced atomic vector. Defaults TRUE. Must singleton logical value: /switch sep Separator paste collapsed strings. Defaults \", \". Must single character string. used forceAtomic == TRUE, wherein lists vectors pasted together. nullChar null tokens returned characters NA? Defaults FALSE. Must singleton logical value: /switch nullChar == TRUE output character, NAs output vector replaced humdrum null character tokens: \".\", \"!\", \"=\", \"*\". forceAtomic FALSE, nullChar ignored.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humActive.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The ","text":"time, active expression just points single field: first read , active expression/field Token. However, active expression can arbitrary R expression involving fields humdrum table. called , expression evaluated within object's humdrum table (similar \"within expression,\" without extra evaluation options). instance, active expression : paste(Token, Record), print Token record number pasted . fields referenced active expression called \"active fields.\" Common commands evaluate active expression include: printing humdrumR object terminal, active expression shown. (evalActive used evaluate expression character string, needed.) humdrumR object prints, active fields marked \"*\" name(s). writing files, active expression written.  \"within expression,\" variable . automatically replaced active expression. Functions like collapseHumdrum], foldHumdrum(), fields(), use active field(s) default arguments. current active field can seen calling getActive(humData). character vector fields used active expression can extracted getActiveFields(humData).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humActive.html"],"id":"setting-the-active-expression","dir":"Reference","previous_headings":"","what":"Setting the active expression","title":"The ","text":"active expression can changed several ways. simplest common using $ operator, takes field name (partially matched) sets active expression simply call field. handy way quickly look different fields data:   complex active expressions can set using setActive, specified directly second argument: e.g., setActive(humData, paste(Token, Record)). Notice active field must Refer least one field humdrum table. Evaluate vector length humdrum table (given target dataTypes), list vectors length. programmatic work, setActiveFields accepts character vector partially matched field names; one field name given, active field just calls field. two field names given, active expression set expression form list(Field1, Field2, Field3, ...). easiest way quickly see two three fields side side. special syntactic sugar, call humData$, liit data fields set active field. useful way look data fields.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humActive.html"],"id":"null-data","dir":"Reference","previous_headings":"","what":"Null data","title":"The ","text":"humdrumR`` identifies \"null data\" based active field---might obvious,  one important jobs active field! Anywhere current active field evaluates \".\"orNA(orNULLfor [lists][base::list()]) considered null data; internal [humdrum table][humTable] data points set toTRUEin theNullfield assigned type\"d\"theType` field. Null data updated whenever active field changed reset, including functions create new fields, like foldHumdrum() within.humdrumR(). work, often data tokens null one field, another field. example, load **kern data, token like \"4r\" (quarter-note rest) token NA call pitch, NA call recip (rhythm).   Now, change active field Pitch Rhythm (using $) see different numbers (non-null) data tokens: ntoken(kerndata$Pitch ,'D') vs ntoken(kerndata$Rhythm, 'D) return different numbers! (difference number rest tokens.) Similarly, apply functions/expressions data (using withinHumdrum() example), result depend active field :   , get different numbers ! (Assuming rests data.) case even though -expression actually using Pitch Rhythm fields! Pitch active field, rest tokens null-data ignored!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humActive.html"],"id":"evaluating-the-active-expression","dir":"Reference","previous_headings":"","what":"Evaluating the active expression","title":"The ","text":"Evaluation active expression usually something done automatically humdrumR functions, especially printing data console. However, can also manually using evalActive command. \"raw\" result evaluating active expression can returned specifying forceAtomic == FALSE. However, default forceAtomic == TRUE causes evalActive coerce evaluated results atomic vector. Obviously, evaluated active result atomic vector, coercion needed. evaluated active result list, must either full length humdrum table, list vectors/lists length. words, result must one \"full length\" vector/lists. full length list, element list coerced single atomic value unlisted create atomic vector. elements list atomic, converted various character representations. tables coerced string \"<table: k=x, n=y>\", x number categories table y total number values table (sum(table(...))). lists length < 5 coerced \"list(, b, c, d, e)\", -e elements list. Longer lists coerced \"list[n]:, n length list. R objects coerced <class>, class class object. Finally, thus-generated full-length vectors (one) pasted together, separated sep (default = \", \"). common practical illustration/application last specify active fields lists fields---example, list(Token, Spine, Record). Following algorithm , evaluated result character vector looking like \"Token, Spine, Record\". exactly setActiveFields fed multiple fieldNames, well special call humData$.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humCoercion.html"],"dir":"Reference","previous_headings":"","what":"humdrumR coercion — humCoercion","title":"humdrumR coercion — humCoercion","text":"Many users may wish work humdrum data, without rely humdrumR's ().humdrumR functionality. Rather, like just get \"normal\" R objects humdrum data. humdrumR defines number functions/methods \"coercing\" humdrum data basic R data types.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humCoercion.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"humdrumR coercion — humCoercion","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humCoercion.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"humdrumR coercion — humCoercion","text":"mode desired output class. Defaults \"\". Must single character string naming atomic vector type coerce output (.e., logical numeric). set \"\", output type simply whatever comes evalActive(), depends class underlying fields. humdrumR HumdrumR data. Must humdrumR data object. dataTypes types humdrum record(s) include. Defaults \"GLIMDd\" .lines() .matrix(); \"Dd\" .data.frame(); \"LIMDd\" .matrices() .data.frames(). Must single character string. Legal values 'G', 'L', '', 'M', 'D', 'd' combination (e.g., \"LIM\"). (See humdrum table documentation explanation.) padPaths Determines spine-paths aligned output. Defaults \"dont\" .lines(); \"corpus\" .matrix() .data.frame(); \"piece\" .matrices() .data.frames() Must single character string, \"corpus\", \"piece\", \"dont\". See details explanation. padder Used fill differences number columns files /spine paths. Defaults NA. Must single atomic value. sep Separator place columns collapsed lines. Defaults \"\\t\" (tab). Must single character string.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humCoercion.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"humdrumR coercion — humCoercion","text":"Generally, coercion works evaluating humdrumR object's active expression forcing result atomic vector. process accomplished evalActive() command. .vector(humdrumR) method essentially wrapper evalActive(), additional option coercing resulting vector particular type using mode argument. .matrix(humdrumR) method take things step putting evaluated active expression two-dimensional matrix, rows representing records columns indicating spine paths (see Padding section ). .data.frame(humdrumR) first calls .matrix converts matrix data.frame. Note .matrix(humdrumR) places entire corpus object one matrix, even multiple pieces. contrast, plural .matrices .data.frames call respective singular versions separately individual file humdrumR corpus return list. row names  matrix/data.frame(s) consist two integer values, separated ., representing: Piece.Record. .lines function converts humdrumR object character vector text lines, columns separated sep argument (defaults \"\\t\"), just see humdrum-syntax file. line single row .matrix.humdrumR, padded values right side removed. matrix's Piece.Record row names preserved lines' names. Note multiple-stop token (Stop > 1L) incorporated two dimensional matrix/data.frame. Thus, .matrix(humdrumR) calls collapseStops(collapseAtomic = TRUE, sep = \" \") humdrumR object creating matrix.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humCoercion.html"],"id":"padding","dir":"Reference","previous_headings":"","what":"Padding","title":"humdrumR coercion — humCoercion","text":"Different pieces single humdrumR object often differ number spines /spine paths contain. squish two dimensional object (matrix data.frame) must necessarily padded number columns. (Global comments---actually NA spines---also padded, placing record column 1.) pad argument single atomic value used pad matrix. Another consideration behavior spine paths. humdrum syntax, spine path leftward spine \"bumps\" data higher spines new columns, example:   beginning end file, second column holds data second spine. However, middle file, second column holds data second spine path first spine. make spine structure clearer, .matrix(humdrumR) option pad spine paths. example, using \"_\" pad argument:   aspect matrix padding behavior can controlled padPaths argument, three possible values/behaviors: \"corpus\": Paths padded spine-paths across pieces corpus align columns. even one file spine path, files padded spines stay aligned. default behavior .matrix(humdrumR). \"piece\": Paths padded, within piece. spines/paths different pieces may align. \"dont\": Paths padded .","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humMerge.html"],"dir":"Reference","previous_headings":"","what":"Merge two (or more) humdrumR datasets — humMerge","title":"Merge two (or more) humdrumR datasets — humMerge","text":"------------------------------------------->             NEEDS DOCUMENTATION             <-------------------------------------------","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humMerge.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge two (or more) humdrumR datasets — humMerge","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humMeter.html"],"dir":"Reference","previous_headings":"","what":"Tools for analyzing rhythm and meter. — humMeter","title":"Tools for analyzing rhythm and meter. — humMeter","text":"humdrumR includes number useful functions working rhythms meter.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humSize.html"],"dir":"Reference","previous_headings":"","what":"humdrumR data size and shape — humSize","title":"humdrumR data size and shape — humSize","text":"functions can used quickly get basic information size \"shape\" humdrumR corpus objects. details, use census() spines() functions instead. HumdrumR objects can divided \"subcorpora.\" anySubcorpora namesSubcorpora functions tell us subcorpora , , called.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humSize.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"humdrumR data size and shape — humSize","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humSize.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"humdrumR data size and shape — humSize","text":"humdrumR HumdrumR data. Must humdrumR data object. dataTypes types humdrum record(s) include census. Defaults \"GLIMDd\". Must single character string. Legal values 'G', 'L', '', 'M', 'D', 'd' combination (e.g., \"LIM\"). (See humdrum table documentation Fields section explanation.)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humSize.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"humdrumR data size and shape — humSize","text":"following functions defined. nfile : number input files corpus. length(humdrumR) synonym. npiece: number pieces corpus. (may multiple pieces per file.) nrecord: number records corpus. nrow(humdrumR) synonym. ntoken: number tokens corpus. ncol(humdrumR): Returns maximum number \"columns\" need represent data 2d matrix. Matches default output .matrix(humdrumR). dim(humdrumR): c(nrow(humdrumR), ncol(humdrumR)).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humSize.html"],"id":"is-any","dir":"Reference","previous_headings":"","what":"Is/Any","title":"humdrumR data size and shape — humSize","text":"additional functions return quick TRUE/FALSE answers regarding humdrumR corpus: .empty: Returns TRUE corpus contains non-null data tokens (D tokens). anyPaths: Returns TRUE spine paths (Path > 0) pieces corpus. anyStops: Returns TRUE multi-stops (Stop > 1) pieces corpus. anySubcorpora: Returns TRUE corpus read different regex patterns matching \"subcorpora\" labels. namesSubcorpora returns names subcorpora labels (Label field). anyMultiPieceFiles: Returns TRUE files contain one piece (Piece != File).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humSummary.html"],"dir":"Reference","previous_headings":"","what":"Summarize humdrumR corpora — humSummary","title":"Summarize humdrumR corpora — humSummary","text":"Summarizes content humdrumR corpus, calling five different corpus summary functions printing results.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humSummary.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize humdrumR corpora — humSummary","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humSummary.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summarize humdrumR corpora — humSummary","text":"humdrumR includes number separate functions summarizing different aspects humdrumR data objects: census() Tabulates raw size humdrumR corpus. reference() Tabulates reference records (metadata) piece. spines() Tabulates number spines spine paths pieces corpus. interpretations() Tabulates types exclusive tandem interpretations corpus. sections() Tabulates formal data (*>) corpus, including barlines. function takes humdrumR object returns data.table. summary method humdrumR objects simply calls functions prints condensed version .","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humSummary.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize humdrumR corpora — humSummary","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humTable.html"],"dir":"Reference","previous_headings":"","what":"Humdrum tables (and their Fields) — humTable","title":"Humdrum tables (and their Fields) — humTable","text":"humdrumR package, fundamental data structure called Humdrum Table. humdrum table encodes information collection one humdrum-syntax files single data.table (data.table \"enhanced\" version R's standard data.frame). Humdrum tables stored \"inside\" every humdrumRclass object work , various humdrumR functions allow study manipulate . want directly access humdrum table within humdrumRclass object, use getHumtab function. getHumtab extracts hudrum table humdrumR object. Individual fields humdrum table can extracted using getFields. Returns data.table(), column corresponding one field. (data.table column-subset humdrum table). Use fields list current fields humdrumRclass object. returns data.table() three columns: field's Name, Class data held field, Type field (e.g., \"Formal\").","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humTable.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Humdrum tables (and their Fields) — humTable","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humTable.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Humdrum tables (and their Fields) — humTable","text":"humdrumR HumdrumR data. Must humdrumR data object. dataTypes types humdrum record(s) include output. Defaults \"GLIMDd\". Must character string, specifies types data tokens/records extract. Legal values : \"G\" (global comments), \"L\" (local comments), \"\" (interpretations), \"M\" (barlines), \"D\" (non-null data), \"d\" (null data). Multiple types can specified single string: e.g., \"GLIMD\". fields fields output. Defaults getActiveFields(humdrumR). Must character string partially matching name data field humdrumR input. example, \"Tok\" match Token field. fieldTypes types fields list. Shows fields default. Must character vector. Legal options \"Data\", \"Structure\", \"Interpretation\", \"Formal\", \"Reference\". Types can partially matched---example, \"S\" \"Structure\".","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humTable.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Humdrum tables (and their Fields) — humTable","text":"humdrum table, row represents single \"token\" original humdrum data. Even multistops---tokens separated spaces---broken onto rows. Meanwhile, column humdrum table represents single piece information associated token, call field. Throughout documentation, keep mind \"token\" refers row humdrum table \"field\" refers column: Token = row Field = column","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humTable.html"],"id":"fields-","dir":"Reference","previous_headings":"","what":"Fields:","title":"Humdrum tables (and their Fields) — humTable","text":"five types fields humdrum table: Data fields Structure fields Interpretation fields Formal fields Reference fields first created call readHumdrum() every humdrum table least nineteen fields: one data field (Token), two interpretation fields (Tandem Exclusive), three formal fields, fifteen structure fields. Additional interpretation reference fields may present depending content humdrum file(s), users can create additional data fields using within(humdrumR) (functions).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humTable.html"],"id":"data-fields-","dir":"Reference","previous_headings":"","what":"Data fields:","title":"Humdrum tables (and their Fields) — humTable","text":"Data fields used describe individual data points humdrum data (opposed groups points). Every humdrum table starts data field called Token, contains character strings representing original strings read humdrum files. Users can create many additional data fields like. Every call withinHumdrum() generates one N new data fields named \\(Result1, Result2, \\ldots, ResultN\\).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humTable.html"],"id":"structure-fields-","dir":"Reference","previous_headings":"","what":"Structure fields:","title":"Humdrum tables (and their Fields) — humTable","text":"Every humdrum table starts fifteen Structure fields, describe data token \"located\" original humdrum data: file, spine, record, etc. See vignette humdrum syntax fully understand terms . File info: Filename :: character unique name humdrum file. may include appended path one file name read different directories (see readHumdrum() docs). Filepath :: character full file name (always includes full path). Label :: character label specified call readHumdrum(), associated particular readHumdrum \"REpath-pattern.\" label specified, patterns just labeled \"_n\", \"n\" number pattern. File :: integer unique number associated file (ordered alphabetically, starting 1). Piece :: integer number specifying number piece corpus. identical File field except one piece read file. Location info: Spine :: integer spine, numbered (left--right) starting 1. field NA wherever Global == TRUE. Path :: integer \"spine path.\" time *^ spine path split occurs humdrum data, right side split becomes new \"path.\" original path numbered 0 additional paths numbered integers right. (spine path splits, Path field 0s.) field always NA Global == TRUE. ParentPath :: integer spine paths (.e., Path > 0), path parent path split? Path == 0, parent path also 0. Record :: integer record (.e., line) number original file. NData :: integer data record enumeration file, starting 1. Stop :: integer token multistop token, numbered starting 1. files multistops, Stop field 1s. field always NA Global == TRUE. Global :: logical token come global record (opposed local record)? Global == TRUE, Spine, Path, Stop fields always NA. Token info: Type :: character type record ? \"D\" = non-null data \"d\" = null data \"\" = interpretation \"M\" = measure/barline \"L\" = local comment \"G\" = global comment. Null :: logical active field data field null? See detailed discussion , section documentation called \"Null Data.\" Filter :: logical record/token filtered ?","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humTable.html"],"id":"interpretation-fields-","dir":"Reference","previous_headings":"","what":"Interpretation fields:","title":"Humdrum tables (and their Fields) — humTable","text":"Interpretation fields describe interpretation metadata humdrum file(s). Humdrum interpretations tokens \"carry forward\" data points , unless cancelled subsequent interpretation. (See humdrum syntax vignette detailed explanation.) humdrum data must exclusive interpretation humdrum tables always Exclusive (:: character) field indicating exclusive interpretation associated token/row Token field. Humdrum data may, may , include additional tandem interpretations. universal rule parsing tandem interpretations impossible, ) tandem interpretations can \"overwrite\" B) users can create tandem interpretations. best can cases identify tandem interpretations appeared previously spine (counting recent first). previous interpretations encoded single character string Tandem field (see extractTandem() docs details). working non-standard interpretations, users can parse Tandem field using extractTandem() function. tandem interpretations occur file, Tandem field full empty strings (\"\"). Fortunately, many tandem interpretations widely used standardized, interpretations known humdrumR. Recognized interpretations (*clefG4 *k[b-]) automatically parsed fields call readHumdrum(). See readHumdrum() documentation details.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humTable.html"],"id":"formal-fields-","dir":"Reference","previous_headings":"","what":"Formal fields:","title":"Humdrum tables (and their Fields) — humTable","text":"Formal fields indicate musical sections, time windows within piece, including formal designations (\"verse\", \"chorus\", etc.) measures/bars. Humdrum data may may include formal metadata fields, indicated token \"*>\". Classified formal marks put fields matching name. Unclassified formal marks placed field called Formal default. Nested formal categories appended underscore number level descent: Formal_1, Formal_2, ..., Formal_N. part section given name lower hierarchical level, field simply empty (\"\") point. Humdrum data may, may , also include barlines (tokens beginning \"=\"). Humdrum tables always include three formal fields related barlines: Bar :: integer many barline records (single double) passed token? \"=\" tokens occur file, Bar zeros. Note field independent whether barlines labeled numbers humdrum file! DoubleBar :: integer many double-barline records passed token? \"==\" tokens occur file, DoubleBar zeros. BarLabel :: character characters occur barline-token initial \"=\" \"==\". include \"-\" common \"implied barline\" token \"=-\", repeat tokens (like \"=:||\"), also explicit bar numbers. Note Bar field always enumerate every bar record, measure-number labels humdrum data (appear BarLabel field) may weird things like skipping numbers, repeating numbers, suffixes (e.g., \"19a\"). barline tokens appear file, BarLabel empty strings (\"\").","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humTable.html"],"id":"reference-fields-","dir":"Reference","previous_headings":"","what":"Reference fields:","title":"Humdrum tables (and their Fields) — humTable","text":"Reference fields describe Reference Records humdrum data. Every reference record (records beginning \"!!!\") humdrum file corpus read readHumdrum parsed field named reference code: \"XXX\" \"!!!XXX\". Reference tokens identical throughout humdrum piece. reference code appears one file another, field NA file code. reference records appear files read readHumdrum(), reference fields created. Examples common reference records \"!!!COM:\" (composer) \"!!!OTL:\" (original title). humdrum data records end COM OTL fields humdrum table.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humTable.html"],"id":"null-data-","dir":"Reference","previous_headings":"","what":"Null Data:","title":"Humdrum tables (and their Fields) — humTable","text":"humdrum syntax, requirement every spine-path contains data every record. Rather, spines often padded null tokens. cases, entire records may padded null tokens. type humdrum record uses different null token: Intepretation: * Comment: ! Barline: = Data: . Null tokens humdrum table identified logical Null field. Null field set humdrum table created (readHumdrum()) updated everytime new active field set. Null set TRUE wherever, either active field character data token single \".\", \"!\", \"=\", \"*\"; active field NA (including NA_character_). parallel Null field, null data tokens (\".\") identified record type: \"d\". updates/changes Null field also propagated Type field---.e., setting Type == d wherever data record Null. important/useful withinHumdrum() routines , default, applied \"D\" data, ignoring \"d\". Whenever print export [humdrumR objecthumdrumRclass, null data active field (.e., Null == TRUE) prints \".\". Thus, working numeric data NA values, NA values print \".\".","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humTable.html"],"id":"reshaping-","dir":"Reference","previous_headings":"","what":"Reshaping:","title":"Humdrum tables (and their Fields) — humTable","text":"Breaking complex syntax humdrum data \"flat\" structure humdrum table, every single token one line data.table, makes humdrum data easier analyze. course, thanks structure fields, can easily regroup reform original humdrum data use structure data (like spines) analyses. However, cases, might want work humdrum data different structure \"shape.\" humdrumR several options \"collapsing\" tokens within humdrum tables, \"folding\" different parts data new fields, otherwise reshaping humdrum data basic R data structures might prefer.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humWindows.html"],"dir":"Reference","previous_headings":"","what":"Create arbitrary ","title":"Create arbitrary ","text":"Create arbitrary \"windows\" across vectors.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humWindows.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create arbitrary ","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumDispatch.html"],"dir":"Reference","previous_headings":"","what":"Regular expression method dispatch and function application — humdrumDispatch","title":"Regular expression method dispatch and function application — humdrumDispatch","text":"humdrumR regular-expression method dispatch system simple system making new functions can smartly applied variety character strings. Humdrum dispatch works like normal R method dispatch, instead dispatching specific methods based class (integer, character, etc.) dispatches based regular expressions. addition, exclusive interpretations can used guide dispatch.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumDispatch.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Regular expression method dispatch and function application — humdrumDispatch","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumDispatch.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Regular expression method dispatch and function application — humdrumDispatch","text":"dispatchDF data.frame describes function called regex input. (See details). Must data.frame. Exclusive Exclusive interpretations dispatch. Defaults NULL. NULL, regexes used dispatch. multiDispatch Whether use multiple dispatch function interpretation. Defaults FALSE. Must singleton logical value: /switch. FALSE \"best\" regex/exclusive match dispatched Exclusive segment. TRUE, differenet functions can dispatched within input vector. ... Arguments pass dispatch functions. outputClass default output class function return. Defaults \"character\". Must single character string. Generally, make sense, dispatched functions return type, explicitly indicate outputClass argument. Dispatch functions also vectorized. str input strings, dispatch called. Must character.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumDispatch.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Regular expression method dispatch and function application — humdrumDispatch","text":"Many humdrumR functions fact, humdrum-dispatch functions: example, tonalInterval.character(). call tonalInterval('ee-'), function recognize input string token  **kern representation, call appropriate parser. instead call tonalInterval(''), function recognize input string token **solfa representation, call appropriate parser .","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumDispatch.html"],"id":"dispatchdf","dir":"Reference","previous_headings":"","what":"dispatchDF","title":"Regular expression method dispatch and function application — humdrumDispatch","text":"dispatchDF must data.table::data.table() created using makeDispatchDF function. makeDispatchDF takes one arguments, list three components (ordered, nameed): character vector exclusive interpretations. (Specify \"\" want exclusive dispatch). regular expression (character string) function can generate regular expression, accepts ... arguments time dispatch. function dispatch.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumDispatch.html"],"id":"makehumdrumdispatcher","dir":"Reference","previous_headings":"","what":"makeHumdrumDispatcher","title":"Regular expression method dispatch and function application — humdrumDispatch","text":"makeHumdrumDispatcher function creates new function automatically performs humdrum-dispatch. number important humdrumR functions created makeHumdrumDispatcher: tonalInterval.character diatonicSet.character tertianSet.character rhythmInterval.character","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumDispatch.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Regular expression method dispatch and function application — humdrumDispatch","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumPitch.html"],"dir":"Reference","previous_headings":"","what":"humdrumR and pitch — humdrumPitch","title":"humdrumR and pitch — humdrumPitch","text":"humdrumR includes number intertwined data structures, associated functions, representing manipulating musical pitch information.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumPitch.html"],"id":"tonality","dir":"Reference","previous_headings":"","what":"Tonality","title":"humdrumR and pitch — humdrumPitch","text":"four data types extensively used humdrumR encode/process tonal musical information: integers --- used encode \"line--fifths\" tonal information tonalInterval --- embeds line--fifth tonal integers alongside octave cent information encode tonal pitch representations (solfege, intervals, letternames, etc.) diatonicSet --- combines line--fifth tonal integer representations represent diatonic tonality, including alterations basic diatonic scale(s). tertianSet --- extension diatonicSet used encode  tertian diatonic harmonies. Users rarely need engage data types. Rather, users work humdrum data pitch information encoded strings, wish manipulate analyze data. widely used humdrumR tools pitch conversion/manipulation functions, including kern(), functions like invert() transpose(). functions make use sophisticated, flexible pitch parsing deparsing functions, bridge \"core\" pitch representations listed real-world humdrum data.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumPitch.html"],"id":"atonality","dir":"Reference","previous_headings":"","what":"Atonality","title":"humdrumR and pitch — humdrumPitch","text":"SECTION INCOMPLETE addition, xxx data types used encode non-tonal (atonal) pitch information. integers --- used encode semitones (well MIDI numbers). xxx --- sets? xxx --- 12-tone rows?","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumR.html"],"dir":"Reference","previous_headings":"","what":"humdrumR — humdrumR","title":"humdrumR — humdrumR","text":"humdrumR toolkit analysis data encoded humdrum syntax. humdrum syntax incredibly flexible, powerful, scheme encoding musical data. Tens thousands musical scores (musical data) encoded humdrum syntax, many available online repositories KernScores.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumR.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"humdrumR — humdrumR","text":"humdrumR intended modernized replacement original humdrum toolkit, leveraging power R give us unprecedented power manipulate analyze humdrum data using concise, expressive syntax.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumR.html"],"id":"package-design","dir":"Reference","previous_headings":"","what":"Package design","title":"humdrumR — humdrumR","text":"package humdrumR seven main components: represent humdrum data R, humdrumR S4 class, core component humdrum table. create humdrumR data, sophisticated humdrum data parser: readHumdrum. humdrumR data can also written back humdrum-syntax text files using writeHumdrum. filter humdrumR data, subset.humdrumR() function, can also called using R's standard indexing operators: [] [[]]. manipulate modify humdrumR data, within methods humdrumR objects. facilitate development functions work humdrum tokens---simple character strings packed information---, useful API call regular-expression dispatch system. Several modules representing manipulating musical pitch information, including core tonalInterval class represent tonal pitch. module representing manipulating musical rhythm information, core rhythmInterval class represent rhythms.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumRclass.html"],"dir":"Reference","previous_headings":"","what":"humdrumR class — humdrumRclass","title":"humdrumR class — humdrumRclass","text":"S4 class basic unit humdrumR package. humdrumR object represents data read one humdrum files. documentation, refer objects interchangeably \"humdrumR corpora\", \"humdrumR objects,\" humdrumR data(sets). coding examples name \"humData.\"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumRclass.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"humdrumR class — humdrumRclass","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumRclass.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"humdrumR class — humdrumRclass","text":"important part humdrumR object humdrum tables holds within ; essence, humdrumR object simply wrapper around humdrum table, helps users visualize, index, summarize, manipulate table variety ways. Basic information size shape humdrumR objects can obtained calls nrecord, npiece, length, ncol, etc.. detailed summary information can obtained humdrumR corpus summary functions. humdrumR data can also coerced basic R data types using .matrix, .data.frame, etc.. number helpful functions also defined \"reshape\" reorganize data (e.g., foldHumdrum(), collapseHumdrum()), extract data \"normal\" R data structures (e.g, .matrix.humdrumR(), evalActive()). powerful features humdrumR tools gives ... Print readable view data shorthand/curtailed humdrum syntax. Filter humdrumR data, using subset.humdrumR() standard R indexing operators: [] [[]]. Apply arbitrary commands humtable fields using ()Humdrum routines.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumRclass.html"],"id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"humdrumR class — humdrumRclass","text":"Humtable humdrum tables---.e, data.table::data.table() particular fields. Files list two elements. first, \"Search\", contains single character representing pattern used call readHumdrum() created humdrumR object. second, \"Names,\" vector strings representing files matched pattern read humdrumR object, names() corresponding \"subcorpora\" labels (Label). Fields list containing strings corresponding existing fields humdrumR object's humdrum table. fields divided five categories: \"Data\", \"Structure\", \"Interpretation\", \"Formal\", \"Reference.\" Active rlang::quosure() expression serves default, \"active expression\" dataset. LoadTime POSIXct value, indicating time readHumdrum() called create humdrumR object.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumRroot.html"],"dir":"Reference","previous_headings":"","what":"humdrumR's root directory on your machine. — humdrumRroot","title":"humdrumR's root directory on your machine. — humdrumRroot","text":"humdrumRroot path humdrumR package install machine. installed humdrumR basic humdrum files stored well, subdirectories examples HumdrumData.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumRroot.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"humdrumR's root directory on your machine. — humdrumRroot","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/humdrumRroot.html"],"id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"humdrumR's root directory on your machine. — humdrumRroot","text":"object class character length 1.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/indexHumdrum.html"],"dir":"Reference","previous_headings":"","what":"Indexing humdrumR objects — indexHumdrum","title":"Indexing humdrumR objects — indexHumdrum","text":"R's built-indexing operators, [] (single brakcets) [[]] (double brackets) can used shortcuts common calls subset.humdrumR(), allowing filter specific pieces, spines, records.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/indexHumdrum.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Indexing humdrumR objects — indexHumdrum","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/indexHumdrum.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Indexing humdrumR objects — indexHumdrum","text":"x HumdrumR data index. Must humdrumR data object. Index vectors matrix/data.frame rows. numeric vector character string treated regular expression. j Index matrix/data.frame columns. numeric vector character string treated regular expression.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/indexHumdrum.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Indexing humdrumR objects — indexHumdrum","text":"R, basic indexing operators, [] [[]], used select subsets data. many data types (instance, base R lists) [single brackets] used \"shallower\" extraction [[double brackets]] used \"deeper\" extraction. HumdrumR corpus indexing follows basic pattern: [single brackets] used index humdrumR objects piece [[double brackets]] used index within pieces. (Accidentally writing [] need [[]] common error, watch !) Whether, indexing piece within, humdrumR objects can use two types indexing arguments: numeric (ordinal integers) character string (regular expressions) powerful/flexible indexing options, use subset directly.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/indexHumdrum.html"],"id":"numeric-indexing-","dir":"Reference","previous_headings":"","what":"Numeric indexing:","title":"Indexing humdrumR objects — indexHumdrum","text":"Indexing humdrumR corpora [single brackets] accept one numeric argument. argument used pick pieces within humdrumR object ordinally. Thus, humdata[1:10] select first ten pieces data humdata[42] select 42nd piece. Indexing humdrumR objects [[double brackets]] accept one two numeric arguments, j, either can used isolation combination. (j used isolation, must named placed comma, humdata[[ , j ]].) used index data records (.e., based humtable Record field). Thus, humdata[[1:20]] indexes first twenty records piece corpus, humdata[[42]] extracts 42nd record piece. j used index spines  (.e., based Spine field). Thus, humdata[[ , 3:4]] returns third fourth spines piece corpus. indexing humdrumR corpora numbers, numeric (double) inputs converted integers. Since subset always renumbers pieces/spines remain filtering/indexing, humdrumR indexing entirely ordinal. example,   return 12th piece original humdata object. first call [] returns 11th 20th pieces, renumbered 1:10 second index call returns new 2nd index, 12th originally. Similarly,   return third spine original data. normal R indexing, negative numbers can used, causing corresponding elements removed instead retained. Thus, humdata[-3:-5] remove third, fourth, fifth pieces data humdata[[ , -3:-5]] remove third, fourth, fifth spines piece. Positive negative indices mixed single argument. cases, indices outside range (value 0) ignored. E.g., corpus twenty pieces call corpus[21], 21st piece, 21 \"range\". input indices 0 error result. input indices range empty humdrumR object returned. instance, humdata[[401:500, ]] return empty humdrumR object pieces 400 data records.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/indexHumdrum.html"],"id":"character-indexing-","dir":"Reference","previous_headings":"","what":"Character indexing:","title":"Indexing humdrumR objects — indexHumdrum","text":"Indexing humdrumR objects [single brackets] accept one vector character strings. strings treated regular expressions (regexes). tokens humdrumR object's active field(s) searched matches regular expressions input. piece contains match regular expressions retained---pieces filtered . Note ([single-bracket] indexing) entire piece retained, even one match. matches occur pieces, empty humdrumR object returned. Indexing humdrumR objects [[double brackets]] accept one two vectors character strings, j, either can used isolation combination. (j used isolation, must placed comma, humdata[[ , j]].) strings treated regular expressions (regexes). tokens humdrumR object's active field(s) searched matches regular expressions input. record contains least one token matching regex retained. Similarly, spine contains least one token matching regex j retained. j used together, matching spines (j) indexed first, tokens matching regular expression(s) must found matching spines.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/indexHumdrum.html"],"id":"removeempty","dir":"Reference","previous_headings":"","what":"removeEmpty","title":"Indexing humdrumR objects — indexHumdrum","text":"default, calls indexing operators completely remove data filtering . However, set removeEmpty argument FALSE, filtered data set NULL, actually removed data object. (See subset.humdrumR() details.)","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/int.html"],"dir":"Reference","previous_headings":"","what":"Calculate intervals between pitches — int","title":"Calculate intervals between pitches — int","text":"functions allow us calculate intervals pitches. int() basic form, calculating interval(s) two input vectors. mint() hint() special forms calculating intervals \"melodically\" \"harmonically,\" respectively.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/int.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate intervals between pitches — int","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/int.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate intervals between pitches — int","text":"x Input pitch information. Can (atomic) vector, tonalInterval, NULL. Must parsable pitch information. Pitches calculate intervals . Defaults middle C / unison. Can (atomic) vector, tonalInterval, NULL. Must parsable pitch information. deparser output representation want? Defaults interval. Must pitch function, like kern(). incomplete pad incomplete intervals (e.g., start/end input). Defaults NULL int(), kern mint() hint(). Must NULL, pitch function, atomic value length(incomplete) == abs(lag). bracket Whether print brackets around incomplete output. Defaults TRUE. Must singleton logical value: /switch. TRUE, square brackets (\"[]\") printed around incomplete observations. classify intervals classified step/skip/leaps? Defaults FALSE. Must singleton logical value: /switch. TRUE, deparser ignored output classified Unison, Step, Skip, Leap. parseArgs optional list arguments passed pitch parser. Defaults empty list(). Must list named arguments pitch parser. lag lag() calculate harmonic/melodic intervals . Defaults 1, means intervals immediate successors x. Must either single number, logical length(x) (see \"Logical lags\" section manual). groupby list vectors group x. Defaults list(). Must list; every element list must length length(x). orderby list vectors group x. Defaults list(). Must list; every element list must length length(x). Used interpret order elements x. Lagged computations done indicated order, output returned original order.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/int.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate intervals between pitches — int","text":"Input vectors x () parsed pitches (tonal interval objects), possible. (Parsing arguments can passed via parseArgs list, parse(...) sugar. Key Exclusive arguments also passed parser.) inputs fail parse show NA output. parsed, intervals pitches calculated x - . resulting intervals \"deparsed\" standard representation; default, intervals() representation used, can set deparser argument pitch function. However, alternative deparser commonly used (besides intervals()) semits(). deparser NULL, raw tonalIntervals returned.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/int.html"],"id":"melodic-and-harmonic-intervals","dir":"Reference","previous_headings":"","what":"Melodic and Harmonic intervals","title":"Calculate intervals between pitches — int","text":"mint hint calculate \"melodic\" \"harmonic\" intervals respectively. context, \"melodies\" sequences notes within spine path, \"harmonies\" intervals notes occurring record (time). Outside () call, mint hint exactly ; used call () see different behaviors, () automatically apply across spine paths (mint()) records (hint()). achieved modifying groupby orderby arguments lag()---can manually achieve default behaviors, behaviors, setting arguments . used () expression, mint() (default) calculate melodic interval approaching note previous note: example, mint('C4', 'D4', 'Eb4') fill return c('[c]', '+M2', '+m2'), D4 approached ascending whole step C4, Eb4 approached ascending half step D4. Similarly, default () behavior hint() calculate successive intervals record (across spine paths), left right. record C3  G4  C5 return values [CC]  +P12  +P4, G4 perfect 12th C3, C5 perfect fourth G4. mint() hint() work passing lagged /dittoed versions x argument int(). Basically, mint() equivalent int(x, lag(x, lag = lag, groupby = list(Piece, Spine, Path)), ...) hint() equivalent int(x, lag(x, lag = lag, groupby = list(Piece, Record), orderby = list(Piece, Record, Spine, Path)), ...). either case, parsed pitch vector copied lagged using lag(), pairs crossing outside groupby groups ignored. lag argument controls far apart melody intervals calculated. instance, lag 2 calculate intervals every note vector. Positive lags (default) calculate approaching intervals: token represents interval current note previous note. Negative lags calculate departing intervals: token represents interval current note next note. Note , passing directed = FALSE deparser, undirected (absolute value) melodic intervals can returned.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/int.html"],"id":"incomplete-value-padding","dir":"Reference","previous_headings":"","what":"Incomplete value padding","title":"Calculate intervals between pitches — int","text":"default, int return NA anywhere x NA. However, NA x NA, can ask different output \"incomplete\" pairs. using incomplete argument. incomplete atomic value, incomplete outputs indices willed value. incomplete argument pitch function (like deparser argument), function used (re)parse values x missing. bracket == TRUE, incomplete output values surrounded [], easier distinguish actual intervals. main use incomplete argument mint() hint(). lagged arguments used mint()/hint() (see previous section) necessarily padded abs(lag) NA values beginning (positive lag) end (negative lag). thus \"incomplete\" pairs passed int(), can controlled using incomplete argument. default, mint() hint() set incomplete = kern(), bracket = TRUE cause notes show bracketed kern, like [ee-] [C#]. incomplete NULL, incomplete values simply padded NA.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/int.html"],"id":"interval-classification","dir":"Reference","previous_headings":"","what":"Interval classification","title":"Calculate intervals between pitches — int","text":"classify argument set TRUE, intervals classified either \"Unison\", \"Step\", \"Skip\", \"Leap\". Alternatively, skips can interpreted leaps setting skips = FALSE. (classify = TRUE overrides deparser argument.) default, intervals categorized tonally, meaning interval tonal steps used basis classification. example, augmented 2nd step, diminished 3rd skip/leap. means augmented diminished unisons marked \"Unison\" well! However, directed = TRUE, augmented/diminished unisons marked + - indicate direction, whereas perfect unisons never marked +/-. Alternatively, may choose categorize intervals atonally setting atonal = TRUE. , intervals categorized based semitone (enharmonic) intervals: D# Eb classified .","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/int.html"],"id":"logical-ditto-lags","dir":"Reference","previous_headings":"","what":"Logical (ditto) lags","title":"Calculate intervals between pitches — int","text":"calls hint() mint() default behavior numeric lag argument passed lag(). alternate option specify lag argument  logical vector length input (x argument). Rather calculating interval pitch another pitch separated regular lag, logical lag argument \"lags\" pitch back previous value lag == TRUE. means one interval can calculated TRUE indices. canonic use \"logical lag\" feature calculate harmonic intervals relative voice, like bass voice. example, consider file:   read file applied hint() Token field (default arguments) result :   record, see intervals lagged (lag == 1) left right: see intervals bass tenoir, tenor alto, alto soprano. wanted see intervals bass? Well, can use logical lag argument, specify Spine == 1: (humData, hint(Token, lag = Spine == 1). means values \"lagged\" back previous value Spine == 1. result :   Now see intervals relative bass. logical lag takes place within groupby groups. However, note values first index lag == TRUE calculated relative first value.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/int.html"],"id":"grouping","dir":"Reference","previous_headings":"","what":"Grouping","title":"Calculate intervals between pitches — int","text":"many cases want perform lagged calculations vector, across certain boundaries. example, vector includes data multiple pieces, want calculate melodic intervals pieces, within pieces. groupby argument indicates one, , grouping vectors, break x (input) argument groups. groupby vectors given, change vector indicates boundary. Value pairs cross groups treated beginning. Basically, using groupby argument function similar identical using tapply(x, groupby, laggedFunction, ...) using groupby expession call ().humdrumR. However, using groupby argument directly usually much faster, specially optimized functions. common use case humdrum data, looking \"melodies\" within spines. , want groupby = list(Piece, Spine, Path). fact, humdrumR () calls automatically feed three fields groupby arguments certain functions: mint, delta, sigma, lag, ditto, ioi, untie, hop. use delta call (), automatically calculate delta \"melodic\" way, within spine path piece. However, wanted, instance, calculate differences across spines (like harmonic intervals) manually set groupby = list(Piece, Record).","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/int.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate intervals between pitches — int","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interpretations.html"],"dir":"Reference","previous_headings":"","what":"Summarize humdrum corpus interpretations. — interpretations","title":"Summarize humdrum corpus interpretations. — interpretations","text":"interpretations used summarize interpretations pieces humdrumR corpus, including exclusive (**) tandem (*) interpretations. interpretations one humdrumR's basic corpus summary functions.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interpretations.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize humdrum corpus interpretations. — interpretations","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interpretations.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize humdrum corpus interpretations. — interpretations","text":"humdrumR HumdrumR data summarize. Must humdrumR data object. Index rows. numeric, selects rows index. character, string matched regular expression filenames corpus.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interpretations.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summarize humdrum corpus interpretations. — interpretations","text":"interpretations returns special data.frame called humInterpretations table. row table represents single piece corpus. first column ({X}) variable indicating unique \"exclusive pattern\" associated piece---exclusive patterns tallied bottom printout. remaining columns indicate many interpretation (indicated column name) appear piece. tandem interpretations, counts returned format Total.Unique.Spines: Total: total instances interpretation, across spines. Unique: number unique versions interpretation. Spines: number spines interpretation appears . example, consider following piece:   piece, several tandem key interpretations, humdrumR call Key. tabulation interpretations return Key column value 6.3.2 piece: 6 six key interpretations total. 3 three unique keys: *C:, *e: *G:. 2 key interpretations occur two spines.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interpretations.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize humdrum corpus interpretations. — interpretations","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interval.html"],"dir":"Reference","previous_headings":"","what":"Tonal (pitch) interval representation — interval","title":"Tonal (pitch) interval representation — interval","text":"returns standard representations intervals Western music.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interval.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tonal (pitch) interval representation — interval","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interval.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tonal (pitch) interval representation — interval","text":"x Input data parse pitch information. x argument can (atomic) vector, tonalInterval, NULL. ... Arguments passed pitch deparser. also two hidden (advanced) arguments can specify: memoize deparse (see details ). generic \"specific\" pitch information (accidentals qualites) discarded? Defaults FALSE. Must singleton logical value: /switch. simple \"compound\" pitch information (octave/contour) discarded? Defaults FALSE. Must singleton logical value: /switch. Key input Key used parser, deparser, transposer. Defaults NULL. Must diatonicSet something coercable diatonicSet; must either length 1 length(x) transposeArgs optional list arguments passed special transpose() call. Defaults empty list(). Must list named arguments transpose(). parseArgs optional list arguments passed pitch parser. Defaults empty list(). Must list named arguments pitch parser. inPlace non-pitch information retained output string. Defaults FALSE. Must singleton  logical value: /switch. argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interval.html"],"id":"basic-pitch-arguments","dir":"Reference","previous_headings":"","what":"Basic pitch arguments","title":"Tonal (pitch) interval representation — interval","text":"pitch function standard arguments control details output. important generic simple arguments, allow control type pitch information returned.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interval.html"],"id":"generic-vs-specific","dir":"Reference","previous_headings":"","what":"Generic vs Specific","title":"Tonal (pitch) interval representation — interval","text":"generic = TRUE, specific pitch information (accidentals qualities) omitted output. alternative way controlling functionality, can use specific argument, specific == !generic. case atonal functions, \"generic\" version pitch output: example, semits('c#', generic = TRUE) return 0, \"generic\" version C# C, corresponds 0. However, note generic version pitch follows key, semits('c#', generic = TRUE, Key = ':') return 1!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interval.html"],"id":"simple-vs-compound","dir":"Reference","previous_headings":"","what":"Simple vs Compound","title":"Tonal (pitch) interval representation — interval","text":"simple = TRUE, compound pitch information (octave contour) omitted output. alternative way controlling functionality, can use compound argument ,compound == !simple. actually one way might want divide compound intervals simple octave parts. example, might like call output -M2 (descending major 2nd) +m7 (ascending minor 7th octave ). functionality can controlled octave.round argument: see pitch deparsing documentation.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interval.html"],"id":"key","dir":"Reference","previous_headings":"","what":"Key","title":"Tonal (pitch) interval representation — interval","text":"Key argument must diatonicSet, something can parsed one. Key argument passed parser, deparser, transpose---unless alternate Key passed transposeArgs parseArgs. Various deparsing options use Key argument; example, use implicitSpecies (see advanced parsing section) dependent Key. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function---means, cases, need explicitly anything Key argument! (want happen, need explicitly specify Key argument, Key = NULL.)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interval.html"],"id":"parse-arguments","dir":"Reference","previous_headings":"","what":"Parse arguments","title":"Tonal (pitch) interval representation — interval","text":"parseArgs argument must list() (named) arguments passed input parser. example, input representation uses \"X\" represent double sharps, specify kern('CX5', parseArgs = list(doublesharp = 'X')) get correct result (\"cc##\"). convenient shorthand, \"syntactic sugar,\" can specify parseArgs alternate way: Simply input parse(args...) unnamed argument pitch function. example, can get exact result typing kern('CX5', parse(doublesharp = 'X')).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interval.html"],"id":"transpose-arguments","dir":"Reference","previous_headings":"","what":"Transpose arguments","title":"Tonal (pitch) interval representation — interval","text":"transposeArgs argument must list() (named) arguments passed internal call transpose(), allowing us easily transpose pitch information. example, type kern(c('C', 'D', 'E'), transposeArgs = list(= 'M9')) can get output c('d', 'e', 'f#'). possible transpose args : (tonalInterval, length == 1 | length == (x)) (diatonicSet, length == 1 | length == (x))  (diatonicSet, length == 1 | length == (x)) real (logical, length == 1) transposition real tonal? relative (logical, length == 1) key-wise transposition based relative parallel keys? convenient shorthand, \"syntactic sugar,\" can specify transposeArgs alternate way: Simply input transpose(args...) unnamed argument pitch function. example, can get exact result typing kern(c('C', 'D', 'E'), transpose(= 'M9')).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interval.html"],"id":"transposing-by-interval","dir":"Reference","previous_headings":"","what":"Transposing by interval","title":"Tonal (pitch) interval representation — interval","text":"calling transpose() directly, argument can anything coercable tonalInterval, output transposed amount. real = FALSE, tonal transposition (within Key) performed. details transposition behavior, check transpose() docs.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interval.html"],"id":"transposing-by-key","dir":"Reference","previous_headings":"","what":"Transposing by key","title":"Tonal (pitch) interval representation — interval","text":"Another way transposing specifying input (\"\") key output (\"\") key. default, Key argument passed transpose , nothing actually happens. Thus, specify either key key, transposition happen /key Key. course, specify transposition happen keys specify. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function. specify key, Key field passed transpose key, result, pitches input transposed whatever keys target () key! real relative arguments give special control key-wise transposition works, check transpose() docs details!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interval.html"],"id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Tonal (pitch) interval representation — interval","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interval.html"],"id":"pitch-gamut-levels","dir":"Reference","previous_headings":"","what":"Pitch-Gamut Levels","title":"Tonal (pitch) interval representation — interval","text":"table() automatically generate factor levels pitch data using gamut() function. makes sure tabulated data sorted logical order, includes missing pitches. simple/complex  generic/specific arguments automatically passed gamut(); additional arguments can passed gamut using gamutArgs = list(...), syntactic sugar gamut(...). (Read gamut() docs explanation gamut generation.) feature used control table layout pitch data, well assure consistent tables grouping data. inPlace = TRUE special tabulation occur.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/interval.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tonal (pitch) interval representation — interval","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/invert.html"],"dir":"Reference","previous_headings":"","what":"Invert or transpose pitches. — invert","title":"Invert or transpose pitches. — invert","text":"Invert transpose pitches.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/invert.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Invert or transpose pitches. — invert","text":"","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/ioi.html"],"dir":"Reference","previous_headings":"","what":"Sum ","title":"Sum ","text":"functions used sum (melodically) adjacent rhythmic duration values associated new onsets/attacks. ioi() adds duration rests previous non-rest (onset) duration, create interonset intervals (IOIs). untie() sums tied durations.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/ioi.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sum ","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/ioi.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sum ","text":"x Input rhythm information. x argument can (atomic) vector, NULL. Must parsable rhythm information. onsets logical vector denotes onsets. Defaults logical vector TRUE wherever rests, indicated presence \"r\" character, input x. Must logical; must length length(x). durations x onsets == FALSE added previous value onsets == TRUE. finalOnset Whether count last onset. Defaults FALSE. Must singleton logical value: /switch. TRUE, last IOI computed last onset end input vector. Otherwise, last IOI undefined (NA). groupby list vectors group x. Defaults list(). Must list; every element list must length length(x). parseArgs optional list arguments passed rhythm parser. Defaults empty list(). Must list named arguments rhythm parser. inPlace non-rhythm information retained output string? Defaults TRUE. Must singleton  logical value: /switch. open beginnings ties indicated x? Defaults [. Must single character string, interpreted regular expression. close ends ties indicated x? Defaults ]. Must single character string, interpreted regular expression.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/ioi.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sum ","text":"functions return \"collapsed\" durations null data tokens. example, untie(c('[4a', '4a]', '2g')) returns c('2a', '.', '2g'), second (tied) duration null (\".\"). interonset intervals, last duration string durations undefined---final onset, next onset, really \"interonset\" interval. Thus, default, ioi() return NA location final duration. However, finalOnset argument set TRUE, function act like one additional onset end sequence: last \"IOI\" calculated last onset fictional \"final onset.\" example, run ioi(c('4.','8r', '4.','8r','2a', '2r')) result c(\"2a\", \".\", \"2a\", \".\", NA, \".\"), last onset (2a) returning NA. However, run ioi(c('4.','8r', '4.','8r','2a', '2r'), finalOnset = TRUE) result c(\"2a\", \".\", \"2a\", \".\", \"1a\", \".\")---last onset's whole duration end returned! Non-onsets (rests) occur first onset returned null.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/ioi.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sum ","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/is.major.html"],"dir":"Reference","previous_headings":"","what":"Test the major/minor modality of a set — is.major","title":"Test the major/minor modality of a set — is.major","text":"functions test majorness/minorness tertian diatonic set, logical TRUE/FALSE. functions testing whether chord strictly major minor chord, rather \"broad\" major/minorness: gnerally, presence minor third degree makes set \"minor\"; thus, diminished chord \"minor\" lydian key \"major.\"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/is.major.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test the major/minor modality of a set — is.major","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/is.major.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test the major/minor modality of a set — is.major","text":"x Input data, interpreted diatonic keys chords. Must diatonicSet tertianSet something can parsed one. ... Parameters passed parsers (tertianSet() diatonicSet()).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/is.major.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test the major/minor modality of a set — is.major","text":"Either function can called directly tertian diatonic sets. called anything else, functions first call tertianSet() parser. values fail parse (returning NA), diatonicSet() parser called .","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/is.simple.html"],"dir":"Reference","previous_headings":"","what":"Test the properties of tonal information — is.simple","title":"Test the properties of tonal information — is.simple","text":"functions test basic properties pitch information. .simple returns TRUE pitch information constrained one octave. .generic returns TRUE pitch information \"natural\" key (Key) argument.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/is.simple.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test the properties of tonal information — is.simple","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/is.simple.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test the properties of tonal information — is.simple","text":"x Pitch information. Must something can parsed pitch information. ... Parameters passed tonalInterval(). octave.round rounding function. Must rouding function. Controls simple intervals interpreted relative C. Key diatonic key used defined generic pitches. Defaults NULL. Must something can parsed diatonic key; must either length 1 length(x).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/is.simple.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test the properties of tonal information — is.simple","text":"functions can called directly tonalIntervals; called anything else, functions first calls tonalInterval() parser. values fail parse NA returned. \"Simple\" intervals fall particular octave relative middle-C/unison. octave.floor argument can used change works: default option, floor, interprets (**kern) pitches  c, d, e, f, g, , b \"simple.\" common alternative, round, identifies G, , B, c, d, e, f \"simple.\" See pitch deparsing docs detailed explanation. \"Generic\" intervals belong key.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/kern.html"],"dir":"Reference","previous_headings":"","what":"Kern pitch representation — kern","title":"Kern pitch representation — kern","text":"Kern (**kern) common humdrum interpretation representing \"notes\" style traditional Western scores. However! humdrumR, kern function outputs pitch part **kern interpretation. **kern rhythms instead created using recip() function.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/kern.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Kern pitch representation — kern","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/kern.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Kern pitch representation — kern","text":"x Input data parse pitch information. x argument can (atomic) vector, tonalInterval, NULL. ... Arguments passed pitch deparser. also two hidden (advanced) arguments can specify: memoize deparse (see details ). generic \"specific\" pitch information (accidentals qualites) discarded? Defaults FALSE. Must singleton logical value: /switch. simple \"compound\" pitch information (octave/contour) discarded? Defaults FALSE. Must singleton logical value: /switch. Key input Key used parser, deparser, transposer. Defaults NULL. Must diatonicSet something coercable diatonicSet; must either length 1 length(x) transposeArgs optional list arguments passed special transpose() call. Defaults empty list(). Must list named arguments transpose(). parseArgs optional list arguments passed pitch parser. Defaults empty list(). Must list named arguments pitch parser. inPlace non-pitch information retained output string. Defaults FALSE. Must singleton  logical value: /switch. argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/kern.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Kern pitch representation — kern","text":"pitch part **kern tokens breakdown tonal pitch information : Steps 1: \"C\" \"c\" 2: \"D\" \"d\" 3: \"E\" \"e\" 4: \"F\" \"f\" 5: \"G\" \"g\" 6: \"\" \"\" 7: \"B\" \"b\" Accidentals Flat: \"-\" Sharp: \"#\" Octave Octave indicated case step characters, well repetition step character. Uppercase letters used octaves ; lowercase letters middle-C octave higher.  octave, octave get one character , higher lower octaves repeating character. example, using C# step value, relative  octave: -3: \"CCC#\" -2: \"CC#\" -1: \"C#\" 0: \"c#\" +1: \"cc#\" +2: \"ccc#\" +3: \"cccc#\" Tokens ordered Step/Octave + Accidentals, separator. Like humdrumR pitch functions, ways kern parses deparses tokens can modified accomodate variations standard **kern pitch representation.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/kern.html"],"id":"basic-pitch-arguments","dir":"Reference","previous_headings":"","what":"Basic pitch arguments","title":"Kern pitch representation — kern","text":"pitch function standard arguments control details output. important generic simple arguments, allow control type pitch information returned.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/kern.html"],"id":"generic-vs-specific","dir":"Reference","previous_headings":"","what":"Generic vs Specific","title":"Kern pitch representation — kern","text":"generic = TRUE, specific pitch information (accidentals qualities) omitted output. alternative way controlling functionality, can use specific argument, specific == !generic. case atonal functions, \"generic\" version pitch output: example, semits('c#', generic = TRUE) return 0, \"generic\" version C# C, corresponds 0. However, note generic version pitch follows key, semits('c#', generic = TRUE, Key = ':') return 1!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/kern.html"],"id":"simple-vs-compound","dir":"Reference","previous_headings":"","what":"Simple vs Compound","title":"Kern pitch representation — kern","text":"simple = TRUE, compound pitch information (octave contour) omitted output. alternative way controlling functionality, can use compound argument ,compound == !simple. actually one way might want divide compound intervals simple octave parts. example, might like call output -M2 (descending major 2nd) +m7 (ascending minor 7th octave ). functionality can controlled octave.round argument: see pitch deparsing documentation.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/kern.html"],"id":"key","dir":"Reference","previous_headings":"","what":"Key","title":"Kern pitch representation — kern","text":"Key argument must diatonicSet, something can parsed one. Key argument passed parser, deparser, transpose---unless alternate Key passed transposeArgs parseArgs. Various deparsing options use Key argument; example, use implicitSpecies (see advanced parsing section) dependent Key. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function---means, cases, need explicitly anything Key argument! (want happen, need explicitly specify Key argument, Key = NULL.)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/kern.html"],"id":"parse-arguments","dir":"Reference","previous_headings":"","what":"Parse arguments","title":"Kern pitch representation — kern","text":"parseArgs argument must list() (named) arguments passed input parser. example, input representation uses \"X\" represent double sharps, specify kern('CX5', parseArgs = list(doublesharp = 'X')) get correct result (\"cc##\"). convenient shorthand, \"syntactic sugar,\" can specify parseArgs alternate way: Simply input parse(args...) unnamed argument pitch function. example, can get exact result typing kern('CX5', parse(doublesharp = 'X')).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/kern.html"],"id":"transpose-arguments","dir":"Reference","previous_headings":"","what":"Transpose arguments","title":"Kern pitch representation — kern","text":"transposeArgs argument must list() (named) arguments passed internal call transpose(), allowing us easily transpose pitch information. example, type kern(c('C', 'D', 'E'), transposeArgs = list(= 'M9')) can get output c('d', 'e', 'f#'). possible transpose args : (tonalInterval, length == 1 | length == (x)) (diatonicSet, length == 1 | length == (x))  (diatonicSet, length == 1 | length == (x)) real (logical, length == 1) transposition real tonal? relative (logical, length == 1) key-wise transposition based relative parallel keys? convenient shorthand, \"syntactic sugar,\" can specify transposeArgs alternate way: Simply input transpose(args...) unnamed argument pitch function. example, can get exact result typing kern(c('C', 'D', 'E'), transpose(= 'M9')).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/kern.html"],"id":"transposing-by-interval","dir":"Reference","previous_headings":"","what":"Transposing by interval","title":"Kern pitch representation — kern","text":"calling transpose() directly, argument can anything coercable tonalInterval, output transposed amount. real = FALSE, tonal transposition (within Key) performed. details transposition behavior, check transpose() docs.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/kern.html"],"id":"transposing-by-key","dir":"Reference","previous_headings":"","what":"Transposing by key","title":"Kern pitch representation — kern","text":"Another way transposing specifying input (\"\") key output (\"\") key. default, Key argument passed transpose , nothing actually happens. Thus, specify either key key, transposition happen /key Key. course, specify transposition happen keys specify. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function. specify key, Key field passed transpose key, result, pitches input transposed whatever keys target () key! real relative arguments give special control key-wise transposition works, check transpose() docs details!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/kern.html"],"id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Kern pitch representation — kern","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/kern.html"],"id":"pitch-gamut-levels","dir":"Reference","previous_headings":"","what":"Pitch-Gamut Levels","title":"Kern pitch representation — kern","text":"table() automatically generate factor levels pitch data using gamut() function. makes sure tabulated data sorted logical order, includes missing pitches. simple/complex  generic/specific arguments automatically passed gamut(); additional arguments can passed gamut using gamutArgs = list(...), syntactic sugar gamut(...). (Read gamut() docs explanation gamut generation.) feature used control table layout pitch data, well assure consistent tables grouping data. inPlace = TRUE special tabulation occur.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/kern.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Kern pitch representation — kern","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/key.html"],"dir":"Reference","previous_headings":"","what":"Humdrum key interpretation — key","title":"Humdrum key interpretation — key","text":"Humdrum key interpretation","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/key.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Humdrum key interpretation — key","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/key.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Humdrum key interpretation — key","text":"x Input data, interpreted diatonic keys. Must atomic vector. Key key used parser, deparser, transposer. Defaults NULL. Must diatonicSet something coercable diatonicSet; must either length 1 length(x) parseArgs optional list arguments passed key parser. Defaults empty list(). Must list named arguments key parser.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/key.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Humdrum key interpretation — key","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/keyDeparsing.html"],"dir":"Reference","previous_headings":"","what":"Generating (","title":"Generating (","text":"humdrumR includes easy--use system generating variety diatonic key representations, can flexibly modified users. \"hood\" humdrumR represents tonal chord information using underlying representation, typically extracted input data using key parser. representation can \"deparsed\" variety predefined output formats, new formats create!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/keyDeparsing.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generating (","text":"Deparsing second step key function processing pipeline: Input representation |> Parsing |> Intermediate (diatonicSet) representation |> Transformation  |> Deparsing (DEPARSING ARGS GO ) |> Output representation Various pitch representations can generated using predefined key functions like key() signature(), romanKey(). functions use common deparsing framework, specified using different combinations arguments deparser. modifying \"deparsing\" arguments, can exercise fine control want pitch information represented output.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/keyFunctions.html"],"dir":"Reference","previous_headings":"","what":"Parsing and deparsing key information — keyFunctions","title":"Parsing and deparsing key information — keyFunctions","text":"functions can used extract \"translate,\" otherwise modify, data representing diatonic key information. functions :","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/keyFunctions.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parsing and deparsing key information — keyFunctions","text":"x Input data, interpreted diatonic keys. Must atomic vector. Key key used parser, deparser, transposer. Defaults NULL. Must diatonicSet something coercable diatonicSet; must either length 1 length(x) parseArgs optional list arguments passed key parser. Defaults empty list(). Must list named arguments key parser.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/keyFunctions.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parsing and deparsing key information — keyFunctions","text":"key() romanKey() signature()","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/keyParsing.html"],"dir":"Reference","previous_headings":"","what":"Parsing key information — keyParsing","title":"Parsing key information — keyParsing","text":"humdrumR includes easy--use powerful system parsing diatonic key information: various basic key representations (including numeric character-string representations) can \"parsed\"---read interpreted humdrumR. part, parsing automatically happens \"behind scenes\" whenever use humdrumR key function, like key() signature().","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/keyParsing.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parsing key information — keyParsing","text":"","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lag.html"],"dir":"Reference","previous_headings":"","what":"Shift data within a vector/matrix/data.frame — lag","title":"Shift data within a vector/matrix/data.frame — lag","text":"lag lead functions take input vectors, matrices, data.frames shifts data n indices. similar data.table::shift() function, additional options.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lag.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shift data within a vector/matrix/data.frame — lag","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lag.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shift data within a vector/matrix/data.frame — lag","text":"x input argument. list, atomic, matrix, data.frame. n amount lag/lead data. Defaults 0. Must natural number. n == 0, x returned unchanged. fill Tokens used pad outputs. Defaults NA. class x. wrap = FALSE parts output padded fill argument. wrap Whether wrap data. Defaults FALSE. Must logical. Must length 1. wrap = TRUE, data end (head tail) copied end output, \"wrapping\" data within data structure. groupby group data. vector list vectors; must length length(x). segment x delineated groupby vector(s) treated separately. margin dimension shift. Must numeric. Arrays data.frames can lagged lead multiple dimensions using margin argument: margin == 1 shifts across rows margin == 2 shifts across columns.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lag.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Shift data within a vector/matrix/data.frame — lag","text":"lagged vector values original vector, except offset n indices. lag moves value high index (n > 0); lead opposite, moving value lower index (n > 0). n can positive negative---negative lags equivalent leads, vice versa. Values near end/beginning either \"wrapped\" opposite end vector, replaced/padded value fill argument. vector , b, c, d, e, f, g can lagged n==1 NA, , b, c, d, e, f. set wrap == TRUE, \"g\" moved beginning output: g, , b, c, d, e, f.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lag.html"],"id":"grouping","dir":"Reference","previous_headings":"","what":"Grouping","title":"Shift data within a vector/matrix/data.frame — lag","text":"many cases want perform lagged calculations vector, across certain boundaries. example, vector includes data multiple pieces, want calculate melodic intervals pieces, within pieces. groupby argument indicates one, , grouping vectors, break x (input) argument groups. groupby vectors given, change vector indicates boundary. Value pairs cross groups treated beginning. Basically, using groupby argument function similar identical using tapply(x, groupby, laggedFunction, ...) using groupby expession call ().humdrumR. However, using groupby argument directly usually much faster, specially optimized functions. common use case humdrum data, looking \"melodies\" within spines. , want groupby = list(Piece, Spine, Path). fact, humdrumR () calls automatically feed three fields groupby arguments certain functions: mint, delta, sigma, lag, ditto, ioi, untie, hop. use delta call (), automatically calculate delta \"melodic\" way, within spine path piece. However, wanted, instance, calculate differences across spines (like harmonic intervals) manually set groupby = list(Piece, Record).","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lilypond.html"],"dir":"Reference","previous_headings":"","what":"Lilypond pitch representation — lilypond","title":"Lilypond pitch representation — lilypond","text":"representation used represent (Western tonal) pitches Lilypond notation format. humdrumR, lilypond function relates pitch part Lilypond notation: Lilypond-like rhythms can creating using recip function.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lilypond.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lilypond pitch representation — lilypond","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lilypond.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lilypond pitch representation — lilypond","text":"x Input data parse pitch information. x argument can (atomic) vector, tonalInterval, NULL. ... Arguments passed pitch deparser. also two hidden (advanced) arguments can specify: memoize deparse (see details ). generic \"specific\" pitch information (accidentals qualites) discarded? Defaults FALSE. Must singleton logical value: /switch. simple \"compound\" pitch information (octave/contour) discarded? Defaults FALSE. Must singleton logical value: /switch. Key input Key used parser, deparser, transposer. Defaults NULL. Must diatonicSet something coercable diatonicSet; must either length 1 length(x) transposeArgs optional list arguments passed special transpose() call. Defaults empty list(). Must list named arguments transpose(). parseArgs optional list arguments passed pitch parser. Defaults empty list(). Must list named arguments pitch parser. inPlace non-pitch information retained output string. Defaults FALSE. Must singleton  logical value: /switch. argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lilypond.html"],"id":"basic-pitch-arguments","dir":"Reference","previous_headings":"","what":"Basic pitch arguments","title":"Lilypond pitch representation — lilypond","text":"pitch function standard arguments control details output. important generic simple arguments, allow control type pitch information returned.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lilypond.html"],"id":"generic-vs-specific","dir":"Reference","previous_headings":"","what":"Generic vs Specific","title":"Lilypond pitch representation — lilypond","text":"generic = TRUE, specific pitch information (accidentals qualities) omitted output. alternative way controlling functionality, can use specific argument, specific == !generic. case atonal functions, \"generic\" version pitch output: example, semits('c#', generic = TRUE) return 0, \"generic\" version C# C, corresponds 0. However, note generic version pitch follows key, semits('c#', generic = TRUE, Key = ':') return 1!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lilypond.html"],"id":"simple-vs-compound","dir":"Reference","previous_headings":"","what":"Simple vs Compound","title":"Lilypond pitch representation — lilypond","text":"simple = TRUE, compound pitch information (octave contour) omitted output. alternative way controlling functionality, can use compound argument ,compound == !simple. actually one way might want divide compound intervals simple octave parts. example, might like call output -M2 (descending major 2nd) +m7 (ascending minor 7th octave ). functionality can controlled octave.round argument: see pitch deparsing documentation.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lilypond.html"],"id":"key","dir":"Reference","previous_headings":"","what":"Key","title":"Lilypond pitch representation — lilypond","text":"Key argument must diatonicSet, something can parsed one. Key argument passed parser, deparser, transpose---unless alternate Key passed transposeArgs parseArgs. Various deparsing options use Key argument; example, use implicitSpecies (see advanced parsing section) dependent Key. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function---means, cases, need explicitly anything Key argument! (want happen, need explicitly specify Key argument, Key = NULL.)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lilypond.html"],"id":"parse-arguments","dir":"Reference","previous_headings":"","what":"Parse arguments","title":"Lilypond pitch representation — lilypond","text":"parseArgs argument must list() (named) arguments passed input parser. example, input representation uses \"X\" represent double sharps, specify kern('CX5', parseArgs = list(doublesharp = 'X')) get correct result (\"cc##\"). convenient shorthand, \"syntactic sugar,\" can specify parseArgs alternate way: Simply input parse(args...) unnamed argument pitch function. example, can get exact result typing kern('CX5', parse(doublesharp = 'X')).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lilypond.html"],"id":"transpose-arguments","dir":"Reference","previous_headings":"","what":"Transpose arguments","title":"Lilypond pitch representation — lilypond","text":"transposeArgs argument must list() (named) arguments passed internal call transpose(), allowing us easily transpose pitch information. example, type kern(c('C', 'D', 'E'), transposeArgs = list(= 'M9')) can get output c('d', 'e', 'f#'). possible transpose args : (tonalInterval, length == 1 | length == (x)) (diatonicSet, length == 1 | length == (x))  (diatonicSet, length == 1 | length == (x)) real (logical, length == 1) transposition real tonal? relative (logical, length == 1) key-wise transposition based relative parallel keys? convenient shorthand, \"syntactic sugar,\" can specify transposeArgs alternate way: Simply input transpose(args...) unnamed argument pitch function. example, can get exact result typing kern(c('C', 'D', 'E'), transpose(= 'M9')).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lilypond.html"],"id":"transposing-by-interval","dir":"Reference","previous_headings":"","what":"Transposing by interval","title":"Lilypond pitch representation — lilypond","text":"calling transpose() directly, argument can anything coercable tonalInterval, output transposed amount. real = FALSE, tonal transposition (within Key) performed. details transposition behavior, check transpose() docs.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lilypond.html"],"id":"transposing-by-key","dir":"Reference","previous_headings":"","what":"Transposing by key","title":"Lilypond pitch representation — lilypond","text":"Another way transposing specifying input (\"\") key output (\"\") key. default, Key argument passed transpose , nothing actually happens. Thus, specify either key key, transposition happen /key Key. course, specify transposition happen keys specify. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function. specify key, Key field passed transpose key, result, pitches input transposed whatever keys target () key! real relative arguments give special control key-wise transposition works, check transpose() docs details!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lilypond.html"],"id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Lilypond pitch representation — lilypond","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lilypond.html"],"id":"pitch-gamut-levels","dir":"Reference","previous_headings":"","what":"Pitch-Gamut Levels","title":"Lilypond pitch representation — lilypond","text":"table() automatically generate factor levels pitch data using gamut() function. makes sure tabulated data sorted logical order, includes missing pitches. simple/complex  generic/specific arguments automatically passed gamut(); additional arguments can passed gamut using gamutArgs = list(...), syntactic sugar gamut(...). (Read gamut() docs explanation gamut generation.) feature used control table layout pitch data, well assure consistent tables grouping data. inPlace = TRUE special tabulation occur.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/lilypond.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lilypond pitch representation — lilypond","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/meter.html"],"dir":"Reference","previous_headings":"","what":"Musical Meter in humdrumR — meter","title":"Musical Meter in humdrumR — meter","text":"HumdrumR represents musical meter, internally, using S4-class meter. meter simply collection regular irregular beat \"levels,\" level represented musical durations. example, meter 4/4 represented recip() beat-levels c(\"1\", \"2\", \"4\", \"8\", \"16\")---, whole-note, half-note, quater-note, eighth-note, sixteenth note. addition, meter tactus---\"main\" beat level.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/meter.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Musical Meter in humdrumR — meter","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/meter.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Musical Meter in humdrumR — meter","text":"x time signature list beats used construct meter. Must character string list either numeric character values. character input parsed time signature, used extract tactus measure levels. contents list parsed durations using rhythmInterval(): durations become levels meter. Failures parse input result error. measure, tick, tactus Durations use longest (measure), shortest (tick), tactus levels. Must singleton character numeric value, list containing single vector values. parsed durations using rhythmInterval(); parse failures lead errors. fill.levels \"gaps\" specified levels added meter? Must singleton logical character value; character values must '', '', '', 'neither'. TRUE shorthand ''; FALSE shorthand 'neither'. subdiv Subdivisions (fractions) tactus add meter. Must positive natural numbers. hyper Multiples measure duration add meter. Must positive natural numbers. tatum least common denominator levels added meter? Must singleton logical value: /switch.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/meter.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Musical Meter in humdrumR — meter","text":"Generating meters humdrumR can done easily meter() function. pass character string humdrum time signature, get meter object: example, meter(\"M4/4\") meter(\"M12/8\"). Additive time signatures, like meter(M2+3/8) also parseable.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/meter.html"],"id":"adding-or-removing-levels","dir":"Reference","previous_headings":"","what":"Adding or removing levels","title":"Musical Meter in humdrumR — meter","text":"Time signatures leave lot room interpretation. Even \"standard\" 4/4 time, number questions need consider analyzing meter: fastest level want count? 16ths? 32nds? 64ths? want count half-note level, \"\" full measure (whole-note) tactus quarter-note? want treat triplets tuplets? piece uses lot want consider hypermeter, measure level? triplet eighth-notes? Fortunately, humdrumR meter() function give options precisely specify metric levels. transparent way simply pass meter() list duration values, like meter(list(\"1\", \"4\", \"8\")). However, meter() includes number helpful arguments can used quickly streamline process defining meter. understand arguments, lets first clarify metric defitions used humdrumR: Measure: duration \"measure\" meter. .e., highest metric level, least common multiple levels. Hypermeter: Metric levels measure indicated time signature. Tactus: \"main,\", usually central, level. Subdivision: level directly tactus. Tick: smallest/fastest metric level. (\"ticks\" grid.) Tatum: smallest common denominator set beats/duration. Note fully specified metric grid tick tatum identical. However, require tick tatum.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/meter.html"],"id":"meter-construction-arguments","dir":"Reference","previous_headings":"","what":"Meter construction arguments","title":"Musical Meter in humdrumR — meter","text":"measure (largest) tick (smallest) levels capture full range meter. tactus typically somewhere middle two, required. fill.levels argument can used 'fill ' levels measure, tactus, tick. means room \"fit\" (geometrically) duple triple subdivisions higher lower level, subdivisions added meter. fill.levels argument must single character string, partially matching either '', '', '', 'neither'. \"\" means fill gap tactus measure; \"\" means fill gap tactus tick. shortcut, logical TRUE FALSE can used alternative way specifiying '' 'neither', respectively. example, start levels measure-tactus-tick combination c(\"1\", \"4\", \"16\"), fill.levels = TRUE, fill levels \"2\" \"8\". tick argument can used directly specify tick meter. especially useful parsing datasets multiple meters, want force use tick value. example, meter(TimeSignature, tick = '32'). tick argument must single value can parsed rhythmic duration. subdiv argument can used explicitly control tactus subdivided. subdiv natural number (greater 1), divide tactus . Similarly, hyper argument natural number explicitly multiply measure . Thus, hyper = 2 adds two-measure hyper meter. tatum argument, TRUE, causes tatum metric levels added meter (already present). useful, example, specify meter mix duple triple levels want make sure tick meter tatum levels. example, levels c(\"4\", \"6\", \"8\"), tatum = TRUE add level \"24\" meter.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/meter.html"],"id":"constructing-meters-from-time-signatures","dir":"Reference","previous_headings":"","what":"Constructing meters from time signatures","title":"Musical Meter in humdrumR — meter","text":"\"meter construction arguments\" can also used reading time signatures. allows use time signatures datasets, maintaining precise control metric levels used. example, command meter(\"M4/4\", fill.levels = FALSE) generates meter levels c(\"1\", \"4\", \"16\"). add eighth-note level adding subdiv = 2, triple-eighth-notes subdiv = 3. add triplet-eighth-notes (subdiv = 3), might want add tatum = TRUE, automatically calculate common tatum levels---case, adding forty-eighth notes meter. opposite end, hyper = 4 add four-measure hyper meter top 4/4 bar. Finally, tactus argument used choose another tactus, like tactus = \"2\". additional, unnamed arguments meter() parsed durations, added levels meter.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/metlev.html"],"dir":"Reference","previous_headings":"","what":"Count or measure metric position — metlev","title":"Count or measure metric position — metlev","text":"functions take vectors rhythmic duration values compute metric position rhythmic onset. metlev() identifies metric level onset; metcount() counts beats within measure; metsubpos() measures distance onset nearest metric beat. metcount() metsubpos() parallel general count() subpos() functions.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/metlev.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count or measure metric position — metlev","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/metlev.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count or measure metric position — metlev","text":"dur input vector rhythmic durations. Must character numeric vector. parsed using rhythmInterval(); Wherever input parsed duration, element treated duration zero. meter meter(s) compute levels . Defaults standard, five-level duple (4/4) meter. Must meter() object character vector. character input, string parsed using meter(); failure parse result error. pickup pickup (anacrusis)? Defaults NULL Must logical length(x), NULL. See \"Pickups\" section . value output levels represented rhythmic duration values? Defaults TRUE. Must singleton logical value: /switch. offBeats -beat onsets numbered output, NA? Defaults TRUE. Must single logical value: /switch. remainderSubdivides -beat onsets associated beat levels evenly subdivide? Defaults FALSE. singleton logical value: /switch. groupby list vectors group x. Defaults list(). Must list; every element list must length length(x). function -record timeline, groupby list music include named Piece Record fields. Luckily, automatically passed ().humdrumR, need worry ! parseArgs optional list arguments passed rhythm parser. Defaults empty list(). Must list named arguments rhythm parser. level metric level counted? Defaults tactus meter. single character value positive natural number. character string input must recip() value, matching beat level meter. numeric input directly indicates level meter, starting highest level (1).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/metlev.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Count or measure metric position — metlev","text":"Watch ! met...() functions require meter information output highly dependent interpret meter scores. full discussion meter can represented, parsed, created humdrumR, see meter() manual. Effective use meter() function essential use metlev(), metcount(), metsubpos().","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/metlev.html"],"id":"metric-levels","dir":"Reference","previous_headings":"","what":"Metric levels","title":"Count or measure metric position — metlev","text":"metlev() identifies \"highest\" (longest) metric level onset lands /: example, 4/4 time: onset downbeat highest level , whole-note level; onset beat three 4/4 measure half-note level; Onsets backbeats (beats two two) fall quarter-note level; next level eighth-note level, quarter-note beat; etc. metlev() output expresses beat levels duration level, recip() format default. whole-note level \"1\" quarter-note level (backbeats) \"4\". can specify different deparsing function (like duration()) using deparser argument. (deparser NULL, rational() numbers returned.) Another option express metric levels simply natural numbers, can achieve argument value = FALSE. case, top level meter 1, next lower-level incrementing : .e., quarter-note level (4/4) 3, sixteenth-note level 5.","code":""},{"path":[],"code":""},{"path":[],"code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/metlev.html"],"id":"metric-counts","dir":"Reference","previous_headings":"","what":"Metric counts","title":"Count or measure metric position — metlev","text":"metcount() function counts one beat level metric hierarchy, within next highest level. full duple meter, counts always simply 1, 2, 1, 2, etc. Meters triple level get 1, 2, 3, etc. level want count controlled level argument, can either character string recip() format natural number (1 top level, 2 next lowest level, etc.).","code":""},{"path":[],"code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/metlev.html"],"id":"-meter-counts--1","dir":"Reference","previous_headings":"","what":"6/8 meter counts:","title":"Count or measure metric position — metlev","text":"case 4/4, want count 1, 2, 3, 4, need make meter() object include half-note level.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/metlev.html"],"id":"-meter-with-no-half-note-level-","dir":"Reference","previous_headings":"","what":"4/4 meter with no half-note level:","title":"Count or measure metric position — metlev","text":"can meter('M4/4', fill.levels = '').","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/metlev.html"],"id":"metric-subpositions","dir":"Reference","previous_headings":"","what":"Metric subpositions","title":"Count or measure metric position — metlev","text":"cases, onsets may occur land beat specified meter. fast beat levels (e.g., 32nd notes), triplets, tuplets. cases, might consider adding levels meter(); example, want 32nd-note level 4/4, use meter('M4/4', tick = '32'). metlev() metcount(), offBeats argument can set FALSE cause offbeat onsets return NA. Another option use metsubpos(), measures far onset nearest associated beat meter. default, -beat onsets always associated closets previous position level meter. remainderSubdivides argument TRUE, -beat onsets associated previous metric level subposition makes even subdivision .","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/metlev.html"],"id":"pickups","dir":"Reference","previous_headings":"","what":"Pickups","title":"Count or measure metric position — metlev","text":"Another option pass pickup argument logical vector length input x. Within piece/group, block TRUE values beginning pickup vector indicate pickup. first index pickup logical FALSE used starting point timeline/count; earlier (pickup == TRUE) points negative numbers, measured backwards start index. humdrumR, datapoints first barline record (=) labeled Bar == 0 Bar field. Thus, common use pickup argument within(humData, timeline(Token, pickup = Bar < 1), makes downbeat first complete bar 1 starting point timeline---notes pickup bars negative timeline.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/metlev.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Count or measure metric position — metlev","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/mutualInfo.html"],"dir":"Reference","previous_headings":"","what":"Calculate Mutual Information of variables — mutualInfo","title":"Calculate Mutual Information of variables — mutualInfo","text":"Calculate Mutual Information variables","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/mutualInfo.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Mutual Information of variables — mutualInfo","text":"","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/nbeats.html"],"dir":"Reference","previous_headings":"","what":"Counting beats — nbeats","title":"Counting beats — nbeats","text":"Counting beats","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/nbeats.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Counting beats — nbeats","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/noteValue.html"],"dir":"Reference","previous_headings":"","what":"Note value representation of duration — noteValue","title":"Note value representation of duration — noteValue","text":"function outputs duration information traditional note value. symbols, Western notation.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/noteValue.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Note value representation of duration — noteValue","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/noteValue.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Note value representation of duration — noteValue","text":"x (atomic vector) x argument can (atomic) vector, rational (rhythmInterval), NULL. ... arguments passed rhythm deparser. also two hidden (advanced) arguments can specify: memoize deparse (see details ). parseArgs (list) parseArgs can list arguments passed rhythm parser. scale numeric rational value used output unit measurement: default value functions rational(1, 1), whole-note \"duration.\" inPlace (logical, length == 1) argument effect input (x argument) character strings, extra, non-duration information input strings \"besides\" rhythm information. , inPlace = TRUE, output placed output string beside original non-rhythm information. inPlace = FALSE, rhythm output information returned (details ).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/noteValue.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Note value representation of duration — noteValue","text":"Note-value symbols simply encoded character vectors, since unicode character table includes musical symbols. course, depends system unicode font installed working: symbols might show properly machine! fact, symbols always print bit strangely (alignment) can hard manipulate like \"normal\" character strings. note-value symbols useful making labels plots. example, tabulate note values use barplot(), get nice bar labels:","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/notehead.html"],"dir":"Reference","previous_headings":"","what":"Note value representation of duration — notehead","title":"Note value representation of duration — notehead","text":"function outputs duration information traditional note value. symbols, Western notation.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/notehead.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Note value representation of duration — notehead","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/notehead.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Note value representation of duration — notehead","text":"x input  vector. x argument can (atomic) vector, rational (rhythmInterval), NULL. Must parsable rhythm infromation. ... Arguments passed rhythm parser. also two hidden (advanced) arguments can specify: memoize deparse (see details ). parseArgs optional list arguments passed rhythm parser. Defaults empty list(). Must list named arguments rhythm parser. scale numeric rational value used output unit measurement. Defaults rational(1, 1). Must numeric rational. inPlace non-rhythm information retained output string? Defaults FALSE. Must singleton  logical value: /switch. Defaults FALSE. singleton logical value, NA. See \"Grace notes\" section .","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/notehead.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Note value representation of duration — notehead","text":"Note-value symbols simply encoded character vectors, since unicode character table includes musical symbols. course, depends system unicode font installed working: symbols might show properly machine! fact, symbols always print bit strangely (alignment) can hard manipulate like \"normal\" character strings. note-value symbols useful making labels plots. example, tabulate note values use barplot(), get nice bar labels:","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/notehead.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Note value representation of duration — notehead","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/octave.html"],"dir":"Reference","previous_headings":"","what":"Extract octave. — octave","title":"Extract octave. — octave","text":"Returns octave pitch falls . default, middle-C bottom zeroth-octave, can changed octave.offset argument. octave labels (like lilypond()-style marks) can used set octave.integer = FALSE.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/octave.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract octave. — octave","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/octave.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract octave. — octave","text":"x Input data parse pitch information. x argument can (atomic) vector, tonalInterval, NULL. ... Arguments passed pitch deparser. also two hidden (advanced) arguments can specify: memoize deparse (see details ). generic \"specific\" pitch information (accidentals qualites) discarded? Defaults FALSE. Must singleton logical value: /switch. simple \"compound\" pitch information (octave/contour) discarded? Defaults FALSE. Must singleton logical value: /switch. Key input Key used parser, deparser, transposer. Defaults NULL. Must diatonicSet something coercable diatonicSet; must either length 1 length(x) transposeArgs optional list arguments passed special transpose() call. Defaults empty list(). Must list named arguments transpose(). parseArgs optional list arguments passed pitch parser. Defaults empty list(). Must list named arguments pitch parser. inPlace non-pitch information retained output string. Defaults FALSE. Must singleton  logical value: /switch. argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":[],"code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/p.html"],"dir":"Reference","previous_headings":"","what":"Tabulate and cross proportions — %*%,probabilityDistribution,probabilityDistribution-method","title":"Tabulate and cross proportions — %*%,probabilityDistribution,probabilityDistribution-method","text":"Tabulate cross proportions","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/p.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tabulate and cross proportions — %*%,probabilityDistribution,probabilityDistribution-method","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/partialMatching.html"],"dir":"Reference","previous_headings":"","what":"Partial matching — partialMatching","title":"Partial matching — partialMatching","text":"R useful functionality called \"partial matching,\" can match incomplete character string variable name list options. achieved using base-R function pmatch(), many R functions make use , many humdrumR functions.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/partialMatching.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Partial matching — partialMatching","text":"example, say data.frame (call df) three columns: \"Number\", \"Letter\", \"Date\":   want access Number column, programming languages require write least df$Number. However, R give correct field even write df$Numb, df$Num, even df$N. partial matching! matching happens left--right, long get beginning variable right, work. course, partial matching works point string matches unambiguously. example, added Dare column df, df$D df$Da return NULL ambiguous. need write least Dar Dat get Dare Date columns respectively.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pc.html"],"dir":"Reference","previous_headings":"","what":"Representation of atonal pitch classes — pc","title":"Representation of atonal pitch classes — pc","text":"encoded humdrum **pc interpretation.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pc.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Representation of atonal pitch classes — pc","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pc.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Representation of atonal pitch classes — pc","text":"x Input data parse pitch information. x argument can (atomic) vector, tonalInterval, NULL. ... Arguments passed pitch deparser. also two hidden (advanced) arguments can specify: memoize deparse (see details ). generic \"specific\" pitch information (accidentals qualites) discarded? Defaults FALSE. Must singleton logical value: /switch. simple \"compound\" pitch information (octave/contour) discarded? Defaults FALSE. Must singleton logical value: /switch. Key input Key used parser, deparser, transposer. Defaults NULL. Must diatonicSet something coercable diatonicSet; must either length 1 length(x) transposeArgs optional list arguments passed special transpose() call. Defaults empty list(). Must list named arguments transpose(). parseArgs optional list arguments passed pitch parser. Defaults empty list(). Must list named arguments pitch parser. inPlace non-pitch information retained output string. Defaults FALSE. Must singleton  logical value: /switch. argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ). ten shorthand-symbol use 10. Defaults \"\". Must single character string. NULL, \"10\" used shorthand. eleven shorthand-symbol use 11. Defaults \"B\". Must single character string. NULL, \"11\" used shorthand.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pc.html"],"id":"basic-pitch-arguments","dir":"Reference","previous_headings":"","what":"Basic pitch arguments","title":"Representation of atonal pitch classes — pc","text":"pitch function standard arguments control details output. important generic simple arguments, allow control type pitch information returned.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pc.html"],"id":"generic-vs-specific","dir":"Reference","previous_headings":"","what":"Generic vs Specific","title":"Representation of atonal pitch classes — pc","text":"generic = TRUE, specific pitch information (accidentals qualities) omitted output. alternative way controlling functionality, can use specific argument, specific == !generic. case atonal functions, \"generic\" version pitch output: example, semits('c#', generic = TRUE) return 0, \"generic\" version C# C, corresponds 0. However, note generic version pitch follows key, semits('c#', generic = TRUE, Key = ':') return 1!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pc.html"],"id":"simple-vs-compound","dir":"Reference","previous_headings":"","what":"Simple vs Compound","title":"Representation of atonal pitch classes — pc","text":"simple = TRUE, compound pitch information (octave contour) omitted output. alternative way controlling functionality, can use compound argument ,compound == !simple. actually one way might want divide compound intervals simple octave parts. example, might like call output -M2 (descending major 2nd) +m7 (ascending minor 7th octave ). functionality can controlled octave.round argument: see pitch deparsing documentation.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pc.html"],"id":"key","dir":"Reference","previous_headings":"","what":"Key","title":"Representation of atonal pitch classes — pc","text":"Key argument must diatonicSet, something can parsed one. Key argument passed parser, deparser, transpose---unless alternate Key passed transposeArgs parseArgs. Various deparsing options use Key argument; example, use implicitSpecies (see advanced parsing section) dependent Key. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function---means, cases, need explicitly anything Key argument! (want happen, need explicitly specify Key argument, Key = NULL.)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pc.html"],"id":"parse-arguments","dir":"Reference","previous_headings":"","what":"Parse arguments","title":"Representation of atonal pitch classes — pc","text":"parseArgs argument must list() (named) arguments passed input parser. example, input representation uses \"X\" represent double sharps, specify kern('CX5', parseArgs = list(doublesharp = 'X')) get correct result (\"cc##\"). convenient shorthand, \"syntactic sugar,\" can specify parseArgs alternate way: Simply input parse(args...) unnamed argument pitch function. example, can get exact result typing kern('CX5', parse(doublesharp = 'X')).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pc.html"],"id":"transpose-arguments","dir":"Reference","previous_headings":"","what":"Transpose arguments","title":"Representation of atonal pitch classes — pc","text":"transposeArgs argument must list() (named) arguments passed internal call transpose(), allowing us easily transpose pitch information. example, type kern(c('C', 'D', 'E'), transposeArgs = list(= 'M9')) can get output c('d', 'e', 'f#'). possible transpose args : (tonalInterval, length == 1 | length == (x)) (diatonicSet, length == 1 | length == (x))  (diatonicSet, length == 1 | length == (x)) real (logical, length == 1) transposition real tonal? relative (logical, length == 1) key-wise transposition based relative parallel keys? convenient shorthand, \"syntactic sugar,\" can specify transposeArgs alternate way: Simply input transpose(args...) unnamed argument pitch function. example, can get exact result typing kern(c('C', 'D', 'E'), transpose(= 'M9')).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pc.html"],"id":"transposing-by-interval","dir":"Reference","previous_headings":"","what":"Transposing by interval","title":"Representation of atonal pitch classes — pc","text":"calling transpose() directly, argument can anything coercable tonalInterval, output transposed amount. real = FALSE, tonal transposition (within Key) performed. details transposition behavior, check transpose() docs.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pc.html"],"id":"transposing-by-key","dir":"Reference","previous_headings":"","what":"Transposing by key","title":"Representation of atonal pitch classes — pc","text":"Another way transposing specifying input (\"\") key output (\"\") key. default, Key argument passed transpose , nothing actually happens. Thus, specify either key key, transposition happen /key Key. course, specify transposition happen keys specify. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function. specify key, Key field passed transpose key, result, pitches input transposed whatever keys target () key! real relative arguments give special control key-wise transposition works, check transpose() docs details!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pc.html"],"id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Representation of atonal pitch classes — pc","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pc.html"],"id":"pitch-gamut-levels","dir":"Reference","previous_headings":"","what":"Pitch-Gamut Levels","title":"Representation of atonal pitch classes — pc","text":"table() automatically generate factor levels pitch data using gamut() function. makes sure tabulated data sorted logical order, includes missing pitches. simple/complex  generic/specific arguments automatically passed gamut(); additional arguments can passed gamut using gamutArgs = list(...), syntactic sugar gamut(...). (Read gamut() docs explanation gamut generation.) feature used control table layout pitch data, well assure consistent tables grouping data. inPlace = TRUE special tabulation occur.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pc.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Representation of atonal pitch classes — pc","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitch.html"],"dir":"Reference","previous_headings":"","what":"Scientific pitch representation — pitch","title":"Scientific pitch representation — pitch","text":"Scientific pitch standard approach representing pitch traditional Western music.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitch.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scientific pitch representation — pitch","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitch.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scientific pitch representation — pitch","text":"x Input data parse pitch information. x argument can (atomic) vector, tonalInterval, NULL. ... Arguments passed pitch deparser. also two hidden (advanced) arguments can specify: memoize deparse (see details ). generic \"specific\" pitch information (accidentals qualites) discarded? Defaults FALSE. Must singleton logical value: /switch. simple \"compound\" pitch information (octave/contour) discarded? Defaults FALSE. Must singleton logical value: /switch. Key input Key used parser, deparser, transposer. Defaults NULL. Must diatonicSet something coercable diatonicSet; must either length 1 length(x) transposeArgs optional list arguments passed special transpose() call. Defaults empty list(). Must list named arguments transpose(). parseArgs optional list arguments passed pitch parser. Defaults empty list(). Must list named arguments pitch parser. inPlace non-pitch information retained output string. Defaults FALSE. Must singleton  logical value: /switch. argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitch.html"],"id":"basic-pitch-arguments","dir":"Reference","previous_headings":"","what":"Basic pitch arguments","title":"Scientific pitch representation — pitch","text":"pitch function standard arguments control details output. important generic simple arguments, allow control type pitch information returned.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitch.html"],"id":"generic-vs-specific","dir":"Reference","previous_headings":"","what":"Generic vs Specific","title":"Scientific pitch representation — pitch","text":"generic = TRUE, specific pitch information (accidentals qualities) omitted output. alternative way controlling functionality, can use specific argument, specific == !generic. case atonal functions, \"generic\" version pitch output: example, semits('c#', generic = TRUE) return 0, \"generic\" version C# C, corresponds 0. However, note generic version pitch follows key, semits('c#', generic = TRUE, Key = ':') return 1!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitch.html"],"id":"simple-vs-compound","dir":"Reference","previous_headings":"","what":"Simple vs Compound","title":"Scientific pitch representation — pitch","text":"simple = TRUE, compound pitch information (octave contour) omitted output. alternative way controlling functionality, can use compound argument ,compound == !simple. actually one way might want divide compound intervals simple octave parts. example, might like call output -M2 (descending major 2nd) +m7 (ascending minor 7th octave ). functionality can controlled octave.round argument: see pitch deparsing documentation.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitch.html"],"id":"key","dir":"Reference","previous_headings":"","what":"Key","title":"Scientific pitch representation — pitch","text":"Key argument must diatonicSet, something can parsed one. Key argument passed parser, deparser, transpose---unless alternate Key passed transposeArgs parseArgs. Various deparsing options use Key argument; example, use implicitSpecies (see advanced parsing section) dependent Key. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function---means, cases, need explicitly anything Key argument! (want happen, need explicitly specify Key argument, Key = NULL.)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitch.html"],"id":"parse-arguments","dir":"Reference","previous_headings":"","what":"Parse arguments","title":"Scientific pitch representation — pitch","text":"parseArgs argument must list() (named) arguments passed input parser. example, input representation uses \"X\" represent double sharps, specify kern('CX5', parseArgs = list(doublesharp = 'X')) get correct result (\"cc##\"). convenient shorthand, \"syntactic sugar,\" can specify parseArgs alternate way: Simply input parse(args...) unnamed argument pitch function. example, can get exact result typing kern('CX5', parse(doublesharp = 'X')).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitch.html"],"id":"transpose-arguments","dir":"Reference","previous_headings":"","what":"Transpose arguments","title":"Scientific pitch representation — pitch","text":"transposeArgs argument must list() (named) arguments passed internal call transpose(), allowing us easily transpose pitch information. example, type kern(c('C', 'D', 'E'), transposeArgs = list(= 'M9')) can get output c('d', 'e', 'f#'). possible transpose args : (tonalInterval, length == 1 | length == (x)) (diatonicSet, length == 1 | length == (x))  (diatonicSet, length == 1 | length == (x)) real (logical, length == 1) transposition real tonal? relative (logical, length == 1) key-wise transposition based relative parallel keys? convenient shorthand, \"syntactic sugar,\" can specify transposeArgs alternate way: Simply input transpose(args...) unnamed argument pitch function. example, can get exact result typing kern(c('C', 'D', 'E'), transpose(= 'M9')).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitch.html"],"id":"transposing-by-interval","dir":"Reference","previous_headings":"","what":"Transposing by interval","title":"Scientific pitch representation — pitch","text":"calling transpose() directly, argument can anything coercable tonalInterval, output transposed amount. real = FALSE, tonal transposition (within Key) performed. details transposition behavior, check transpose() docs.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitch.html"],"id":"transposing-by-key","dir":"Reference","previous_headings":"","what":"Transposing by key","title":"Scientific pitch representation — pitch","text":"Another way transposing specifying input (\"\") key output (\"\") key. default, Key argument passed transpose , nothing actually happens. Thus, specify either key key, transposition happen /key Key. course, specify transposition happen keys specify. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function. specify key, Key field passed transpose key, result, pitches input transposed whatever keys target () key! real relative arguments give special control key-wise transposition works, check transpose() docs details!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitch.html"],"id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Scientific pitch representation — pitch","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitch.html"],"id":"pitch-gamut-levels","dir":"Reference","previous_headings":"","what":"Pitch-Gamut Levels","title":"Scientific pitch representation — pitch","text":"table() automatically generate factor levels pitch data using gamut() function. makes sure tabulated data sorted logical order, includes missing pitches. simple/complex  generic/specific arguments automatically passed gamut(); additional arguments can passed gamut using gamutArgs = list(...), syntactic sugar gamut(...). (Read gamut() docs explanation gamut generation.) feature used control table layout pitch data, well assure consistent tables grouping data. inPlace = TRUE special tabulation occur.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitch.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Scientific pitch representation — pitch","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html"],"dir":"Reference","previous_headings":"","what":"Generating (","title":"Generating (","text":"humdrumR includes easy--use system generating variety tonal (atonal) pitch representations, can flexibly modified users. \"hood\" humdrumR represents tonal pitch information using underlying representation, typically extracted input data using pitch parser. representation can \"deparsed\" variety predefined output formats (like **kern), new formats create!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generating (","text":"Deparsing second step pitch function processing pipeline: Input representation |> Parsing |> Intermediate (tonalInterval) representation |> Transformation  |> Deparsing (DEPARSING ARGS GO ) |> Output representation Various pitch representations like **kern, **solfa, **semits can generated using predefined pitch functions like kern() semits(), solfa() respectively. functions use common deparsing framework, specified using different combinations arguments deparser.modifying \"deparsing\" arguments, can exercise fine control want pitch information represented output. documentation talks deparsing step. overview parsing process, look .","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html"],"id":"basic-pitch-arguments","dir":"Reference","previous_headings":"","what":"Basic pitch arguments","title":"Generating (","text":"pitch function standard arguments control details output. important generic simple arguments, allow control type pitch information returned.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html"],"id":"generic-vs-specific","dir":"Reference","previous_headings":"","what":"Generic vs Specific","title":"Generating (","text":"generic = TRUE, specific pitch information (accidentals qualities) omitted output. alternative way controlling functionality, can use specific argument, specific == !generic. case atonal functions, \"generic\" version pitch output: example, semits('c#', generic = TRUE) return 0, \"generic\" version C# C, corresponds 0. However, note generic version pitch follows key, semits('c#', generic = TRUE, Key = ':') return 1!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html"],"id":"simple-vs-compound","dir":"Reference","previous_headings":"","what":"Simple vs Compound","title":"Generating (","text":"simple = TRUE, compound pitch information (octave contour) omitted output. alternative way controlling functionality, can use compound argument ,compound == !simple. actually one way might want divide compound intervals simple octave parts. example, might like call output -M2 (descending major 2nd) +m7 (ascending minor 7th octave ). functionality can controlled octave.round argument: see pitch deparsing documentation.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html"],"id":"key","dir":"Reference","previous_headings":"","what":"Key","title":"Generating (","text":"Key argument must diatonicSet, something can parsed one. Key argument passed parser, deparser, transpose---unless alternate Key passed transposeArgs parseArgs. Various deparsing options use Key argument; example, use implicitSpecies (see advanced parsing section) dependent Key. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function---means, cases, need explicitly anything Key argument! (want happen, need explicitly specify Key argument, Key = NULL.)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html"],"id":"parse-arguments","dir":"Reference","previous_headings":"","what":"Parse arguments","title":"Generating (","text":"parseArgs argument must list() (named) arguments passed input parser. example, input representation uses \"X\" represent double sharps, specify kern('CX5', parseArgs = list(doublesharp = 'X')) get correct result (\"cc##\"). convenient shorthand, \"syntactic sugar,\" can specify parseArgs alternate way: Simply input parse(args...) unnamed argument pitch function. example, can get exact result typing kern('CX5', parse(doublesharp = 'X')).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html"],"id":"transpose-arguments","dir":"Reference","previous_headings":"","what":"Transpose arguments","title":"Generating (","text":"transposeArgs argument must list() (named) arguments passed internal call transpose(), allowing us easily transpose pitch information. example, type kern(c('C', 'D', 'E'), transposeArgs = list(= 'M9')) can get output c('d', 'e', 'f#'). possible transpose args : (tonalInterval, length == 1 | length == (x)) (diatonicSet, length == 1 | length == (x))  (diatonicSet, length == 1 | length == (x)) real (logical, length == 1) transposition real tonal? relative (logical, length == 1) key-wise transposition based relative parallel keys? convenient shorthand, \"syntactic sugar,\" can specify transposeArgs alternate way: Simply input transpose(args...) unnamed argument pitch function. example, can get exact result typing kern(c('C', 'D', 'E'), transpose(= 'M9')).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html"],"id":"transposing-by-interval","dir":"Reference","previous_headings":"","what":"Transposing by interval","title":"Generating (","text":"calling transpose() directly, argument can anything coercable tonalInterval, output transposed amount. real = FALSE, tonal transposition (within Key) performed. details transposition behavior, check transpose() docs.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html"],"id":"transposing-by-key","dir":"Reference","previous_headings":"","what":"Transposing by key","title":"Generating (","text":"Another way transposing specifying input (\"\") key output (\"\") key. default, Key argument passed transpose , nothing actually happens. Thus, specify either key key, transposition happen /key Key. course, specify transposition happen keys specify. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function. specify key, Key field passed transpose key, result, pitches input transposed whatever keys target () key! real relative arguments give special control key-wise transposition works, check transpose() docs details!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html"],"id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Generating (","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html"],"id":"deparsing-arguments","dir":"Reference","previous_headings":"","what":"Deparsing arguments","title":"Generating (","text":"following \"advanced\" deparsing arguments available (read details ): Steps step.labels step.signed Species (accidentals qualities) qualities specifier.maximum Accidentals natural, flat, sharp, doubleflat, doublesharp Qualities perfect, major, minor, augment, diminish Implicit vs Explicit Species implicitSpecies absoluteSpecies explicitNaturals cautionary memory, memoryWindows Octave octave.integer , , octave.offset octave.round octave.relative, octave.absolute String parsing parts sep Note deparsing arguments similar (sometimes identical) parallel parsing arguments. \"advanced\" arguments can used directly pitch function: example, kern(x, qualities = TRUE). humdrumR pitch functions associated default deparsing arguments. example, use kern(), flat set (default) \"-\". However, wanted print **kern-like pitch data, except different flat symbol, like \"_\", modify deparser: kern('Eb5', flat = \"_\"). overrides default value **kern, output \"ee_\" instead \"ee-\".","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html"],"id":"steps","dir":"Reference","previous_headings":"","what":"Steps","title":"Generating (","text":"representations \"tonal\" pitch information include representation diatonic steps. can control deparser writes diatonic steps using step.labels argument. step.labels argument must atomic vector unique values, length positive multiple seven. Examples step.labels arguments currently used humdrumR pitch functions include: step.labels = c('', 'B', 'C', 'D', 'E', 'F', 'G') step.labels = c('', 'II', 'III', 'IV', 'V', 'VI', 'VII') step.labels = c('d', 'r', 'm', 'f', 's', 'l', 't') step.labels NULL, steps assumed printed integers, including negative integers representing downward steps. also step.signed (logical, length == 1) argument: step.signed = TRUE, lowercase versions step.labels interpreted negative (downward) steps uppercase versions step.labels interpreted positive (upwards) steps. option used, example, default kern() helmholtz() parsers.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html"],"id":"species","dir":"Reference","previous_headings":"","what":"Species","title":"Generating (","text":"tonal pitch representations, \"specific\" versions tonal pitches---tonal \"species\"---indicated \"specifiers\": either accidentals qualities. qualities (logical, length == 1) argument indicates whether accidentals used (qualities = FALSE) qualities (qualities = TRUE). specifiers can repeated number times, like \"triple sharps\" \"doubly augmented\"; specifier.maximum (integer, length == 1) argument sets maximum limit number specifiers write. example, force triple sharps (\"###\") double sharps (\"##\") deparse just \"#\", specifying specifier.maximum = 1L.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html"],"id":"accidentals","dir":"Reference","previous_headings":"","what":"Accidentals","title":"Generating (","text":"qualities = FALSE deparser print accidentals three types: naturals, flats, sharps. natural, flat, /sharp (character, length == 1) arguments can used indicate accidentals printed output. example, set kern('Eb5', flat = 'flat') get output \"eeflat\". Examples accidental argument combinations currently used humdrumR pitch functions include: (flat = \"b\", sharp = \"#\") ->  pitch() (flat = \"-\", sharp = \"#\") ->  kern() (flat = \"es\", sharp = \"\") -> lilypond() (flat = \"-\", sharp = \"+\") -> degree() doubleflat, doublesharp (character, length == 1) arguments NULL default, can set special symbol wanted represent two sharps flats. example, modify pitch() use special double sharp symbol: pitch(\"f##\", doublesharp = \"x\") output \"Fx4\". printing naturals controlled natural argument. However, default, humdrumR deparsers printing naturals. can force naturals print setting explicitNaturals (logical, length == 1) argument TRUE. exact behavior explicitNaturals depends implicitSpecies, absoluteSpecies, Key argument (details ).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html"],"id":"qualities","dir":"Reference","previous_headings":"","what":"Qualities","title":"Generating (","text":"qualities = TRUE deparser print qualities, five types: perfect, minor, major, augmented, diminished. perfect, major, minor, diminish, /augment (character, length == 1) arguments can used indicate qualities printed output. (Note: talking interval/degree qualities , chord qualities!) example, can write interval(c(\"g-\", \"f#\"), augment = 'aug', diminish = 'dim') output c(\"+dim5\", \"+aug4\"). Examples quality argument combinations currently used humdrumR pitch functions include: parse(major = \"M\", minor = \"m\", perfect = \"P\", diminish = \"d\", augment = \"\") parse(diminish = \"o\", augment = \"+\")","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html"],"id":"implicit-vs-explicit-species","dir":"Reference","previous_headings":"","what":"Implicit vs Explicit Species","title":"Generating (","text":"musical data, specifiers (e.g., accidentals qualities) explicitly indicated; instead, must infer species pitch context---like key signature!.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html"],"id":"from-the-key","dir":"Reference","previous_headings":"","what":"From the Key","title":"Generating (","text":"important argument implicitSpecies (logical, length == 1): implicitSpecies = TRUE, species input without explicit species indicated interpreted using Key. example, kern('C', Key = ':', parse(implicitSpecies = TRUE)) parsed \"C#\" C sharp major. kern('C', Key = ':', parse(implicitSpecies = TRUE)) parsed \"C\" C natural minor. kern('C', Key = '-:', parse(implicitSpecies = TRUE)) parsed \"C-\" C flat -flat minor. default, input already specifiers, interpreted absolutely---overriding \"implicit\" Key---, even implicitSpecies = TRUE. Thus, major: kern(\"C#\", Key = ':', parse(implicitSpecies = TRUE)) parsed \"C#\". \"#\" unnecessary. kern(\"Cn\", Key = ':', parse(implicitSpecies = TRUE)) parsed \"C\". \"n\" overrides Key. kern(\"C#\", Key = ':', parse(implicitSpecies = TRUE)) parsed \"C#\". \"#\" overrides Key. However! can also change behavior setting absoluteSpecies (logical, length == 1) argument FALSE. , specifiers input interpreted \"top \" key accidental: kern(\"C#\", Key = ':', parse(implicitSpecies = TRUE, absoluteSpecies = FALSE)) parsed \"C##\". \"#\" input added \"#\" Key, resulting double sharp! unusual behavior, absolute pitch representations like **kern. However, use scale chord degrees, absoluteSpecies = FALSE might appropriate. example, reading figured bass key E minor, \"b7\" figure E bass interpreted double flat (diminished) 7th (Db E)! data encoded, use absoluteSpecies = FALSE.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html"],"id":"memory","dir":"Reference","previous_headings":"","what":"Memory","title":"Generating (","text":"musical data, assume accidental note \"stays effect\" scale step next bar, different accidental replaces . Fortunately, humdrumR parser (tonalInterval()) also knows parse data encoded \"memory\" way. memory = TRUE, accidental (quality) input note \"remembered\" previous appearances scale step. example, kern(c(\"D#\", \"E\", \"D\", \"E\", \"Dn\", \"C\", \"D\"), parse(memory = TRUE)) parsed c(\"D#\", \"E\", \"D#\", \"E\", \"D\", \"C\", \"D\") want \"memory\" last specific time windows (like bars), can also specify memoryWindows argument. memoryWindows must atomic vector length input (x argument). unique value within memoryWindows vector treated \"window\" within memory operates. common use case pass Bar field humdrumR dataset memoryWindows! memory memoryWindows argument work whatever values implicitSpecies absoluteSpecies specified! Though examples use accidentals, arguments effect parsing qualities (qualities = TRUE).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html"],"id":"octave","dir":"Reference","previous_headings":"","what":"Octave","title":"Generating (","text":"final piece information encoded () pitch representations indication \"compound pitch\"--- incorporating octave information. humdrumR octaves always defined terms scale steps: two notes scale degree/letter name always octave. mainly comes regards Cb B#: Cb4 semitone ; B#3 enharmonically middle-C.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html"],"id":"integer-octaves","dir":"Reference","previous_headings":"","what":"Integer Octaves","title":"Generating (","text":"simplest way octave information can encoded integer value, Scientific Pitch. need parse integer-encoded octaves, set octave.integer (logical, length == 1) argument TRUE. default, humdrumR considers \"central\" octave (octave == 0) octave , equivalently, unison. However, different octave used central octave, can specify octave.offset (integer, length == 1) argument. illustrate, default Scientific Pitch parser used arguments: kern('C5', parse(octave.integer = TRUE, octave.offset = 4) Returns \"cc\" (octave middle C).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html"],"id":"non-integer-octave-markers","dir":"Reference","previous_headings":"","what":"Non-integer Octave Markers","title":"Generating (","text":"octave.integer = FALSE, humdrumR parser instead looks three possible symbols indicate octave information. symbols controlled using , , (character, length == 1) arguments. symbol, symbol, interpreted \"central\" octave; repeating strings symbols indicate increasing positive () negative () octaves. example, lilypond notation, , represents lower octaves, ' (single apostrophe) represents upper octaves. default lilypond() parser uses arguments: pitch(c(\"c\", \"c\", \"c'\"), parse(octave.integer = FALSE, = \"'\", = \",\", octave.offset = 1)) Returns c(\"C2\", \"C3\", \"C4\"). (Note lilypond makes octave  central octave, using octave.offset = 1.)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html"],"id":"octave-rounding-","dir":"Reference","previous_headings":"","what":"Octave \"Rounding\"","title":"Generating (","text":"situations, pitch data might interpret \"groupby\" octaves little differently. absolute pitch representations (e.g., kern(), pitch()), \"boundary\" one octave next B (degree 7) C (degree 1). However, example, working data representing intervals, might think \"octave\" spanning range -P4 (G) +P4 (f). case, \"octave boundary\" centered around unison (), rather starting middle-C/unison. data represented way, use octave.round argument; octave.round must rounding function, either round, floor, ceiling, trunc, expand. functions indicate interpret simple pitches \"rounding\" nearest C/unison. default behavior pitch representations octave.round = floor: scale step rounded downwards nearest C. B associated C 7 steps . , hand, octave.round = round, scale-steps \"rounded\" closest C, B associated closer C . Indeed, octave.round = round gets us -P4 <-> +P4 behavior mentioned earlier! working parsing intervals, octave.round option allows control \"simple part\" (less octave) compound interval represented. example, might think ascending major 12th ascending octave plus ascending perfect 5th: ** +P8 + P5**. encode interval two ascending octaves minus perfect fourth: + P15 - P4. following table illustrates different octave.round arguments \"partition\" compound intervals simple parts octaves: Notice , octave.floor used, simple intervals represented ascending. parsing \"absolute\" pitch representations, octave.round option allows control octave notes associated . following table illustrates:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html"],"id":"absolute-or-relative-contour-octave","dir":"Reference","previous_headings":"","what":"Absolute or Relative (contour) Octave","title":"Generating (","text":"notation encoding schemes, \"octave\" note interpreted relative previous note, rather absolute reference. prominent system Lilypond's relative octave entry style. style often used combination scale degree representations---RS200 corpus. example, data set might say Re Mi vSo La Ti , \"v\" indicating jump . activate relative-octave parsing, set octave.relative = TRUE---alternatively, can use octave.absolute = FALSE, equivalent. relative-octave data, assume octave indications indicate shift relative previous note. usually used combination octave markers like \"^\" () \"v\" (). Different combinations octave.round allow us parse different behaviors: octave.round = round, marker (marker) indicates note pitch closest previous pitch. Octave markers indicate alterations assumption. always, based scale steps, semitones! fourth \"closer\" fifth, regardless quality: C F# ascending C Gb descending! ascending diminished 5th written C ^Gb---= ^. octave.round = floor, marker (marker) indicates note octave previous pitch. Octave markers indicate alterations assumption. setting, going C B always requires mark.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html"],"id":"string-parsing","dir":"Reference","previous_headings":"","what":"String Parsing","title":"Generating (","text":"addition three types musical parsing considerations reviewed (steps, species, octaves), also general string-parsing issues can consider/control.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html"],"id":"parts-and-order","dir":"Reference","previous_headings":"","what":"Parts and Order","title":"Generating (","text":"far () discussed various ways tonal pitch information (step, species, octave) can encoded, humdrumR parser can modified handle different options. However, two general parsing issues/options consider: information encoded, order? parts argument can specifyied indicate . parts argument must character vector length 1--3. characters must partial match either \"step\", \"species\", \"octave\". presense strings parts vector indicate information parsed. order strings indicates order pieces pitch information encoded input strings. illustrate, imagine input data identical standard interval representation---e.g., M2 P5---except quality appears step---e.g., 2M 5P. call interval(c(\"2M\", \"5P\"), parse(parts = c(\"step\", \"species\"))) sure enough get correct parse! One final string-parsing argument sep, indicates character string separating pitch information components: common case comma space. example, use parse command like : kern(\"E flat 5\", parse(flat = \"flat\", sep = \" \")).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchDeparsing.html"],"id":"pitch-gamut-levels","dir":"Reference","previous_headings":"","what":"Pitch-Gamut Levels","title":"Generating (","text":"table() automatically generate factor levels pitch data using gamut() function. makes sure tabulated data sorted logical order, includes missing pitches. simple/complex  generic/specific arguments automatically passed gamut(); additional arguments can passed gamut using gamutArgs = list(...), syntactic sugar gamut(...). (Read gamut() docs explanation gamut generation.) feature used control table layout pitch data, well assure consistent tables grouping data. inPlace = TRUE special tabulation occur.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchFunctions.html"],"dir":"Reference","previous_headings":"","what":"Translate between pitch representations. — pitchFunctions","title":"Translate between pitch representations. — pitchFunctions","text":"functions used extract translate different representations pitch information. functions can also things like transposing simplifying pitches.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchFunctions.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Translate between pitch representations. — pitchFunctions","text":"x Input data parse pitch information. x argument can (atomic) vector, tonalInterval, NULL. ... Arguments passed pitch deparser. also two hidden (advanced) arguments can specify: memoize deparse (see details ). generic \"specific\" pitch information (accidentals qualites) discarded? Defaults FALSE. Must singleton logical value: /switch. simple \"compound\" pitch information (octave/contour) discarded? Defaults FALSE. Must singleton logical value: /switch. Key input Key used parser, deparser, transposer. Defaults NULL. Must diatonicSet something coercable diatonicSet; must either length 1 length(x) parseArgs optional list arguments passed pitch parser. Defaults empty list(). Must list named arguments pitch parser. transposeArgs optional list arguments passed special transpose() call. Defaults empty list(). Must list named arguments transpose(). inPlace non-pitch information retained output string. Defaults FALSE. Must singleton  logical value: /switch. argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchFunctions.html"],"id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Translate between pitch representations. — pitchFunctions","text":"NULL inputs (x argument) return NULL output. Otherwise, returns vector/matrix length/dimension x. NA values input x propagated output.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchFunctions.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Translate between pitch representations. — pitchFunctions","text":"full list pitch functions : Tonal pitch representations Absolute pitch representations kern() pitch() lilypond() helmholtz() tonh() (German-style notation) Relative pitch representations interval() solfa() (relative-solfege) solfg() (French-style fixed-solfege) degree() (absolute scale degrees) deg() (melodic scale degrees) bhatk() (hindustani swara) Partial pitch representations step() accidental() quality() octave() Atonal pitch representations Musical pitch representations semits() midi() cents() pc() (pitch classes) Physical pitch representations freq() pitch functions work similar ways, similar arguments functionality. function takes input pitch representation (can anything) outputs pitch representation. example, kern() takes input representation outputs **kern (pitch) data. Underneath hood, full processing function looks like : Input representation (e.g., **pitch **semits) |> Parsing (done tonalInterval()) |> Intermediate (tonalInterval) representation |> Transformation (e.g., transpose()) |> Deparsing |> Output representation (e.g. **kern **solfa) read details parsing step, read . read details \"deparsing\" step, read . read details specific function, click links list , type ?func R command line: example, ?kern. \"partial\" pitch functions octave(), step(), accidental(), quality() -called return one part/aspect pitch information, part. example, accidental() returns accidentals () pitches.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html"],"dir":"Reference","previous_headings":"","what":"Parsing pitch information — pitchParsing","title":"Parsing pitch information — pitchParsing","text":"humdrumR includes easy--use powerful system parsing pitch information: various basic pitch representations (including numeric character-string representations) can \"parsed\"---read interpreted humdrumR. part, parsing automatically happens \"behind scenes\" whenever use humdrumR pitch function, like kern() semit(), solfa().","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parsing pitch information — pitchParsing","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parsing pitch information — pitchParsing","text":"Exclusive exclusive interpretation guide parsing input. Must character; must either length 1 length(x). str input vector. Must either character numeric. Key diatonic key used interpret pitch information. Defaults NULL. Must diatonicSet something coercable diatonicSet; must either length 1 length(x) example, use implicitSpecies (see advanced parsing section) dependent Key. output tonalInterval output within key: thus, tonalInterval('C#', Key = \":\") returns tint representing Major 3rd, C# major third major.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html"],"id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parsing pitch information — pitchParsing","text":"tonalInterval() returns tonalInterval object length dimensions x. NULL inputs (x argument) return NULL output. NA values input x propagated output.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parsing pitch information — pitchParsing","text":"underlying parser used humdrumR pitch functions can called explicitly using function tonalInterval(). tonalInterval parser attempt parse input information tonalInterval object---back-end pitch representation probably need care ! use one main pitch functions, like kern() semits(), input parsed tonalInterval object, immediately deparsed representation asked (e.g., **kern **semits). Thus, underlying pipeline humdrumR pitch functions looks something like: Input representation (e.g., **pitch **semits) |> Parsing (done tonalInterval()) |> Intermediate (tonalInterval) representation |> Deparsing |> Output representation (e.g. **kern **solfa) documentation talks parsing step. overview \"deparsing\" process, look . learn \"deparsing\" specific representations, start go straight docs specific functions--- example, call ?kern learn kern().","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html"],"id":"dispatch","dir":"Reference","previous_headings":"","what":"Dispatch","title":"Parsing pitch information — pitchParsing","text":"pitch parser (tonalInterval()) generic function, meaning accepts variety inputs automatically \"dispatches\" appropriate method parsing ehe input. R's standard S3 system used dispatch either numeric character-string input: Generally, numeric (integer) inputs interpreted various atonal pitch representations character strings interpreted various tonal pitch representations. Given either character string number, humdrumR uses either regular-expression matching humdrum exclusive interpretation matching dispatch specific parsing methods.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html"],"id":"tonal-parsing-character-string-inputs-","dir":"Reference","previous_headings":"","what":"Tonal Parsing (character-string inputs)","title":"Parsing pitch information — pitchParsing","text":"Since humdrum data inherently string-based, powerful part humdrumR pitch-parser system parsing pitch (mostly tonal) information character strings. (includes character tokens pitch information embedded alongside information; Details .) pitch parser (tonalInterval()) uses combination regular-expressions exclusive interpretations decide parse input string. twelve regular-expression patterns pitch tonalInterval() knows parse automatically:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html"],"id":"exclusive-dispatch","dir":"Reference","previous_headings":"","what":"Exclusive Dispatch","title":"Parsing pitch information — pitchParsing","text":"call tonalInterval() (pitch function) character-string vector, non-NULL Exclusive argument, Exclusive argument used choose input interpretation want, based \"Exclusive\" column table . example, kern(x, Exclusive = 'solfa') force parser interpret x **solfa data. Similarly, solfa(x, Exclusive = 'kern') force parser interpret x **kern data. use pitch function within special call withinHumdrum, humdrumR automatically pass Exclusive field humdrum data function---means, cases, need explicitly anything Exclusive argument! (want happen, need explicitly specify Exclusive argument, Exclusive = NULL.)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html"],"id":"regex-dispatch","dir":"Reference","previous_headings":"","what":"Regex Dispatch","title":"Parsing pitch information — pitchParsing","text":"call tonalInterval() (pitch function) character-string vector, Exclusive argument missing NULL, humdrumR instead use regular-expression patterns select known interpretation. example, pitch('') automatically recognize '' solfege, interpret data accordingly (output G4). one matches, humdrumR use longest match, tie, pick based order table (topmost first). match, tonalInterval (pitch function) return NA values. Remember, Exclusive specified, overrides regex-based dispatch, means pitch('', Exclusive = 'kern') return NA, '' interpreted **kern value.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html"],"id":"-in-place-parsing","dir":"Reference","previous_headings":"","what":"\"In place\" parsing","title":"Parsing pitch information — pitchParsing","text":"lots humdrum data, character strings encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR pitch parser (tonalInterval()) automatically \"pull \" pitch information within strings, can find , using appropriate known regular expressions. Various pitch parsing functions option keep original \"extra\" data, using inPlace argument.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html"],"id":"advanced-tonal-parsing-options","dir":"Reference","previous_headings":"","what":"Advanced Tonal Parsing Options","title":"Parsing pitch information — pitchParsing","text":"eleven tonal representations listed parsed common intesrface. using \"advanced\" parsing arguments, can tweak parsing done, accommodate even input representations! means controlling behavior tonalInterval(), second step pipeline: Input representation |> Parsing (done tonalInterval(PARSE ARGS GO !)) |> Intermediate (tonalInterval) representation |> Deparsing |> Output representation Note arguments similar identical parallel \"advanced\" deparsing arguments used various pitch functions. following \"advanced\" parsing arguments available (read details ): Steps step.labels step.signed Species (accidentals qualities) qualities specifier.maximum Accidentals natural, flat, sharp, doubleflat, doublesharp Qualities perfect, major, minor, augment, diminish Implicit vs Explicit Species implicitSpecies absoluteSpecies memory, memoryWindows Octave octave.integer , , octave.offset octave.round octave.relative, octave.absolute String parsing parts sep \"advanced\" arguments can used directly pitch function, call tonalInterval . use tonalInterval just specify directly arguments: example, tonalInterval(x, qualities = TRUE). use pitch functions, can either... Put parseArgs argument: kern(x, parseArgs = list(qualities = TRUE)) use \"syntactic sugar\" short-hand form: kern(x, parse(qualities = TRUE)) known Exclusive/Regex-dispatch combo (see table ) associated default parsing arguments. example, set Exclusive = 'kern' just use data look like **kern, flat argument set \"-\", However, , example, input data looked like **kern except used different flat symbol, like \"_\", modify parser: kern(\"EE_\", parse(flat = \"_\")) overrides default value **kern---notice, also updates **kern regular expression accordingly, works exactly standard kern() function.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html"],"id":"steps","dir":"Reference","previous_headings":"","what":"Steps","title":"Parsing pitch information — pitchParsing","text":"representation \"tonal\" pitch information include representation diatonic steps. can control parser reads diatonic steps pitch representation using step.labels argument. step.labels argument must atomic vector unique values, length positive multiple seven. Examples step.labels arguments currently used preset humdrumR pitch parsers include: parse(step.labels = c('', 'B', 'C', 'D', 'E', 'F', 'G')) --- (**Tonh) parse(step.labels = c('d', 'r', 'm', 'f', 's', 'l', 't')) --- (**solfa) parse(step.labels = c('', 'II', 'III', 'IV', 'V', 'VI', 'VII')) --- (roman numerals) step.labels NULL, steps assumed represented integers, including negative integers representing downward steps. also step.signed (logical, length == 1) argument: step.signed = TRUE, lowercase versions step.labels interpreted negative (downward) steps uppercase versions step.labels interpreted positive (upwards) steps. option used, example, default kern() helmholtz() parsers.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html"],"id":"species","dir":"Reference","previous_headings":"","what":"Species","title":"Parsing pitch information — pitchParsing","text":"tonal pitch representations, \"specific\" versions tonal pitches---tonal \"species\"---indicated \"specifiers\": either accidentals qualities. qualities (logical, length == 1) argument indicates whether accidentals used (qualities = FALSE) qualities (qualities = TRUE). specifiers can repeated number times, like \"triple sharps\" \"doubly augmented\"; specifier.maximum (integer, length == 1) argument sets maximum limit number specifiers read. example, force triple sharps (\"###\") double sharps (\"##\") parse just \"#\", specifying specifier.maximum = 1L.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html"],"id":"accidentals","dir":"Reference","previous_headings":"","what":"Accidentals","title":"Parsing pitch information — pitchParsing","text":"qualities = FALSE parser look accidentals input, recognizing three types: naturals, flats, sharps. natural, flat, /sharp (character, length == 1) arguments can used indicate accidentals represented input. example, input strings look like c(\"Eflat\", \"C\"), set argument flat = \"flat\". Examples accidental argument combinations currently used preset humdrumR pitch parsers include: parse(flat = \"b\", sharp = \"#\") -> **pitch parse(flat = \"-\", sharp = \"#\") -> **kern parse(flat = \"-\", sharp = \"+\") -> **degree doubleflat, doublesharp (character, length == 1) arguments NULL default, can set special symbol used represent two sharps flats. example, might input represents double sharps \"x\". call kern(\"Fx\", parse(doublesharp = \"x\")) output \"F##\".","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html"],"id":"qualities","dir":"Reference","previous_headings":"","what":"Qualities","title":"Parsing pitch information — pitchParsing","text":"qualities = TRUE parser look qualities input, recognizing five types: perfect, minor, major, augmented, diminished. perfect, major, minor, diminish, /augment (character, length == 1) arguments can used indicate qualities represented input. (Note: talking interval/degree qualities , chord qualities!) example, input strings look like c(\"maj3\", \"p4\"), set arguments major = \"maj\" perfect = \"p\". Examples quality argument combinations currently used humdrumR pitch functions include: parse(major = \"M\", minor = \"m\", perfect = \"P\", diminish = \"d\", augment = \"\") parse(diminish = \"o\", augment = \"+\")","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html"],"id":"implicit-vs-explicit-species","dir":"Reference","previous_headings":"","what":"Implicit vs Explicit Species","title":"Parsing pitch information — pitchParsing","text":"musical data, specifiers (e.g., accidentals qualities) explicitly indicated; instead, must infer species pitch context---like key signature!.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html"],"id":"from-the-key","dir":"Reference","previous_headings":"","what":"From the Key","title":"Parsing pitch information — pitchParsing","text":"important argument implicitSpecies (logical, length == 1): implicitSpecies = TRUE, species input without explicit species indicated interpreted using Key. example, kern('C', Key = ':', parse(implicitSpecies = TRUE)) parsed \"C#\" C sharp major. kern('C', Key = ':', parse(implicitSpecies = TRUE)) parsed \"C\" C natural minor. kern('C', Key = '-:', parse(implicitSpecies = TRUE)) parsed \"C-\" C flat -flat minor. default, input already specifiers, interpreted absolutely---overriding \"implicit\" Key---, even implicitSpecies = TRUE. Thus, major: kern(\"C#\", Key = ':', parse(implicitSpecies = TRUE)) parsed \"C#\". \"#\" unnecessary. kern(\"Cn\", Key = ':', parse(implicitSpecies = TRUE)) parsed \"C\". \"n\" overrides Key. kern(\"C#\", Key = ':', parse(implicitSpecies = TRUE)) parsed \"C#\". \"#\" overrides Key. However! can also change behavior setting absoluteSpecies (logical, length == 1) argument FALSE. , specifiers input interpreted \"top \" key accidental: kern(\"C#\", Key = ':', parse(implicitSpecies = TRUE, absoluteSpecies = FALSE)) parsed \"C##\". \"#\" input added \"#\" Key, resulting double sharp! unusual behavior, absolute pitch representations like **kern. However, use scale chord degrees, absoluteSpecies = FALSE might appropriate. example, reading figured bass key E minor, \"b7\" figure E bass interpreted double flat (diminished) 7th (Db E)! data encoded, use absoluteSpecies = FALSE.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html"],"id":"memory","dir":"Reference","previous_headings":"","what":"Memory","title":"Parsing pitch information — pitchParsing","text":"musical data, assume accidental note \"stays effect\" scale step next bar, different accidental replaces . Fortunately, humdrumR parser (tonalInterval()) also knows parse data encoded \"memory\" way. memory = TRUE, accidental (quality) input note \"remembered\" previous appearances scale step. example, kern(c(\"D#\", \"E\", \"D\", \"E\", \"Dn\", \"C\", \"D\"), parse(memory = TRUE)) parsed c(\"D#\", \"E\", \"D#\", \"E\", \"D\", \"C\", \"D\") want \"memory\" last specific time windows (like bars), can also specify memoryWindows argument. memoryWindows must atomic vector length input (x argument). unique value within memoryWindows vector treated \"window\" within memory operates. common use case pass Bar field humdrumR dataset memoryWindows! memory memoryWindows argument work whatever values implicitSpecies absoluteSpecies specified! Though examples use accidentals, arguments effect parsing qualities (qualities = TRUE).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html"],"id":"octave","dir":"Reference","previous_headings":"","what":"Octave","title":"Parsing pitch information — pitchParsing","text":"final piece information encoded () pitch representations indication \"compound pitch\"--- incorporating octave information. humdrumR octaves always defined terms scale steps: two notes scale degree/letter name always octave. mainly comes regards Cb B#: Cb4 semitone ; B#3 enharmonically middle-C.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html"],"id":"integer-octaves","dir":"Reference","previous_headings":"","what":"Integer Octaves","title":"Parsing pitch information — pitchParsing","text":"simplest way octave information can encoded integer value, Scientific Pitch. need parse integer-encoded octaves, set octave.integer (logical, length == 1) argument TRUE. default, humdrumR considers \"central\" octave (octave == 0) octave , equivalently, unison. However, different octave used central octave, can specify octave.offset (integer, length == 1) argument. illustrate, default Scientific Pitch parser used arguments: kern('C5', parse(octave.integer = TRUE, octave.offset = 4) Returns \"cc\" (octave middle C).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html"],"id":"non-integer-octave-markers","dir":"Reference","previous_headings":"","what":"Non-integer Octave Markers","title":"Parsing pitch information — pitchParsing","text":"octave.integer = FALSE, humdrumR parser instead looks three possible symbols indicate octave information. symbols controlled using , , (character, length == 1) arguments. symbol, symbol, interpreted \"central\" octave; repeating strings symbols indicate increasing positive () negative () octaves. example, lilypond notation, , represents lower octaves, ' (single apostrophe) represents upper octaves. default lilypond() parser uses arguments: pitch(c(\"c\", \"c\", \"c'\"), parse(octave.integer = FALSE, = \"'\", = \",\", octave.offset = 1)) Returns c(\"C2\", \"C3\", \"C4\"). (Note lilypond makes octave  central octave, using octave.offset = 1.)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html"],"id":"octave-rounding-","dir":"Reference","previous_headings":"","what":"Octave \"Rounding\"","title":"Parsing pitch information — pitchParsing","text":"situations, pitch data might interpret \"boundaries\" octaves little differently. absolute pitch representations (e.g., kern(), pitch()), \"boundary\" one octave next B (degree 7) C (degree 1). However, example, working data representing intervals, might think \"octave\" spanning range -P4 (G) +P4 (f). case, \"octave boundary\" centered around unison (), rather starting middle-C/unison. data represented way, use octave.round argument; octave.round must rounding function, either round, floor, ceiling, trunc, expand. functions indicate interpret simple pitches \"rounding\" nearest C/unison. default behavior pitch representations octave.round = floor: scale step rounded downwards nearest C. B associated C 7 steps . , hand, octave.round = round, scale-steps \"rounded\" closest C, B associated closer C . Indeed, octave.round = round gets us -P4 <-> +P4 behavior mentioned earlier! working parsing intervals, octave.round option allows control \"simple part\" (less octave) compound interval represented. example, might think ascending major 12th ascending octave plus ascending perfect 5th: ** +P8 + P5**. encode interval two ascending octaves minus perfect fourth: + P15 - P4. following table illustrates different octave.round arguments \"partition\" compound intervals simple parts octaves: Notice , octave.floor used, simple intervals represented ascending. parsing \"absolute\" pitch representations, octave.round option allows control octave notes associated . following table illustrates:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html"],"id":"absolute-or-relative-contour-octave","dir":"Reference","previous_headings":"","what":"Absolute or Relative (contour) Octave","title":"Parsing pitch information — pitchParsing","text":"notation encoding schemes, \"octave\" note interpreted relative previous note, rather absolute reference. prominent system Lilypond's relative octave entry style. style often used combination scale degree representations---RS200 corpus. example, data set might say Re Mi vSo La Ti , \"v\" indicating jump . activate relative-octave parsing, set octave.relative = TRUE---alternatively, can use octave.absolute = FALSE, equivalent. relative-octave data, assume octave indications indicate shift relative previous note. usually used combination octave markers like \"^\" () \"v\" (). Different combinations octave.round allow us parse different behaviors: octave.round = round, marker (marker) indicates note pitch closest previous pitch. Octave markers indicate alterations assumption. always, based scale steps, semitones! fourth \"closer\" fifth, regardless quality: C F# ascending C Gb descending! ascending diminished 5th written C ^Gb---= ^. octave.round = floor, marker (marker) indicates note octave previous pitch. Octave markers indicate alterations assumption. setting, going C B always requires mark.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html"],"id":"string-parsing","dir":"Reference","previous_headings":"","what":"String Parsing","title":"Parsing pitch information — pitchParsing","text":"addition three types musical parsing considerations reviewed (steps, species, octaves), also general string-parsing issues can consider/control.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html"],"id":"parts-and-order","dir":"Reference","previous_headings":"","what":"Parts and Order","title":"Parsing pitch information — pitchParsing","text":"far () discussed various ways tonal pitch information (step, species, octave) can encoded, humdrumR parser can modified handle different options. However, two general parsing issues/options consider: information encoded, order? parts argument can specifyied indicate . parts argument must character vector length 1--3. characters must partial match either \"step\", \"species\", \"octave\". presense strings parts vector indicate information parsed. order strings indicates order pieces pitch information encoded input strings. illustrate, imagine input data identical standard interval representation---e.g., M2 P5---except quality appears step---e.g., 2M 5P. call interval(c(\"2M\", \"5P\"), parse(parts = c(\"step\", \"species\"))) sure enough get correct parse! One final string-parsing argument sep, indicates character string separating pitch information components: common case comma space. example, use parse command like : kern(\"E flat 5\", parse(flat = \"flat\", sep = \" \")).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html"],"id":"atonal-parsing-numeric-inputs-","dir":"Reference","previous_headings":"","what":"Atonal Parsing (numeric inputs)","title":"Parsing pitch information — pitchParsing","text":"humdrumR pitch parser (tonalInterval()) interpret numeric inputs atonal pitch information. default, numbers interpreted semitones. However, parses midi(), cents(),  frequencies also defined. Dispatch different parsers controlled Exclusive argument.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html"],"id":"enharmonic-interpretation","dir":"Reference","previous_headings":"","what":"Enharmonic Interpretation","title":"Parsing pitch information — pitchParsing","text":"converting atonal representation tonal one, must decide interpret tonality input---specifically, enharmonic spelling notes use.  humdrumR numeric parser interprets atonal pitches \"enharmonic window\" 12 steps line--fifths. position window set enharmonic.center (integer, length == 1) argument. default, enharmonic.center = 0, creates window -5 (b2) +6) (#4). prefer #1 instead b2, set enharmonic.center = 1. flats, set enharmonic.center = -1. sharps, set enharmonic.center = 4. enharmonic.center argument work translating pitch representation, like kern(). However, present table terms scale degrees atonal -> enharmonic calculation centered key. , Key argument specified, \"enharmonic window\" centered around key. translating kern Key = F#:, output range Gn B#. want , set Key = NULL.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html"],"id":"melodic-interpretation-of-chromatic-notes","dir":"Reference","previous_headings":"","what":"Melodic Interpretation of Chromatic Notes","title":"Parsing pitch information — pitchParsing","text":"common chromatic notes melodic passages labeled based melodic contour: .e., ascending chromatic notes labeled sharp descending chromatic notes labeled flat. behavior can engaged setting accidental.melodic (logical, length == 1) argument. accidental.melodic = TRUE, input first centered enharmonic window (), places chromatic alteration proceeds upwards non-chromatic note altered (necessary) sharp, vice verse descending notes flats. example, kern(0:2) returns c(\"c\", \"d-\", \"d\"), kern(0:2, parse(accidental.melodic = TRUE)) returns c(\"c\", \"c#\", \"d\").","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchParsing.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parsing pitch information — pitchParsing","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/ptable.html"],"dir":"Reference","previous_headings":"","what":"Tabulate and cross proportions — ptable","title":"Tabulate and cross proportions — ptable","text":"Tabulate cross proportions","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/ptable.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tabulate and cross proportions — ptable","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/quality.html"],"dir":"Reference","previous_headings":"","what":"Extract quality from pitch — quality","title":"Extract quality from pitch — quality","text":"Use want extract tonal qualities pitch data, discarding octave step information.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/quality.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract quality from pitch — quality","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/quality.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract quality from pitch — quality","text":"x Input data parse pitch information. x argument can (atomic) vector, tonalInterval, NULL. ... Arguments passed pitch deparser. also two hidden (advanced) arguments can specify: memoize deparse (see details ). generic \"specific\" pitch information (accidentals qualites) discarded? Defaults FALSE. Must singleton logical value: /switch. simple \"compound\" pitch information (octave/contour) discarded? Defaults FALSE. Must singleton logical value: /switch. Key input Key used parser, deparser, transposer. Defaults NULL. Must diatonicSet something coercable diatonicSet; must either length 1 length(x) transposeArgs optional list arguments passed special transpose() call. Defaults empty list(). Must list named arguments transpose(). parseArgs optional list arguments passed pitch parser. Defaults empty list(). Must list named arguments pitch parser. inPlace non-pitch information retained output string. Defaults FALSE. Must singleton  logical value: /switch. argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/quality.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract quality from pitch — quality","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rational.html"],"dir":"Reference","previous_headings":"","what":"Rational numbers — rational","title":"Rational numbers — rational","text":"R built rational number representation; humdrumR defines one.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rational.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rational numbers — rational","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rational.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rational numbers — rational","text":"Using rational numbers, can represent numbers like 1/3 without numeric inaccuracies. words, \\(1/3 * 3 = 3\\), never \\(.999999999\\). hand, rational numbers start numerators demoninators large, can run integer overflow problems. Since rational numbers using context music analysis relatively simple, can safely use numbers without numeric inaccuracy. fraction class (associated constructor) represents rational numbers character strings. Unlike rational, fraction class numeric thus arithmetic. However, fraction can converted /rational.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/readHumdrum.html"],"dir":"Reference","previous_headings":"","what":"Find and read humdrum files into R — knownInterpretations","title":"Find and read humdrum files into R — knownInterpretations","text":"functions find valid humdrum files local machine read humdrumR.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/readHumdrum.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find and read humdrum files into R — knownInterpretations","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/readHumdrum.html"],"id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Find and read humdrum files into R — knownInterpretations","text":"object class data.table (inherits data.frame) 24 rows 5 columns.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/readHumdrum.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find and read humdrum files into R — knownInterpretations","text":"... One patterns used identify files read. Must character strings. details: see \"REpath-patterns\" section . contains REGEX filtering files. Defaults NULL. Must character. !.null(contains), contains argument treated regular expressions: files contain matches regular expressions read. Thus, readHumdrum('.*krn$', contains = \"EEE\") read kern files contain matches \"EE\"---kern E two octaves middle C (lower). recursive files found recursively sub directories? Defaults FALSE. Must singleton logical value: /switch. TRUE, final part search pattern (.e., file search) searched recursively sub directories. allowDuplicates Indicating happen multiple search patterns match files. Defaults FALSE. Must singleton logical value: /switch. allowDuplicates = TRUE, files read multiple times, grouped respective corpora Label field. allowDuplicates = FALSE, redundant files read corpus first pattern match. verbose Whether print filename reading . Defaults FALSE. Must singleton logical value: /switch. TRUE, names matching files printed parsing begins. useful check make sure reading wrong files! tandems Controls , , tandem interpretations parsed fields. Defaults \"known\". Must character. reference reference records parsed fields. Defaults \"\". Must character.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/readHumdrum.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find and read humdrum files into R — knownInterpretations","text":"findHumdrum work finding reading text files R. readHumdrum utilizes findHumdrum read files, parses create humdrum table build humdrumR data object around table.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/readHumdrum.html"],"id":"repath-patterns","dir":"Reference","previous_headings":"","what":"REpath-patterns","title":"Find and read humdrum files into R — knownInterpretations","text":"\"REpath-patterns\" specified using ... arguments. combination, ... arguments used search file paths. part search path specify (\"dirpart/dirpart/filepart\", etc) matched regular expressions directories/files disc. Thus, can say things like findHumdrum(\"../^.*/.*krn$\"), match kern files directory beginning capital \"\" directory current working directory. conveniance, can break path across multiple arguments instead using delimited strings: example, code findHumdrum(\"..\", \"^.*\", \".*krn$\") give identical result previous example (findHumdrum(\"../^.*/,*krn$\")). useful searching one pattern (see next paragraph) directory. want search one pattern, can input character vector: instance, readHumdrum(c(\"mozart\", \"beethoven\")---command search filenames containing \"mozart\" \"beethoven.\" works directories : readHumdrum(c(\"Mozart\", \"Beethoven\"), \".*krn$\") look kern files directories containing \"Mozart\" \"Beethoven.\" patterns named, names show identifying patterns [humdrumR][humdrumR] object's Label field. Unnamed patterns simply labeled numbers. refer files matched regex patterns \"subcorpora\" total corpus. Normal (system appropriate) conventions (.e., directories separated \"/\", '~' beginning indicate home, \"..\" indicate directory working directory, etc.) followed. pattern contains solo dot followed file sep---e.g., \"./\", \"x/./y\"---treated current directory, regular expression. pattern contains two dots---e.g., \"../\"---treated directory , regular expression. want create regular expression match directory, use \".*/\". regex pattern \"\" matches file (changed \".*\"). specifiy ... argument, findHumdrum (readHumdrum) default \".*\" well. Thus, readHumdrum() read humdrum files working directory. (two files different directories share name, unique name created file appending names directories occupy, recursively names unique.) single humdrum file multiple pieces ---meaning spine paths close *-, open **---parsed separately. distinguished Piece field. multi-piece files, Piece File identical.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/readHumdrum.html"],"id":"validity","dir":"Reference","previous_headings":"","what":"Validity","title":"Find and read humdrum files into R — knownInterpretations","text":"findHumdrum readHumdrum automatically ignore non-text files. , files contain humdrum syntax errors (checked validateHumdrum()) automatically skipped. want see specifically errors occurred, call validateHumdrum() directly use errorReport.path argument.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/readHumdrum.html"],"id":"tandem-interpretations","dir":"Reference","previous_headings":"","what":"Tandem Interpretations","title":"Find and read humdrum files into R — knownInterpretations","text":"tandem interpretations humdrum dataset summarized humdrum table's Tandem field, described detail . addition, certain \"known\" tandem interpretations parsed fields automatically. example, *clefG4 \"*clefF2 parsed Clef data, *k[b-] parsed KeySignature. \"known\" tandem interpretations humdrumR recognizes encoded built-table called knownInterpretations. interpretation humdrumR name (\"Clef\", \"TimeSignature\", etc.) well regular expression associated . tandems argument readHumdrum controls tandem interpretations parsed fields. can helpful either save processing time memory parsing interpretations need, parse interpretations humdrumR recognize. default value tandems argument \"known\". tandems argument contains \"known\" tandem interpretations built-knownInterpretations table parsed. Users may specify different interpretations parse two ways: character strings matching one name values Name column knownInterpretations. instance, specify tandems = c('Clef', 'TimeSignature'), clef (e.g., \"*clefG2\"), time signature (e.g., \"*M3/4\") intepretations parsed. character string(s) tandem exactly match one names knownInterpretations$Name, treated regular expressions used match tandem interpretations data. allows users parse non-standard tandem interpretations humdrumR already know . values tandems named, names used resulting fields. matches given interpretation found, field created interpretation. tandems = NULL, tandem interpretations parsed.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/readHumdrum.html"],"id":"reference-records","dir":"Reference","previous_headings":"","what":"Reference Records","title":"Find and read humdrum files into R — knownInterpretations","text":"default (reference = \"\"), humdrumR reads reference records data. reference code record (e.g, \"OTL\", \"!!!OTL: xxx\") used name associated field. (reference record reference code (.e., lacks colon), field called \"Unkeyed.\") large datasets many reference records, reference data can actually make large portion humdrum table, eat lot memory. cases, might want read () reference records---can instead read reference records planning use analyses (). reference = NULL, reference records parsed. Otherwise, character values reference treated reference codes matching reference records parsed. instance, readHumdrum(_, reference = \"OTL\") parse OTL reference records. values reference named, names used name associated fields. Thus, specifing reference = c(Title = 'OTL'), can use \"OTL\" reference records populate field called \"Title\". one reference records reference code, either explicitely numbered (e.g., \"!!!COM1:\", \"!!!COM2:\") read rather making two fields, single field created (\"COM\" ) multiple values separated \";\". humdrum data includes files containing multiple pieces, special consideration needed determine (guess) reference records (global comments) \"go \" piece. Obviously, reference records beginning end file grouped first last pieces respectively. However, reference records pieces multi-piece file require guess work. readHumdrum() look reference codes attempt group -reference records pieces logical way avoiding duplicated reference codes.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/readHumdrum.html"],"id":"spines-and-paths","dir":"Reference","previous_headings":"","what":"Spines and Paths","title":"Find and read humdrum files into R — knownInterpretations","text":"humdrum syntax, data placed \"spines,\" \"columns\" spreadsheet. \"column\" refers tab-delineated group values. \"Spines\" can single column, may (time) split multiple columns, can turn split , using \"*^\" interpretation token. reverse can happen well, two columns merging single column, using \"v\" token. means , humdrum data first glance looks like simple two-dimensional table, actually flexible tree structure. spines split merge, total number columns can change piece, creating \"ragged\" edge. Another similar issue corpus humdrum files may varying numbers spines/columns, pieces. (\"Global\" comment/reference records also special case, always single value, even interspersed multi-column local records.) readHumdrum assumes slightly strict version humdrum syntax: spines appear beginning file (headed exclusive interpretations like \"**kern\") can never merge . Thus, humdrum file read humdrumR must end fewer columns starts. Spine merges (\"*v\") can happen within spine paths originally split spine. extra-strict specification spine paths humdrum syntax , fortunately, something informally followed humdrum datasets. strict spine-path definition makes everything work fairly simply: Within piece, spines appear beginning piece \"true\" spines throughout piece, numbered left right, starting 1L. local token, value Spine field integer indicating \"true\" spines belongs ---global tokens NA value Spine field, belong spine. spine path splits (\"*^\") main spines form spine paths. Every spine's paths numbered Path field, right left, starting 0L. spine splits 0Ls Path field.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/readHumdrum.html"],"id":"result","dir":"Reference","previous_headings":"","what":"Result","title":"Find and read humdrum files into R — knownInterpretations","text":"findHumdrum returns \"fileFrame\" (data.table), listing file names, patterns match, directories found , raw text content files. readHumdrum returns fully parsed humdrumR object.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/readHumdrum.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find and read humdrum files into R — knownInterpretations","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/recip.html"],"dir":"Reference","previous_headings":"","what":"Reciprocal representation of duration — recip","title":"Reciprocal representation of duration — recip","text":"standard approach representing conventional note values humdrum \"reciprocal\" **recip. Representation. **recip rhythmic values often used part **kern representation, also includes pitch information notation details.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/recip.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reciprocal representation of duration — recip","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/recip.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reciprocal representation of duration — recip","text":"x input  vector. x argument can (atomic) vector, rational (rhythmInterval), NULL. Must parsable rhythm infromation. ... Arguments passed rhythm parser. also two hidden (advanced) arguments can specify: memoize deparse (see details ). sep separator printed numerator denominator. single character string. Must single character string. parseArgs optional list arguments passed rhythm parser. Defaults empty list(). Must list named arguments rhythm parser. scale numeric rational value used output unit measurement. Defaults rational(1, 1). Must numeric rational. inPlace non-rhythm information retained output string? Defaults FALSE. Must singleton  logical value: /switch. Defaults FALSE. singleton logical value, NA. See \"Grace notes\" section .","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/recip.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reciprocal representation of duration — recip","text":"**recip values literally reciprocal duration value. Since note values conventional music notation simple fractions reciprocal approach highly concise similar conventional western notation terminology. \"quarter note\" represented reciprocal 1/4: simply \"4\". Full reciprocal fractions can specified: \"2%3\" indicate 3/2. % separator can changed using sep argument. conventional note values, \"dots\" can added value increase duration ratio (2 - (2^{-n})), n number dots. (One dot 3/2; two dots 7/4; etc.).","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/recip.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reciprocal representation of duration — recip","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/recordDuration.html"],"dir":"Reference","previous_headings":"","what":"Calculate duration of each record in a corpus — recordDuration","title":"Calculate duration of each record in a corpus — recordDuration","text":"Calculate duration record corpus","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/recordDuration.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate duration of each record in a corpus — recordDuration","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/recordDuration.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate duration of each record in a corpus — recordDuration","text":"humdrumR HumdrumR data.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/reference.html"],"dir":"Reference","previous_headings":"","what":"Summarize reference records in a humdrumR corpus — reference","title":"Summarize reference records in a humdrumR corpus — reference","text":"reference used tabulate reference records present humdrumR corpus. reference one humdrumR's basic corpus summary functions.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/reference.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize reference records in a humdrumR corpus — reference","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/reference.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize reference records in a humdrumR corpus — reference","text":"x Input extracting reference information. Must character string (look reference code) humdrumR. drop Whether return normal data.table humCensus table. Defaults FALSE. Must singleton logical value: /switch. drop = TRUE, normal data.table returned instead humCensus table. Index rows. numeric, selects rows index. character, string matched regular expression filenames corpus. j Index columns. numeric, selects columns index. character, partially matched column names (reference codes).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/reference.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summarize reference records in a humdrumR corpus — reference","text":"reference can used look information common reference codes: supply reference code character string reference check known reference codes print information matching codes (one). instance, reference('OTL') returns description standard humdrum !!!OTL reference record (original title metadata). applied humdrumR corpus reference returns special data.frame called humReference table. humReference table one column reference code appears corpus. Since reference records can long print one screen, humdrum files can multiple type reference code, humReference table normally prints number type reference record appear piece. However, one type reference code present humReference table, complete reference records code printed piece. Likewise, one piece present table, piece's complete reference records printed. Thus, want see actual reference records, try indexing humReference table one column row (see ). humReference table one row piece corpus. Rows labeled file name piece number index. addition, humReference object printed, three different summary totals printed reference code: indicates many pieces corpus contain least one example code. Sum indicates total number reference code appear corpus, including multiple appearances one piece (like multiple \"!!!COM\" records). Unique tabulates number unique token corpus, code. corpus two unique composers (encoded \"!!!COM\"), Unique total 2. assumes tokens exactly identical, including white space; \"!!!COM: J.S. Bach\" \"!!!COM: JS Bach\" counted two unique reference records.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/reference.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize reference records in a humdrumR corpus — reference","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/regexConstruction.html"],"dir":"Reference","previous_headings":"","what":"Making Regular Expressions — regexConstruction","title":"Making Regular Expressions — regexConstruction","text":"humdrumR includes helpful functions creating new regular expressions work stringr package.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/regexConstruction.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Making Regular Expressions — regexConstruction","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/regexConstruction.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Making Regular Expressions — regexConstruction","text":"captureRE take character vector collapse \"capture group.\" n argument can used append number tag, instance '*' (zero ) group. .e., captureRE(c(\"\", \"b\", \"c\"), '*') output \"[abc]*\". captureUniq make similar capture group captureRE, expression makes sure 1 character repeats. instance, captureUniq(c('', 'b','c')) return \"([abc])\\\\1*\"---expression match \"aaa\" \"bb\" \"aabb\".","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rhythmDeparsing.html"],"dir":"Reference","previous_headings":"","what":"Generating (","title":"Generating (","text":"humdrumR includes easy--use system generating variety rhythm (time duration) representations, can flexibly modified users. \"hood\" humdrumR represents rhythmic duration information rational numbers, typically extracted input data using rhythm parser. rational representation can \"deparsed\" variety predefined output formats (like **recip), new formats create!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rhythmDeparsing.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generating (","text":"Deparsing second step rhythm function processing pipeline: Input representation |> Parsing |> Intermediate (rational) representation |> Deparsing (DEPARSING ARGS GO ) |> Output representation Various rhythm representations like **recip, **dur, **duration can generated using predefined rhythm functions like recip() dur(), duration() respectively. functions use common deparsing framework. documentation talks deparsing step. overview parsing process, look .","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rhythmDeparsing.html"],"id":"basic-rhythm-arguments","dir":"Reference","previous_headings":"","what":"Basic rhythm arguments","title":"Generating (","text":"Different rhythms share standard arguments control details output. important scale argument.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rhythmDeparsing.html"],"id":"scalar-unit","dir":"Reference","previous_headings":"","what":"Scalar unit","title":"Generating (","text":"scale argument numeric rational value indicates reference unit used duration values: \"1\" duration? default, unit \"whole note\" duration. changing unit, can rescale output. example, recip value represents fraction unit: e.g., \"2\" equals 1/2 unit. call recip('2', scale = 1/16) telling us get half sixteenth: case '32'.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rhythmDeparsing.html"],"id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Generating (","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **recip data might include tokens like \"4.ee-[. humdrumR parser (rhythmInterval) automatically \"pull \" rhythm information within strings, can find using appropriate known regular expressions. example, duration('4.ee-[') returns 0.375. However, pitch functions (like recip() dur()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , duration('4.ee-[', inPlace = TRUE) return 0.375ee-[---keeping \"ee-[\". Note inPlace = TRUE force functions like duration, normally return numeric values, return character strings input character string.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rhythmFunctions.html"],"dir":"Reference","previous_headings":"","what":"Translate between rhythm representations. — rhythmFunctions","title":"Translate between rhythm representations. — rhythmFunctions","text":"functions used extract translate different representations rhythmic (time duration) information.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rhythmFunctions.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Translate between rhythm representations. — rhythmFunctions","text":"x input  vector. x argument can (atomic) vector, rational (rhythmInterval), NULL. Must parsable rhythm infromation. ... Arguments passed rhythm parser. also two hidden (advanced) arguments can specify: memoize deparse (see details ). scale numeric rational value used output unit measurement. Defaults rational(1, 1). Must numeric rational. parseArgs optional list arguments passed rhythm parser. Defaults empty list(). Must list named arguments rhythm parser. inPlace non-rhythm information retained output string? Defaults FALSE. Must singleton  logical value: /switch. Defaults FALSE. singleton logical value, NA. See \"Grace notes\" section .","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rhythmFunctions.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Translate between rhythm representations. — rhythmFunctions","text":"full list rhythm functions : Metric rhythm representations Symbolic rhythm representations recip() (reciprocal note values) notehead() (traditional note-value symbols) Numeric rhythm representations duration() (Whole notes) quarters() (quarter notes/crotchets) Ametric rhythm representations Symbolic rhythm representations dur() (durations time) Numeric rhythm representations seconds() ms() (milliseconds) rhythm functions work similar ways, similar arguments functionality. function takes input rhythm (time duration) representation (can anything) outputs rhythm representation. example, recip() takes input representation outputs **recip (reciprocal durations) data. Underneath hood, full processing function looks like : Input representation (e.g., **recip **dur) |> Parsing (done rhythmInterval()) |> Intermediate (rational) representation |> Deparsing |> Output representation (e.g. **recip **duration) read details parsing step, read . read details \"deparsing\" step, read . read details specific function, click links list , type ?func R command line: example, ?notehead.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rhythmFunctions.html"],"id":"grace-notes","dir":"Reference","previous_headings":"","what":"Grace notes","title":"Translate between rhythm representations. — rhythmFunctions","text":"**recip **kern data sometime include tokens indicating grace notes---special category duration, usually used indicate \"freely\" -metric notes otherwise metric context. humdrum data, grace notes marked \"q\" \"Q\"; q reserved tokens () duration information, Q marked along duration information: example, aa-q 16aa-Q. practice, distinction always made, rarely important. default, **recip parser treats input marked grace notes duration zero. However, pass grace argument rhythm parser, can control behavior. parse(grace = TRUE), grace-note durations (like 16 \"16aa-Q\") parsed like duration. grace = NA, grace-notes return NA. grace = FALSE, duration returns zero (default behavior).","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rhythmParsing.html"],"dir":"Reference","previous_headings":"","what":"Parsing rhythm information — rhythmParsing","title":"Parsing rhythm information — rhythmParsing","text":"humdrumR includes easy--use powerful system parsing rhythm (time duration) information: various basic rhythm representations (including numeric character-string representations) can \"parsed\"---read interpreted humdrumR. part, parsing automatically happens \"behind scenes\" whenever use humdrumR rhythm function, like recip(), dur(), duration().","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rhythmParsing.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parsing rhythm information — rhythmParsing","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rhythmParsing.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parsing rhythm information — rhythmParsing","text":"underlying parser used humdrumR rhythm functions can called explicitly using function rhythmInterval(). rhythmInterval parser attempt parse input information ratioanl number object. use one main rhythm functions, like recip() dur(), input parsed rational object, immediately deparsed representation asked (e.g., **recip **dur). Thus, underlying pipeline humdrumR rhythm functions looks something like: Input representation (e.g., **recip **dur) |> Parsing (done rhythmInterval()) |> Intermediate (rational) representation |> Deparsing |> Output representation (e.g. **recip **duration) documentation talks parsing step. overview \"deparsing\" process, look . learn \"deparsing\" specific representations, start go straight docs specific functions--- example, call ?recip learn recip().","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rhythmParsing.html"],"id":"dispatch","dir":"Reference","previous_headings":"","what":"Dispatch","title":"Parsing rhythm information — rhythmParsing","text":"rhythm parser (rhythmInterval()) generic function, meaning accepts variety inputs automatically \"dispatches\" appropriate method input. R's standard S3 system used dispatch either numeric character-string input: Though rhythmic representations essentially numbers, several standard representations included mix numeric non-numeric symbols. Given either character string number, humdrumR uses either regular-expression matching humdrum exclusive interpretation matching dispatch specific parsing methods.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rhythmParsing.html"],"id":"symbolic-parsing","dir":"Reference","previous_headings":"","what":"Symbolic Parsing","title":"Parsing rhythm information — rhythmParsing","text":"Since humdrum data inherently string-based, input data ultimately starts character strings. (includes character tokens rhythm information embedded alongside information; Details .) rhythm parser (rhythmInterval()) uses combination regular-expressions exclusive interpretations decide parse input string. three regular-expression patterns rhythm rhythmInterval() knows parse automatically:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rhythmParsing.html"],"id":"exclusive-dispatch","dir":"Reference","previous_headings":"","what":"Exclusive Dispatch","title":"Parsing rhythm information — rhythmParsing","text":"call rhythmInterval() (rhythm function) character-string vector, non-NULL Exclusive argument, Exclusive argument used choose input interpretation want, based \"Exclusive\" column table . example, seconds(x, Exclusive = 'recip') force parser interpret x **recip data. Similarly, recip(x, Exclusive = 'dur') force parser interpret x **dur data. use rhythm function within special call withinHumdrum, humdrumR automatically pass Exclusive field humdrum data function---means, cases, need explicitly anything Exclusive argument! (want happen, need explicitly specify Exclusive argument, Exclusive = NULL.)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rhythmParsing.html"],"id":"regex-dispatch","dir":"Reference","previous_headings":"","what":"Regex Dispatch","title":"Parsing rhythm information — rhythmParsing","text":"call rhythmInterval() (rhythm function) character-string vector, Exclusive argument missing NULL, humdrumR instead use regular-expression patterns select known interpretation. example, seconds('4.') automatically recognize '4.' **recip token, interpret data accordingly (output 1.5). one matches, humdrumR use longest match, tie, pick based order table (topmost first). match, rhythmInterval() (rhythm function) return NA values. Remember, Exclusive specified, overrides regex-based dispatch, means pitch('4.', Exclusive = 'notevalue') return NA, '4.' interpreted **notevalue.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rhythmParsing.html"],"id":"-in-place-parsing","dir":"Reference","previous_headings":"","what":"\"In place\" parsing","title":"Parsing rhythm information — rhythmParsing","text":"lots humdrum data, character strings encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR rhythm parser (rhythmInterval()) automatically \"pull \" rhythm information within strings, can find , using appropriate known regular expressions. Various rhythm parsing functions option keep original \"extra\" data, using inPlace argument.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/romanKey.html"],"dir":"Reference","previous_headings":"","what":"Roman numeral key areas — romanKey","title":"Roman numeral key areas — romanKey","text":"Roman numeral key areas","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/romanKey.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Roman numeral key areas — romanKey","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/romanKey.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Roman numeral key areas — romanKey","text":"x Input data, interpreted diatonic keys. Must atomic vector. Key key used parser, deparser, transposer. Defaults NULL. Must diatonicSet something coercable diatonicSet; must either length 1 length(x) parseArgs optional list arguments passed key parser. Defaults empty list(). Must list named arguments key parser.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/romanKey.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Roman numeral key areas — romanKey","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/romanNumerals.html"],"dir":"Reference","previous_headings":"","what":"Roman Numeral — romanNumerals","title":"Roman Numeral — romanNumerals","text":"Roman numerals can calculated diatonicSets (keys) tertian sets (chords). later case standard meaning \"roman numeral.\" However, former case used well, instance represent modulation schemes analyses classical music. instance, modulate -V, vi/V. importantly, many \"roman numerals\" harmonic analyses implicitely combine tertian diatonic roman numerals: \"applied\" roman numerals. Given roman numeral like \"V65/V\", \"V65\" represents chord \"/V\" represents key.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/segments.html"],"dir":"Reference","previous_headings":"","what":"Identify contiguous segments of data in a vector — segments","title":"Identify contiguous segments of data in a vector — segments","text":"segments changes extremely useful functions finding contiguous \"segments\" indicated vector.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/segments.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify contiguous segments of data in a vector — segments","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/segments.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify contiguous segments of data in a vector — segments","text":"... list atomic vectors. vectors differ length, recycled match length longest vector. first first index (last index reverse == TRUE) marked \"change.\" Defaults TRUE. Must singleton logical value: /switch. Whether mark changes input vectors. Defaults TRUE. Must singleton logical value: /switch. TRUE, change input vector marked change. FALSE, changes must occur input vectors marked change. reverse Whether excecution order reversed. Defaults FALSE. Must singleton logical value: /switch. TRUE function excecuted backwards input vector(s). value Whether return changed value matrix. Defaults FALSE. Must singleton logical value: /switch. TRUE, input values changes occur returned matrix, row matching change column containing value associated input vector.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/segments.html"],"id":"changes","dir":"Reference","previous_headings":"","what":"Changes","title":"Identify contiguous segments of data in a vector — segments","text":"changes takes input vector finds indices value x[] != x[-1]---.e., value one index \"changed\" since last index. default, changes returns logical vector length input, TRUE indices change occured. first argument indicates whether first index (== 1) marked TRUE. changes can accept one input vector. argument set TRUE (default), change input marked change (TRUE) output. == FALSE, changes must happen vectors marked output. Finally, reverse argument reverses behavior changes, checkig instead x[] != x[+ 1].","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/segments.html"],"id":"values","dir":"Reference","previous_headings":"","what":"Values","title":"Identify contiguous segments of data in a vector — segments","text":"default, values input vector(s) change occurs placed matrix put values attribute logical output. However, value argument set TRUE, values returned.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/segments.html"],"id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Identify contiguous segments of data in a vector — segments","text":"segments builds changes function. segments function takes logical input cummulatively tallies TRUE value vector, left right (right left, reverse == TRUE). Thus, input c(TRUE, FALSE, TRUE, FALSE, FALSE, TRUE, TRUE, FALSE) return c(1, 1, 2, 2, 2, 3, 4, 4). creates contiguous blocks values can used groupby argument call within.humdrumR(), similar functions like base::tapply(). input vector(s) segments logical, first fed changes create logical input.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/segments.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify contiguous segments of data in a vector — segments","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/semits.html"],"dir":"Reference","previous_headings":"","what":"Atonal pitch representations — semits","title":"Atonal pitch representations — semits","text":"function translates pitch information basic atonal pitch values: midi semits map pitches standard 12-tone-equal-temperament semitone (integer) values. semits 0 (zero) middle-C (unison). contrast, MIDI pitch values output midi place middle-C/unison 60. cents returns cents, one hundredth semitone.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/semits.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Atonal pitch representations — semits","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/semits.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Atonal pitch representations — semits","text":"x Input data parse pitch information. x argument can (atomic) vector, tonalInterval, NULL. ... Arguments passed pitch deparser. also two hidden (advanced) arguments can specify: memoize deparse (see details ). generic \"specific\" pitch information (accidentals qualites) discarded? Defaults FALSE. Must singleton logical value: /switch. simple \"compound\" pitch information (octave/contour) discarded? Defaults FALSE. Must singleton logical value: /switch. Key input Key used parser, deparser, transposer. Defaults NULL. Must diatonicSet something coercable diatonicSet; must either length 1 length(x) transposeArgs optional list arguments passed special transpose() call. Defaults empty list(). Must list named arguments transpose(). parseArgs optional list arguments passed pitch parser. Defaults empty list(). Must list named arguments pitch parser. inPlace non-pitch information retained output string. Defaults FALSE. Must singleton  logical value: /switch. argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ). tonalHarmonic frequency \"tonal harmonic\" (perfect 12th). Defaults 2^(19/12), 12-tone-equal-temperament 12th. Must single number. Pythagorean tuning, set tonalHarmonic = 3.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/semits.html"],"id":"cents","dir":"Reference","previous_headings":"","what":"Cents","title":"Atonal pitch representations — semits","text":"default, output cents simply semits(x) * 100. However, tonalHarmonic value can modified cents produce cent-values alternate tunings. example, cents('g', tonalHarmonic = 3) returns 701.9550009, \"pure\" third harmonic (3) 1.955 sharper equal-temperment. Thus, whereas midi semits return integers, cents always returns real-number (double) values. TonalIntervals parsed frequencies might also arbitrary cent deviations. example, cents(440 * 10/9, Exclusive = 'freq') returns 1082.404---correspond \"minor tone\" =440.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/semits.html"],"id":"basic-pitch-arguments","dir":"Reference","previous_headings":"","what":"Basic pitch arguments","title":"Atonal pitch representations — semits","text":"pitch function standard arguments control details output. important generic simple arguments, allow control type pitch information returned.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/semits.html"],"id":"generic-vs-specific","dir":"Reference","previous_headings":"","what":"Generic vs Specific","title":"Atonal pitch representations — semits","text":"generic = TRUE, specific pitch information (accidentals qualities) omitted output. alternative way controlling functionality, can use specific argument, specific == !generic. case atonal functions, \"generic\" version pitch output: example, semits('c#', generic = TRUE) return 0, \"generic\" version C# C, corresponds 0. However, note generic version pitch follows key, semits('c#', generic = TRUE, Key = ':') return 1!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/semits.html"],"id":"simple-vs-compound","dir":"Reference","previous_headings":"","what":"Simple vs Compound","title":"Atonal pitch representations — semits","text":"simple = TRUE, compound pitch information (octave contour) omitted output. alternative way controlling functionality, can use compound argument ,compound == !simple. actually one way might want divide compound intervals simple octave parts. example, might like call output -M2 (descending major 2nd) +m7 (ascending minor 7th octave ). functionality can controlled octave.round argument: see pitch deparsing documentation.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/semits.html"],"id":"key","dir":"Reference","previous_headings":"","what":"Key","title":"Atonal pitch representations — semits","text":"Key argument must diatonicSet, something can parsed one. Key argument passed parser, deparser, transpose---unless alternate Key passed transposeArgs parseArgs. Various deparsing options use Key argument; example, use implicitSpecies (see advanced parsing section) dependent Key. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function---means, cases, need explicitly anything Key argument! (want happen, need explicitly specify Key argument, Key = NULL.)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/semits.html"],"id":"parse-arguments","dir":"Reference","previous_headings":"","what":"Parse arguments","title":"Atonal pitch representations — semits","text":"parseArgs argument must list() (named) arguments passed input parser. example, input representation uses \"X\" represent double sharps, specify kern('CX5', parseArgs = list(doublesharp = 'X')) get correct result (\"cc##\"). convenient shorthand, \"syntactic sugar,\" can specify parseArgs alternate way: Simply input parse(args...) unnamed argument pitch function. example, can get exact result typing kern('CX5', parse(doublesharp = 'X')).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/semits.html"],"id":"transpose-arguments","dir":"Reference","previous_headings":"","what":"Transpose arguments","title":"Atonal pitch representations — semits","text":"transposeArgs argument must list() (named) arguments passed internal call transpose(), allowing us easily transpose pitch information. example, type kern(c('C', 'D', 'E'), transposeArgs = list(= 'M9')) can get output c('d', 'e', 'f#'). possible transpose args : (tonalInterval, length == 1 | length == (x)) (diatonicSet, length == 1 | length == (x))  (diatonicSet, length == 1 | length == (x)) real (logical, length == 1) transposition real tonal? relative (logical, length == 1) key-wise transposition based relative parallel keys? convenient shorthand, \"syntactic sugar,\" can specify transposeArgs alternate way: Simply input transpose(args...) unnamed argument pitch function. example, can get exact result typing kern(c('C', 'D', 'E'), transpose(= 'M9')).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/semits.html"],"id":"transposing-by-interval","dir":"Reference","previous_headings":"","what":"Transposing by interval","title":"Atonal pitch representations — semits","text":"calling transpose() directly, argument can anything coercable tonalInterval, output transposed amount. real = FALSE, tonal transposition (within Key) performed. details transposition behavior, check transpose() docs.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/semits.html"],"id":"transposing-by-key","dir":"Reference","previous_headings":"","what":"Transposing by key","title":"Atonal pitch representations — semits","text":"Another way transposing specifying input (\"\") key output (\"\") key. default, Key argument passed transpose , nothing actually happens. Thus, specify either key key, transposition happen /key Key. course, specify transposition happen keys specify. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function. specify key, Key field passed transpose key, result, pitches input transposed whatever keys target () key! real relative arguments give special control key-wise transposition works, check transpose() docs details!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/semits.html"],"id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Atonal pitch representations — semits","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/semits.html"],"id":"pitch-gamut-levels","dir":"Reference","previous_headings":"","what":"Pitch-Gamut Levels","title":"Atonal pitch representations — semits","text":"table() automatically generate factor levels pitch data using gamut() function. makes sure tabulated data sorted logical order, includes missing pitches. simple/complex  generic/specific arguments automatically passed gamut(); additional arguments can passed gamut using gamutArgs = list(...), syntactic sugar gamut(...). (Read gamut() docs explanation gamut generation.) feature used control table layout pitch data, well assure consistent tables grouping data. inPlace = TRUE special tabulation occur.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/semits.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Atonal pitch representations — semits","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/sigma.html"],"dir":"Reference","previous_headings":"","what":"Cumulative sum of numeric vector — sigma","title":"Cumulative sum of numeric vector — sigma","text":"Calculate sequential cummulative sum values numeric vectors.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/sigma.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cumulative sum of numeric vector — sigma","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/sigma.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cumulative sum of numeric vector — sigma","text":"x input vector. Must atomic numbers. NULL values returned NULL. lag lag use. Defaults 1. Must natural number. (See Greater lags section, .) skip function indicate values skip. Defaults .na. must function can applied x return logical vector length. TRUE values skipped calculations. default, skip function .na, NA values input (x argument) skipped. skipped values returned output vector. init Initial value fill beginning calculation. Defaults 0. class x; length must longer lag. NA values beginning (end right == TRUE) filled values summing. groupby group data. Defaults list(). vector list vectors; must length length(x). Differences calculated across groups indicated groupby vector(s). orderby order calculating difference. Defaults list(). vector list vectors; must length length(x). Differences x calculated based order orderby vector(s), determined base::order(). right init padding \"right\" (end vector)? Defaults FALSE. Must singleton logical value: /switch. default, right == FALSE init padding beginning output.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/sigma.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cumulative sum of numeric vector — sigma","text":"sigma similar base-R cumsum(). However, sigma favored humdrumR use : groupby argument, automatically used humdrumR () commands constrain differences within pieces/spines/paths humdrum data. Using groupby argument function (details ) generally faster using groupby argument withinHumdrum(). (can) automatically skip NA () values. sigma also init argument can used ensure full invertability delta(). See \"Invertability\" section . applied matrix, sigma applied separately column, unless margin set 1 (rows) , higher-dimensional array, higher value.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/sigma.html"],"id":"invertability","dir":"Reference","previous_headings":"","what":"Invertability","title":"Cumulative sum of numeric vector — sigma","text":"sigma delta functions inverses , meaning right arguments set, sigma(delta(x)) == x delta(sigma(x)) == x. words, two functions \"reverse\" . key init argument needs set 0, arguments (lag, skip, groupby, etc.) need match. actually,  sigma(delta(x, init = 0, ...)) == x delta(sigma(x), init = 0)) == x. take differences values (delta(x)), resulting differences tell us fully reconstruct original unless know \"start\" (constant offset). example, delta(c(5, 7, 5, 6)) == c(NA, 2, -2, 1) know input goes 2, back 2, 1, starting value (first 5) lost. call sigma , get: sigma(c(NA, 2, -2, 1)) == c(0, 2,0, 1) get right contour, offset constant 5. call delta(x, init = 0) necessary constant (first value) kept beginning vector delta(c(5, 7, 5, 6), init = 0) == c(5, 2, -2, 1) sigma gets want, full invertability: sigma(delta(c(5, 7, 5, 6), init = 0)) == c(5, 7, 5, 6) Alternatively, specify necessary constant init argument sigma: sigma(delta(c(5, 7, 5, 6)), init = 5) == c(5, 7, 5, 6) init arguments two functions complementary. Currently, right argument delta complement sigma, invertability holds true right = FALSE (default).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/sigma.html"],"id":"greater-lags","dir":"Reference","previous_headings":"","what":"Greater lags","title":"Cumulative sum of numeric vector — sigma","text":"behavior sigma abs(lag) > 1 easiest understand inverse behavior delta(abs(lag) > 1), intuitive. (sigma inverse delta(), see Invertability section ). Generally, abs(lag) > 1, x grouped indices modulo lag, cumulative sum calculated separately set modulo indices. example, consider lag == 2 following input: cumulative sum 1 0 modulo-index groups : Index 1: cumsum(c(1,2,5)) == c(1, 3, 8). Index 0: cumsum(c(3,2)) == c(3, 5) Interleaved back order, result c(1,3,3,5,8). may clear, sure enough delta(c(1, 3, 3, 5, 8), lag = 2, init = 0) returns original c(1,3,2,2,5) vector! , understanding delta(..., lag = n) easier sigma(..., lag = n) (see Invtertability section .)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/sigma.html"],"id":"negative-lag","dir":"Reference","previous_headings":"","what":"Negative lag","title":"Cumulative sum of numeric vector — sigma","text":"lag negative, output equivalent positive lag, except sign reversed (output * -1). behavior easiest understand inverse behavior delta(lag < 0), intuitive. (sigma inverse delta(), see Invertability section ).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/sigma.html"],"id":"grouping","dir":"Reference","previous_headings":"","what":"Grouping","title":"Cumulative sum of numeric vector — sigma","text":"many cases want perform lagged calculations vector, across certain boundaries. example, vector includes data multiple pieces, want calculate melodic intervals pieces, within pieces. groupby argument indicates one, , grouping vectors, break x (input) argument groups. groupby vectors given, change vector indicates boundary. Value pairs cross groups treated beginning. Basically, using groupby argument function similar identical using tapply(x, groupby, laggedFunction, ...) using groupby expession call ().humdrumR. However, using groupby argument directly usually much faster, specially optimized functions. common use case humdrum data, looking \"melodies\" within spines. , want groupby = list(Piece, Spine, Path). fact, humdrumR () calls automatically feed three fields groupby arguments certain functions: mint, delta, sigma, lag, ditto, ioi, untie, hop. use delta call (), automatically calculate delta \"melodic\" way, within spine path piece. However, wanted, instance, calculate differences across spines (like harmonic intervals) manually set groupby = list(Piece, Record).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/sigma.html"],"id":"order","dir":"Reference","previous_headings":"","what":"Order","title":"Cumulative sum of numeric vector — sigma","text":"performing lagged calculations, typically assume order values input vector (x) order want \"lag\" across. E.g., first element \"\" second element, \"\" third element, etc. [Humdrum tables][humTable] always ordered Piece > Piece > Spine > Path > Record > Stop. Thus, lagged calculations across fields humtable , default, \"melodic\": next element next element spine path. example, consider data:   default order tokens (Token field) b c d e f. wanted instead lag across tokens harmonically (across records) need specifiy different order example, say orderby = list(Pice, Record, Spine)---lagged function interpret Token field d b e c f. another example, note Stop comes last order. consider happens stops data:","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/signature.html"],"dir":"Reference","previous_headings":"","what":"Humdrum key signature — signature","title":"Humdrum key signature — signature","text":"Humdrum key signature","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/signature.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Humdrum key signature — signature","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/signature.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Humdrum key signature — signature","text":"x Input data, interpreted diatonic keys. Must atomic vector. Key key used parser, deparser, transposer. Defaults NULL. Must diatonicSet something coercable diatonicSet; must either length 1 length(x) parseArgs optional list arguments passed key parser. Defaults empty list(). Must list named arguments key parser.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/signature.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Humdrum key signature — signature","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/silbeFormat.html"],"dir":"Reference","previous_headings":"","what":"silbeFormat — silbeFormat","title":"silbeFormat — silbeFormat","text":"Check formatting lyrics correct, -'s right places (.e., denote start end syllable)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/silbeFormat.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"silbeFormat — silbeFormat","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/silbeFormat.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"silbeFormat — silbeFormat","text":"cVector data checked improper formatting. Must data.frame. now, please read spine dataframe 1 column.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/silbeFormat.html"],"id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"silbeFormat — silbeFormat","text":"\"Formatted properly.\" lyrics formatted properly, else print error message corrections.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/silbeFormat.html"],"id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"silbeFormat — silbeFormat","text":"function might detect multiple inconsistencies/errors given value particular index, help user determine exact issue(s) transcription.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfa.html"],"dir":"Reference","previous_headings":"","what":"Relative-do Solfege representation — solfa","title":"Relative-do Solfege representation — solfa","text":"Relative-Solfege representation","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfa.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relative-do Solfege representation — solfa","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfa.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relative-do Solfege representation — solfa","text":"x Input data parse pitch information. x argument can (atomic) vector, tonalInterval, NULL. ... Arguments passed pitch deparser. also two hidden (advanced) arguments can specify: memoize deparse (see details ). generic \"specific\" pitch information (accidentals qualites) discarded? Defaults FALSE. Must singleton logical value: /switch. simple \"compound\" pitch information (octave/contour) discarded? Defaults FALSE. Must singleton logical value: /switch. Key input Key used parser, deparser, transposer. Defaults NULL. Must diatonicSet something coercable diatonicSet; must either length 1 length(x) transposeArgs optional list arguments passed special transpose() call. Defaults empty list(). Must list named arguments transpose(). parseArgs optional list arguments passed pitch parser. Defaults empty list(). Must list named arguments pitch parser. inPlace non-pitch information retained output string. Defaults FALSE. Must singleton  logical value: /switch. argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfa.html"],"id":"basic-pitch-arguments","dir":"Reference","previous_headings":"","what":"Basic pitch arguments","title":"Relative-do Solfege representation — solfa","text":"pitch function standard arguments control details output. important generic simple arguments, allow control type pitch information returned.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfa.html"],"id":"generic-vs-specific","dir":"Reference","previous_headings":"","what":"Generic vs Specific","title":"Relative-do Solfege representation — solfa","text":"generic = TRUE, specific pitch information (accidentals qualities) omitted output. alternative way controlling functionality, can use specific argument, specific == !generic. case atonal functions, \"generic\" version pitch output: example, semits('c#', generic = TRUE) return 0, \"generic\" version C# C, corresponds 0. However, note generic version pitch follows key, semits('c#', generic = TRUE, Key = ':') return 1!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfa.html"],"id":"simple-vs-compound","dir":"Reference","previous_headings":"","what":"Simple vs Compound","title":"Relative-do Solfege representation — solfa","text":"simple = TRUE, compound pitch information (octave contour) omitted output. alternative way controlling functionality, can use compound argument ,compound == !simple. actually one way might want divide compound intervals simple octave parts. example, might like call output -M2 (descending major 2nd) +m7 (ascending minor 7th octave ). functionality can controlled octave.round argument: see pitch deparsing documentation.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfa.html"],"id":"key","dir":"Reference","previous_headings":"","what":"Key","title":"Relative-do Solfege representation — solfa","text":"Key argument must diatonicSet, something can parsed one. Key argument passed parser, deparser, transpose---unless alternate Key passed transposeArgs parseArgs. Various deparsing options use Key argument; example, use implicitSpecies (see advanced parsing section) dependent Key. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function---means, cases, need explicitly anything Key argument! (want happen, need explicitly specify Key argument, Key = NULL.)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfa.html"],"id":"parse-arguments","dir":"Reference","previous_headings":"","what":"Parse arguments","title":"Relative-do Solfege representation — solfa","text":"parseArgs argument must list() (named) arguments passed input parser. example, input representation uses \"X\" represent double sharps, specify kern('CX5', parseArgs = list(doublesharp = 'X')) get correct result (\"cc##\"). convenient shorthand, \"syntactic sugar,\" can specify parseArgs alternate way: Simply input parse(args...) unnamed argument pitch function. example, can get exact result typing kern('CX5', parse(doublesharp = 'X')).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfa.html"],"id":"transpose-arguments","dir":"Reference","previous_headings":"","what":"Transpose arguments","title":"Relative-do Solfege representation — solfa","text":"transposeArgs argument must list() (named) arguments passed internal call transpose(), allowing us easily transpose pitch information. example, type kern(c('C', 'D', 'E'), transposeArgs = list(= 'M9')) can get output c('d', 'e', 'f#'). possible transpose args : (tonalInterval, length == 1 | length == (x)) (diatonicSet, length == 1 | length == (x))  (diatonicSet, length == 1 | length == (x)) real (logical, length == 1) transposition real tonal? relative (logical, length == 1) key-wise transposition based relative parallel keys? convenient shorthand, \"syntactic sugar,\" can specify transposeArgs alternate way: Simply input transpose(args...) unnamed argument pitch function. example, can get exact result typing kern(c('C', 'D', 'E'), transpose(= 'M9')).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfa.html"],"id":"transposing-by-interval","dir":"Reference","previous_headings":"","what":"Transposing by interval","title":"Relative-do Solfege representation — solfa","text":"calling transpose() directly, argument can anything coercable tonalInterval, output transposed amount. real = FALSE, tonal transposition (within Key) performed. details transposition behavior, check transpose() docs.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfa.html"],"id":"transposing-by-key","dir":"Reference","previous_headings":"","what":"Transposing by key","title":"Relative-do Solfege representation — solfa","text":"Another way transposing specifying input (\"\") key output (\"\") key. default, Key argument passed transpose , nothing actually happens. Thus, specify either key key, transposition happen /key Key. course, specify transposition happen keys specify. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function. specify key, Key field passed transpose key, result, pitches input transposed whatever keys target () key! real relative arguments give special control key-wise transposition works, check transpose() docs details!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfa.html"],"id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Relative-do Solfege representation — solfa","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfa.html"],"id":"pitch-gamut-levels","dir":"Reference","previous_headings":"","what":"Pitch-Gamut Levels","title":"Relative-do Solfege representation — solfa","text":"table() automatically generate factor levels pitch data using gamut() function. makes sure tabulated data sorted logical order, includes missing pitches. simple/complex  generic/specific arguments automatically passed gamut(); additional arguments can passed gamut using gamutArgs = list(...), syntactic sugar gamut(...). (Read gamut() docs explanation gamut generation.) feature used control table layout pitch data, well assure consistent tables grouping data. inPlace = TRUE special tabulation occur.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfa.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Relative-do Solfege representation — solfa","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfg.html"],"dir":"Reference","previous_headings":"","what":"Fixed-do Solfege representation — solfg","title":"Fixed-do Solfege representation — solfg","text":"Based common French system notating pitches, encoded humdrum **solfg interpretation.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfg.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fixed-do Solfege representation — solfg","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfg.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fixed-do Solfege representation — solfg","text":"x Input data parse pitch information. x argument can (atomic) vector, tonalInterval, NULL. ... Arguments passed pitch deparser. also two hidden (advanced) arguments can specify: memoize deparse (see details ). generic \"specific\" pitch information (accidentals qualites) discarded? Defaults FALSE. Must singleton logical value: /switch. simple \"compound\" pitch information (octave/contour) discarded? Defaults FALSE. Must singleton logical value: /switch. Key input Key used parser, deparser, transposer. Defaults NULL. Must diatonicSet something coercable diatonicSet; must either length 1 length(x) transposeArgs optional list arguments passed special transpose() call. Defaults empty list(). Must list named arguments transpose(). parseArgs optional list arguments passed pitch parser. Defaults empty list(). Must list named arguments pitch parser. inPlace non-pitch information retained output string. Defaults FALSE. Must singleton  logical value: /switch. argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfg.html"],"id":"basic-pitch-arguments","dir":"Reference","previous_headings":"","what":"Basic pitch arguments","title":"Fixed-do Solfege representation — solfg","text":"pitch function standard arguments control details output. important generic simple arguments, allow control type pitch information returned.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfg.html"],"id":"generic-vs-specific","dir":"Reference","previous_headings":"","what":"Generic vs Specific","title":"Fixed-do Solfege representation — solfg","text":"generic = TRUE, specific pitch information (accidentals qualities) omitted output. alternative way controlling functionality, can use specific argument, specific == !generic. case atonal functions, \"generic\" version pitch output: example, semits('c#', generic = TRUE) return 0, \"generic\" version C# C, corresponds 0. However, note generic version pitch follows key, semits('c#', generic = TRUE, Key = ':') return 1!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfg.html"],"id":"simple-vs-compound","dir":"Reference","previous_headings":"","what":"Simple vs Compound","title":"Fixed-do Solfege representation — solfg","text":"simple = TRUE, compound pitch information (octave contour) omitted output. alternative way controlling functionality, can use compound argument ,compound == !simple. actually one way might want divide compound intervals simple octave parts. example, might like call output -M2 (descending major 2nd) +m7 (ascending minor 7th octave ). functionality can controlled octave.round argument: see pitch deparsing documentation.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfg.html"],"id":"key","dir":"Reference","previous_headings":"","what":"Key","title":"Fixed-do Solfege representation — solfg","text":"Key argument must diatonicSet, something can parsed one. Key argument passed parser, deparser, transpose---unless alternate Key passed transposeArgs parseArgs. Various deparsing options use Key argument; example, use implicitSpecies (see advanced parsing section) dependent Key. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function---means, cases, need explicitly anything Key argument! (want happen, need explicitly specify Key argument, Key = NULL.)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfg.html"],"id":"parse-arguments","dir":"Reference","previous_headings":"","what":"Parse arguments","title":"Fixed-do Solfege representation — solfg","text":"parseArgs argument must list() (named) arguments passed input parser. example, input representation uses \"X\" represent double sharps, specify kern('CX5', parseArgs = list(doublesharp = 'X')) get correct result (\"cc##\"). convenient shorthand, \"syntactic sugar,\" can specify parseArgs alternate way: Simply input parse(args...) unnamed argument pitch function. example, can get exact result typing kern('CX5', parse(doublesharp = 'X')).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfg.html"],"id":"transpose-arguments","dir":"Reference","previous_headings":"","what":"Transpose arguments","title":"Fixed-do Solfege representation — solfg","text":"transposeArgs argument must list() (named) arguments passed internal call transpose(), allowing us easily transpose pitch information. example, type kern(c('C', 'D', 'E'), transposeArgs = list(= 'M9')) can get output c('d', 'e', 'f#'). possible transpose args : (tonalInterval, length == 1 | length == (x)) (diatonicSet, length == 1 | length == (x))  (diatonicSet, length == 1 | length == (x)) real (logical, length == 1) transposition real tonal? relative (logical, length == 1) key-wise transposition based relative parallel keys? convenient shorthand, \"syntactic sugar,\" can specify transposeArgs alternate way: Simply input transpose(args...) unnamed argument pitch function. example, can get exact result typing kern(c('C', 'D', 'E'), transpose(= 'M9')).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfg.html"],"id":"transposing-by-interval","dir":"Reference","previous_headings":"","what":"Transposing by interval","title":"Fixed-do Solfege representation — solfg","text":"calling transpose() directly, argument can anything coercable tonalInterval, output transposed amount. real = FALSE, tonal transposition (within Key) performed. details transposition behavior, check transpose() docs.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfg.html"],"id":"transposing-by-key","dir":"Reference","previous_headings":"","what":"Transposing by key","title":"Fixed-do Solfege representation — solfg","text":"Another way transposing specifying input (\"\") key output (\"\") key. default, Key argument passed transpose , nothing actually happens. Thus, specify either key key, transposition happen /key Key. course, specify transposition happen keys specify. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function. specify key, Key field passed transpose key, result, pitches input transposed whatever keys target () key! real relative arguments give special control key-wise transposition works, check transpose() docs details!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfg.html"],"id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"Fixed-do Solfege representation — solfg","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfg.html"],"id":"pitch-gamut-levels","dir":"Reference","previous_headings":"","what":"Pitch-Gamut Levels","title":"Fixed-do Solfege representation — solfg","text":"table() automatically generate factor levels pitch data using gamut() function. makes sure tabulated data sorted logical order, includes missing pitches. simple/complex  generic/specific arguments automatically passed gamut(); additional arguments can passed gamut using gamutArgs = list(...), syntactic sugar gamut(...). (Read gamut() docs explanation gamut generation.) feature used control table layout pitch data, well assure consistent tables grouping data. inPlace = TRUE special tabulation occur.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/solfg.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fixed-do Solfege representation — solfg","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/sonority.html"],"dir":"Reference","previous_headings":"","what":"Interpret tertian sonorities from set(s) of notes. — sonority","title":"Interpret tertian sonorities from set(s) of notes. — sonority","text":"sonority() function accepts vectors notes, usually grouped multiple chords groupby argument, interprets notes tertian sonority. Chords output using representation indicated deparser argument. default, /within.humdrumR automatically pass sonority groupby argument groupby = list(Piece, Record), chords estimated record dataset.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/sonority.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interpret tertian sonorities from set(s) of notes. — sonority","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/sonority.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interpret tertian sonorities from set(s) of notes. — sonority","text":"x Input data, interpreted pitches. vector interpreted pitch information using tonalInterval(). deparser output representation want? Defaults chord(). Must chord function, like roman(), harm() chord(). Key input key used deparser. Defaults NULL, indicating c major. However, /within.humdrum automatically pass Key field data sonority, one. Must diatonicSet something coercable diatonicSet; must either length 1 length(x) chord parsers use Key, irrelevant, want use Key roman numerals. inversions interpret note sets inversions? Defaults TRUE. Must singleton logical value: /switch. incomplete return incomplete chords? Defaults TRUE. Must singleton logical value: /switch. enharmonic pitches interpreted enharmonically? Defaults FALSE. Must singleton logical value: /switch. inPlace output always match input? Defaults FALSE groupby list; TRUE . Must singleton logical value: /switch. fill output duplicate chord every note input? Defaults TRUE. Must singleton logical value: /switch. argument effect inPlace = TRUE.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/sonority.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Interpret tertian sonorities from set(s) of notes. — sonority","text":"inPlace = TRUE, sonority()returns vectorized output, output matching length input vector. default,fill = FALSE, output chord repeated align  notes chord. fill = FALSE, chord returned , padded null tokens match length input. Finally, inPlace = FALSEonly one chord returned group ingroupby`. inversions = TRUE, notes interpreted chordal inversion compact (triad like) circle thirds. inversions = FALSE, lowest note always interpreted root. incomplete = TRUE, incomplete chords returns , might see things like \"C7no5\" (seventh chord fifth). incomplete = FALSE, sonority() (attempt) fill missing \"implied\" triad notes, note like missing 5ths. default, sonority() interpret spelling notes strictly, \"mispelled\" triad, like B, E♭, F♯ interpreted something weird---case augmented Eb chord third sharp 9! Note case cross relations---example, B♭ B♮ chord---sonority() simply ignore later species appears. However, enharmonic = TRUE, sonority() reinterpret input notes collapsing single diatonic set circle--fifths. means set B, Eb, F♯ interpreted B, D♯, F♯ set B♭, D, F, B♮ interpreted B♭, D, F, C♭.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/sonority.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interpret tertian sonorities from set(s) of notes. — sonority","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/spines.html"],"dir":"Reference","previous_headings":"","what":"Summarize spines in humdrum dataset. — spines","title":"Summarize spines in humdrum dataset. — spines","text":"spines tabulates spines spine paths within files humdrumR corpus. spines one humdrumR's basic corpus summary functions.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/spines.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize spines in humdrum dataset. — spines","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/spines.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize spines in humdrum dataset. — spines","text":"humdrumR HumdrumR data summarize. Must humdrumR data object. drop Whether return normal data.table humCensus table. Defaults FALSE. Must singleton logical value: /switch. drop = TRUE, normal data.table returned instead humCensus table. Index rows. numeric, selects rows index. character, string matched regular expression filenames corpus.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/spines.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summarize spines in humdrum dataset. — spines","text":"spines returns special data.frame called humSpines table. humSpines table five columns information piece: Spines number spines. Paths total number spine paths. number spines contain spine paths. *^ total number spine splits (\"*^\"). *v total number spine joins (\"*v\"). humSpine table prints command line, \"tallies\" unique combinations spines paths files also printed.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/spines.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize spines in humdrum dataset. — spines","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/step.html"],"dir":"Reference","previous_headings":"","what":"Extract scale step. — step","title":"Extract scale step. — step","text":"equivalent using pitch function arguments generic = TRUE, simple = TRUE, step.labels = NULL. default, step() returns steps relative key---set Key = NULL want .","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/step.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract scale step. — step","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/step.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract scale step. — step","text":"x Input data parse pitch information. x argument can (atomic) vector, tonalInterval, NULL. ... Arguments passed pitch deparser. also two hidden (advanced) arguments can specify: memoize deparse (see details ). generic \"specific\" pitch information (accidentals qualites) discarded? Defaults FALSE. Must singleton logical value: /switch. simple \"compound\" pitch information (octave/contour) discarded? Defaults FALSE. Must singleton logical value: /switch. Key input Key used parser, deparser, transposer. Defaults NULL. Must diatonicSet something coercable diatonicSet; must either length 1 length(x) transposeArgs optional list arguments passed special transpose() call. Defaults empty list(). Must list named arguments transpose(). parseArgs optional list arguments passed pitch parser. Defaults empty list(). Must list named arguments pitch parser. inPlace non-pitch information retained output string. Defaults FALSE. Must singleton  logical value: /switch. argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ).","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/step.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract scale step. — step","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/struct.html"],"dir":"Reference","previous_headings":"","what":"struct — struct","title":"struct — struct","text":"Virtual class help create atomic-vector-like composite data objects.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/struct.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"struct — struct","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/struct.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"struct — struct","text":"humdrumR defines number S4 classes , underneath surface, composite data types made collections base-R atomic vectors, stuck together. \"vectorized\" nature R's atomic types one R's key strengths, humdrumR try ) mostly use standard atomic types B) make new types define act much like atomic vectors possible. struct virtual S4 class serves purpose: creating composite atomic vectors act (mostly) like base-R atomic vectors. \"virtual class\" structs really exist independent objects, struct class defines (abstractly) necessarry methods treat collection atomic vectors single vector/matrix-like object---simply make new subclass inherit struct taken care . (, specify contains = \"struct\" call setClass.) Important humdrumR classes inherit struct include: tonal intervals diatonicSet tertianSet rational() warned, R's S4 object-system limited regard: really define S4 classes act fully like R atomics, many features hard-coded R replicated. important limitation struct may encounter , though struct classes work (ok) data.frames, data.tables tibbles either work give strange behaviors put structs .","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/struct.html"],"id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"struct — struct","text":"dim Either NULL non-negative integer-vector length == 2L, representing number rows columns respectively. Dimensions can zero. rownames Either NULL integer/character-vector length either ) dim == NULL, length struct B) dim != NULL, number rows struct. colnames Either NULL (must NULL dim == NULL) integer/character-vector length equal number columns struct.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/struct.html"],"id":"behavior","dir":"Reference","previous_headings":"","what":"Behavior","title":"struct — struct","text":"struct subclasses (.e., classes inherit struct) behave similarly normal R atomic vectors/matrices. However, differ respects, mostly ways intended avoid quirky behaviors R matrices: general, distinction dimensionless vectors dimensioned vectors (matrices) slightly weaker structs normal R atomic vectors/matrices. importantly, dimensioned structs drop dimensions various common operations (c, [], etc.), way base-R matrices . general, easier interact multi-column (matrix-)struct way dimensionless (vector-)struct. example, struct dimensions length(struct) == nrow(struct), instead length(matrix) == nrow(matrix) * ncol(matrix)---.e., \"height\" struct (number rows) length. Another big difference behaviors c: c always cause structs lose dimensions c can used concatinated multi-column structs, even mixes dimensionless dimensioned structs: struct arguments c dimensions, structs concatinated via call rbind, dimensionless vectors coerced 1-column matrices. course, (resulting) number columns must error occur! differences: structs can either dimensions (dim(struct) == NULL) two dimensions. Higher dimensional structs supported (yet). rowSums colSums coerce dimensionless struct column matrix. structs always throw error try index index value greater length/nrow struct. different atomic vectors, pad vector length index give---sometimes useful quirky behavior. structs two dimensions cartesian indexing argument. cartesian = TRUE, j arguments treated cartesian coordinates. (behavior can achieved base R matrices (structs) inputing matrix two columns.)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/struct.html"],"id":"requirements","dir":"Reference","previous_headings":"","what":"Requirements","title":"struct — struct","text":"work, struct makes assumptions class. class must one slots vectors, length. struct's indexing method cause vectors indexed one. define new subclass struct, inherit validObject method assures elements dimension. Thus, writing validObject method (using setValidity) just worry specifically validity information slots, slots length.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/struct.html"],"id":"initialize","dir":"Reference","previous_headings":"","what":"Initialize","title":"struct — struct","text":"initialize method automatically makes slots length predefined structs. want make specialized initialize method, can still take advantage inherited method using callNextMethod beginning method.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/struct.html"],"id":"predefined-methods","dir":"Reference","previous_headings":"","what":"Predefined methods","title":"struct — struct","text":"main purpose struct virtual class defines many basic methods need manipulate subclass objects. importantly, indexing methods fully defined (mimic base-R atomic vector/matrix indexing), well basic \"structural\" methods like (col/row)names, dim, length, ncol, nrow, etc. addition: define > >=, < <= automatically defined. define .character subclass, show format methods automatically defined. , default arithmetic methods addition, subtraction, (scalar-integer) multiplication, negation (-x) defined. default addition behavior numeric (base::integer base::numeric) slot subclasses added together. Thus, struct1 + struct2 extract numeric/integer slot struct, add together create new struct result. -struct negate numeric fields, subtraction simply defined adding negation. Since scalar multiplication defined, two structs multiplied, struct can multiplied integer (numeric fields multiplied integer(s)). definitions work subclass, need create , specific, method!","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/struct.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"struct — struct","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/subset.humdrumR.html"],"dir":"Reference","previous_headings":"","what":"Filter humdrum data — subset.humdrumR","title":"Filter humdrum data — subset.humdrumR","text":"subset.humdrumR command used filter humdrumR corpus. standard indexing operators ([] [[]]) actually work calling subset --hood; can read indexing options . However, using subset directly can accomplish much sophisticated filtering commands indexing methods.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/subset.humdrumR.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filter humdrum data — subset.humdrumR","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/subset.humdrumR.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filter humdrum data — subset.humdrumR","text":"x HumdrumR data. Must humdrumR data object. ... Arbitrary expressions passed (). \"within\" expression(s) must evaluate full-length logical values.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/subset.humdrumR.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Filter humdrum data — subset.humdrumR","text":"subset.humdrumR used similar manner withinHumdrum, taking number \"within expressions\" arguments. fact, expression arguments passed directly internal call withinHumdrum, control expressions (like subset) can used well. requirement expressions/functions fed subset.humdrumR must predicate expressions return logical (TRUE/FALSE) vector. returned vector must also length input data (number rows humdrum table). (can use fill expression want \"expand\" shorter outputs filtering purposes.)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/subset.humdrumR.html"],"id":"filter-field","dir":"Reference","previous_headings":"","what":"Filter field","title":"Filter humdrum data — subset.humdrumR","text":"using subset, humdrumR necessarily delete data filter . Rather, logical field humdrum table called Filter. subset.humdrumR updates humdrum table's Filter field using logical (|) existing Filter field negation predicate: Filter | !Predicate. HumdrumR functions (mostly) ignore data points Filter == TRUE, treating like NULL data. example, print filtered humdrumR see filtered data points turned null data (.), calls withinHumdrum ignore filtered data. means can, recover filtered data calling clearFilter dataset. cases might filter large parts data, leave bunch empty null data points (\".\"). want remove filtered data points, can call removeEmptyFiles, removeEmptyPieces, removeEmptySpines,  removeEmptyPaths, removeEmptyRecords, removeEmptyStops. functions go piece/spine/path/record check data region null filtered (.e., Null == TRUE | Filter == TRUE); , data removed. can remove data null (within region) otherwise humdrum syntax broken. default, subset.humdrumR automatically calls removeEmptyPieces end. However, can stop specifying  removeEmptyPieces = FALSE.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/subset.humdrumR.html"],"id":"renumbering","dir":"Reference","previous_headings":"","what":"Renumbering","title":"Filter humdrum data — subset.humdrumR","text":"filtered pieces removed corpus (using removeEmptyPieces removeEmptySpines, combination subset) File, Piece, /Spine fields renumbered represented remaining regions, starting 1. example, corpus 10 pieces remove first piece (Piece == 1), remaining pieces renumbered 2:10 1:9. Spine renumbering works , except done independently within piece.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/syncopation.html"],"dir":"Reference","previous_headings":"","what":"Identify syncopated rhythms — syncopation","title":"Identify syncopated rhythms — syncopation","text":"syncopation() function takes vector rhythmic duration values meter identifies durations syncopated, return TRUE synocopations FALSE otherwise. output syncopation depends lot meter specified/interpreted check meter() documentation looking control output.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/syncopation.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify syncopated rhythms — syncopation","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/syncopation.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify syncopated rhythms — syncopation","text":"dur input vector rhythmic durations. Must character numeric vector. parsed using rhythmInterval(); Wherever input parsed duration, element treated duration zero. meter meter(s) compute levels . Defaults standard, five-level duple (4/4) meter. Must meter() object character vector. character input, string parsed using meter(); failure parse result error. levels metrics levels identify syncopations? Defaults \"\". Must non-empty character numeric vector. levels simply singleton string \"\", syncopations metric level identified. Otherwise, levels parsed rhythmInterval(); fail parse may lead error. parsed levels must levels given meter(). groupby list vectors group x. Defaults list(). Must list; every element list must length length(x). function -record timeline, groupby list music include named Piece Record fields. Luckily, automatically passed ().humdrumR, need worry !","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/syncopation.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Identify syncopated rhythms — syncopation","text":"syncopation occurs whenever rhythmic duration longer highest metric level lands . cases, might want restrict attention syncopations occur specific metric level: example, \"eighth-note syncpations.\" can proved set metric levels levels argument, restriction. levels must parsable durations match levels meter().","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tactus.html"],"dir":"Reference","previous_headings":"","what":"Extract levels from meters — tactus","title":"Extract levels from meters — tactus","text":"functions take meter() objects---values parseable meters---return specific levels meter. tactus() extracts tactus meter; measure() extracts length full measure meter. nbeats() counts number tactus beats meter. functions particularly useful arguments count subpos functions.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tactus.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract levels from meters — tactus","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tactus.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract levels from meters — tactus","text":"x input compute desired duration . Must meter() object character vector. character input parsed using meter(); failures parse result errors. deparser output format desired? default recip(). Must rhythm function NULL. sep Seperator irregular beat patterns. Defaults \"+\". singleton character value. tactus pattern irregular beats, pasted together using separator.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tactus.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract levels from meters — tactus","text":"default, tactus() measure() deparse output recip(); alternative deparser (output format) can chosen using deparser argument.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tactus.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract levels from meters — tactus","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tally.html"],"dir":"Reference","previous_headings":"","what":"Tabulate and/or cross-tabulate data — tally","title":"Tabulate and/or cross-tabulate data — tally","text":"tally() function exactly like R's fundamental table() function, except 1) give special treatment humdrumR token() data 2) intuitive/simple argument names 3) makes easier combine/manipulate disparate output tables.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tally.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tabulate and/or cross-tabulate data — tally","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tally.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tabulate and/or cross-tabulate data — tally","text":"tally() function essentially wrapper around base::table() function. However, token() class arguments treated like factors(), calling generating levels. assures , example, pitch data tabulated order pitch height, \"missing\" pitches counted zero. tally() , default, count NA values present---want count NAs, specify na.rm = TRUE. can also tell tally() exclude (count) arbitrary values provide vector exclude argument. tally() always give names dimensions table creates. can specify names directly argument names, like tally(Kern = kern(Token)); specify name, tally() make name(s) based expression(s) tallying. (Note tally() copy base::table()'s obtusely-named dnn deparse.level arguments.)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tally.html"],"id":"manipulating-humdrum-tables","dir":"Reference","previous_headings":"","what":"Manipulating humdrum tables","title":"Tabulate and/or cross-tabulate data — tally","text":"output tally() special form R table, humdrum.table. Given two humdrum.tables, apply basic R operators (e.g., arithmetic, comparisons) row/column binding (cbind/rbind) humdrumR align tables dimension-names operation. means, two tables pitch data, one table includes specific pitch , can still add together bind matrix. See examples!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tally.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tabulate and/or cross-tabulate data — tally","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tatum.html"],"dir":"Reference","previous_headings":"","what":"Find common denominator of beats — tatum","title":"Find common denominator of beats — tatum","text":"humdrumR, define tatum greatest common denominator set durations. words, given set durations, largest duration divides given beats tatum---common unit can measure durations","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tatum.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find common denominator of beats — tatum","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tatum.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find common denominator of beats — tatum","text":"x input compute tatum . Must meter() object, singleton character value, vector either character, numeric, rational() values. character input, valuest match regular expression \"^\\*?M\" parsed time signature using meter(), strings parsed durations using rhythmInterval(). numeric input also parsed using rhythmInterval(); parse failures result errors. deparser output format desired? character meter input, default recip(); numeric input, default duration(). Must rhythm function NULL.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tatum.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find common denominator of beats — tatum","text":"tatum() generic function; can read input can parsed rhythm parser. can also take meter() object character string form \"MX/Y\". tatum meter() tatum meters metric levels. meters durations provided---like tatum(c('M4/4', '6')---, tatum meters' levels durations computed. deparser argument rhythm function controls output format. deparser NULL, tatum returned rational() value.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tatum.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find common denominator of beats — tatum","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tertian.html"],"dir":"Reference","previous_headings":"","what":"Tertian quality chord representation — tertian","title":"Tertian quality chord representation — tertian","text":"functions generic form tertian harmony representation, commonly used music theory. representation, root chord indicated **kern, followed one quality indicators, like \"CMM\" (C major seventh).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tertian.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tertian quality chord representation — tertian","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tertian.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tertian quality chord representation — tertian","text":"x atomic vector. x argument can (atomic) vectors Key diatonic key used parser, deparser, transposer. Defaults NULL, interpreted C major. Must diatonicSet something coercable diatonicSet; must either length 1 length(x). transposeArgs optional list arguments passed transpose() call. Defaults empty list(). Must list named arguments transpose(). parseArgs optional list arguments chord parser. Defaults empty list(). Must list named arguments chord parser. inPlace non-chord information retained output string. Defaults FALSE. Must singleton logical value: /switch.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tertian.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tertian quality chord representation — tertian","text":"first quality root indicates quality triad. Subsequent qualities, present, indicate quality 7th, 9th, 11th, 13th respectively. examples: M: major triad Mm: dominant-seventh chord MM: major-seventh chord Mmm: dominant-seventh--flat-9 chord. oo: fully-diminished-seventh chord. Missing extensions can indicated position using .. example, E-Mm.P indicates E-flat dominant-11th chord 9th. Missing members triad can indicated specifying either 5 3 immediately root, quality indicators. example, C5M indicates C major chord 3rd, G3mm indicates G-minor-seventh chord missing 5th. default quality indicators P (perfect), M (major), m (minor), o (diminished), + (augmented), can overridden calls respective arguments: example, tertian('Cdim', diminish = 'd').","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tertian.html"],"id":"inversions","dir":"Reference","previous_headings":"","what":"Inversions","title":"Tertian quality chord representation — tertian","text":"Inversions indicated slash notation, scale degree right slash. example, first-inversion major chord /3.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tertian.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tertian quality chord representation — tertian","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tertianSetS4.html"],"dir":"Reference","previous_headings":"","what":"Tertian set — tertianSetS4","title":"Tertian set — tertianSetS4","text":"tertianSet one humdrumR's types tonal data, representing Western tertian harmonies. tertianSet subclass diatonicSet (thence, struct).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tertianSetS4.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tertian set — tertianSetS4","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tertianSetS4.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tertian set — tertianSetS4","text":"structural addition, compared diatonicSet, Extensions slot. slot indicates tertian chord members active chord. seven possible chord members: root, third, fifth, seventh, ninth, eleventh, thirteenth. Every possible combination seven degrees represented single integer, corresponding 7-bit representation /offs seven degrees reverse order (13, 11, 9, 7, 5, 3, 1). example, integer 15 corresponds seventh chord: binary, 15 0001111. initial three zeros indicate 13th, 11th, 9th part harmony, four ones indicate root, third, fifth, seventh part harmony. Ultimately, adding removing chord degree harmony can achieved adding power two associated degree: Root: \\(\\pm 1\\) Third: \\(\\pm 2\\) Fifth: \\(\\pm 4\\) Seventh: \\(\\pm 8\\) Ninth: \\(\\pm 16\\) Eleventh: \\(\\pm 32\\) Thirteenth: \\(\\pm 64\\) tertianSet many specific methods defined reading/writing harmonic information.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/time.html"],"dir":"Reference","previous_headings":"","what":"Clock-time representations of duration — time","title":"Clock-time representations of duration — time","text":"functions convert duration values clock-time representations. seconds() ms() output numeric values. dur() outputs character string encoding humdrum **dur representation time.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/time.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clock-time representations of duration — time","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/time.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clock-time representations of duration — time","text":"x input  vector. x argument can (atomic) vector, rational (rhythmInterval), NULL. Must parsable rhythm infromation. ... Arguments passed rhythm parser. also two hidden (advanced) arguments can specify: memoize deparse (see details ). parseArgs optional list arguments passed rhythm parser. Defaults empty list(). Must list named arguments rhythm parser. scale numeric rational value used output unit measurement. Defaults rational(1, 1). Must numeric rational. inPlace non-rhythm information retained output string? Defaults FALSE. Must singleton  logical value: /switch. Defaults FALSE. singleton logical value, NA. See \"Grace notes\" section . minutes (logical, T/F) dur output include minutes? hours (logical, T/F) dur output include hours? days (logical, T/F) dur output include days? months (logical, T/F) dur output include months? years (logical, T/F) dur output include years?","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/time.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Clock-time representations of duration — time","text":"functions require BPM (beats-per-minute) argument specified. default, value 60 bpm.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/time.html"],"id":"dur","dir":"Reference","previous_headings":"","what":"dur","title":"Clock-time representations of duration — time","text":"**dur output can modified include different clock-time units: minutes, hours, days, months, years arguments true/false logical arguments, indicating whether use unit output (default FALSE). example, minutes = FALSE, input 90 seconds return \":90\" (90 seconds!), minutes = TRUE, output :1:30 (one minute thirty seconds).","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/time.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clock-time representations of duration — time","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/timebase.html"],"dir":"Reference","previous_headings":"","what":"Represent time on a regular grid — timebase","title":"Represent time on a regular grid — timebase","text":"timebase() function takes humdrumR dataset converts rhythmic information data step-sequencer like representation, humdrum data record representing one step. duration step \"timebase\", can controlled tb argument. timebase() function currently beta-draft, may work well.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/timebase.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Represent time on a regular grid — timebase","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/timebase.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Represent time on a regular grid — timebase","text":"humdrumR HumdrumR data. data must least one spine rhythmic (duration) encoded. timebase duration step output sequence. Defaults sixteenth-note. Must single atomic value, can parsed duration.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/timeline.html"],"dir":"Reference","previous_headings":"","what":"Rhythmic timeline of a piece — timeline","title":"Rhythmic timeline of a piece — timeline","text":"functions calculate ammount time (either beats, seconds) unfolded since beginning piece, giving sense timeline events unfold. music21 information described \"offsets\"---however, prefer reserve words \"onset\" \"offset\" refer beginning (attack) end (release) rhythmic events.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/timeline.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rhythmic timeline of a piece — timeline","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/timeline.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rhythmic timeline of a piece — timeline","text":"x Input rhythm information. Must atomic, NULL. parsed duration information. start timeline begin? Defaults 0. Must single number. pickup pickup (anacrusis)? Defaults NULL Must logical length(x), NULL. See \"Pickups\" section . threadNA rhythm-less tokens return NA? Defaults TRUE. Must singleton logical value: /switch. parseArgs optional list arguments passed rhythm parser. Defaults empty list(). Must list named arguments rhythm parser. groupby list vectors group x. Defaults list(). Must list; every element list must length length(x). function -record timeline, groupby list music include named Piece Record fields. Luckily, automatically passed ().humdrumR, need worry ! BPM tempo. Defaults 60. Must single number character string format \"MM120\" (120 bpm). default, ().humdrumR passes BPM field, present. minutes minutes counted output? Defaults TRUE. Must singleton logical value: /switch. TRUE, output seconds converted character string encoding minutes, seconds, milliseconds format MM.SS.ms.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/timeline.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rhythmic timeline of a piece — timeline","text":"Music unfolds time, humdrum data typically represents placing simultaneous events record, successive events ever higher records---progressing \"top \" file. humdrum data, (implicit) ordering data time present. Record NData fields capture ordering data parsed humdrumR. However, many (probably ) humdrum data files contain least information relative duration events, representing detailed information timing rhythm. timeline() parses input vector x durations, computes cumulative sum durations, start argument appended beginning. result numeric vector representing total duration since beginning vector (plus value start, defaults zero). cumulative durations timeline() represent musical duration units, 1 equals whole note. timestamp() converts durations seconds, either using BPM argument/field determine tempo using default tempo 60 beats per minute. minutes == TRUE, output formatted \"minute:seconds.milliseconds\" character strings. groupby argument provided, localDuration() used compute minimum durations group computing cumulative sum unique values Record groupby. default, ().humdrumR automatically pass groupby = list(Piece = Piece, Record = Record) calls timeline() timestamp(). Thus, call like within(humData, timeline(Token)) compute correct timeline position tokens across spines/paths/stops---values record . Note , timeline() timestamp() follow default behavior duration() treating grace-notes duration 0. means position timeline simply inherited previous event timeline, occur time. want use specified duration(s) grace notes, specify grace = TRUE. default, tokens without (parsable) rhythm information returned NA. However, threadNA = FALSE, rhythm-less tokens treated duration 0 well, thus (shared) position timeline.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/timeline.html"],"id":"pickups","dir":"Reference","previous_headings":"","what":"Pickups","title":"Rhythmic timeline of a piece — timeline","text":"Another option pass pickup argument logical vector length input x. Within piece/group, block TRUE values beginning pickup vector indicate pickup. first index pickup logical FALSE used starting point timeline/count; earlier (pickup == TRUE) points negative numbers, measured backwards start index. humdrumR, datapoints first barline record (=) labeled Bar == 0 Bar field. Thus, common use pickup argument within(humData, timeline(Token, pickup = Bar < 1), makes downbeat first complete bar 1 starting point timeline---notes pickup bars negative timeline.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/timeline.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rhythmic timeline of a piece — timeline","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/token.html"],"dir":"Reference","previous_headings":"","what":"Humdrum tokens — token","title":"Humdrum tokens — token","text":"token S4 class acts simple \"wrapper\" around atomic data, allowing humdrumR give data special treatment. basically atomic vectors known exclusive interpretation. able treat exactly like \"normal\" class atomic vector---e.g., character, numeric.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/token.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Humdrum tokens — token","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonalIntervalS4.html"],"dir":"Reference","previous_headings":"","what":"Representation of tonal pitch information — tonalIntervalS4","title":"Representation of tonal pitch information — tonalIntervalS4","text":"tonalInterval core tonal pitch representation humdrumR. tonalInterval abstract representation tonal pitch, can translated /standard \"concrete\" pitch representations: solfege, scientific pitch, semitones, frequencies, scale degrees, intervals, etc. part, users need interact tonalIntervals directly---rather, tonalIntervals work behind scene numerous humdrumR pitch functions. See pitch functions pitch parsing documentation details tonalIntervals used humdrumR.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonalIntervalS4.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Representation of tonal pitch information — tonalIntervalS4","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonalIntervalS4.html"],"id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Representation of tonal pitch information — tonalIntervalS4","text":"Octave integers representing octave offset. Fifth integers representing \"line--fifths\" value. Cent numeric values representing cents (1200th octave). tonalInterval S4 subclass humdrumR's virtual class struct, inherits lot useful \"vector-like\" behaviors/functionality.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonalIntervalS4.html"],"id":"creating-tonal-intervals","dir":"Reference","previous_headings":"","what":"Creating tonal intervals","title":"Representation of tonal pitch information — tonalIntervalS4","text":"Generally, tonalIntervals created using tonalInterval() function, various methods. tonalInterval function primarily parser, documented elsewhere, interprets various input representations generates tonalInterval S4 objects (documented ). Alternatively, constructor function tint can used directly create tonalInterval objects. three arguments tint correspond three slots: octave, LO5th (Fifth), cent. inputs coerced match length. octave argument can left blank, case appropriate octave automatically computed place interval octave . default, .character method, thus (via struct) show method, tonalIntervals call interval(). Thus, return tonalInterval command line see **interval representation printed.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonalIntervalS4.html"],"id":"predefined-intervals-","dir":"Reference","previous_headings":"","what":"Predefined Intervals:","title":"Representation of tonal pitch information — tonalIntervalS4","text":"humdrumR automatically exports bunch tonalIntervals, named musical interval representation. Every generic interval 1 15 combined every interval quality dd (doubly diminished), d (diminished), m (minor), M (major), (augumented) AA (doubly augmented). Thus, loading humdrumR, can type things like M3 + M3 get A5. addition, variables unison (= P1 = tint(0, 0)) pythagorean.comma (= d2 = tint(-19,12)) exported well.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonalIntervalS4.html"],"id":"arithmetic-","dir":"Reference","previous_headings":"","what":"Arithmetic:","title":"Representation of tonal pitch information — tonalIntervalS4","text":"Technically, tonalIntervals examples algebraic modules integers. means certain arithmetic operations defined tonalIntervals can called using standard arithmetic operators (+, -, etc.): Addition: tonalIntervals can added together, acting exactly expect (.e., \\(M3 + m3 = P5\\)). Subtraction: tonalIntervals can subtracted just added. Also, can negated single - operator (like -M3). Multiplication: tonalIntervals can multiplied together. However, scalar (integer) multiplication defined: thus, tonalIntervals can multiplied integers create new tonalIntervals: e.g., \\(M2 * 3 = A4\\). Division: natural inverse scale multiplication, Euclidean division defined tonalIntervals---.e., division /whole (integer) pieces, often leftover \"remainders\" (modulo). R, Euclidean division achieved %/% operator---/---, associated %% used remainder/modulo. Two tonalIntervals can divided produced integer; Conversely, tonalInterval can divided integer produce tonalInterval. Take note way humdrumR defines Euclidean division based tonal space---.e., line--fifths---frequency atonal-semitone space. example, augmented-fourth divided major-second 3L, diminished-fifth divided major-second 3L---d5 %/% M2 equals -3L remainder P8 (plus octave)! division algorithm works applying standard Euclidean division @Fifth slot (line--fifths tonal space), shifting @Octave value remainder match appropriate octave. attempt addition tonalInterval non-tonalInterval atomic vector (e.g., integer, character), humdrumR attempt coerce input tonalInterval, using tonalInterval() parser, math output answer original format (non-tonalInterval) format. instance, M3 + 2 interpret 2 two semitones add major-second major-third, resulting 6 semitones. \"-place\" parsing/deparsing used, \"extra\" characters input passed . example, M3 + 4.ee- return 4.gg.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonalIntervalS4.html"],"id":"relational-operators","dir":"Reference","previous_headings":"","what":"Relational Operators","title":"Representation of tonal pitch information — tonalIntervalS4","text":"tonalIntervals can compared using standard relational operations, like ==, !=, >, >=. Two tonalIntervals equal (according ==) slots (Octave, Fifth, Cent) exactly identical. Thus, enharmonic notes (like C Db) equal. contrast, ordinal comparisons (e.g., >, <=) tonalIntervals based semitone (equal temperament) size, enharmonicity irrelevant. Thus, m3 >= A2 A2 >= m3 TRUE, even though m3 == A2 .","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonalIntervalS4.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Representation of tonal pitch information — tonalIntervalS4","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonh.html"],"dir":"Reference","previous_headings":"","what":"German-style pitch notation. — tonh","title":"German-style pitch notation. — tonh","text":"Based common German system notating pitches, encoded humdrum **Tonh interpretation.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonh.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"German-style pitch notation. — tonh","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonh.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"German-style pitch notation. — tonh","text":"x Input data parse pitch information. x argument can (atomic) vector, tonalInterval, NULL. ... Arguments passed pitch deparser. also two hidden (advanced) arguments can specify: memoize deparse (see details ). generic \"specific\" pitch information (accidentals qualites) discarded? Defaults FALSE. Must singleton logical value: /switch. simple \"compound\" pitch information (octave/contour) discarded? Defaults FALSE. Must singleton logical value: /switch. Key input Key used parser, deparser, transposer. Defaults NULL. Must diatonicSet something coercable diatonicSet; must either length 1 length(x) transposeArgs optional list arguments passed special transpose() call. Defaults empty list(). Must list named arguments transpose(). parseArgs optional list arguments passed pitch parser. Defaults empty list(). Must list named arguments pitch parser. inPlace non-pitch information retained output string. Defaults FALSE. Must singleton  logical value: /switch. argument effect input (x argument) character strings, extra, non-pitch information input strings \"besides\" pitch information. , inPlace = TRUE, output placed output string beside original non-pitch information. inPlace = FALSE, pitch output information returned (details ). S special shorthand Eb Ab used?. Defaults TRUE. S = TRUE, E-flat (Ees) output \"S\" -flat (Aes) output \"\".","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonh.html"],"id":"basic-pitch-arguments","dir":"Reference","previous_headings":"","what":"Basic pitch arguments","title":"German-style pitch notation. — tonh","text":"pitch function standard arguments control details output. important generic simple arguments, allow control type pitch information returned.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonh.html"],"id":"generic-vs-specific","dir":"Reference","previous_headings":"","what":"Generic vs Specific","title":"German-style pitch notation. — tonh","text":"generic = TRUE, specific pitch information (accidentals qualities) omitted output. alternative way controlling functionality, can use specific argument, specific == !generic. case atonal functions, \"generic\" version pitch output: example, semits('c#', generic = TRUE) return 0, \"generic\" version C# C, corresponds 0. However, note generic version pitch follows key, semits('c#', generic = TRUE, Key = ':') return 1!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonh.html"],"id":"simple-vs-compound","dir":"Reference","previous_headings":"","what":"Simple vs Compound","title":"German-style pitch notation. — tonh","text":"simple = TRUE, compound pitch information (octave contour) omitted output. alternative way controlling functionality, can use compound argument ,compound == !simple. actually one way might want divide compound intervals simple octave parts. example, might like call output -M2 (descending major 2nd) +m7 (ascending minor 7th octave ). functionality can controlled octave.round argument: see pitch deparsing documentation.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonh.html"],"id":"key","dir":"Reference","previous_headings":"","what":"Key","title":"German-style pitch notation. — tonh","text":"Key argument must diatonicSet, something can parsed one. Key argument passed parser, deparser, transpose---unless alternate Key passed transposeArgs parseArgs. Various deparsing options use Key argument; example, use implicitSpecies (see advanced parsing section) dependent Key. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function---means, cases, need explicitly anything Key argument! (want happen, need explicitly specify Key argument, Key = NULL.)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonh.html"],"id":"parse-arguments","dir":"Reference","previous_headings":"","what":"Parse arguments","title":"German-style pitch notation. — tonh","text":"parseArgs argument must list() (named) arguments passed input parser. example, input representation uses \"X\" represent double sharps, specify kern('CX5', parseArgs = list(doublesharp = 'X')) get correct result (\"cc##\"). convenient shorthand, \"syntactic sugar,\" can specify parseArgs alternate way: Simply input parse(args...) unnamed argument pitch function. example, can get exact result typing kern('CX5', parse(doublesharp = 'X')).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonh.html"],"id":"transpose-arguments","dir":"Reference","previous_headings":"","what":"Transpose arguments","title":"German-style pitch notation. — tonh","text":"transposeArgs argument must list() (named) arguments passed internal call transpose(), allowing us easily transpose pitch information. example, type kern(c('C', 'D', 'E'), transposeArgs = list(= 'M9')) can get output c('d', 'e', 'f#'). possible transpose args : (tonalInterval, length == 1 | length == (x)) (diatonicSet, length == 1 | length == (x))  (diatonicSet, length == 1 | length == (x)) real (logical, length == 1) transposition real tonal? relative (logical, length == 1) key-wise transposition based relative parallel keys? convenient shorthand, \"syntactic sugar,\" can specify transposeArgs alternate way: Simply input transpose(args...) unnamed argument pitch function. example, can get exact result typing kern(c('C', 'D', 'E'), transpose(= 'M9')).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonh.html"],"id":"transposing-by-interval","dir":"Reference","previous_headings":"","what":"Transposing by interval","title":"German-style pitch notation. — tonh","text":"calling transpose() directly, argument can anything coercable tonalInterval, output transposed amount. real = FALSE, tonal transposition (within Key) performed. details transposition behavior, check transpose() docs.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonh.html"],"id":"transposing-by-key","dir":"Reference","previous_headings":"","what":"Transposing by key","title":"German-style pitch notation. — tonh","text":"Another way transposing specifying input (\"\") key output (\"\") key. default, Key argument passed transpose , nothing actually happens. Thus, specify either key key, transposition happen /key Key. course, specify transposition happen keys specify. use pitch function within special call withinHumdrum, humdrumR automatically pass Key field humdrum data function. specify key, Key field passed transpose key, result, pitches input transposed whatever keys target () key! real relative arguments give special control key-wise transposition works, check transpose() docs details!","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonh.html"],"id":"in-place-parsing","dir":"Reference","previous_headings":"","what":"In-place parsing","title":"German-style pitch notation. — tonh","text":"humdrum data, character strings often encoded multiple pieces musical information right besides : example, **kern data might include tokens like \"4.ee-[. humdrumR parser (tonalInterval) automatically \"pull \" pitch information within strings, can find using appropriate known regular expressions. example, pitch('4.ee-[') returns Eb5. However, pitch functions (like pitch() kern()) option keep \"extra\" information return result \"place\"---.e., embedded right found input string. controlled inPlace argument, FALSE default. , pitch('4.ee-[', inPlace = TRUE) return 4.Eb5[---keeping \"4.\" \"[\". (obviously works input string, numeric!) Note inPlace = TRUE force functions like semits, normally return numeric values, return character strings input character string.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonh.html"],"id":"pitch-gamut-levels","dir":"Reference","previous_headings":"","what":"Pitch-Gamut Levels","title":"German-style pitch notation. — tonh","text":"table() automatically generate factor levels pitch data using gamut() function. makes sure tabulated data sorted logical order, includes missing pitches. simple/complex  generic/specific arguments automatically passed gamut(); additional arguments can passed gamut using gamutArgs = list(...), syntactic sugar gamut(...). (Read gamut() docs explanation gamut generation.) feature used control table layout pitch data, well assure consistent tables grouping data. inPlace = TRUE special tabulation occur.","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/tonh.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"German-style pitch notation. — tonh","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/transpose.html"],"dir":"Reference","previous_headings":"","what":"Transpose pitches and keys — transpose","title":"Transpose pitches and keys — transpose","text":"function transposes pitches keys various intervals target keys. Inside box, inputs transpositions take place tonalIntervals diatonicSets, numeric character string representation pitches can transposed well. function incorporated directly tonalTransform, thence, pitch translation functions, probably call directly often.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/transpose.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transpose pitches and keys — transpose","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/transpose.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transpose pitches and keys — transpose","text":"x ***input pitch(es) transpose. *** Can tonalInterval something intepretable pitch information. Transpose interval. Can tonalInterval something intepretable tonalInterval. Key Transpose key (key). Can diatonicSet something intepretable diatonicSet. tonal /transpositions, \"\" key. value NULL, defaults C major. Transpose key (Key key). Can diatonicSet something intepretable diatonicSet. real transposition real (tonal)? Defaults TRUE. Must singleon logical value: /switch. real == FALSE, transposition tonal. relative transposition keys relative (parallel)? Defaults FALSE. Must singleton logical value: /switch. relavent using transposing keys (Key ) different modes. relative == FALSE, transposition parallel.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/transpose.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Transpose pitches and keys — transpose","text":"two distinct types transposition (real tonal). also two different approaches specifying transpositions: \"\" \"\". \"\" transpositions can also either parallel relative.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/transpose.html"],"id":"types-of-transposition","dir":"Reference","previous_headings":"","what":"Types of Transposition","title":"Transpose pitches and keys — transpose","text":"two different types transposition: real transposition tonal transposition. real transposition, inputs transposed specific interval. example, pitches {C D E F G} transposed major second {C D E F# G}. tonal transposition, inputs transposed generic intervals, within key. example, sequence {C D E F G}, key C major, translated generic second {D E F G }. choose real tonal transposition, use real argument: real = TRUE real transposition, real = FALSE tonal transposition.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/transpose.html"],"id":"alterations","dir":"Reference","previous_headings":"","what":"Alterations","title":"Transpose pitches and keys — transpose","text":"Tonal transposition complicated presence alterations input pitches. instance, given pitches {C F# G D# E}`` key C major, tonally transposed second, within C major? one obvious, correct answer answer, can easily identified. algorithm implemented humdrumR` follows: Alterations/accidentals input identified. (case, F# D#). generic pitches transposed within key, resulting {D G E F}. Alterations input added output unless resulting pitches interpreted comma call tintPartion, given enharmonic wrap value (default 12). example, adding first accidental results {G#} comma. However, second accidental results {E#} comma away natural {F}. Thus, accidental added output, resulting {E}, {E#}. resulting output {D G# E F}. size enharmonicWrap effectively determines extreme accidentals allowed. default value, 12, assures output notes enharmonically equivalent notes key. illustrate, sequence {C F# G D# E, B- - G C# D, B D- C} transposed tonally within C major seven possible generic intervals, enharmonicWrap = 12:","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/transpose.html"],"id":"specifying-transpositions","dir":"Reference","previous_headings":"","what":"Specifying Transpositions","title":"Transpose pitches and keys — transpose","text":"two approaches specifying transpositions, arguments. argument must interval, input translated interval. interval specific real = FALSE, input treated generic interval, tranposition takes place within key indicated Key argument. argument translates input desired key. example, input key E major want transposed G major, say = '*E:'. real = TRUE, input simply translated root key, exact intervals. real = FALSE, input translated root new key, intervals changed match new key well. either case, result depends input's key , indicated standard Key argument. Key arguments like \"\" key. Key = NULL, input key interpreted C major. Consider input notes {D B C # B, D C# D E D} key G major. specify = e:, real = TRUE, output {B G# F## G#, B # B C# B}. (Notice even though key minor, output still clearly E major). specify = e:, real = FALSE, output instead {B G F# G, B # B C B}. Building previous example, consider input key matters well. use input notes ({D B C # B, D C# D E D}) input Key C major, : specify = e:, real = TRUE, output {F# D# E C## D#, F# E# F# G# F#}. specify = e:, real = FALSE, output instead {F# D E C# D, F# E F# G F#}. specified, transposition applied first, followed transposition. real = FALSE, transposition happens within key, Key key.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/transpose.html"],"id":"relative-vs-parallel","dir":"Reference","previous_headings":"","what":"Relative vs Parallel","title":"Transpose pitches and keys — transpose","text":"transposing , diferent approaches determining relationship \"\" key (Key argument) \"\" key (argument). think \"parallel\" relationships keys, match roots keys regardless modes. instance, C major C minor parallel keys. instead think \"relative\" relationships keys, match modes keys, roots. instance, C major minor relative keys. similar distinction \"la-based minor\" solfege (relative) vs \"fixed-\" solfege (parallel). transposing using argument, relative = FALSE input key (Key argument) transposed match root argument. example, input key G minor `` key C major, output transposed G minor. However, relative = TRUEthe input key transposed match mode thetokey: G minor input C majortowould translated minor, parallel minor thetokey. theKey(key) andto` (key) arguments mode, parallel relative transpositions .","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/transpose.html"],"id":"special-operators-","dir":"Reference","previous_headings":"","what":"Special Operators +-","title":"Transpose pitches and keys — transpose","text":"note, real transposition interval can achieved concisely using + - operators, long least one side operators actual tonalInterval object. humdrumR preassigns common tonalIntervals objects global environment. Thus, can type commands like \"c#\" + M2 get d#, c(\"C4\", \"E4\", \"C5\") - m6 get \"E3\" \"G#3\" \"E4\".","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/unfoldStops.html"],"dir":"Reference","previous_headings":"","what":"","title":"","text":"record/spine/path locations different numbers stops different fields, function spreads data smaller fields multiple stops.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/unfoldStops.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"","text":"","code":""},{"path":[],"code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/validateHumdrum.html"],"dir":"Reference","previous_headings":"","what":"Validate humdrum files — validateHumdrum","title":"Validate humdrum files — validateHumdrum","text":"function checks files local machine violations humdrum syntax. Detailed error reports can generated, pointing specific problematic records files.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/validateHumdrum.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate humdrum files — validateHumdrum","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/validateHumdrum.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate humdrum files — validateHumdrum","text":"... Arguments passed findHumdrum(). Used identify files local machine test humdrum validity. mainly used pass regex file-path search patterns, may also used pass recursive /contains arguments findHumdrum(). errorReport.path directory path write error report files. Defaults NULL. Must single character string. NULL (default), error report files written.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/validateHumdrum.html"],"id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate humdrum files — validateHumdrum","text":"validateHumdrum() returns \"error frame\" data.table object, invisibly (\"see\" output, must save variable, look ). error frame data.table three columns: Filepath: file name. Record: record contains error. Message: description error. Valid files rows error frame.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/validateHumdrum.html"],"id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Validate humdrum files — validateHumdrum","text":"violations general humdrum syntax identified. example, missing exclusive interpretations, *- spine enders, null data tokens. validateHumdrum function check ill-formed data content---example, **kern spine containing token \"Lsharp\" rejected. Note validateHumdrum quite picky details! \"Hanging white space,\" even global records, marked invalid files! validateHumdrum called manner readHumdrum(), providing one regex search patterns match files machine. (..., recursive, contains arguments simply passed findHumdrum().) called, validateHumdrum prints basic messages informing result file matching validity testing.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/validateHumdrum.html"],"id":"error-reports","dir":"Reference","previous_headings":"","what":"Error reports","title":"Validate humdrum files — validateHumdrum","text":"desired, contents validateHumdrum \"error frame\" can written text files. allows us print errors tagged right alongside original raw data. write error report, set errorReport.path argument non-NULL string, pointing directory path machine. directory exist, R (attempt ) create . errorReport.path directory, complete error report(s) files (returned \"fileFrame\", see ) written single file named 'humdrumR_syntaxErrorReport_DATE.txt' (date coming Sys.Date).  addition, sub directory called AnnotatedFilesis created. directory, copies files contain errors written, with_errorAnnotations` appended names. file, individual errors directly indicated record occur. output looks like :","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/validateHumdrum.html"],"id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Validate humdrum files — validateHumdrum","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html"],"dir":"Reference","previous_headings":"","what":"with(in)Humdrum — withinHumdrum","title":"with(in)Humdrum — withinHumdrum","text":"Evaluate arbitrary expressions using fields within humdrumR data, employing split/apply/combine, windowing, analysis options.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"with(in)Humdrum — withinHumdrum","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"with(in)Humdrum — withinHumdrum","text":"data HumdrumR data. Must humdrumR data object. ... number expressions evaluate. Unnamed expressions interpreted \"main\" within-expressions. Possible evaluation control arguments include , subset, context. evaluation options can achieved recycle side arguments. dataTypes types humdrum records include. Defaults \"D\". Must single character string. Legal values 'G', 'L', '', 'M', 'D', 'd' combination (e.g., \"LIM\"). (See humdrum table documentation Fields section explanation.) drop Whether return simplified data structure. Defaults TRUE. Must singleton logical value: /switch. argument conceptually similar drop argument R matrices. drop = TRUE, output .humdrumR simplified much possible (trying return \"raw\" vector, list, table, etc. within ). drop = FALSE, result always data.table. default value (drop = TRUE) usually want intuitive, complex code, can helpful set drop = FALSE output consistent. variables named list values, interpolated within-expression(s) wherever variable name matches named list. Defaults list(). Must list. alignLeft output shorter input aligned left? Defaults TRUE. Must singleton logical value: /switch.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html"],"id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"with(in)Humdrum — withinHumdrum","text":"within.humdrumR  new humdrumR data object. .humdrumR, whatever value returned expression , drop = TRUE, data.table.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html"],"id":"overview","dir":"Reference","previous_headings":"","what":"Overview","title":"with(in)Humdrum — withinHumdrum","text":"functions primary means working humdrumR data. analogous base-R within methods data.frames. Specifically allow evaluate arbitrary expressions using fields humdrumR data object. means can drop \"inside\" humdrumR data object run whatever commands want using fields humdrum data table, keeping data safely \"encapsulated\" within humdrum object---least, want pull . difference .humdrumR within.humdrumR analogous difference base::() base::within(). .humdrumR evaluates expression(s) simply returns result evaluation. within.humdrumR evaluates expression(s) inserts results back humdrumR object, generating new fields called ResultX (see details). addition, within offer number powerful options make working humdrum data easier: evaluation control arguments can used control expressions evaluated. can evaluate expressions... subset data using subset... either ignoring rest data evaluating different expression part. Separately different subsets data, recombined (split-apply-combine) using . Across contextual windows data (e.g., ngrams, rolling windows). produce plots particular plotting parameters, /without returning anything using sidefx. \"Fill\" short results match original field size using fill. certain record types (defaulting data records) using dataTypes. arguments specified named arguments /within calls. Even though formal arguments, partially matched, write grou instead groupby, get error! cases, can specify one type control argument (details ).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html"],"id":"expression-evaluation","dir":"Reference","previous_headings":"","what":"Expression evaluation","title":"with(in)Humdrum — withinHumdrum","text":"\"expression\" legal bit R code, like 2 + 2 x - mean(x). call /within.humdrumR must least one expression evaluate. refer \"within-expressions.\" expressions passed /within.humdrumR unnamed arguments: example, (humData, myExpressionHere). Within expressions evaluated within humdrumR object's humdrum table, means expression can refer fields humdrumR object name (Record, Token, Piece, etc.) just like variables. Since fields humdrum object vectors length, within expressions easily (generally ) vectorized. Note within-expression value evaluated data-points/records match type indicated dataTypes argument. default, non-null data tokens (\"D\") used. multiple within-expressions provided, expression evaluated order (left right). expression can refer results last expression (.), variables defined previous expressions. number special syntactic sugars can used within expressions. . placeholder. Side effects Recycled (\"filled\") results Lagged vectors etc. explained .","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html"],"id":"the-placeholder","dir":"Reference","previous_headings":"","what":"The . placeholder","title":"with(in)Humdrum — withinHumdrum","text":". variable can used special placeholder within expressions. first within expression, . interpreted humdrumR object's current active expression. multiple within expressions given, beyond first expression,  . refers result previous expression. example, Token active expression, :   return result :","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html"],"id":"side-effects-","dir":"Reference","previous_headings":"","what":"Side effects:","title":"with(in)Humdrum — withinHumdrum","text":"cases, want evaluate within-expression \"side effect\"; means expression something want (\"side effect\") actually evaluate (return) result want. common \"side effect\" creating plot. examples might printing text console using base::cat() base::print(), writing file. Side effects can achieved naming expression sidefx fx---usual, arguments can partially matched, side also works, commonly used. Side-effect expressions executed, result () ignored. means call something like newData <- within(humData, side = plot(x)), plot made result (newData) identical humData. Side-effects can also used combination within expressions. result ignored, fed next expression .. example command   creates histogram nchar(Token) also returns mean nchar(Token). (Note variables explicitly assigned side call visible later calls, confusing, !)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html"],"id":"recycling-filling-results-","dir":"Reference","previous_headings":"","what":"Recycling (\"filling\") results:","title":"with(in)Humdrum — withinHumdrum","text":"result within expression may shorter input vectors (humtable fields). However, calls within.humdrumR particular, like return single number recycle \"fill\" original data field. words, like output (result) expression repeated matches length input field(s). manually using base::rep() function, /within.humdrumR provide syntactic sugar : can name expression recycle fill (partially matched), cause result recycled. take yourExpression(field, ...) wrap rep(yourExpression(field, ...), length.= length(field)).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html"],"id":"lagged-vectors","dir":"Reference","previous_headings":"","what":"Lagged vectors","title":"with(in)Humdrum — withinHumdrum","text":"often want work \"lagged\" vectors data. example, want look relationship vector previous values vector---e.g., vector offset \"lagged\" one index. humdrumR lag() function useful , gives us several options lagging vectors, always keeping length vectorization never hindered. within.humdrumR give us convenient short cut using lag. within-expression, vector can indexed integer argument named lag (case insensitive), causing lagged integer. (vector indexed lag = 0 returns unchanged vector.) example, following two calls :   lag index multiple values indexed object appears within higher function call, lag inserted separate argument call. Thus, two calls also :   lag() function groupby argument, /within.humdrumR automatically feed fields list(Piece, Spine, Path). default \"melodic\" behavior music. like turn , need override adding groupby argument lagged index, like Token[lag = 1, groupby = list(...)]. Using lagged vectors, since vectorized, fastest (computationally) easiest way working n-grams. example, want create character-string 5-grams data, call:   Note , since /within.humdrumR passes groupby = list(Piece, Spine, Path) lag(), true \"melodic\" n-grams, created within spine-paths within piece.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html"],"id":"results","dir":"Reference","previous_headings":"","what":"Results","title":"with(in)Humdrum — withinHumdrum","text":"difference .humdrumR within.humdrumR results evaluated within-expression(s).","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html"],"id":"within","dir":"Reference","previous_headings":"","what":"Within","title":"with(in)Humdrum — withinHumdrum","text":"calls within.humdrumR, result final within-expression inserted back [humtable][humdrum table]. results atomic vectors, though lists can also placed fields. results shorter input fields humtable padded null values fill length input. Non-vector results (objects) tables put lists, treated like list. result, data/record-types indicated dataTypes argument also returned padded null values. explicitly name result within-expression, put new field labeled ResultX, X lowest number \"ResultX\" fields already taken. can explicitly name result field top-level assignment expression. example, within(data, Semits <- semits(Token)) put result semits(Token) new field called Semits. fact, assign results multiple within-expressions, result length last result put new field. Thus, can create multiple new fields single call: example,   creates two new fields, Semits Recip. (explained , second within-expression also refer Semits variable created previous expression.)","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html"],"id":"with","dir":"Reference","previous_headings":"","what":"With","title":"with(in)Humdrum — withinHumdrum","text":"calls .humdrumR, result simply returned . want want get humdrumR object drop back \"normal\" R, often last stages analysis. .humdrumR drop argument, defaults TRUE. drop = FALSE, result returned data.table(). column names results table generated described previous section: .e., defaulting ResultX allowing explicit naming one explicit assignments within-expressions. addition, subset groupby arguments used, columns included indicate value evaluated subset/groupby factor row.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html"],"id":"partitioning-data","dir":"Reference","previous_headings":"","what":"Partitioning data","title":"with(in)Humdrum — withinHumdrum","text":"groupby (e.g., ) subset expression control arguments evaluate within-expressions within specific subsets data. subset argument can used evaluate within-expression within subset data. groupby argument breaks data groups, evaluating within-expression(s) separately within group. results grouped evaluations returned list () recombined original data within---form \"split-apply-combine\" routine key R data analysis. subset groupby arguments arbitrary expressions evaluated within [humdrum table][humTable], can (usually ) refer fields table. /within.humdrumR call can include zero, one, subset /groupby arguments, including combinations . one subset/groupy argument included, evaluated order (left right), recursively: one evaluated within partition(s) established previous expression. normal within expression(s) , evaluated within partition(s) established last  subset/groupby argument. \"Advanced\" partitioning section explores detail.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html"],"id":"apply-in-subset-","dir":"Reference","previous_headings":"","what":"Apply in subset:","title":"with(in)Humdrum — withinHumdrum","text":"subset argument arbitrary expression identifies subset humdrum data. subset expressions must evaluate single logical vector, subset result, short, automatically recycled full length [humdrum table][humTable]. within expression(s) evaluated subset argument(s) return TRUE. call , result evaluated subset == TRUE returned. However, call within, must decide rest data: complement subset. default, within pads returned values null data ever subset == FALSE (complement). , example, run command within(humData, kern(Token), subset = Spine == 1) new field created within filled kern data Spine == 1, remaining spines () null. want explicitly control put complement part new field, can specifying alternate within-expression(s) evaluate subset == FALSE. must named complement, aliases rest otherwise ([partially matched][partialMatching]). complement expression can specified combination subset argument, must addition normal within-expression. idea evaluate \"normal\" within-expression subset == TRUE, else specify evaluate complement expression. results Complement expressions always recycled fill whole complement (see \"recycle\") common use case complement expression use within expression change data one spine return data unchanged spines. example, specify within(humData, kern(Token), subset = Spine == 1, complement = Token). Spine 1 () kern applied . However, instead return new field null values spine(s), call return original (unaltered) values Token field spines.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html"],"id":"group-by-","dir":"Reference","previous_headings":"","what":"Group by:","title":"with(in)Humdrum — withinHumdrum","text":"groupby expression (use short) partitions data exhaustively (possibly non-contiguous) groups, evaluates within-expression(s) separately within group. works similarly argument [data.table][data.table]s, INDEX argument [base][tapply], INDICES argument [base][]. groupby expression must evaluate, within humdrumR data object, vector (list vectors equal length) group data . unique combination values across vectors becomes one group. commonly, groupby expression(s) simply field(s) data: instance,   apply function [base][table] Token field separately piece humdrumR data. However, can also use complex expressions like   evaluate expression two groups, one either spine number three less record number even, another group opposite true. groupby expression evaluates list grouping vectors, within expressions evaluated across every combination categories across vectors. Thus,   apply table Token across spine piece.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html"],"id":"advanced-partitioning-","dir":"Reference","previous_headings":"","what":"Advanced partitioning:","title":"with(in)Humdrum — withinHumdrum","text":"multiple groupby subset expressions, combinations two, specified, evaluated recursively, order left right. subset specified groupby, subset expression evaluated within groupby group groupby specified subset, grouping expression evaluated subset == TRUE. Thus, specify","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html"],"id":"windowing-data","dir":"Reference","previous_headings":"","what":"Windowing data","title":"with(in)Humdrum — withinHumdrum","text":"/within.humdrumR can work tandem context() function evaluate expressions within arbitrary contextual windows. , simply place call context() unnamed argument /within.humdrumR(); must provide open close arguments. overlap, depth, rightward, duplicate_indices, min_length, max_length arguments can used , just separate call context() --- see context() man page. give context() command inside /within.humdrumR call x reference argument: active field used reference vector context() --- e.g., open close character string, matched regular expressions active field. list(Piece, Spine, Path) also automatically passed groupby argument context(). using context() inside /within.humdrumR, alignToOpen argument effect. want output align right side window, use alignLeft = FALSE argument /within, argument context(). inPlace, collapse, sep, stripRegex arguments effect context() used syntactic sugar /within.humdrumR call. subset expression, can provide complement expression go along context(). (Note complement argument context() ignored.) complement expression evaluated data points captured within contextual windows. subset expressions placed context() expression evaluated first, order left right. means can first run subset groupby, calculate context within subset/partition. However, subset groupby expressions passed argument context() ignored.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html"],"id":"plotting-parameters","dir":"Reference","previous_headings":"","what":"Plotting parameters","title":"with(in)Humdrum — withinHumdrum","text":"mentioned , plots within-expressions (often) called using sidefx argument name. plotting, /within.humdrumR also allows specify plotting options inline, without make separate call par(). par() argument can specified providing named list graphics keyword. example, can set plot margins mar argument:   best part /within.humdrumR reset par previous state done. can also use syntactic sugar, graphics(parargs = ...):","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html"],"id":"splatting","dir":"Reference","previous_headings":"","what":"Splatting","title":"with(in)Humdrum — withinHumdrum","text":"(\"Splatting\" refers feeding function list/vector arguments.) Sometimes want divide data pieces (l\\'partition option), rather applying expression piece, want feed separate pieces separate arguments function. /within.humdrumR can use syntactic sugar just . can index field call splat argument, must Field %% x. example,   call, Token field divided two groups, one Spine == 1 Spine == 2; first group (Spine == 1) used first argument list, second group (Spine == 2) second argument. Thus, within translates previous expression :","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html"],"id":"advanced-scripting","dir":"Reference","previous_headings":"","what":"Advanced scripting","title":"with(in)Humdrum — withinHumdrum","text":".humdrumR within.humdrumR use non-standard evaluation expressions. useful command line script running one command time. However, want advanced scripting non-standard evaluation can problem. example, loop list within-expressions reuse common combination coor arguments many times. Fortunately, R formula, way capturing (\"quoting\") expressions concrete object can manipulate. Better yet, /within.humdrumR interpret formulae passed arguments. Basically, right-hand side formula interpreted expression evaluate. formula passed unnamed argument /within, left-hand side formula () treated argument name. name formula argument left-hand side, left-hand side ignored.   approach allows us , ~table(Token) ~ Spine variables, allowing us things like:   can even make lists loop :","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/withinHumdrum.html"],"id":"variables","dir":"Reference","previous_headings":"","what":"Variables","title":"with(in)Humdrum — withinHumdrum","text":"Another useful scripting option include free variables within-expressions, can fed using variables argument. variables must named list. Variables within-expression match name variables list value interpolated. allows us, example, run commands like:   time called, N .^N replaced current value n.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/wort.html"],"dir":"Reference","previous_headings":"","what":"Extract words from syllables — wort","title":"Extract words from syllables — wort","text":"Transform humdrumR's syllabic form lyrics complete words, row contain either one word null data token.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/wort.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract words from syllables — wort","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/wort.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract words from syllables — wort","text":"nullTokens Whether null tokens replace empty spaces syllables moved combine others make word. Defaults TRUE. Must singleton logical value: /switch. keepSilbe Whether user wants save silbe format output case needed back translation later uses. Defaults FALSE. Must singleton logical value: /switch. indices Whether linguistics version word printed. Defaults FALSE. Must singleton logical value: /switch. data data transformed. Must character.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/wort.html"],"id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract words from syllables — wort","text":"transformed data","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/writeHumdrum.html"],"dir":"Reference","previous_headings":"","what":"Write humdrumR data to humdrum files — writeHumdrum","title":"Write humdrumR data to humdrum files — writeHumdrum","text":"writeHumdrum writes humdrumR data humdrum-syntax text files. current active expression evaluated generate humdrum output data. written output match printout printing data R terminal.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/writeHumdrum.html"],"id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write humdrumR data to humdrum files — writeHumdrum","text":"","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/writeHumdrum.html"],"id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write humdrumR data to humdrum files — writeHumdrum","text":"humdrumR HumdrumR data write. Must humdrumR data object. prefix prefix add output filenames. Defaults \"humdrumR_\". Must single character string. renamer function modify output filenames. Defaults force (keep original filenames). Must function accepts character vector returns new charater vector length. affix affix add output filenames. Defaults \"\". Must single character string. Affix appended end filename, extension. extension extension use new files. Defaults NULL, means file extension original files used. Must NULL, single, non-empty character string. directory directory write files . Defaults NULL. Must single character string. NULL, files written directory (directories) read . overwrite Whether overite existing files. Defaults FALSE. Must singleton logical value: /switch. FALSE, writeHumdrum refuse overwrite files. TRUE, writeHumdrum overwrite files, additional prompt user. verbose Whether show file names writing. Defaults FALSE. Must singleton logical value: /switch. TRUE, new output file name printed console writing happens. EMD string write new !!!EMD: record file. Defaults \"Editing humdrumR, version X.X.X.XXX, current data/time.\" Must single character string. NULL, appended.","code":""},{"path":["https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/writeHumdrum.html"],"id":"file-names","dir":"Reference","previous_headings":"","what":"File names","title":"Write humdrumR data to humdrum files — writeHumdrum","text":"main option control writeHumdrum files write . writeHumdrum uses original names files, read readHumdrum, basis new file names. default, writeHumdrum refuse overwrite original files---overwriting allowed specify overwrite == TRUE respond \"y\" prompt. writeHumdrum generates new file names modifying original read file names. renamer argument must function takes original names input character vector (excluding directory path file extension) returns new character vector length (default R's identity function force). running renamer, character-string affix prefix arguments appended/prepended renamed names. (affix affixed extension.) Finally, extension argument can used specify different file extension. files data set contain multiple pieces, can either write pieces files (seperateFiles = FALSE), originally, write piece new file (separateFiles = TRUE); writing pieces separate files, piece's file name appended _pieceN, N number piece within file. directory argument indicates file path write files. directory exist, created. directory NULL, files written original input directory (directories). EMD argument specifies character string put new !!!EMD reference record end file. EMD records keep track modifications humdrum data. default behavior print string indicating humdrumR version number date. EMD set NULL, appended files.","code":""}]
