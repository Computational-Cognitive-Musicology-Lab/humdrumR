<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="description" content="Apply arbitrary expressions to fields within [S4class][humdrumRclass] data."><title>with(in)Humdrum — withinHumdrum • humdrumR</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.1.0/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.1.0/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- bootstrap-toc --><script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="with(in)Humdrum — withinHumdrum"><meta property="og:description" content="Apply arbitrary expressions to fields within [S4class][humdrumRclass] data."><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-dark navbar-expand-lg bg-primary"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">humdrumR</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.3.0.9000</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <a class="dropdown-item" href="../articles/GettingStarted.html">Getting started with humdrumR</a>
    <a class="dropdown-item" href="../articles/HumdrumSyntax.html">The Humdrum Syntax</a>
    <a class="dropdown-item" href="../articles/Intervals.html">Rhythm and Pitch Intervals</a>
    <a class="dropdown-item" href="../articles/IntroForCoders.html">HumdrumR for Coders</a>
    <a class="dropdown-item" href="../articles/KeysAndChord.html">Diatonic and Tertian Sets in humdrumR</a>
    <a class="dropdown-item" href="../articles/Overview.html">Overview of humdrumR</a>
    <a class="dropdown-item" href="../articles/PitchAndTonality.html">Pitch and Tonality in humdrumR</a>
    <a class="dropdown-item" href="../articles/ReadWrite.html">Reading and writing data with humdrumR</a>
    <a class="dropdown-item" href="../articles/RhythmAndMeter.html">Rhythm and Meter in humdrumR</a>
    <a class="dropdown-item" href="../articles/Validation.html">Validating Humdrum Data</a>
  </div>
</li>
      </ul><form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off"></form>

      <ul class="navbar-nav"><li class="nav-item">
  <a class="nav-link" href="https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul></div>

    
  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="" class="logo" alt=""><h1>with(in)Humdrum</h1>
      <small class="dont-index">Source: <a href="https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/blob/HEAD/R/Apply.R"><code>R/Apply.R</code></a></small>
      <div class="d-none name"><code>withinHumdrum.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>Apply arbitrary expressions to fields within <code>[S4class][humdrumRclass]</code> data.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="fu">withinHumdrum</span><span class="op">(</span><span class="va">humdrumR</span>, <span class="va">...</span><span class="op">)</span>

<span class="fu">withHumdrum</span><span class="op">(</span><span class="va">humdrumR</span>, <span class="va">...</span>, drop <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>

<span class="fu">inHumdrum</span><span class="op">(</span><span class="va">humdrumR</span>, <span class="va">...</span><span class="op">)</span>

<span class="fu">humApply</span><span class="op">(</span><span class="va">humdrumR</span>, <span class="va">FUN</span>, <span class="va">...</span>, within <span class="op">=</span> <span class="cn">TRUE</span>, doplot <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>
    <dl><dt>humdrumR</dt>
<dd><p>A <a href="humdrumRclass.html">humdrumRclass</a> data object.</p></dd>
<dt>...</dt>
<dd><p>Any arguments which can be fed to
<code>[humdrumR:with-in-Humdrum][with(in)Humdrum]</code> as formulae (except for
<code>do</code> expressions, which are replaced by the <code>FUN</code> argument!).
However, rather that writinging formula in the format <code>Keyword ~ Expression</code>,
<code>humApply</code> arguments should be written as normal <code>R</code> arguments:
<code>Keyword = Expression</code>.
Unnamed arguments are ignored.
#' @param within A logical. If <code>TRUE</code> (the default),
<code>[humdrumR:with-in-Humdrum][withinHumdrum]</code> is used to apply the
function---meaning that the output is reconstituted into a new field in the
<code>humdrumR</code> object. If <code>within == FALSE</code>,
<code>[humdrumR:with-in-Humdrum][withHumdrum]</code> is used instead,
which results in the function's output being returned inprocessed.</p></dd>
<dt>drop</dt>
<dd><p>This argument is concetually similar to the <code>drop</code> argument in R matrices and data.frames.
If <code>drop = TRUE</code>, the output of <code>withHumdrum</code> is simplified as much as possible (trying to return
the "raw" vector, list, table, etc. within it). If <code>drop = FALSE</code>, the result is <em>always</em>
a <code>data.table</code>. The default value (<code>drop = TRUE</code>) is usually what we want because it is more
intuitive, but in more complex code, it can be helpful to set <code>drop = FALSE</code> so that
the output is consistent.</p></dd>
<dt>FUN</dt>
<dd><p>A function to apply to the humdrumR:humdrumR<code>field(s) in the</code>humdrumR` object.</p></dd>
<dt>doplot</dt>
<dd><p>Boolean. If <code>TRUE</code> the <code>FUN</code> argument is treated
as a <code>doplot</code> expression by <code>[humdrumR:with-in-Humdrum][with(in)Humdrum]</code>,
so the result is ignored (for plotting or side-effects purposes).</p></dd>
</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    <p>From <code>withinHumdrum</code> and <code>inHumdrum</code>, a new humdrumR data object.
From <code>withHumdrum</code>, whatever value is returned by expression.</p>
    </div>
    <div class="section level2">
    <h2 id="overview">Overview<a class="anchor" aria-label="anchor" href="#overview"></a></h2>
    

<p>These functions are the primary means of working with
humdrumR data. (They are analogous to the base functions
<code>[base][with]</code> and <code>[base][within]</code>
as applied to <code>[base:data.frame][data.frames]</code>.)
Specifically they allow you to evaluate arbitrary
expressions involving fields in a humdrumR data object.
They also includes a number of special evaluation options:</p><ul><li><p>Evaluate an expression in only matching parts of the data.</p></li>
<li><p>Evaluate an expression separately in subsets of the data.</p></li>
<li><p>Evaluate an expression across windows in the data (e.g., ngrams, rolling windows).</p></li>
<li><p>Evaluate an expression which produces a plot, with particular plotting parameters set using <code>[graphics][par]</code>.</p></li>
</ul><p>The difference between <code>withHumdrum</code> and <code>withinHumdrum</code> is
analogous to the difference between <code>[base][with]</code> and <code>[base][within]</code>.
<code>withHumdrum</code> evaluates your expression(s) and then simply returns the result of
the evaluation. <code>withinHumdrum</code> evaluates your expression(s) and then
(attempts) to insert the results back into the humdrumR object, generating new
fields called <code>PipeX</code> (see details).</p>
<p><code>inHumdrum</code> is simply a short hand for <code>withinHumdrum</code>.</p>
    </div>
    <div class="section level2">
    <h2 id="formulae"><code>Formulae</code><a class="anchor" aria-label="anchor" href="#formulae"></a></h2>
    

<p>Every formula in the <code>formulae</code> argument
is treated as a <code>Keyword ~ Expression(s)</code>
pairing. Multiple expressions can be input using multiple <code>~</code> operators:
<code>Keyword ~ Expression1 [~ Expression2 ~ ... ~ ExpressionN]</code>
(the leftmost expression is treated as the keyword.)
If there is no leftmost expression (i.e., <code>~ Expression</code>), the Keyword
defaults to "<code>do</code>." The keyword expression must be a single, simple name/symbol, following
standard R rules (i.e., "<code>.foobar</code>" is acceptable but "<code>3 + foobar</code>" is not).</p>
<p>Legal keywords, and their meanings are:</p><ol><li><p><code>do</code> An expression to be evaluated within the <code>humdrumR</code> data object (see "Expression evaluation").</p></li>
<li><p><code>doplot</code> An expression to be evaluated within the <code>humdrumR</code> data object while ignoring the result of the expression (see "Expression evaluation" and "Plotting".</p></li>
<li><p><code>by</code> An expression used to break the data into groups, with the <code>do</code> expression(s) evaluated
separately in each group (see "Partitioning").</p></li>
<li><p><code>where</code> An expression indicating a subset of the data in which to evaluate the <code>do</code> expression (see "Partitioning").</p></li>
<li><p><code>ngrams</code> A positive number <em>n</em>. The expression is evaluated across overlapping length-<em>n</em> windows.</p></li>
<li><p><code>recordtypes</code> A string or vector of characters drawn from <code>c("D", "d", "I", "L", "M","G")</code>. These characters
correspond to types of humdrum records: <strong>D</strong>ata, null <strong>d</strong>ata, <strong>I</strong>nterpretations,
<strong>M</strong>easures, <strong>L</strong>ocal comments, and <strong>G</strong>lobal comments respectively. The expression
is only evaluated on data drawn from the specified record types (defaults to <code>"D"</code>).</p></li>
<li><p><code>pre</code> An expression to evaluate once before evaluating the do expression(s). Useful, for instance, for taking logs
or opening a graphing window. The <code>pre</code> expression is evaluated in the global environment.</p></li>
<li><p><code>post</code> An expression evaluate once after evaluating the do expression(s). Always evaluated in the global environment.</p></li>
</ol></div>
    <div class="section level2">
    <h2 id="expression-evaluation">Expression evaluation<a class="anchor" aria-label="anchor" href="#expression-evaluation"></a></h2>
    


<p>The right-hand side of any formula in the <code>formulae</code> argument with the keyword <code>do</code> or <code>doplot</code>
(or with no keyword specified) is evaluated within the <code>humdrumR</code> data object.
The expression can, thus, refer to any field in the humdrumR object (Record, Token, File, etc.).
You can also include a <code>.</code> anywhere in the expression, which will be
interpreted as the humdrumR object's current <code>[dest=humdrumR][Active]</code>
expression.</p><div class="sourceCode"><pre><code><span class="va">humdata</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/readHumdrum.html">readHumdrum</a></span><span class="op">(</span><span class="st">'directorywithdata/*.krn'</span><span class="op">)</span> <span class="co"># read some data</span>

<span class="fu"><a href="../reference/withinHumdrum.html">withinHumdrum</a></span><span class="op">(</span><span class="va">humdata</span>, <span class="op">~</span><span class="fu">getPitch</span><span class="op">(</span><span class="va">Token</span><span class="op">)</span><span class="op">)</span> <span class="co"># The most basic pattern</span>
<span class="fu"><a href="../reference/withinHumdrum.html">withinHumdrum</a></span><span class="op">(</span><span class="va">humdata</span>, <span class="op">~</span><span class="fu">getPitch</span><span class="op">(</span><span class="va">.</span><span class="op">)</span><span class="op">)</span> <span class="co"># Same as previous (unless `Active` field has been changed))</span>

<span class="fu"><a href="../reference/withinHumdrum.html">withinHumdrum</a></span><span class="op">(</span><span class="va">humdata</span>, <span class="op">~</span><span class="fu"><a href="../reference/pitchFunctions.html">solfa</a></span><span class="op">(</span><span class="fu">getPitch</span><span class="op">(</span><span class="va">Token</span><span class="op">)</span>, key <span class="op">=</span> <span class="va">Key</span><span class="op">)</span><span class="op">)</span> 
<span class="co"># Assumes that the Key field was parsed during the call to `[readHumdrum][readHumdrum]`</span>

<span class="fu"><a href="../reference/withinHumdrum.html">withinHumdrum</a></span><span class="op">(</span><span class="va">humdata</span>, <span class="op">~</span><span class="fu">getSemits</span><span class="op">(</span><span class="va">Token</span><span class="op">)</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="fu">getSemits</span><span class="op">(</span><span class="va">Token</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></code></pre></div>

<p>If multiple <code>do</code> expressions are provided, they are each evaluated one at a time,
with the result of each piped into the next. Other, non-<code>do</code>, formulae (like <code>by~</code> or
<code>ngrams~</code>) are reused for each expression evaluated.</p>
    </div>
    <div class="section level2">
    <h2 id="partitioning">Partitioning<a class="anchor" aria-label="anchor" href="#partitioning"></a></h2>
    


<p>A <code>by</code> expression is used to break the data into subsets, with the <code>do</code> expression(s) evaluated
separately within each subset. This works the similarly to the <code>by</code> argument in
<code>[data.table][data.table]</code>s, the <code>INDEX</code>
argument of <code>[base][tapply]</code>, or the <code>INDICES</code> argument of <code>[base][by]</code>.
Each <code>by</code> expression must evaluate, within the <code>humdrumR</code> data object, to a vector (or a list of vectors
of equal length) of categories to group the data by.
Most commonly, the <code>by</code> expression(s) are simply field(s) in the data:
for instance,</p><div class="sourceCode"><pre><code><span class="fu"><a href="../reference/withinHumdrum.html">withinHumdrum</a></span><span class="op">(</span><span class="va">humdata</span>,
         <span class="va">do</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">Token</span><span class="op">)</span>,
         <span class="va">by</span> <span class="op">~</span> <span class="va">File</span><span class="op">)</span></code></pre></div>

<p>will apply the function <code>[base][table]</code> to the <code>Token</code> field
<em>separately</em> for each file in the <code>humdrumR</code> data.
However, we can also use more complex expressions like</p><div class="sourceCode"><pre><code>withinHumdrum(humdata,
         do ~ table(Token), 
         by ~ Spine &gt; 3 | Record \%\% 2 == 0)
</code></pre></div>

<p>which will evaluate the do expression in two groups, one where either the spine number is
three or less <em>or</em> the record number is even, and another group where the opposite is true.</p>
<p>If the <code>by</code> expression evaluates to a list of grouping vectors,
the <code>do</code> expressions are evaulated across every combination of categories in all the vectors.
Thus,
withinHumdrum(humdata,
do ~ table(Token),
by ~ list(File, Spine))
will apply <code>table</code> to <code>Token</code> across each spine <em>in</em> each file.
As some <a href="https://en.wikipedia.org/wiki/Syntactic_sugarsyntactic" class="external-link">syntactic sugar</a>, if the
<code>by</code> expression has more than two parts, all parts except
the (leftmost) keyword part are combined in a list (i.e., <code>by ~ File ~ Spine</code>
becomes <code>by ~ list(File, Spine)}</code>.
Thus the previous example can also be written:
withinHumdrum(humdata,
do ~ table(Token),
by ~ File ~ Spine)</p>
<p>A <code>where</code> expression is used to identify a subset of the data and evaluate
the <code>do</code> expression(s) <em>only</em> in that subset.
<code>where</code> expressions must evaluated, within the <code>humdrumR</code> data object, to
a single logical vector. The <code>do</code> expression(s) are only evaluated where this logical
vector is <code>TRUE</code>.
Wherever the <code>where</code> expression evaluates to <code>FALSE</code>, the original <code>humdrumR</code> data is
kept unchanged.</p>
<p>If multiple partitioning formulae (i.e, <code>by</code> and <code>where</code>) expressions
are evaluated recursively, in order from left to right. Thus if you specify
withinHumdrum(humdata,
do ~ sd(semits),
by ~ File,
where ~ semits &gt; mean(semits))
a the standard deviation of the <code>semits</code> field will be calculated only in each file,
but only where the <code>semits</code> field is greater than the mean <code>semits</code> value
<em>within that file</em>. Contrast this with this call:
withinHumdrum(humdata,
do ~ sd(semits)
where ~ semits &gt; mean(semits),
by ~ File)
wherein the standard deviation of <code>semits</code> is, again, calculated for each file,
but this time wherever the <code>semits</code> field is greater than the mean value <em>across all the data</em>.</p>
    </div>
    <div class="section level2">
    <h2 id="plotting">Plotting<a class="anchor" aria-label="anchor" href="#plotting"></a></h2>
    

<p>The <code>doplot</code> keyword behaves exactly like the <code>do</code> keyword, except that the result of the
evaluation is ignored. This is useful for plotting <em>as well as</em> other side-effects (like writing to a file).
If <code>doplot</code> is used with <code>withHumdrum</code>, the function simply returns <code>NULL</code> (after executing the <code>doplot</code>
expression
If <code>doplot</code> is used with <code>withinHumdrum</code> (or <code>inHumdrum</code>), the function simply returns the unaltered
<code>humdrumR</code> argument.</p>
<p><code>withinHumdrum</code> also allows you to specify plotting options in line, without having to make a separate call
to <code>[graphics][par]</code>. Any <code>[graphics][par]</code> argument can be specified as a <code>Keyword ~ Expression</code> pair
in the <code>formulae</code> argument. For instance, if you call a <code>doplot</code> expression with a <code>by</code> expression
that creates four groups, R will create four plots---but you will only see the last one! Normally, you would need to
call <code>par(mfcol = c(2,2))</code> <em>before</em> calling your plotting function. However, with <code>withinHumdrum</code> you can
soecific <code>mfcol = c(2,2)</code> right in a <code>formulae</code> formula:
withinHumdrum(humdata,
doplot ~ fooplot(.),
by ~ list(Two, byTwo),
mfcol ~ c(2, 2))
The best part is <code>withinHumdrum</code> will reset <code>par</code> to it's previous state after <code>withinHumdrum</code> is done.</p>
    </div>
    <div class="section level2">
    <h2 id="tandem-interpretations">Tandem interpretations<a class="anchor" aria-label="anchor" href="#tandem-interpretations"></a></h2>
    


<p>The function <code>[readHumdrum][readHumdrum]</code> automatically parses
tandem interpretations (that it recognizes) into
their own fields in the resulting <code>[humdrumR][humdrumRclass]</code> data.
For instance, data with a <code>'*clefF4'</code> will show
up as a <code>Clef</code> field. However, users might read humdrum data with their
own custom tandem interpretations that are not built into <code>humdrumR</code>.
<code>humdrumR</code> includes the function <code>[getTandem][getTandem]</code> to help us
extract arbitrary tandem intrpretation data.
Luckily, <code>withinHumdrum</code> knows some
<a href="https://en.wikipedia.org/wiki/Syntactic_sugarsyntactic" class="external-link">syntactic sugar</a>
which makes it easy to do this anywhere in our expressions, simply by putting a
named object beginning with the symbol <code>*</code>. Of course, R doesn't normally
allow names to begin with symbols like <code>*</code>, but you can force it by
placing grave symbols around the name <code>*name</code>. If you do this in a <code>withinHumdrum</code>
expression, <code>withinHumdrum</code> will treat this name as a
regular expression and substitute a call <code>getTandem(Tandem, 'regular expression')</code> in the expression.
This means you can could do something like
withinHumdrum(humdata,
do ~ myFunction(Token, <code>*mytandempattern</code>))
and <code>myFunction</code> will be called with the first argument being the
<code>Token</code> field, and the second argument being tandem interpretations
which match <code>'mytandempattern'</code> (extracted from the <code>Tandem</code> field).</p>
    </div>
    <div class="section level2">
    <h2 id="splatting">Splatting<a class="anchor" aria-label="anchor" href="#splatting"></a></h2>
    


<p>("Splatting" refers to feeding a function a list/vector of arguments.)
Sometimes we want to divide our data into pieces (a l\'a <code>partition</code> option), but
rather than applying the same expression to each piece, we want to feed
the separate pieces as separate arguments to the same function.
In <code>withinHumdrum</code> you can use some
<a href="https://en.wikipedia.org/wiki/Syntactic_sugarsyntactic" class="external-link">syntactic sugar</a>
to do just this, using the <code>@</code> symbol in the format <code>myFunction(TargetExpr@GroupingExpr)</code>.
If we make this call</p>
<p>withinHumdrum(humdata,
do ~ myFunction(Token@Spine))</p>
<p>and there are four spines
this is how <code>withinHumdrum</code> will intepret the expression:</p>
<p>withinHumdrum(humData,
do ~ myFunction(TokenSpine == 1, # first argument when Spine == 1
TokenSpine == 2, # second argument when Spine == 2
TokenSpine == 3, # etc.
TokenSpine == 4))</p>
    </div>
    <div class="section level2">
    <h2 id="argument-interpolation">Argument interpolation<a class="anchor" aria-label="anchor" href="#argument-interpolation"></a></h2>
    


<p>Any named arguments to <code>withinHumdrum</code> are <code>[humdrumR:interpolateArguments][interpolated]</code> into the
<code>do</code> expressions. This is useful if you've already created a list of formulas that you like, but would like
to make small changes to a function call within the <code>do</code> expressions, without starting from scratch.
Examples:</p><div class="sourceCode"><pre><code><span class="va">mycommand</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">do</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">.</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>, <span class="va">by</span> <span class="op">~</span> <span class="va">Spine</span> <span class="op">~</span> <span class="va">File</span><span class="op">)</span>
<span class="fu"><a href="../reference/withinHumdrum.html">withinHumdrum</a></span><span class="op">(</span><span class="va">humdata</span>,
              <span class="va">mycommand</span>,
              na.rm <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span>
<span class="co"># mycommand is executed with na.rm changed to FALSE              </span></code></pre></div>

    </div>
    <div class="section level2">
    <h2 id="piping">Piping<a class="anchor" aria-label="anchor" href="#piping"></a></h2>
    


<p>For calls to <code>withinHumdrum</code>, the result of each <code>do</code> expression
is insterted back into the <code>[humtable][humdrum table]</code>. The results
are put into new field(s) labeled Pipe1, PipeX, ..., PipeN. If the results
of the expression are shorter than the rows in the humtable,
or an <code>object</code>, the humdrum table is shrunk to fit them.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span class="va">humdata</span> <span class="op">&lt;-</span> <span class="fu"><a href="readHumdrum.html">readHumdrum</a></span><span class="op">(</span><span class="st">'directorywithdata/*.krn'</span><span class="op">)</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Finding and reading files...</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	REpath-pattern 'directorywithdata/*.krn' matches 0 text files in 0 directories.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> Zero files read from disk. </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> No files to validate.</span>
<span class="r-in"></span>
<span class="r-in"><span class="fu">withinHumdrum</span><span class="op">(</span><span class="va">humdata</span>, <span class="op">~</span><span class="fu"><a href="https://rdrr.io/r/base/nchar.html" class="external-link">nchar</a></span><span class="op">(</span><span class="va">.</span><span class="op">)</span><span class="op">)</span> <span class="co"># counts characters in each data token.</span></span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>`call_stack()` is deprecated as of rlang 0.3.0.</span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span style="color: #555555;">This warning is displayed once per session.</span></span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span class="warning">Warning: </span>`global_frame()` is deprecated as of rlang 0.3.0.</span>
<span class="r-wrn co"><span class="r-pr">#&gt;</span> <span style="color: #555555;">This warning is displayed once per session.</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> HumdrumR error in call stack:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	  NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	    (function (..., crayon_enabled, crayon_colors, pkgdown_internet) { options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, pkgdown.internet = pkgdown_internet) pkgdown::build_site(...) })(pkg = base::quote(structure(list(package = "humdrumR", version = "0.3.0.9000", lang = "en", src_path = structure("/home/nat/Bridge/Coding/R/Packages/humdrumR", class = c("fs_path", "character")), dst_path = structure("/home/nat/Bridge/Coding/R/Packages/humdrumR/docs", class = c("fs_path", "character")), install_metadata = FALSE, desc = &lt;environment&gt;, meta = list(authors = list(`Nathaniel Condit-Schultz` = list( href = "http://fathermckenzie.net/"), `Claire Arthur` = list( href = "https://clairearthur.com/")), url = "https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR", home = list(sidebar = list(structure = c("links", "license", "community", "citation", "authors", "dev", "toc"))), template = list(bootstrap = 5L, bootswatch = "flatly"), reference = list(list(title = "Musical Tools", desc = "These pages describe the classes and functions that directly represent or engage musical/music-theoretic concepts.\n", contents = "intervalCalculus"), list(subtitle = "Pitch", desc = "Pitch and tonality classes and functions.", contents = c("humdrumPitch", "pitch", "tonalInterval", "tonalTransformations", "LO5th", "diatonicSet", "tertianSet", "romanNumerals", "transpose", "chordTransformer", "keyTransformer", "pitchFunctions")), list(subtitle = "Rhythm", desc = "Rhythm and meter classes and functions.", contents = c("humMeter", "rhythmInterval", "time", "metricPosition", "rhythmDecompose", "rhythmFunctions", "rhythmOffset", "plotRhythm")), list(title = "Reading and Summarizing Data", desc = "These tools allow you to import, validate, and abstractly summarize the content of humdrum data."), list(subtitle = "Reading and Writing", contents = c("humValidation", "readHumdrum", "writeHumdrum")), list(subtite = "Summarizing", contents = c("humSummary", "humCensus", "humReference", "humSpines")), list(title = "Working with Data", desc = "These pages describe tools used to manipulate the musical data ensconced within humdrumR data structures.\n"), list(subtitle = "Manipulating Humdrum Data", contents = c("withinHumdrum", "humPipe", "filterHumdrum", "humWindows", "interpolateArguments", "humFormulae")), list(subtitle = "Manipulating Vectors", contents = c("fillThru", "lag")), list(subtitle = "Regular Expressions", desc = "[Regular Expressions](https://en.wikipedia.org/wiki/Regular_expression) are essential tools for working with humdrum data. These functions provide functionality for working with regular expressions.\n", contents = c("RegexFind", "humdrumDispatch", "regexConstruction", "REparser")), list(title = "Data Structures", desc = "These are pages describe the data structures of humdrumR---which contain the musical data.\n", contents = c("humdrumRclass", "getFields", "getTandem", "humActive", "humAssignment", "humCoercion", "humColumns", "humMerge", "humInterpretations", "humPrint", "humShape", "humSize", "humTable", "struct")), list(title = "Other Functions", desc = "Other useful tools"), list(subtitle = "Numeric values", contents = c("rational", "decimal", "humdrumRroot")))), figures = structure(list( dev = "ragg::agg_png", dpi = 96L, dev.args = list(), fig.ext = "png", fig.width = 7.29166666666667, fig.height = NULL, fig.retina = 2L, fig.asp = 0.618046971569839, bg = NULL, other.parameters = list()), class = "print_yaml"), repo = list( url = list(home = "https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/", source = "https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/blob/HEAD/", issue = "https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/issues/", user = "https://github.com/")), development = list( destination = "dev", mode = "default", version_label = "muted", in_dev = FALSE), topics = structure(list(name = c(LO5th.Rd = "LO5th", REparser.Rd = "REparser", RegexFind.Rd = "RegexFind", chordTransformer.Rd = "chordTransformer", decimal.Rd = "decimal", diatonicSet.Rd = "diatonicSet", fillThru.Rd = "fillThru", filterHumdrum.Rd = "filterHumdrum", getFields.Rd = "getFields", getTandem.Rd = "getTandem", humActive.Rd = "humActive", humAssignment.Rd = "humAssignment", humCensus.Rd = "humCensus", humCoercion.Rd = "humCoercion", humColumns.Rd = "humColumns", humFormulae.Rd = "humFormulae", humInterpretations.Rd = "humInterpretations", humMerge.Rd = "humMerge", humMeter.Rd = "humMeter", humPipe.Rd = "humPipe", humPrint.Rd = "humPrint", humReference.Rd = "humReference", humShape.Rd = "humShape", humSize.Rd = "humSize", humSpines.Rd = "humSpines", humSummary.Rd = "humSummary", humTable.Rd = "humTable", humValidation.Rd = "humValidation", humWindows.Rd = "humWindows", humdrumDispatch.Rd = "humdrumDispatch", humdrumPitch.Rd = "humdrumPitch", humdrumR.Rd = "humdrumR", humdrumRclass.Rd = "humdrumRclass", humdrumRroot.Rd = "humdrumRroot", interpolateArguments.Rd = "interpolateArguments", intervalCalculus.Rd = "intervalCalculus", keyTransformer.Rd = "keyTransformer", lag.Rd = "lag", metricPosition.Rd = "metricPosition", pitchFunctions.Rd = "pitchFunctions", plotRhythm.Rd = "plotRhythm", rational.Rd = "rational", readHumdrum.Rd = "readHumdrum", regexConstruction.Rd = "regexConstruction", rhythmDecompose.Rd = "rhythmDecompose", rhythmFunctions.Rd = "rhythmFunctions", rhythmInterval.Rd = "rhythmInterval", rhythmOffset.Rd = "rhythmOffset", romanNumerals.Rd = "romanNumerals", struct.Rd = "struct", tertianSet.Rd = "tertianSet", time.Rd = "time", tonalInterval.Rd = "tonalInterval", tonalTransformations.Rd = "tonalTransformations", transpose.Rd = "transpose", withinHumdrum.Rd = "withinHumdrum", writeHumdrum.Rd = "writeHumdrum"), file_in = c("LO5th.Rd", "REparser.Rd", "RegexFind.Rd", "chordTransformer.Rd", "decimal.Rd", "diatonicSet.Rd", "fillThru.Rd", "filterHumdrum.Rd", "getFields.Rd", "getTandem.Rd", "humActive.Rd", "humAssignment.Rd", "humCensus.Rd", "humCoercion.Rd", "humColumns.Rd", "humFormulae.Rd", "humInterpretations.Rd", "humMerge.Rd", "humMeter.Rd", "humPipe.Rd", "humPrint.Rd", "humReference.Rd", "humShape.Rd", "humSize.Rd", "humSpines.Rd", "humSummary.Rd", "humTable.Rd", "humValidation.Rd", "humWindows.Rd", "humdrumDispatch.Rd", "humdrumPitch.Rd", "humdrumR.Rd", "humdrumRclass.Rd", "humdrumRroot.Rd", "interpolateArguments.Rd", "intervalCalculus.Rd", "keyTransformer.Rd", "lag.Rd", "metricPosition.Rd", "pitchFunctions.Rd", "plotRhythm.Rd", "rational.Rd", "readHumdrum.Rd", "regexConstruction.Rd", "rhythmDecompose.Rd", "rhythmFunctions.Rd", "rhythmInterval.Rd", "rhythmOffset.Rd", "romanNumerals.Rd", "struct.Rd", "tertianSet.Rd", "time.Rd", "tonalInterval.Rd", "tonalTransformations.Rd", "transpose.Rd", "withinHumdrum.Rd", "writeHumdrum.Rd"), file_out = c("LO5th.html", "REparser.html", "RegexFind.html", "chordTransformer.html", "decimal.html", "diatonicSet.html", "fillThru.html", "filterHumdrum.html", "getFields.html", "getTandem.html", "humActive.html", "humAssignment.html", "humCensus.html", "humCoercion.html", "humColumns.html", "humFormulae.html", "humInterpretations.html", "humMerge.html", "humMeter.html", "humPipe.html", "humPrint.html", "humReference.html", "humShape.html", "humSize.html", "humSpines.html", "humSummary.html", "humTable.html", "humValidation.html", "humWindows.html", "humdrumDispatch.html", "humdrumPitch.html", "humdrumR.html", "humdrumRclass.html", "humdrumRroot.html", "interpolateArguments.html", "intervalCalculus.html", "keyTransformer.html", "lag.html", "metricPosition.html", "pitchFunctions.html", "plotRhythm.html", "rational.html", "readHumdrum.html", "regexConstruction.html", "rhythmDecompose.html", "rhythmFunctions.html", "rhythmInterval.html", "rhythmOffset.html", "romanNumerals.html", "struct.html", "tertianSet.html", "time.html", "tonalInterval.html", "tonalTransformations.html", "transpose.html", "withinHumdrum.html", "writeHumdrum.html" ), alias = list(LO5th.Rd = "LO5th", REparser.Rd = c("REparser", "REparse"), RegexFind.Rd = c("RegexFind", "%~l%", "%~i%", "%~n%", "%~m%", "%~%"), chordTransformer.Rd = c("chordTransformer", "figuredBass"), decimal.Rd = c("decimal", "as.decimal"), diatonicSet.Rd = c("diatonicSet", "dset", "as.character,diatonicSet-method", "is.diatonicSet", "order.diatonicSet", "==,diatonicSet,diatonicSet-method", "Compare,diatonicSet,diatonicSet-method", "diatonicSet.diatonicSet", "diatonicSet.logical", "diatonicSet.numeric", "diatonicSet.integer", "diatonicSet.character"), fillThru.Rd = c("fillThru", "fillForward", "fillBackwards"), filterHumdrum.Rd = c("filterHumdrum", "removeEmptyFiles", "removeEmptySpines", "removeEmptyRecords", "[,humdrumR,missing,ANY-method", "[,humdrumR,numeric,ANY-method", "[,humdrumR,character,ANY-method", "[,humdrumR,formula,ANY-method", "[[,humdrumR,numeric,missing-method", "[[,humdrumR,missing,numeric-method", "[[,humdrumR,character,missing-method", "[[,humdrumR,ANY,ANY-method" ), getFields.Rd = "getFields", getTandem.Rd = "getTandem", humActive.Rd = c("humActive", "evalActive", "getActive", "setActive", "setActiveFields"), humAssignment.Rd = "humAssignment", humCensus.Rd = c("humCensus", "census", "[.humCensus", "print.humCensus"), humCoercion.Rd = c("humCoercion", "as.lines", "as.matrix.humdrumR", "as.matrices", "as.data.frames" ), humColumns.Rd = "humColumns", humFormulae.Rd = c("humFormulae", "ditto"), humInterpretations.Rd = c("humInterpretations", "interpretations", "print.humInterpretations"), humMerge.Rd = c("humMerge", "mergeHumdrum"), humMeter.Rd = "humMeter", humPipe.Rd = c("humPipe", "%hum&gt;%", "%hum&lt;%", "%humT%", "%s&gt;%", "%hums&gt;%", "%hums&lt;%", "%humsT%", "%hums[]%"), humPrint.Rd = c("humPrint", "print_humtab" ), humReference.Rd = c("humReference", "reference", "reference.character", "reference.humdrumR", "[.humReference", "print.humReference" ), humShape.Rd = c("humShape", "foldHumdrum", "foldStops", "foldPaths", "foldRecords", "spinePipe"), humSize.Rd = c("humSize", "nrecords", "ntokens", "npieces", "anySubcorpora", "namesSubcorpora", "nfiles", "is.empty", "anyPaths", "anyStops"), humSpines.Rd = c("humSpines", "spines", "[.humSpines", "print.humSpines"), humSummary.Rd = "humSummary", humTable.Rd = c("humTable", "getHumtab"), humValidation.Rd = c("humValidation", "validateHumdrum"), humWindows.Rd = c("humWindows", "windows", "hop", "nest"), humdrumDispatch.Rd = c("humdrumDispatch", "makeDispatchDF", "makeHumdrumDispatcher", "print.humdrumDispatch" ), humdrumPitch.Rd = "humdrumPitch", humdrumR.Rd = "humdrumR", humdrumRclass.Rd = c("humdrumRclass", "makeHumdrumR", "humdrumRS4", "is.humdrumR", "$,humdrumR-method", "fields", "$&lt;-,humdrumR,vector-method", "$&lt;-,humdrumR,humdrumR-method", "[&lt;-,humdrumR,character,ANY,vector-method", "[&lt;-,humdrumR,character,ANY,humdrumR-method", "[[,humdrumR,missing,character-method", "[[,humdrumR,missing,missing-method", "[[,humdrumR,formula,missing-method", "[[,humdrumR,missing,formula-method" ), humdrumRroot.Rd = "humdrumRroot", interpolateArguments.Rd = "interpolateArguments", intervalCalculus.Rd = c("intervalCalculus", "integrate", "sigma", "derive", "delta", "calculus"), keyTransformer.Rd = c("keyTransformer", "key"), lag.Rd = c("lag", "lead"), metricPosition.Rd = "metricPosition", pitchFunctions.Rd = c("pitchFunctions", "semit", "midi", "pitch", "kern", "lilypond", "interval", "degree", "solfa" ), plotRhythm.Rd = c("plotRhythm", "plotRhythm.default", "plotRhythm.rhythmInterval"), rational.Rd = c("rational", "as.rational", "fraction", "as.fraction"), readHumdrum.Rd = c("readHumdrum", "findHumdrum"), regexConstruction.Rd = c("regexConstruction", "captureRE", "captureUniq", "orRE"), rhythmDecompose.Rd = "rhythmDecompose", rhythmFunctions.Rd = c("rhythmFunctions", "recip", "duration" ), rhythmInterval.Rd = c("rhythmInterval", "rint", "as.character,rhythmInterval-method", "as.double.rhythmInterval", "is.rhythmInterval", "is.numeric,rhythmInterval-method", "order.rhythmInterval", "Compare,rhythmInterval,rhythmInterval-method", "Summary,rhythmInterval-method", "rhythmInterval.logical", "rhythmInterval.NULL", "rhythmInterval.numeric", "rhythmInterval.rational", "rhythmInterval.fraction", "rhythmInterval.integer", "rhythmInterval.character"), rhythmOffset.Rd = "rhythmOffset", romanNumerals.Rd = "romanNumerals", struct.Rd = c("struct", "is.struct"), tertianSet.Rd = c("tertianSet", "tset", "is.tertianSet"), time.Rd = c("time", "bpm2ms", "ms2bpm" ), tonalInterval.Rd = c("tonalInterval", "tint", "is.tonalInterval", "tonalInterval.tonalInterval", "tonalInterval.logical", "tonalInterval.NULL", "tonalInterval.numeric", "tonalInterval.rational", "tonalInterval.fraction", "tonalInterval.integer", "tonalInterval.character", "rhythmInterval.rhythmInterval"), tonalTransformations.Rd = c("tonalTransformations", "invert"), transpose.Rd = "transpose", withinHumdrum.Rd = c("withinHumdrum", "withHumdrum", "inHumdrum", "humApply"), writeHumdrum.Rd = "writeHumdrum"), funs = list(LO5th.Rd = "LO5th()", REparser.Rd = c("REparser()", "REparse()"), RegexFind.Rd = c("`%~l%`", "`%~i%`", "`%~n%`", "`%~m%`", "`%~%`"), chordTransformer.Rd = "figuredBass()", decimal.Rd = c("decimal()", "as.decimal()"), diatonicSet.Rd = c("dset()", "as.character(&lt;i&gt;&amp;lt;diatonicSet&amp;gt;&lt;/i&gt;)", "is.diatonicSet()", "order.diatonicSet()", "`==`(&lt;i&gt;&amp;lt;diatonicSet&amp;gt;&lt;/i&gt;,&lt;i&gt;&amp;lt;diatonicSet&amp;gt;&lt;/i&gt;)", "Compare(&lt;i&gt;&amp;lt;diatonicSet&amp;gt;&lt;/i&gt;,&lt;i&gt;&amp;lt;diatonicSet&amp;gt;&lt;/i&gt;)", "diatonicSet(&lt;i&gt;&amp;lt;diatonicSet&amp;gt;&lt;/i&gt;)", "diatonicSet(&lt;i&gt;&amp;lt;logical&amp;gt;&lt;/i&gt;)", "diatonicSet(&lt;i&gt;&amp;lt;numeric&amp;gt;&lt;/i&gt;)", "diatonicSet(&lt;i&gt;&amp;lt;integer&amp;gt;&lt;/i&gt;)", "diatonicSet(&lt;i&gt;&amp;lt;character&amp;gt;&lt;/i&gt;)", "as.character(&lt;i&gt;&amp;lt;tertianSet&amp;gt;&lt;/i&gt;)", "`==`(&lt;i&gt;&amp;lt;tertianSet&amp;gt;&lt;/i&gt;,&lt;i&gt;&amp;lt;tertianSet&amp;gt;&lt;/i&gt;)" ), fillThru.Rd = c("fillThru()", "fillForward()", "fillBackwards()"), filterHumdrum.Rd = c("filterHumdrum()", "removeEmptyFiles()", "removeEmptySpines()", "removeEmptyRecords()", "`[`", "`[`", "`[`", "`[`", "`[[`", "`[[`", "`[[`", "`[[`"), getFields.Rd = "getFields()", getTandem.Rd = "getTandem()", humActive.Rd = c("evalActive()", "getActive()", "setActive()", "setActiveFields()"), humAssignment.Rd = character(0), humCensus.Rd = c("census()", "`[`", "print(&lt;i&gt;&amp;lt;humCensus&amp;gt;&lt;/i&gt;)" ), humCoercion.Rd = c("as.vector(&lt;i&gt;&amp;lt;humdrumR&amp;gt;&lt;/i&gt;)", "as.lines()", "as.matrix(&lt;i&gt;&amp;lt;humdrumR&amp;gt;&lt;/i&gt;)", "as.data.frame(&lt;i&gt;&amp;lt;humdrumR&amp;gt;&lt;/i&gt;)", "as.matrices()", "as.data.frames()"), humColumns.Rd = character(0), humFormulae.Rd = "ditto", humInterpretations.Rd = c("interpretations()", "print(&lt;i&gt;&amp;lt;humInterpretations&amp;gt;&lt;/i&gt;)"), humMerge.Rd = "mergeHumdrum()", humMeter.Rd = character(0), humPipe.Rd = c("`%hum&amp;gt;%`", "`%hum&amp;lt;%`", "`%humT%`", "`%s&amp;gt;%`", "`%hums&amp;gt;%`", "`%hums&amp;lt;%`", "`%humsT%`", "`%hums[]%`"), humPrint.Rd = c("show(&lt;i&gt;&amp;lt;humdrumR&amp;gt;&lt;/i&gt;)", "print_humtab()"), humReference.Rd = c("reference()", "reference()", "reference()", "`[`(&lt;i&gt;&amp;lt;humReference&amp;gt;&lt;/i&gt;)" ), humShape.Rd = c("foldHumdrum()", "foldStops()", "foldPaths()", "foldRecords()", "spinePipe()"), humSize.Rd = c("nrecords()", "ntokens()", "npieces()", "anySubcorpora()", "namesSubcorpora()", "nfiles()", "length(&lt;i&gt;&amp;lt;humdrumR&amp;gt;&lt;/i&gt;)", "nrow(&lt;i&gt;&amp;lt;humdrumR&amp;gt;&lt;/i&gt;)", "is.empty()", "anyPaths()", "anyStops()"), humSpines.Rd = c("spines()", "`[`(&lt;i&gt;&amp;lt;humSpines&amp;gt;&lt;/i&gt;)", "print(&lt;i&gt;&amp;lt;humSpines&amp;gt;&lt;/i&gt;)" ), humSummary.Rd = "summary(&lt;i&gt;&amp;lt;humdrumR&amp;gt;&lt;/i&gt;)", humTable.Rd = "getHumtab()", humValidation.Rd = "validateHumdrum()", humWindows.Rd = c("windows()", "hop()", "nest()"), humdrumDispatch.Rd = c("humdrumDispatch()", "makeDispatchDF()", "makeHumdrumDispatcher()", "print(&lt;i&gt;&amp;lt;humdrumDispatch&amp;gt;&lt;/i&gt;)" ), humdrumPitch.Rd = character(0), humdrumR.Rd = character(0), humdrumRclass.Rd = character(0), humdrumRroot.Rd = "humdrumRroot", interpolateArguments.Rd = "interpolateArguments()", intervalCalculus.Rd = c("integrate()", "sigma()", "derive()", "delta()", "calculus()"), keyTransformer.Rd = "key()", lag.Rd = c("lag()", "lead()"), metricPosition.Rd = "metricPosition()", pitchFunctions.Rd = c("semit()", "midi()", "pitch()", "kern()", "lilypond()", "interval()", "degree()", "solfa()"), plotRhythm.Rd = "plotRhythm()", rational.Rd = c("rational()", "as.rational()", "fraction()", "as.fraction()"), readHumdrum.Rd = c("findHumdrum()", "readHumdrum()" ), regexConstruction.Rd = c("captureRE()", "captureUniq()", "orRE()"), rhythmDecompose.Rd = "rhythmDecompose()", rhythmFunctions.Rd = c("recip()", "duration()"), rhythmInterval.Rd = character(0), rhythmOffset.Rd = "rhythmOffset()", romanNumerals.Rd = character(0), struct.Rd = "is.struct()", tertianSet.Rd = c("tertianSet()", "tset()", "is.tertianSet()" ), time.Rd = c("bpm2ms()", "ms2bpm()"), tonalInterval.Rd = character(0), tonalTransformations.Rd = "invert()", transpose.Rd = "transpose()", withinHumdrum.Rd = c("withinHumdrum()", "withHumdrum()", "inHumdrum()", "humApply()"), writeHumdrum.Rd = "writeHumdrum()"), title = c(LO5th.Rd = "Line of Fifths", REparser.Rd = "Parse String Using Regular expressions", RegexFind.Rd = "Match strings against regular expression", chordTransformer.Rd = "Parsing and deparsing chord information.", decimal.Rd = "Decimal numbers", diatonicSet.Rd = "Tonal (diatonic) sets", fillThru.Rd = "Propogate data points to \"fill\" null data.", filterHumdrum.Rd = "Filter humdrum data", getFields.Rd = "-------------------------------------------&amp;gt; NEEDS DOCUMENTATION &amp;lt;-------------------------------------------\nGet named", getTandem.Rd = "Get tandem interpretation information from humdrum data.", humActive.Rd = "The \"Active expression\" of a humdrumR object.", humAssignment.Rd = "Assigning new fields", humCensus.Rd = "Tabulate records and tokens in a humdrumR corpus", humCoercion.Rd = "humdrumR Coercion.", humColumns.Rd = "Spines vs Paths vs Columns", humFormulae.Rd = "Standard humdrumR formulae.", humInterpretations.Rd = "Summarize humdrum corpus interpretations.", humMerge.Rd = "Merge two (or more) humdrumR datasets", humMeter.Rd = "Tools for analyzing rhythm and meter.", humPipe.Rd = "Piping humdrumR data", humPrint.Rd = "-------------------------------------------&amp;gt; NEEDS DOCUMENTATION &amp;lt;-------------------------------------------", humReference.Rd = "Summarize reference records in a humdrumR corpus", humShape.Rd = "HumdrumR data \"Shape\"", humSize.Rd = "humdrumR size and shape", humSpines.Rd = "Summarize spines in humdrum dataset", humSummary.Rd = "Summarize humdrumR corpora", humTable.Rd = "Humdrum Tables", humValidation.Rd = "Validate humdrum files", humWindows.Rd = "Applying functions across arbitrary windows.\n----------------------------------------------&amp;gt; NEEDS DOCUMENTATION &amp;lt;----------------------------------------------------", humdrumDispatch.Rd = "Regular expression method dispatch and function application", humdrumPitch.Rd = "humdrumR and pitch", humdrumR.Rd = "humdrumR", humdrumRclass.Rd = "HumdrumR class", humdrumRroot.Rd = "&lt;code&gt;humdrumR&lt;/code&gt;'s root directory on your machine.", interpolateArguments.Rd = "Change or insert values in an expression", intervalCalculus.Rd = "Interval \"calculus\"", keyTransformer.Rd = "Parsing and deparsing key information", lag.Rd = "Shift data within a vector/matrix/data.frame", metricPosition.Rd = "Calculate metric positions from duration data.", pitchFunctions.Rd = "Manipulate pitch data", plotRhythm.Rd = "-------------------------------------------&amp;gt; NEEDS DOCUMENTATION &amp;lt;-------------------------------------------\nPlotting rhythmic symbols in R base graphics", rational.Rd = "Rational numbers", readHumdrum.Rd = "Find and read humdrum files into R", regexConstruction.Rd = "Making Regular Expressions", rhythmDecompose.Rd = "Decompose durations in terms of other durations", rhythmFunctions.Rd = "Manipulate pitch data", rhythmInterval.Rd = "Representation of rhythmic information", rhythmOffset.Rd = "Calculate rhythmic \"offset\"", romanNumerals.Rd = "Roman Numeral", struct.Rd = "struct", tertianSet.Rd = "Tertian set", time.Rd = "Time transformations", tonalInterval.Rd = "Representation of tonal pitch information", tonalTransformations.Rd = "Invert or transpose tonal intervals.", transpose.Rd = "Transpose pitches and keys", withinHumdrum.Rd = "with(in)Humdrum", writeHumdrum.Rd = "Write &lt;code&gt;humdrumR&lt;/code&gt; data to humdrum files." ), rd = list(LO5th.Rd = structure(list(structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/tonalInterval.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("LO5th", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("LO5th", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("Line of Fifths", class = c("TEXT", "tag" ))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("LO5th(x, generic = FALSE, ...)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Returns an integer vector or array, matching the input.\n", class = c("TEXT", "tag"))), class = c("tag_value", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("The function ", class = c("TEXT", "tag")), structure(list(structure("LO5th", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is a S3-generic function with methods to extract\n", class = c("TEXT", "tag")), structure("the \"line-of-fifths\" value from various pitch objects and representations.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("The Line of Fifths", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Every interval in Western music is associated with a integer on the line of fifths:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag" )), structure(" Bb = m7 = -2\n", class = c("TEXT", "tag" )), structure(list(), class = c("tag_item", "tag")), structure(" F = P4 = -1\n", class = c("TEXT", "tag" )), structure(list(), class = c("tag_item", "tag" )), structure(" C = P1 = 0\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" G = P5 = 1\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" D = M2 = 2\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" A = M6 = 3\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" E = M3 = 4\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" B = M7 = 5\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" F# = A4 = 6\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" etc.\n", class = c("TEXT", "tag" ))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("The natural notes of (C) major scale---which we also call the ", class = c("TEXT", "tag")), structure(list(structure("generic intervals", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure("---fall in the range ", class = c("TEXT", "tag")), structure(list(structure("-1:5", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("In fact, any diatonic key is a block of seven consecutive numbers of the line-of-fifths: for example, Eb major is ", class = c("TEXT", "tag")), structure(list(structure("-4:2", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("\"Sharps\" and \"flats\" represent ", class = c("TEXT", "tag")), structure(list(structure("+7", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("-7", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" on the line-of-fifths respectively.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("tint()", class = c("TEXT", "tag"))), Rd_option = structure("=tint", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Other ", class = c("TEXT", "tag")), structure(list( structure("core pitch representation", class = c("TEXT", "tag"))), class = c("LIST", "tag")), structure(": \n", class = c("TEXT", "tag")), structure(list(structure(list(structure("tonalInterval", class = c("TEXT", "tag"))), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("core pitch representation", class = c("TEXT", "tag"))), class = c("LIST", "tag"))), class = c("tag_concept", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), REparser.Rd = structure(list(structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Regex.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("REparser", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("REparser", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("REparse", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("Parse String Using Regular expressions", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("REparser(\n", class = c("RCODE", "tag")), structure(" res,\n", class = c("RCODE", "tag" )), structure(" parse.strict = TRUE,\n", class = c("RCODE", "tag")), structure(" parse.exhaust = TRUE,\n", class = c("RCODE", "tag")), structure(" parse.lead = FALSE,\n", class = c("RCODE", "tag")), structure(" parse.rest = FALSE,\n", class = c("RCODE", "tag")), structure(" toEnv = FALSE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag")), structure("REparse(\n", class = c("RCODE", "tag")), structure(" str,\n", class = c("RCODE", "tag")), structure(" res,\n", class = c("RCODE", "tag")), structure(" parse.strict = TRUE,\n", class = c("RCODE", "tag")), structure(" parse.exhaust = TRUE,\n", class = c("RCODE", "tag")), structure(" parse.lead = FALSE,\n", class = c("RCODE", "tag")), structure(" parse.rest = FALSE,\n", class = c("RCODE", "tag")), structure(" reverse = FALSE,\n", class = c("RCODE", "tag")), structure(" sep = NULL,\n", class = c("RCODE", "tag")), structure(" toEnv = FALSE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" ))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Takes an input string and parses it into a sequence of regular expressions.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag")), structure(list(structure("exhaustive", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is TRUE, the string must be exhaustively broken up by the matching regular expressions.\n", class = c("TEXT", "tag")), structure("Superfluous (non-match) characters at the begginning, end, or in bettween matches, will result in\n", class = c("TEXT", "tag")), structure("all ", class = c("TEXT", "tag" )), structure(list(structure("NA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" being returned.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), RegexFind.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Regex.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("RegexFind", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("RegexFind", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("%~l%", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("%~i%", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("%~n%", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("%~m%", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("%~%", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Match strings against regular expression", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("x %~l% pattern\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("x %~i% pattern\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("x %~n% pattern\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("x %~m% pattern\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("x %~% pattern\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("These infix functions are simply syntactic sugar for\n", class = c("TEXT", "tag")), structure("existing ", class = c("TEXT", "tag")), structure(list(structure("R", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" regular expression matching functions.\n", class = c("TEXT", "tag")), structure("If the a vector of regexes is given as the right argument, matches to ", class = c("TEXT", "tag")), structure(list(structure("any", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" of the regexes are returned.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("%~l%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(": Matches ", class = c("TEXT", "tag")), structure(list(structure("pattern", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" in ", class = c("TEXT", "tag")), structure(list(structure("x", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and returns ", class = c("TEXT", "tag")), structure(list(structure("logical", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". Shorthand for ", class = c("TEXT", "tag")), structure(list(structure(list(structure("base::grepl()", class = c("TEXT", "tag"))), Rd_option = structure("base:grep", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("%~%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(": The \"default\"---same as ", class = c("TEXT", "tag")), structure(list(structure("%~l%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("%~i%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(": Matches ", class = c("TEXT", "tag")), structure(list(structure("pattern", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" in ", class = c("TEXT", "tag")), structure(list(structure("x", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and returns ", class = c("TEXT", "tag")), structure(list(structure("integer", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" indices. Shorthand for ", class = c("TEXT", "tag")), structure(list(structure(list(structure("base::grep()", class = c("TEXT", "tag"))), Rd_option = structure("base:grep", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("%~n%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(": Matches ", class = c("TEXT", "tag")), structure(list(structure("pattern", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" in ", class = c("TEXT", "tag")), structure(list(structure("x", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and returns ", class = c("TEXT", "tag")), structure(list(structure("integer", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" counts (can be greater than one if more\n", class = c("TEXT", "tag")), structure("than one match occurs in the same token). Shorthand for ", class = c("TEXT", "tag")), structure(list(structure(list(structure("stringi::stri_count_regex()", class = c("TEXT", "tag"))), Rd_option = structure("stringi:stri_count", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("%~m%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(": Matches ", class = c("TEXT", "tag")), structure(list(structure("pattern", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" in ", class = c("TEXT", "tag")), structure(list(structure("x", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and returns matching strings (or NA if no match). Shorthand for ", class = c("TEXT", "tag")), structure(list(structure(list(structure("stringi::stri_extract_first_regex()", class = c("TEXT", "tag"))), Rd_option = structure("stringi:stri_extract", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), chordTransformer.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/tertianSet.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("chordTransformer", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("chordTransformer", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("figuredBass", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Parsing and deparsing chord information.", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("figuredBass(\n", class = c("RCODE", "tag")), structure(" x,\n", class = c("RCODE", "tag" )), structure(" ...,\n", class = c("RCODE", "tag" )), structure(" Key = NULL,\n", class = c("RCODE", "tag")), structure(" Exclusive = NULL,\n", class = c("RCODE", "tag")), structure(" parseArgs = list(),\n", class = c("RCODE", "tag")), structure(" transposeArgs = list(),\n", class = c("RCODE", "tag")), structure(" figurationArgs = list(),\n", class = c("RCODE", "tag")), structure(" inPlace = FALSE,\n", class = c("RCODE", "tag")), structure(" memoize = TRUE,\n", class = c("RCODE", "tag")), structure(" deparse = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" ))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("These functions are used to work with chord information.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("xxx\n", class = c("TEXT", "tag" )), structure("Tertian sets can be read/wrote in various ways.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), decimal.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/tools.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("decimal", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("decimal", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("as.decimal", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Decimal numbers", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("decimal(x)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("as.decimal(x, ...)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("These functions create decimal numbers that are identical to base R\n", class = c("TEXT", "tag")), structure(list(structure("numeric", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (real) numbers.\n", class = c("TEXT", "tag")), structure("However, these numbers are understood by the ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("rational numbers", class = c("TEXT", "tag"))), Rd_option = structure("=rational", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" ))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("rational()", class = c("TEXT", "tag"))), Rd_option = structure("=rational", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Other ", class = c("TEXT", "tag")), structure(list(structure("humdrumR numeric functions", class = c("TEXT", "tag"))), class = c("LIST", "tag")), structure(": \n", class = c("TEXT", "tag")), structure(list(structure(list(structure("rational", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("()", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("humdrumR numeric functions", class = c("TEXT", "tag"))), class = c("LIST", "tag"))), class = c("tag_concept", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), diatonicSet.Rd = structure(list(structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/diatonicSet.R, R/tertianSet.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("diatonicSet", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("diatonicSet", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("dset", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("as.character,diatonicSet-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("is.diatonicSet", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("order.diatonicSet", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("==,diatonicSet,diatonicSet-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Compare,diatonicSet,diatonicSet-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("diatonicSet.diatonicSet", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("diatonicSet.logical", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("diatonicSet.numeric", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("diatonicSet.integer", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("diatonicSet.character", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Tonal (diatonic) sets", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("dset(root = 0L, signature = root, alterations = 0L)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag")), structure(list(structure(list(structure("as.character", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("diatonicSet", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(x)\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("is.diatonicSet(x)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("order.diatonicSet(\n", class = c("RCODE", "tag")), structure(" x,\n", class = c("RCODE", "tag" )), structure(" ...,\n", class = c("RCODE", "tag" )), structure(" parallel = TRUE,\n", class = c("RCODE", "tag")), structure(" na.last = TRUE,\n", class = c("RCODE", "tag")), structure(" decreasing = FALSE,\n", class = c("RCODE", "tag")), structure(" method = c(\"auto\", \"shell\", \"radix\")\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure(list( structure(list(structure("==", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("diatonicSet,diatonicSet", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(e1, e2)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("Compare", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("diatonicSet,diatonicSet", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(e1, e2)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("diatonicSet", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("diatonicSet", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("diatonicSet", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("logical", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("diatonicSet", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("numeric", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x)\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure(list( structure(list(structure("diatonicSet", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("integer", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x)\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure(list( structure(list(structure("diatonicSet", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("character", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(str, Exclusive = NULL, Key = NULL, ..., multiDispatch = FALSE)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("as.character", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("tertianSet", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(x)\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure(list( structure(list(structure("==", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("tertianSet,tertianSet", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(e1, e2)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("diatonicSet", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is one of ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("'s\n", class = c("TEXT", "tag")), structure("types of tonal data, representing Western diatonic keys.\n", class = c("TEXT", "tag")), structure("For the most part, users should not need to interact with diatonicSets directly---rather, diatonicSets work behind the scene in numerous ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" pitch functions.\n", class = c("TEXT", "tag")), structure("See the ", class = c("TEXT", "tag" )), structure(list(structure("keyRepresentations", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("keyTransformations", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" documentation for details of usage and functionality or the ", class = c("TEXT", "tag")), structure(list(structure("Tonality in humdrumR", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" vignette for\n", class = c("TEXT", "tag")), structure("a detailed explanation of the theory and specifics of diatonicSets.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("diatonicSet", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is a ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://adv-r.had.co.nz/S4.html", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("S4", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag" )), structure(" subclass of ", class = c("TEXT", "tag" )), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("'s virtual class ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(",\n", class = c("TEXT", "tag")), structure("from which it inherits a lot of useful \"vector-like\" behaviors/functionality.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("The constructor function ", class = c("TEXT", "tag")), structure(list(structure("dset", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" can be used to create ", class = c("TEXT", "tag")), structure(list(structure("diatonicSets", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" directly.\n", class = c("TEXT", "tag")), structure("The three arguments corespond to the three slots: ", class = c("TEXT", "tag")), structure(list(structure("root", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("mode", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", and ", class = c("TEXT", "tag")), structure(list(structure("alteration", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("All inputs will be coerced to match in length.\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag")), structure(list(structure("root", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument will attempt to coerce character strings to ", class = c("TEXT", "tag")), structure(list(structure("tonalIntervals", class = c("TEXT", "tag"))), Rd_option = structure("=tonalInterval", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(", and use their ", class = c("TEXT", "tag")), structure(list(structure("LO5th", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" value as the root.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("By default, the ", class = c("TEXT", "tag" )), structure(list(structure("as.character", class = c("TEXT", "tag"))), Rd_option = structure("base:character", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" method, and thus (via ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(") the ", class = c("TEXT", "tag")), structure(list(structure("show", class = c("TEXT", "tag"))), Rd_option = structure("methods:show", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" method,\n", class = c("TEXT", "tag")), structure("for diatonicSets call ", class = c("TEXT", "tag")), structure(list(structure("key()", class = c("TEXT", "tag"))), Rd_option = structure("=diatonicRepresentations", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure("Thus, if you return a ", class = c("TEXT", "tag")), structure(list(structure("diatonicSet", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" on the command line (or call ", class = c("TEXT", "tag")), structure(list(structure("print", class = c("TEXT", "tag"))), Rd_option = structure("base:print", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" one one),\n", class = c("TEXT", "tag")), structure("you'll see the ", class = c("TEXT", "tag")), structure(list(structure("key interpretation", class = c("TEXT", "tag"))), Rd_option = structure("=diatonicRepresentations", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" representation printed.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Slots", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure(list(structure("Root", class = c("RCODE", "tag"))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("integers representing the root of the key on the line-of-fifths", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure(list(structure("Signature", class = c("RCODE", "tag"))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("integers representing the signature (number of accidentals) of the key.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure(list(structure("Alteration", class = c("RCODE", "tag"))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("integers representing alterations of the diatonic set\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("A key is represented by two integers, ", class = c("TEXT", "tag")), structure(list(structure("Root", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("Signature", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Root is simply the tonic note of the key on the circle of fifths.\n", class = c("TEXT", "tag")), structure("Signature is a value on the circle of fifths, indicating the diatonic mode.\n", class = c("TEXT", "tag")), structure("You can think of the ", class = c("TEXT", "tag")), structure(list(structure("Signature", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" value as indicating the number of accidentals, with negative numbers\n", class = c("TEXT", "tag")), structure("for flats and positive numbers for sharps.\n", class = c("TEXT", "tag")), structure("You can also think of the signature as indicating how much the \"natural key\" (C major) is\n", class = c("TEXT", "tag")), structure("slid up and down the line-of-fifths.\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Mode_(music)", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("traditional diatonic modes", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" of Western music occur wherever ", class = c("TEXT", "tag")), structure(list(structure("Signature - Tonic", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is in the range ", class = c("TEXT", "tag")), structure(list(structure("-5:1", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(":\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("Signature - Tonic = +1 \\rightarrow", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(" Lydian\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("Signature - Tonic = +0 \\rightarrow", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(" Major (Ionian)\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("Signature - Tonic = -1 \\rightarrow", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(" Mixolydian\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("Signature - Tonic = -2 \\rightarrow", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(" Dorian\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("Signature - Tonic = -3 \\rightarrow", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(" Minor (Aeolian)\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("Signature - Tonic = -5 \\rightarrow", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(" Locrian\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("Signature - Tonic = -4 \\rightarrow", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(" Phyrgian\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(structure("Note that you can make diatonicSets where the ", class = c("TEXT", "tag")), structure(list(structure("Root", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is outside the ", class = c("TEXT", "tag")), structure(list(structure("Key", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". This is unusual, and may result in sets you wouldn't predict.", class = c("TEXT", "tag"))), class = c("tag_emph", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_describe", "tag"))), class = "tag")), class = c("tag_section", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Alterations", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag")), structure(list(structure("Alteration", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" slots (also integer) can be used to represent various\n", class = c("TEXT", "tag")), structure("\"altered\" scales.\n", class = c("TEXT", "tag")), structure("The integer values are interpreted as a seven-trit ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Balanced_ternary", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("balanced ternary", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" string.\n", class = c("TEXT", "tag")), structure("(\"trits\" are the ternary equivalent of binary \"bits.\")\n", class = c("TEXT", "tag")), structure("Balanced ternary allows for three digits, ", class = c("TEXT", "tag")), structure(list(structure("0", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (unaltered degree), ", class = c("TEXT", "tag")), structure(list(structure("1", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (sharpened degree), and ", class = c("TEXT", "tag")), structure(list(structure("-1", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (flattened degree).\n", class = c("TEXT", "tag")), structure("The seven trits correspond to the seven scale degrees on the line-of-fifth indicated by the ", class = c("TEXT", "tag")), structure(list(structure("signature", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure("---i.e., ordered from\n", class = c("TEXT", "tag")), structure("lowest to hightest on the line-of-fifths, not relative to the root.\n", class = c("TEXT", "tag")), structure("(For instance, when ", class = c("TEXT", "tag")), structure(list(structure("Signature == 0", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the degrees are ", class = c("TEXT", "tag")), structure(list(structure("c(-1, 0, 1, 2, 3, 4, 5)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".)\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("The ternary arrangement maps powers of three to each scale degree, as so that in the ", class = c("TEXT", "tag")), structure(list(structure("Alteration", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" integer:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure(list(structure("\\pm 1", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(": raise or flatten the ", class = c("TEXT", "tag")), structure(list(structure("7th", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" scale degree.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("\\pm 3", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(": raise or flatten the ", class = c("TEXT", "tag")), structure(list(structure("3rd", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" scale degree.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("\\pm 9", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(": raise or flatten the ", class = c("TEXT", "tag")), structure(list(structure("6th", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" scale degree.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("\\pm 27", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(": raise or flatten the ", class = c("TEXT", "tag")), structure(list(structure("2nd", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" scale degree.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("\\pm 81", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(": raise or flatten the ", class = c("TEXT", "tag")), structure(list(structure("5th", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" scale degree.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("\\pm 243", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(": raise or flatten the ", class = c("TEXT", "tag")), structure(list(structure("1st", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" scale degree.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("\\pm 749", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(": raise or flatten the ", class = c("TEXT", "tag")), structure(list(structure("4th", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" scale degree.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("For example, consider ", class = c("TEXT", "tag")), structure(list(structure("Alteration == 26", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(":\n", class = c("TEXT", "tag")), structure("In a balanced ternary representation, the decimal integer 26 is represented as ", class = c("TEXT", "tag")), structure(list(structure("1 0 0 1 0 -1 0", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("(In other words 1 in the \"27s place\" and -1 in the \"ones place\"---i.e., 27 - 1).\n", class = c("TEXT", "tag")), structure("This represents a raised 2nd (the 27) and a lowered 7th (the -1).\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag")), structure(list( structure("Alteration", class = c("RCODE", "tag" ))), class = c("tag_code", "tag")), structure(" integer allows us to concisely represent all the 2,187 possible combinations of raised and lowered diatonic scale degrees!\n", class = c("TEXT", "tag")), structure("However, combined with the ", class = c("TEXT", "tag")), structure(list(structure("Signature", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" slot, there is some redundancy in scale representation.\n", class = c("TEXT", "tag")), structure("For example, a melodic minor scale can be represented as a major scale (", class = c("TEXT", "tag")), structure(list(structure("Signature - Root == 0", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") with a lowered third degree (", class = c("TEXT", "tag")), structure(list(structure("Alteration == -3", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") ", class = c("TEXT", "tag")), structure(list(structure("or", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" as\n", class = c("TEXT", "tag")), structure("minor scale (", class = c("TEXT", "tag")), structure(list(structure("Signature - Root == -3", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") with raised 6ths and 7ths (", class = c("TEXT", "tag")), structure(list(structure("Alteration == 10", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag")), structure("However, though these two representations result in the same set on the line-of-fifths, some might consider them to be\n", class = c("TEXT", "tag")), structure("conceptually different in some contexts, so we consider the redundancy acceptable.\n", class = c("TEXT", "tag")), structure("Another case of encoding redundancy ", class = c("TEXT", "tag")), structure(list(structure("is", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" that ", class = c("TEXT", "tag")), structure(list(structure("Alteration - 1", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (flatten the 7th) is exactly equivalent to ", class = c("TEXT", "tag")), structure(list(structure("Signature - 1", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Similarly, ", class = c("TEXT", "tag")), structure(list(structure("Alteration + 749", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (raise the 4th) is exactly equivalent to ", class = c("TEXT", "tag")), structure(list(structure("Signature + 1", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Double-flat and double-sharp degrees are ", class = c("TEXT", "tag")), structure(list(structure("not", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" encodable in ", class = c("TEXT", "tag")), structure(list(structure("diatonicSet", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("However, in combination with the ", class = c("TEXT", "tag")), structure(list(structure("Signature", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" slot, sets with double-flat/sharps (like doubly-diminished 7ths) can be encoded.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Arithmatic", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Arithmetic between diatonicSets is not defined.\n", class = c("TEXT", "tag")), structure("However, a number of useful arithmetic operations between diatonicSets and other data types ", class = c("TEXT", "tag")), structure(list(structure("are", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" defined:\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("XXXX Elaborate\n", class = c("TEXT", "tag")), structure("XXXX Need to implement special logic for adding Alterations! (Taking into account Signature addition.)\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Relational Operators", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("diatonicSets can be compared using the standard ", class = c("TEXT", "tag")), structure(list(structure("relational operations", class = c("TEXT", "tag"))), Rd_option = structure("base:Comparison", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list( structure("==", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", and ", class = c("TEXT", "tag")), structure(list(structure("!=", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Two diatonicSets are equal (according to ", class = c("TEXT", "tag")), structure(list(structure("==", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") only if all their slots (", class = c("TEXT", "tag")), structure(list(structure("Root", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("Signature", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", and ", class = c("TEXT", "tag")), structure(list(structure("Alteration", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(")\n", class = c("TEXT", "tag")), structure("are exactly identical.\n", class = c("TEXT", "tag")), structure("Ordinal comparisons (e.g., ", class = c("TEXT", "tag")), structure(list(structure("&gt;", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("&lt;=", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") between diatonicSets are on their ", class = c("TEXT", "tag")), structure(list(structure("Signature", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" only.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Coercion", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" knows how to ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Type_conversion", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("coerce", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag" )), structure(" several ", class = c("TEXT", "tag")), structure(list(structure("base-R atomic types", class = c("TEXT", "tag"))), Rd_option = structure("base:vector", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" into diatonicSets.\n", class = c("TEXT", "tag")), structure("This can be done using the ", class = c("TEXT", "tag")), structure(list(structure("as", class = c("TEXT", "tag"))), Rd_option = structure("methods:as", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" function---e.g., ", class = c("TEXT", "tag")), structure(list(structure("as(3, \"diatonicSet\")", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("---or more intuitively using the function ", class = c("TEXT", "tag")), structure(list(structure("diatonicSet()", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Coercision methods are defined for\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("integer", class = c("TEXT", "tag"))), Rd_option = structure("base:integer", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(": interpreted as root of major key\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("numeric", class = c("TEXT", "tag"))), Rd_option = structure("base:numeric", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(": rounded to nearest integer and intepreted as root of major key\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("character", class = c("TEXT", "tag"))), Rd_option = structure("base:character", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(": interpreted using ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s ", class = c("TEXT", "tag")), structure(list(structure("regular expression dispatch system", class = c("TEXT", "tag"))), Rd_option = structure("=regexDispatch", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(", as\n", class = c("TEXT", "tag")), structure("explained fully ", class = c("TEXT", "tag")), structure(list(structure("here", class = c("TEXT", "tag"))), Rd_option = structure("=diatonicRepresentations", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" ))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), fillThru.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/tools.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("fillThru", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("fillThru", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("fillForward", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("fillBackwards", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Propogate data points to \"fill\" null data.", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("fillThru(x, nonnull = function(x) !is.na(x) &amp; x != \".\", reverse = FALSE)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("fillForward(...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("fillBackwards(...)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("fillThru", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is a function that allow you to \"fill\" null values in a vector\n", class = c("TEXT", "tag")), structure("with non-null values from earlier/later in the same vector.\n", class = c("TEXT", "tag")), structure("The default, \"foward,\" behavior fills each null value with the previous (lower index) non-null value, if there are any.\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag" )), structure(list(structure("reverse", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument can be used to cause \"backeward\" filling, where the ", class = c("TEXT", "tag")), structure(list(structure("next", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" (higher index) non-null value is used.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Which values are considered \"non-null\" can be controlled using the ", class = c("TEXT", "tag")), structure(list(structure("nonnull", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument.\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag" )), structure(list(structure("nonnull", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument can either be a logical vector which is the same length as the input (", class = c("TEXT", "tag")), structure(list(structure("x", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") argument, a numeric\n", class = c("TEXT", "tag")), structure("vector of positive indices, or a function which, when applied to ", class = c("TEXT", "tag")), structure(list(structure("x", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" returns an appropriate logical/numeric vector.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), filterHumdrum.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Filter.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("filterHumdrum", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("filterHumdrum", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("removeEmptyFiles", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("removeEmptySpines", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("removeEmptyRecords", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[,humdrumR,missing,ANY-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[,humdrumR,numeric,ANY-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[,humdrumR,character,ANY-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[,humdrumR,formula,ANY-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[[,humdrumR,numeric,missing-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[[,humdrumR,missing,numeric-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[[,humdrumR,character,missing-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[[,humdrumR,ANY,ANY-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Filter humdrum data", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("filterHumdrum(humdrumR, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("removeEmptyFiles(humdrumR)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("removeEmptySpines(humdrumR)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("removeEmptyRecords(humdrumR)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdata[] # returns unchanged\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdata[x:y]\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdata['regex']\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdata[~expression]\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdata[[x:y]]\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdata[[ , x:y]]\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdata[['regex']]\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdata[[x:y, l:m]]\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("filterHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is a command used to filter a ", class = c("TEXT", "tag")), structure(list(structure("humdrumR corpus", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Indexing a humdrumR corpus (using the ", class = c("TEXT", "tag")), structure(list(structure("[]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("[[]]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" operators)\n", class = c("TEXT", "tag")), structure("uses calls to ", class = c("TEXT", "tag")), structure(list(structure("filterHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("!\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure(list( structure("filterHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is used in a similar manner as ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(",\n", class = c("TEXT", "tag")), structure("taking any number of \"do expressions\" (or functions) as arguments.\n", class = c("TEXT", "tag")), structure("(In fact, do expressions/function arguments are passed directly to an internal call to ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".)\n", class = c("TEXT", "tag")), structure("The only difference is that the expressions/functions fed to ", class = c("TEXT", "tag")), structure(list(structure("filterHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("must", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" be ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("predicate", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" expressions\n", class = c("TEXT", "tag")), structure("which return a logical (", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("/", class = c("TEXT", "tag")), structure(list(structure("FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") vector.\n", class = c("TEXT", "tag")), structure("The returned vector must also be the same length as the input data (the number\n", class = c("TEXT", "tag")), structure("of rows in the ", class = c("TEXT", "tag")), structure(list(structure("humdrum table", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(").\n", class = c("TEXT", "tag")), structure("(You can use a ", class = c("TEXT", "tag")), structure(list(structure("dofill~", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" expression if you want to \"expand\" shorter outputs for filtering pusposes.)\n", class = c("TEXT", "tag")), structure(list(structure("filterHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" updates the humdrum table's ", class = c("TEXT", "tag")), structure(list(structure("Filter", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field using an logical OR (", class = c("TEXT", "tag")), structure(list(structure("|", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") between the existing ", class = c("TEXT", "tag")), structure(list(structure("Filter", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field and the negation of your predicate: ", class = c("TEXT", "tag")), structure(list(structure("Filter | !Predicate", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("HumdrumR functions (mostly) ignore all data points where ", class = c("TEXT", "tag")), structure(list(structure("Filter == TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(": when you print a filtered ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" you'll see all the filtered data points turned to null data (", class = c("TEXT", "tag")), structure(list(structure(".", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("), and\n", class = c("TEXT", "tag")), structure("any calls to ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("TEXT", "tag"))), Rd_option = structure("=with(in)Humdrum", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" will ignore the filtered data.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("By default, ", class = c("TEXT", "tag")), structure(list(structure("filterHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" completely removes any files in the corpus where ", class = c("TEXT", "tag")), structure(list(structure("all", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" the data records are filtered out.\n", class = c("TEXT", "tag")), structure("However, you can stop this by specifying the ", class = c("TEXT", "tag")), structure(list(structure("removeEmptyFiles", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argumet as ", class = c("TEXT", "tag")), structure(list(structure("FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("If you ", class = c("TEXT", "tag")), structure(list(structure("want", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" to remove empty files, spines, or records, you should call ", class = c("TEXT", "tag")), structure(list(structure("removeEmptyFiles", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("removeEmptySpines", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", or ", class = c("TEXT", "tag")), structure(list(structure("removeEmptyRecords", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Indexing", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("In R, the basic ", class = c("TEXT", "tag")), structure(list(structure("indexing operators", class = c("TEXT", "tag"))), Rd_option = structure("base:Extract", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(", ", class = c("TEXT", "tag" )), structure(list(structure("[]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("[[]]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(",\n", class = c("TEXT", "tag")), structure("are used to select subsets of data.\n", class = c("TEXT", "tag")), structure("For many R data types (for instance, base R ", class = c("TEXT", "tag")), structure(list(structure("lists", class = c("TEXT", "tag"))), Rd_option = structure("base:list", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(")\n", class = c("TEXT", "tag" )), structure("the ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("single brackets", class = c("TEXT", "tag")), structure(list(structure("]", class = c("VERB", "tag"))), class = c("tag_verb", "tag"))), class = c("tag_strong", "tag")), structure(" are used for \"shallower\" extraction while the\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("[[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("double brackets", class = c("TEXT", "tag")), structure(list(structure("]]", class = c("VERB", "tag"))), class = c("tag_verb", "tag"))), class = c("tag_strong", "tag")), structure(" are used for \"deeper\" extraction.\n", class = c("TEXT", "tag")), structure(list(structure("HumdrumR corpus", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" indexing follows this same basic pattern:\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("single brackets", class = c("TEXT", "tag")), structure(list(structure("]", class = c("VERB", "tag"))), class = c("tag_verb", "tag"))), class = c("tag_strong", "tag")), structure(" are used to index ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" objects\n", class = c("TEXT", "tag")), structure(list(structure("by piece", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" while ", class = c("TEXT", "tag")), structure(list(structure(list(structure("[[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("double brackets", class = c("TEXT", "tag")), structure(list(structure("]]", class = c("VERB", "tag"))), class = c("tag_verb", "tag"))), class = c("tag_strong", "tag")), structure(" are used to index\n", class = c("TEXT", "tag")), structure(list(structure("within pieces", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(". (Accidentally writing ", class = c("TEXT", "tag")), structure(list(structure("[]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" when you need\n", class = c("TEXT", "tag")), structure(list(structure("[[]]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" is a very common error, so watch out!)\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Whether, indexing by piece or within, ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" objects can use\n", class = c("TEXT", "tag")), structure("three types of indexing arguments:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" By ", class = c("TEXT", "tag")), structure(list(structure("numeric", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (ordinal integers)\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" By ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" string (regular expressions)\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" By ", class = c("TEXT", "tag")), structure(list(structure("formula", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (arbitrary expressions)\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("The last option (by ", class = c("TEXT", "tag")), structure(list(structure("formula", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") is the most powerful option,\n", class = c("TEXT", "tag")), structure("and indeed, the first two options (", class = c("TEXT", "tag")), structure(list(structure("numeric", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" indexing)\n", class = c("TEXT", "tag")), structure("are just convenient shorthands for indexing that can be accomplished using\n", class = c("TEXT", "tag")), structure("the ", class = c("TEXT", "tag")), structure(list(structure("formula", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" method.\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Numeric indexing:", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Indexing ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" corpora with\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("single brackets", class = c("TEXT", "tag")), structure(list(structure("]", class = c("VERB", "tag"))), class = c("tag_verb", "tag"))), class = c("tag_strong", "tag")), structure(" will accept\n", class = c("TEXT", "tag")), structure("one numeric argument.\n", class = c("TEXT", "tag")), structure("This argument will be used to pick pieces within the ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object ordinally.\n", class = c("TEXT", "tag")), structure("Thus, ", class = c("TEXT", "tag")), structure(list(structure("humdata[1:10]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will select the first ten pieces in the data while ", class = c("TEXT", "tag")), structure(list(structure("humdata[42]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("will select only the 42nd piece.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Indexing ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" objects with\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("[[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("double brackets", class = c("TEXT", "tag")), structure(list(structure("]]", class = c("VERB", "tag"))), class = c("tag_verb", "tag"))), class = c("tag_strong", "tag")), structure(" will accept\n", class = c("TEXT", "tag")), structure("one or two numeric arguments, ", class = c("TEXT", "tag")), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", either of which can\n", class = c("TEXT", "tag")), structure("be used in isolation or in combination.\n", class = c("TEXT", "tag")), structure("(If ", class = c("TEXT", "tag")), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is used in isolation, it must be placed after a comma, as in ", class = c("TEXT", "tag")), structure(list(structure("humdata[[ , j ]]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".)\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is used to index data records (i.e., based on the humtable ", class = c("TEXT", "tag")), structure(list(structure("Record", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field) ordinally.\n", class = c("TEXT", "tag")), structure("Thus, ", class = c("TEXT", "tag")), structure(list(structure("humdata[[1:20]]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" indexes the first twenty records ", class = c("TEXT", "tag")), structure(list(structure("from each file", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure("\n", class = c("TEXT", "tag")), structure("in the corpus, and ", class = c("TEXT", "tag")), structure(list(structure("humdata[[42]]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" extracts the 42nd record ", class = c("TEXT", "tag")), structure(list(structure("from each file", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is used to index spines (i.e., based on the ", class = c("TEXT", "tag")), structure(list(structure("Spine", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field) ordinally.\n", class = c("TEXT", "tag")), structure("Thus, ", class = c("TEXT", "tag")), structure(list(structure("humdata[[ , 3:4]]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" returns the third and fourth spines ", class = c("TEXT", "tag")), structure(list(structure("from each", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure("\n", class = c("TEXT", "tag")), structure("file in the corpus.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("When indexing ", class = c("TEXT", "tag")), structure(list(structure("humdrumR corpora", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" with numbers,\n", class = c("TEXT", "tag")), structure("all ", class = c("TEXT", "tag")), structure(list(structure("numeric", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (double) inputs are converted to integers.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Note that numeric ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" indexing is entirely ", class = c("TEXT", "tag")), structure(list(structure("ordinal", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(", meaning\n", class = c("TEXT", "tag")), structure("that pieces/data records/spines are not matched based on their value in their\n", class = c("TEXT", "tag")), structure("respective fields, but rather on their order among all existing values.\n", class = c("TEXT", "tag")), structure("Thus, for ", class = c("TEXT", "tag")), structure(list(structure("[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("single-bracket", class = c("TEXT", "tag")), structure(list(structure("]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" indexing the $i_", class = c("TEXT", "tag")), structure(list(structure("th", class = c("TEXT", "tag"))), class = c("LIST", "tag")), structure("$ piece in the\n", class = c("TEXT", "tag")), structure("corpus is taken, regardless of that ", class = c("TEXT", "tag")), structure(list(structure("FileN", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field associated\n", class = c("TEXT", "tag")), structure("with that piece.\n", class = c("TEXT", "tag")), structure("For example,", class = c("TEXT", "tag")), structure(list(structure("humsubset &lt;- humdata[11:20]\n", class = c("VERB", "tag")), structure("humsubset[2]\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("will return the 12th piece from the original ", class = c("TEXT", "tag")), structure(list(structure("humdata", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object, ", class = c("TEXT", "tag")), structure(list(structure("not", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" the second piece.\n", class = c("TEXT", "tag")), structure("This is beacuse the first call to ", class = c("TEXT", "tag")), structure(list(structure("[]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" returns the 11th through 20th pieces, and the second call\n", class = c("TEXT", "tag")), structure("returns the ", class = c("TEXT", "tag")), structure(list(structure("second", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" piece that is still present (the 12th).\n", class = c("TEXT", "tag")), structure("Similarly,", class = c("TEXT", "tag")), structure(list(structure("humsubset2 &lt;- humdata[[ , 2:4]]\n", class = c("VERB", "tag")), structure("humsubset2[[ , 2]]\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag" )), structure("will return the third spine from the original data.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("As in normal R indexing, negative numbers can be used, causing corresponding elements to be\n", class = c("TEXT", "tag")), structure(list(structure("removed", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" instead of retained. Thus, ", class = c("TEXT", "tag")), structure(list(structure("humdata[-3:-5]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will remove the third, fourth, and fifth pieces from the data\n", class = c("TEXT", "tag")), structure("while ", class = c("TEXT", "tag")), structure(list(structure("humdata[[ , -3:-5]]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will remove the third, fourth, and fifth spines from each piece.\n", class = c("TEXT", "tag")), structure("Positive and negative indices cannot be mixed in a single argument.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("In all cases, indices outside of range (or of value ", class = c("TEXT", "tag")), structure(list(structure("0", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") are ignored.\n", class = c("TEXT", "tag")), structure("E.g., if you have a corpus of twenty files and you call ", class = c("TEXT", "tag")), structure(list(structure("corpus[21]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", there is no 21st piece, so ", class = c("TEXT", "tag")), structure(list(structure("21", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is \"out of range\".\n", class = c("TEXT", "tag")), structure("If all your input indices are ", class = c("TEXT", "tag")), structure(list(structure("0", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and error will result.\n", class = c("TEXT", "tag")), structure("If all your input indices are out of range then\n", class = c("TEXT", "tag")), structure("an empty ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object is returned.\n", class = c("TEXT", "tag")), structure("For instance, ", class = c("TEXT", "tag")), structure(list(structure("humdata[[401:500, ]]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will return an empty\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object if there are no pieces with more than 400\n", class = c("TEXT", "tag")), structure("data records.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Character indexing:", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Indexing ", class = c("TEXT", "tag")), structure(list(structure("humdrumR objects", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumR:humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" with\n", class = c("TEXT", "tag")), structure(list(structure("[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("single brackets", class = c("TEXT", "tag")), structure(list(structure("]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" will accept one\n", class = c("TEXT", "tag")), structure("vector of ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" strings. These strings are\n", class = c("TEXT", "tag")), structure("treated as\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Regular_expression", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("regular expressions", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" (regexes).\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("The tokens from the humdrumR object's ", class = c("TEXT", "tag")), structure(list(structure("Active", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" fields are searched\n", class = c("TEXT", "tag")), structure("for matches to any of the regular expressions you input. Any piece that contains\n", class = c("TEXT", "tag")), structure(list(structure("any", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" match to ", class = c("TEXT", "tag")), structure(list(structure("any", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" of the regular expressions is retained---all other pieces\n", class = c("TEXT", "tag")), structure("are filtered out. Note that (because this is ", class = c("TEXT", "tag")), structure(list(structure("[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("single-bracket", class = c("TEXT", "tag")), structure(list(structure("]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" indexing) the entire piece is retained, even if there is only one match.\n", class = c("TEXT", "tag")), structure("If no matches occur in any pieces, an empty ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object is returned.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Indexing ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" objects with ", class = c("TEXT", "tag")), structure(list(structure("[[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("double brackets", class = c("TEXT", "tag")), structure(list(structure("]]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" will\n", class = c("TEXT", "tag")), structure("accept one or two vectors of ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" strings, ", class = c("TEXT", "tag")), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag")), structure("either of which can\n", class = c("TEXT", "tag")), structure("be used in isolation or in combination.\n", class = c("TEXT", "tag")), structure("(If ", class = c("TEXT", "tag")), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is used in isolation, it must be placed after a comma,\n", class = c("TEXT", "tag")), structure("as in ", class = c("TEXT", "tag")), structure(list(structure("humdata[[ , j]]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".)\n", class = c("TEXT", "tag")), structure("These strings are\n", class = c("TEXT", "tag")), structure("treated as ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Regular_expression", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("regular expressions", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" (regexes).\n", class = c("TEXT", "tag")), structure("The tokens from the humdrumR object's ", class = c("TEXT", "tag")), structure(list(structure("Active", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" fields are searched\n", class = c("TEXT", "tag")), structure("for matches to any of the regular expressions you input.\n", class = c("TEXT", "tag")), structure("Any record which contains at least one token matching any regex in ", class = c("TEXT", "tag")), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("will be retained.\n", class = c("TEXT", "tag")), structure("Similarly, any spine which contains at least one token matching any\n", class = c("TEXT", "tag")), structure("regex in ", class = c("TEXT", "tag")), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is retained.\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag" )), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" are used together,\n", class = c("TEXT", "tag")), structure("matching spines (", class = c("TEXT", "tag")), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") are indexed first, so that\n", class = c("TEXT", "tag")), structure("tokens matching the regular expression(s) in ", class = c("TEXT", "tag")), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("must be found in the matching spines.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("A third argument, ", class = c("TEXT", "tag")), structure(list(structure("k", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", can also be used, but only if\n", class = c("TEXT", "tag")), structure("both the ", class = c("TEXT", "tag")), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" arguments are missing.\n", class = c("TEXT", "tag")), structure("In order for this to work, you need to put two commas to mark the \"missing\" ", class = c("TEXT", "tag")), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" arguments:\n", class = c("TEXT", "tag")), structure("e.g., ", class = c("TEXT", "tag")), structure(list(structure("humdata[[ , , '[Ee]-']]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("In the case of ", class = c("TEXT", "tag")), structure(list(structure("k", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", only matching tokens are retained,\n", class = c("TEXT", "tag")), structure("regardless of their spine or record number(s).\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Formula indexing:", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Indexing ", class = c("TEXT", "tag")), structure(list(structure("humdrumR objects", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumR:humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" with\n", class = c("TEXT", "tag")), structure(list(structure("formulae", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is the most powerful, flexible indexing option.\n", class = c("TEXT", "tag")), structure("Either ", class = c("TEXT", "tag")), structure(list(structure("[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("single", class = c("TEXT", "tag")), structure(list(structure("]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("[[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("double", class = c("TEXT", "tag")), structure(list(structure("]]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" brackets will accept\n", class = c("TEXT", "tag")), structure("a (single) formula. The formula are fed directly as arguments to\n", class = c("TEXT", "tag")), structure(list(structure("filterHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("---as such, they music evaluate to a logical vector of the same\n", class = c("TEXT", "tag")), structure("length as the input.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("In the case of ", class = c("TEXT", "tag")), structure(list(structure("[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("single-bracket", class = c("TEXT", "tag")), structure(list(structure("]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" indexing, only one ", class = c("TEXT", "tag")), structure(list(structure("formula", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("is accepted, and ", class = c("TEXT", "tag")), structure(list(structure("every piece", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" that evalues with at least one\n", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will be retained.\n", class = c("TEXT", "tag")), structure("For instance, ", class = c("TEXT", "tag")), structure(list(structure("humdata[~Spine &gt; 4]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will return all pieces\n", class = c("TEXT", "tag")), structure("which contain five (or more) spines.\n", class = c("TEXT", "tag")), structure(list(structure("[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("single-bracket", class = c("TEXT", "tag")), structure(list(structure("]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" formula indexing is especially useful for indexing\n", class = c("TEXT", "tag")), structure("meta-data properties like reference records:\n", class = c("TEXT", "tag")), structure("for instance, ", class = c("TEXT", "tag")), structure(list(structure("humdata[~COM == \"Paul McCartney\"]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will return\n", class = c("TEXT", "tag")), structure("all pieces with a ", class = c("TEXT", "tag")), structure(list(structure("!!!COM: Paul McCartney", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" reference record.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("In the case of ", class = c("TEXT", "tag")), structure(list(structure("[[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("double-bracket", class = c("TEXT", "tag")), structure(list(structure("]]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" indexing, one or two formulas are accepted,\n", class = c("TEXT", "tag")), structure("in arguments ", class = c("TEXT", "tag")), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", either of which can\n", class = c("TEXT", "tag")), structure("be used in isolation or in combination.\n", class = c("TEXT", "tag")), structure("(If ", class = c("TEXT", "tag")), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is used in isolation, it must be placed after a comma,\n", class = c("TEXT", "tag")), structure("as in ", class = c("TEXT", "tag")), structure(list(structure("humdata[[ , j]]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".)\n", class = c("TEXT", "tag")), structure("In the case of ", class = c("TEXT", "tag")), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" formulae, any record which evaluates to\n", class = c("TEXT", "tag")), structure("at least one ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" value is retained.\n", class = c("TEXT", "tag")), structure("In the case of ", class = c("TEXT", "tag")), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", any spine which evaluates to\n", class = c("TEXT", "tag")), structure("at least one ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" value is retained.\n", class = c("TEXT", "tag")), structure("Any piece which contains no matches is dropped entirely.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("For ", class = c("TEXT", "tag" )), structure(list(structure("[[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("double-bracket", class = c("TEXT", "tag")), structure(list(structure("]]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" formula indexing, a third argument, ", class = c("TEXT", "tag")), structure(list(structure("k", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("may be used in the absence of ", class = c("TEXT", "tag")), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("In order for this to work, you need to put two commas to mark the \"missing\" ", class = c("TEXT", "tag")), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" arguments:\n", class = c("TEXT", "tag")), structure("e.g., ", class = c("TEXT", "tag")), structure(list(structure("humdata[[ , , ~formula]]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("In the case of ", class = c("TEXT", "tag")), structure(list(structure("k", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" all tokens which evaluate to ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("are retained, regardless of piece/spine/record.\n", class = c("TEXT", "tag")), structure("Pieces, spines, or records with no ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" values\n", class = c("TEXT", "tag")), structure("are simply dropped.\n", class = c("TEXT", "tag")), structure("Using the ", class = c("TEXT", "tag")), structure(list(structure("k", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument is exactly the same a \"plain\" call to ", class = c("TEXT", "tag")), structure(list(structure("filterHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag" ))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), getFields.Rd = structure(list(structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/humdrumR-class.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("getFields", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("getFields", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("-------------------------------------------&gt; NEEDS DOCUMENTATION &lt;-------------------------------------------\n", class = c("TEXT", "tag")), structure("Get named", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("getFields(humdrumR, fieldnames = NULL, dataTypes = \"D\")\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("-------------------------------------------&gt; NEEDS DOCUMENTATION &lt;-------------------------------------------\n", class = c("TEXT", "tag")), structure("Get named\n", class = c("TEXT", "tag" ))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), getTandem.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Apply.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("getTandem", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("getTandem", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Get tandem interpretation information from humdrum data.", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("getTandem(tandem, regex)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Every ", class = c("TEXT", "tag" )), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" object has a field called\n", class = c("TEXT", "tag")), structure(list(structure("Tandem", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" which is a vector of strings which accumulates\n", class = c("TEXT", "tag")), structure("tandem interpretations in each Spine. This function (", class = c("TEXT", "tag")), structure(list(structure("getTandem", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(")\n", class = c("TEXT", "tag")), structure("extracts tandem interpretations from this field, based on a matching\n", class = c("TEXT", "tag")), structure("regular expression. The obligatory ", class = c("TEXT", "tag")), structure(list(structure("'*'", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("does not", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" need to\n", class = c("TEXT", "tag")), structure("be included in the ", class = c("TEXT", "tag")), structure(list(structure("regex", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", as it is added automatically. Thus,\n", class = c("TEXT", "tag")), structure("if you want to find tandem interpretations that match '*clef..', you\n", class = c("TEXT", "tag")), structure("just have to write ", class = c("TEXT", "tag")), structure(list(structure("regex = 'clef..'", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humActive.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/humdrumR-class.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humActive", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humActive", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("evalActive", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("getActive", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("setActive", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("setActiveFields", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("The \"Active expression\" of a humdrumR object.", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("evalActive(\n", class = c("RCODE", "tag")), structure(" humdrumR,\n", class = c("RCODE", "tag")), structure(" dataTypes = \"D\",\n", class = c("RCODE", "tag")), structure(" forceVector = FALSE,\n", class = c("RCODE", "tag")), structure(" sep = \", \",\n", class = c("RCODE", "tag")), structure(" nullAs = NA\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("getActive(humdrumR)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("setActive(humdrumR, form)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("setActiveFields(humdrumR, fieldnames)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" data object.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("dataTypes", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("Which dataTypes of humdrum records to include. Legal values are ", class = c("TEXT", "tag")), structure(list(structure("'G', 'L', 'I', 'M', 'D', 'd', 'P'", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("\n", class = c("TEXT", "tag")), structure("or any combination of these in a single string (e.g., ", class = c("TEXT", "tag")), structure(list(structure("\"LIM\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag")), structure("(see the ", class = c("TEXT", "tag")), structure(list(structure("humdrum table", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" documentation ", class = c("TEXT", "tag")), structure(list(structure("Fields", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" section for an explanation.).", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("forceVector", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure(list( structure("logical", class = c("RCODE", "tag" ))), class = c("tag_code", "tag")), structure(". If ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the result is forced to be an atomic vector.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("sep", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A length-one ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" string. If ", class = c("TEXT", "tag")), structure(list(structure("forceVector == TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" this value is used as a separator\n", class = c("TEXT", "tag")), structure("between tokens that are collapsed.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("nullAsDot", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A single ", class = c("TEXT", "tag")), structure(list(structure("atomic", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" value. Any null tokens are coerced to this value (default is ", class = c("TEXT", "tag")), structure(list(structure(".", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" ))), class = c("tag_arguments", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("This \"Active\" expression is used as the default value in a lot of humdrumR code.\n", class = c("TEXT", "tag")), structure("For one, it is the data which is printed by ", class = c("TEXT", "tag")), structure(list(structure("show", class = c("TEXT", "tag"))), Rd_option = structure("methods:show", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" calls,\n", class = c("TEXT", "tag")), structure("i.e., whenever you return a ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object in the terminal.\n", class = c("TEXT", "tag")), structure("In any expression within a call to\n", class = c("TEXT", "tag")), structure(list(structure("with(in)Humdrum", class = c("TEXT", "tag"))), Rd_option = structure("=withinHumdrum", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(".", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is automatically replaced with the ", class = c("TEXT", "tag")), structure(list(structure("Active", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure("The active expression can be changed with the commands\n", class = c("TEXT", "tag")), structure(list(structure("setActive or the $ operator", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure("This is a handy way to quickly look at different fields in your data.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("The ", class = c("TEXT", "tag" )), structure(list(structure("Active", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression is often just the name of a\n", class = c("TEXT", "tag")), structure(list(structure("field", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(":\n", class = c("TEXT", "tag" )), structure("for instance, the default value is ", class = c("TEXT", "tag")), structure(list(structure("Token", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("However, it can actually be any complex expression which evaluates\n", class = c("TEXT", "tag")), structure("within the ", class = c("TEXT", "tag")), structure(list(structure("humdrum table", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure("For instance, the ", class = c("TEXT", "tag")), structure(list(structure("Active", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression could be:\n", class = c("TEXT", "tag")), structure(list(structure("paste0(Token, \" \", Record)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", which would automatically\n", class = c("TEXT", "tag")), structure("print each Token with its record number pasted to it.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Null data", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("HumdrumR identifies \"null data\" based on the active field.\n", class = c("TEXT", "tag")), structure("Anywhere the current active field evaluates to ", class = c("TEXT", "tag")), structure(list(structure("\".\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("NA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is considered Null data, and assigned the type ", class = c("TEXT", "tag")), structure(list(structure("\"d\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" in the internal\n", class = c("TEXT", "tag")), structure(list(structure("humdrum table", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure("As you work, there will often be data tokens which are null in one field, but not in another field.\n", class = c("TEXT", "tag")), structure("For example, if you load ", class = c("TEXT", "tag")), structure(list(structure("**kern", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" data, a token like ", class = c("TEXT", "tag")), structure(list(structure("\"4r\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (quarter-note rest) token will be ", class = c("TEXT", "tag")), structure(list(structure("NA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" if you call ", class = c("TEXT", "tag")), structure(list(structure("pitch", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", but\n", class = c("TEXT", "tag")), structure("not ", class = c("TEXT", "tag")), structure(list(structure("NA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" if you call ", class = c("TEXT", "tag")), structure(list(structure("recip", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (rhythm).", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("VERB", "tag")), structure("kerndata &lt;- readHumdrum(...)\n", class = c("VERB", "tag")), structure("\n", class = c("VERB", "tag" )), structure("kerndata$Token %hum&gt;% pitch -&gt; kerndata$Pitch\n", class = c("VERB", "tag")), structure("kerndata$Token %hum&gt;% recip -&gt; kerndata$Rhythm\n", class = c("VERB", "tag")), structure("\n", class = c("VERB", "tag" ))), class = c("tag_preformatted", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Now, if you change the active field between ", class = c("TEXT", "tag")), structure(list(structure("Pitch", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("Rhythm", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" you'll see that there\n", class = c("TEXT", "tag")), structure("are different numbers of (non-null) data tokens: ", class = c("TEXT", "tag")), structure(list(structure("ntokens(kerndata$Pitch)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" vs ", class = c("TEXT", "tag")), structure(list(structure("ntokens(kerndata$Rhythm)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will return different numbers!\n", class = c("TEXT", "tag")), structure("(The different would be the number of rest tokens.)\n", class = c("TEXT", "tag")), structure("Similarly, if you apply functions/expressions to this data (using ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" for example), the result will depend on\n", class = c("TEXT", "tag")), structure("what the active field is:", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("VERB", "tag")), structure("kerndata$Pitch %hum&lt;% ~length(Token)\n", class = c("VERB", "tag")), structure("kerndata$Rhythm %hum&lt;% ~length(Token)\n", class = c("VERB", "tag")), structure("\n", class = c("VERB", "tag" ))), class = c("tag_preformatted", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Once again, we'll get different numbers here! (Assuming there are rests in the data.)\n", class = c("TEXT", "tag")), structure("This is the case even though the do-expression isn't actually using the ", class = c("TEXT", "tag")), structure(list(structure("Pitch", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("Rhythm", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" fields!\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag" )), structure(list(structure("Pitch", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is the active field the rest tokens are null-data and will be ignored!\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humAssignment.Rd = structure(list(structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/humdrumR-class.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("humAssignment", class = c("VERB", "tag" ))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humAssignment", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Assigning new fields", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("R objects often have ways of assigning new values to\n", class = c("TEXT", "tag")), structure(list(structure("part", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" of the object using ", class = c("TEXT", "tag")), structure(list(structure("indexing operators", class = c("TEXT", "tag"))), Rd_option = structure("base:Extract", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(structure("HumdrumR objects", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumR:humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" objects are no different, as they allow us to insert\n", class = c("TEXT", "tag")), structure("new fields into them!\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("A new field can be inserted into a ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object in two ways:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag" )), structure(" A field can be copied from one humdrumR object to another if their\n", class = c("TEXT", "tag")), structure("internal ", class = c("TEXT", "tag" )), structure(list(structure("humdrum tables", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" have the exact same number of data tokens (i.e., rows).\n", class = c("TEXT", "tag")), structure("It might not seem obvious, but this mechanism is very useful because it can be used to ", class = c("TEXT", "tag")), structure(list(structure("rename", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" existing fields\n", class = c("TEXT", "tag")), structure("within a humdrumR object (explained below).\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag" )), structure(" A ", class = c("TEXT", "tag")), structure(list( structure("vector", class = c("TEXT", "tag"))), Rd_option = structure("base:vector", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("list of vectors", class = c("TEXT", "tag"))), Rd_option = structure("base:list", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" can be inserted as\n", class = c("TEXT", "tag")), structure("new fields in a humdrumR object.\n", class = c("TEXT", "tag"))), class = c("tag_enumerate", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Fields can be assigned using two syntaxes:", class = c("TEXT", "tag")), structure(list(structure("humdata['fieldname'] &lt;- x\n", class = c("VERB", "tag")), structure("# or\n", class = c("VERB", "tag")), structure("humdata[c('fieldname1', 'fieldname2')] &lt;- x\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("or", class = c("TEXT", "tag")), structure(list(structure("humdata$fieldname &lt;- x\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("where \"fieldname\" can be whatever you want it to be, of course!\n", class = c("TEXT", "tag")), structure(list(structure(list(structure(list( structure("humdrumR -&gt; humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" assignment:", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Assigning a field from one ", class = c("TEXT", "tag")), structure(list(structure("humdrumR object", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumR:humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("to another works like this:\n", class = c("TEXT", "tag")), structure("(Recall that the two objects must have the exact same numbers of data tokens.)\n", class = c("TEXT", "tag")), structure("The name(s) given in the indexing expression on the left side of the assignment (i.e., ", class = c("TEXT", "tag")), structure(list(structure("humdata[c('name1', 'name2')]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or\n", class = c("TEXT", "tag")), structure(list(structure("humdata$name", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") are used as new field names.\n", class = c("TEXT", "tag")), structure("How fields are extracted from the right side of the assignment is a little trickier:\n", class = c("TEXT", "tag")), structure("Any fields in the right-side ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object which are named $PipeN$ (where $N$ is an integer) are copied\n", class = c("TEXT", "tag")), structure("in descending order into the named fields on the left side.\n", class = c("TEXT", "tag")), structure("If there are no $PipeN$ fields on the right side, any fields used in the current Active formula (on the right side)\n", class = c("TEXT", "tag")), structure("are copied instead.\n", class = c("TEXT", "tag")), structure("This system might seem odd at first, but it is very useful in combination with the ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" function,\n", class = c("TEXT", "tag")), structure("or its convenient pipe operator ", class = c("TEXT", "tag")), structure(list(structure("%hum&gt;%", class = c("TEXT", "tag"))), Rd_option = structure("=humPipe", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("When ", class = c("TEXT", "tag" )), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" creates new fields, it calls them $Pipe1 ", class = c("TEXT", "tag")), structure(list(), class = c("tag_ldots", "tag")), structure(" Pipe2 ", class = c("TEXT", "tag")), structure(list(), class = c("tag_ldots", "tag")), structure(" PipeN$.\n", class = c("TEXT", "tag")), structure("Since the output of ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is always the same as the input except with these new \"Pipe\" fields,\n", class = c("TEXT", "tag")), structure("Byou can use ", class = c("TEXT", "tag")), structure(list(structure("humdrumR &lt;- humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" assignment to immediately assign these pipe fields more meaningful names in the original object.\n", class = c("TEXT", "tag")), structure("This makes the most sense with an example:", class = c("TEXT", "tag")), structure(list(structure("humdata$Semits &lt;- humdata %hum&gt;% ~semit(Token) \n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("In humdrumR, we actually favor the left-to-right \"piping\" style.\n", class = c("TEXT", "tag")), structure("Luckily, R allows you to assign left-to-right, so the proper humdrumR style is actually:", class = c("TEXT", "tag")), structure(list(structure("humdata %hum&gt;% ~semit(Token) -&gt; humdata$Semits\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Calls to ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (or ", class = c("TEXT", "tag")), structure(list(structure("%hum&gt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(") keep producing new pipe fields.\n", class = c("TEXT", "tag")), structure("If there are more than one pipe fields, you can assign multiple fields at once using the ", class = c("TEXT", "tag")), structure(list(structure("[]&lt;-", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" syntax:", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("VERB", "tag")), structure("humdata %hum&gt;% ~semit(Token) %hum&gt;% ~pitch(Token) -&gt; humdata[c('semit', 'pitch')]\n", class = c("VERB", "tag")), structure("\n", class = c("VERB", "tag" ))), class = c("tag_preformatted", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("#' ", class = c("TEXT", "tag")), structure(list(structure("IMPORTANT NOTE!", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(": Any \"PipeN\" fields in the humdrumR object you assign from\n", class = c("TEXT", "tag")), structure("that you don't assign field names are simply dropped.\n", class = c("TEXT", "tag")), structure("This is nice, because often you might proceed through a serious of piped steps, but you only\n", class = c("TEXT", "tag")), structure("want the last one (or two).\n", class = c("TEXT", "tag")), structure("If you want to keep all your pipe fields either don't re-assign them at all (i.e., keep the \"PipeN\" names)\n", class = c("TEXT", "tag")), structure("or assign them all names using the ", class = c("TEXT", "tag")), structure(list(structure("-&gt;[c(\"name1\", \"name2\", \"name3\", ...)]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" syntax.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure(list(structure("humdrumR -&gt; vector", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" assignment:", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("You can assign vectors or lists of vectors straight into a ", class = c("TEXT", "tag")), structure(list(structure("humdrumR object", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumR:humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure("All vectors must be the same length as the number of data tokens\n", class = c("TEXT", "tag")), structure("in the target object.\n", class = c("TEXT", "tag")), structure("If you provide multiple vectors to assign (as a ", class = c("TEXT", "tag")), structure(list(structure("list", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("data.frame", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" of vectors)\n", class = c("TEXT", "tag")), structure("you must provide the same number of fieldnames using the ", class = c("TEXT", "tag")), structure(list(structure("-&gt;[c('name1', 'name2', ...)]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" syntax.\n", class = c("TEXT", "tag")), structure("You can use the ", class = c("TEXT", "tag")), structure(list(structure("ntokens", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" command to determine the right length of vectors you need!\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humCensus.Rd = structure(list(structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Summary.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("humCensus", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("humCensus", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("census", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("[.humCensus", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("print.humCensus", class = c("VERB", "tag" ))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Tabulate records and tokens in a humdrumR corpus", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("census(humdrumR, dataTypes = \"GLIMDd\", by = \"Filename\", removeEmpty = FALSE)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag")), structure("census(humdata)[i]\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("print", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humCensus", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(censusTable, showEach = TRUE, screenWidth = options(\"width\")$width - 10L)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A humdrumR object", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("dataTypes", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" string of length 1.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("by", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" string of length 1. Must be a ", class = c("TEXT", "tag")), structure(list(structure("field", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" in the humdrumR object.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag" )), structure("\n", class = c("TEXT", "tag"))), class = c("tag_arguments", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure(list( structure("census", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is one of ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("'s\n", class = c("TEXT", "tag")), structure(list(structure("summary functions", class = c("TEXT", "tag"))), Rd_option = structure("=humSummary", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(", used to\n", class = c("TEXT", "tag")), structure("tabulate the raw size of a ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" corpus.\n", class = c("TEXT", "tag")), structure(list(structure("census", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" takes a ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" object\n", class = c("TEXT", "tag")), structure("and and returns a ", class = c("TEXT", "tag")), structure(list(structure("humCensus", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" table.\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag" )), structure(list(structure("dataType", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument controls what types of records to tabulate:\n", class = c("TEXT", "tag")), structure("legal values are ", class = c("TEXT", "tag")), structure(list(structure("'G', 'L', 'I', 'M', 'D', 'd'", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("\n", class = c("TEXT", "tag")), structure("or any combination of these (e.g., ", class = c("TEXT", "tag")), structure(list(structure("\"LIM\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag")), structure("The default is ", class = c("TEXT", "tag")), structure(list(structure("\"D\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("A ", class = c("TEXT", "tag")), structure(list( structure("humCensus", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" table has five columns of information:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag" )), structure(" Records\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" The total number of records.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Tokens\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" The total number of tokens.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" (unique)\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" The number of ", class = c("TEXT", "tag")), structure(list(structure("unique", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" tokens\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Characters\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" The total numder of characters. This includes humdrum control characters like ", class = c("TEXT", "tag")), structure(list(structure("*", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("!!", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" (per token)\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" This is simply ", class = c("TEXT", "tag")), structure(list(structure("Characters / Tokens", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", indicating the mean length of each token.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_enumerate", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("A ", class = c("TEXT", "tag")), structure(list(structure("humCensus", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" table has one row for each file in the corpus.\n", class = c("TEXT", "tag")), structure("Rows are labeled with each file's corresponding\n", class = c("TEXT", "tag")), structure("number (from the ", class = c("TEXT", "tag")), structure(list(structure("humTable's", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list( structure("File", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" field) and name (the ", class = c("TEXT", "tag")), structure(list(structure("Filename", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" field).\n", class = c("TEXT", "tag")), structure("In addition, when a ", class = c("TEXT", "tag")), structure(list(structure("humCensus", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object is printed,\n", class = c("TEXT", "tag")), structure("the totals across all files are printed as well---(unique) and (per token)\n", class = c("TEXT", "tag")), structure("across all files are calculated across all files as well, not summed.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Indexing", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Rows of a ", class = c("TEXT", "tag" )), structure(list(structure("humCensus", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object can be selected with a single argument ", class = c("TEXT", "tag")), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(": e.g., ", class = c("TEXT", "tag")), structure(list(structure("censusTable[i]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag")), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is ", class = c("TEXT", "tag")), structure(list(structure("numeric", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the corresponding rows are selected ordinally (not by ", class = c("TEXT", "tag")), structure(list(structure("File", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" number).\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag" )), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is a ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" string, this string is mached as a regular expression against file names.\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag" )), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is a formula, the right-hand side of the formula is evaluated within the table---if it evaluates to a logical vector,\n", class = c("TEXT", "tag")), structure("files are selected accordingly. For instance,\n", class = c("TEXT", "tag")), structure(list(structure("censusTable[~Tokens &gt; 100]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will select all files\n", class = c("TEXT", "tag")), structure("with more than 100 tokens. (The '(unique)' and '(per token)' columns\n", class = c("TEXT", "tag")), structure("must be referred to with their names enclosed in ", class = c("TEXT", "tag")), structure(list(structure("\\``---for example, ", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("censusTable", class = c("TEXT", "tag")), structure(list(structure("~\\verb", class = c("TEXT", "tag")), structure(list(structure("(unique)\\", class = c("TEXT", "tag"))), class = c("LIST", "tag")), structure(" &gt; 100", class = c("TEXT", "tag"))), Rd_option = structure("=~\\`(unique)\\` &gt; 100", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("` will return all files with\n", class = c("TEXT", "tag")), structure("more than 100 unique tokens.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("A ", class = c("TEXT", "tag")), structure(list( structure("drop", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument is also available. If ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", a plain\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("data.table::data.table()", class = c("TEXT", "tag"))), Rd_option = structure("data.table:data.table", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(" is returned.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Other humdrum data summary functions: \n", class = c("TEXT", "tag")), structure(list(structure(list(structure("humInterpretations", class = c("TEXT", "tag"))), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("humSpines", class = c("TEXT", "tag"))), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag" )), structure(list(structure(list(structure("humSummary", class = c("TEXT", "tag"))), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("humdrum data summary functions", class = c("TEXT", "tag"))), class = c("tag_concept", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humCoercion.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/humdrumR-class.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humCoercion", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humCoercion", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("as.lines", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("as.matrix.humdrumR", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("as.matrices", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("as.data.frames", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR Coercion.", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure(list(structure(list(structure("as.vector", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(x, mode = \"any\")\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("as.lines(\n", class = c("RCODE", "tag" )), structure(" humdrumR,\n", class = c("RCODE", "tag")), structure(" dataTypes = \"GLIMDd\",\n", class = c("RCODE", "tag")), structure(" fieldname = NULL,\n", class = c("RCODE", "tag")), structure(" alignColumns = FALSE,\n", class = c("RCODE", "tag")), structure(" padPaths = FALSE,\n", class = c("RCODE", "tag")), structure(" padder = \"\"\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure(list( structure(list(structure("as.matrix", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(\n", class = c("RCODE", "tag" )), structure(" x,\n", class = c("RCODE", "tag")), structure(" dataTypes = \"D\",\n", class = c("RCODE", "tag")), structure(" fieldnames = NULL,\n", class = c("RCODE", "tag")), structure(" alignColumns = TRUE,\n", class = c("RCODE", "tag")), structure(" padder = NA,\n", class = c("RCODE", "tag")), structure(" path.fold = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("as.data.frame", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(\n", class = c("RCODE", "tag")), structure(" x,\n", class = c("RCODE", "tag")), structure(" dataTypes = \"D\",\n", class = c("RCODE", "tag")), structure(" fieldname = NULL,\n", class = c("RCODE", "tag")), structure(" padder = NA,\n", class = c("RCODE", "tag")), structure(" fold.path = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("as.matrices(\n", class = c("RCODE", "tag")), structure(" humdrumR,\n", class = c("RCODE", "tag")), structure(" dataTypes = \"D\",\n", class = c("RCODE", "tag")), structure(" fieldnames = NULL,\n", class = c("RCODE", "tag")), structure(" padder = NA,\n", class = c("RCODE", "tag")), structure(" path.fold = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("as.data.frames(\n", class = c("RCODE", "tag")), structure(" humdrumR,\n", class = c("RCODE", "tag")), structure(" dataTypes = \"D\",\n", class = c("RCODE", "tag")), structure(" fieldnames = NULL,\n", class = c("RCODE", "tag")), structure(" padder = NA,\n", class = c("RCODE", "tag")), structure(" path.fold = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("mode", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("If the ", class = c("TEXT", "tag")), structure(list(structure("mode", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument is not ", class = c("TEXT", "tag")), structure(list(structure("'any'", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", it can be a single ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("string naming an atomic mode---the output will be coerced to this mode (if possible).", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("dataTypes", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("Which types of humdrum records to include. Legal values are ", class = c("TEXT", "tag")), structure(list(structure("'G', 'L', 'I', 'M', 'D', 'd'", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("\n", class = c("TEXT", "tag")), structure("or any combination of these (e.g., ", class = c("TEXT", "tag")), structure(list(structure("\"LIM\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag")), structure("(see the ", class = c("TEXT", "tag")), structure(list(structure("humdrum table", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" documentation ", class = c("TEXT", "tag")), structure(list(structure("Fields", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" section for explanation.).", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("padder", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("An atomic value of length one. If ", class = c("TEXT", "tag")), structure(list(structure("par.files", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("pad.paths", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" are true, the ", class = c("TEXT", "tag")), structure(list(structure("padder", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("argument is used to fill in the desired gaps.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("pad.files", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure(list( structure("logical", class = c("RCODE", "tag" ))), class = c("tag_code", "tag")), structure(" (default ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("). If any pieces in the ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" corpus have fewer\n", class = c("TEXT", "tag")), structure(list(structure("[humdrumR:humTable][spines/columns]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" than the maximum, should they be padded with the ", class = c("TEXT", "tag")), structure(list(structure("padder", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument (", class = c("TEXT", "tag")), structure(list(structure("par.files == TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") or\n", class = c("TEXT", "tag")), structure("should an an error occur (", class = c("TEXT", "tag")), structure(list(structure("pad.files == FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(")? Note that these \"padded\" points are not represented in the original humdrum data.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("pad.paths", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure(list( structure("logical", class = c("RCODE", "tag" ))), class = c("tag_code", "tag")), structure(" If any spine path splits (", class = c("TEXT", "tag")), structure(list(structure("'*^'", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") occur in the humdrumR data, should they be padded\n", class = c("TEXT", "tag")), structure("with the ", class = c("TEXT", "tag")), structure(list(structure("padder", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument (", class = c("TEXT", "tag")), structure(list(structure("par.files == TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") or\n", class = c("TEXT", "tag")), structure("should an an error occur (", class = c("TEXT", "tag")), structure(list(structure("pad.paths == FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(")?\n", class = c("TEXT", "tag")), structure("Note that these \"padded\" points are not represented in the original humdrum data.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("field(s)", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("If the ", class = c("TEXT", "tag")), structure(list(structure("field", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument is ", class = c("TEXT", "tag")), structure(list(structure("not", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", it can instead be a ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" string matching\n", class = c("TEXT", "tag")), structure("the ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" object's fields. If so, these fields are extracted instead of the\n", class = c("TEXT", "tag")), structure(list(structure("Active expression", class = c("TEXT", "tag"))), Rd_option = structure("=humActive", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure("For calls to ", class = c("TEXT", "tag")), structure(list(structure("as.vector", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("as.data.frame", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", only one field can be extracted.\n", class = c("TEXT", "tag")), structure("However, for calls to ", class = c("TEXT", "tag")), structure(list(structure("as.matrix", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", multiple fields can be extraced---these fields will be\n", class = c("TEXT", "tag")), structure("returned in a third matrix dimension, each field forming one rectangular slice.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" ))), class = c("tag_arguments", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Many users may wish to work with humdrum data without\n", class = c("TEXT", "tag")), structure("using the ", class = c("TEXT", "tag")), structure(list(structure("[humdrumR:humdrumR][humdrumR]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" API, instead using\n", class = c("TEXT", "tag")), structure("basic ", class = c("TEXT", "tag" )), structure(list(structure("R", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data types.\n", class = c("TEXT", "tag")), structure("For this purpose, ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" data objects can be coerced to\n", class = c("TEXT", "tag")), structure("basic ", class = c("TEXT", "tag" )), structure(list(structure("R", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data types.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("as.vector(humdata)", class = c("TEXT", "tag"))), Rd_option = structure("base:vector", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" evaluates the ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" object's\n", class = c("TEXT", "tag")), structure(list(structure("Active", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" expression, and (attempts) to force the result to a vector of mode. This\n", class = c("TEXT", "tag")), structure("method is essentially a wrapper for ", class = c("TEXT", "tag")), structure(list(structure("evalActive", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("as.matrix(humdata", class = c("TEXT", "tag"))), Rd_option = structure("base:matrix", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" also evaluates the ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" object's\n", class = c("TEXT", "tag")), structure(list(structure("Active", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" expression, but wraps it into a matrix of dimensions ", class = c("TEXT", "tag")), structure(list(structure("c([humdrumR:humSize][nrow(humdata), ncol(humdata)])", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Note that \"", class = c("TEXT", "tag")), structure(list(structure("[humdrumR:humTable][Columns]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("\" in humdrum data are not necesarily the same as spines.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(structure("as.data.frame(humdata)", class = c("TEXT", "tag"))), Rd_option = structure("base:as.data.frame", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" first calls ", class = c("TEXT", "tag")), structure(list(structure("as.matrix", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" then converts the matrix to a ", class = c("TEXT", "tag")), structure(list(structure("data.frame", class = c("TEXT", "tag"))), Rd_option = structure("base:data.frame", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure(list(structure("as.data.table(humdata)", class = c("TEXT", "tag"))), Rd_option = structure("data.table:as.data.table", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" first calls ", class = c("TEXT", "tag")), structure(list(structure("as.matrix", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" then converts the matrix to a ", class = c("TEXT", "tag")), structure(list(structure(list(structure("data.table::data.table()", class = c("TEXT", "tag"))), Rd_option = structure("data.table:data.table", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(structure("as.matrices", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("as.data.frames", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", and ", class = c("TEXT", "tag")), structure(list(structure("as.data.tables", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" call ", class = c("TEXT", "tag")), structure(list(structure("as.matrix", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("/", class = c("TEXT", "tag")), structure(list(structure("as.data.frame", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("/", class = c("TEXT", "tag")), structure(list(structure("as.data.table", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("on each individual file in a ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" corpus, returning a list of matices/data.frames/data.tables.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humColumns.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/humdrumR-class.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humColumns", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humColumns", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Spines vs Paths vs Columns", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("In the ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("http://www.humdrum.org/guide/ch05/", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("humdrum syntax", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(", data is placed in \"spines,\"\n", class = c("TEXT", "tag")), structure("which are not the same as \"columns\" in a spreadsheet. A \"column\" refers to a\n", class = c("TEXT", "tag")), structure("tab-delineated group of values.\n", class = c("TEXT", "tag")), structure("\"Spines\" can be a single column, or they may (at any time) split into multiple columns,\n", class = c("TEXT", "tag")), structure("which can in turn split again, using the ", class = c("TEXT", "tag")), structure(list(structure("\"*^\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" interpretation token. The reverse can happen as well,\n", class = c("TEXT", "tag")), structure("with two or more columns merging into a single column, using the ", class = c("TEXT", "tag")), structure(list(structure("\"v\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" token.\n", class = c("TEXT", "tag")), structure("This means that, while humdrum data at first glance looks like a simple two-dimensional table,\n", class = c("TEXT", "tag")), structure("it is actually a flexible tree structure. As spines split and merge, the total number of columns\n", class = c("TEXT", "tag")), structure("can change during a piece, creating a \"ragged\" edge.\n", class = c("TEXT", "tag")), structure("Another similar issue is that a corpus of humdrum files may have varying numbers of spines/columns, between pieces.\n", class = c("TEXT", "tag")), structure("(\"Global\" comment/reference records are also a special case, as that are always a single value, even if interspersed with\n", class = c("TEXT", "tag")), structure("multi-column local records.)\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("In ", class = c("TEXT", "tag" )), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(", spines, columns, and spine paths work like this.\n", class = c("TEXT", "tag")), structure("First of all, we actually assume a slightly more strict version of the humdrum syntax:\n", class = c("TEXT", "tag")), structure("we assume that all the spines which appear at the beginning of a file (headed with exlusive interpretations\n", class = c("TEXT", "tag")), structure("like ", class = c("TEXT", "tag" )), structure(list(structure("\"**kern\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") can never merge into each other. Thus, a humdrum file read into ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("must not end with fewer columns than it starts.\n", class = c("TEXT", "tag")), structure("Spine merges (", class = c("TEXT", "tag")), structure(list(structure("\"*v\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") can only happen within spine paths that originally split off the same spine.\n", class = c("TEXT", "tag")), structure("This extra-strict specification of spine paths in the humdrum syntax is, fortunately, something that has been\n", class = c("TEXT", "tag")), structure("informally followed in most humdrum datasets.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Our strict spine-path definition makes everything work fairly simply:\n", class = c("TEXT", "tag")), structure("Within a piece, the spines which appear at the beginning of the piece are the \"true\" spines through the rest of the piece, numbered\n", class = c("TEXT", "tag")), structure("from left to right, starting from ", class = c("TEXT", "tag")), structure(list(structure("1L", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("For each local token, the value in the ", class = c("TEXT", "tag")), structure(list(structure("Spine", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field is an integer indicating which of these\n", class = c("TEXT", "tag")), structure("\"true\" spines it belongs to---global tokens have a ", class = c("TEXT", "tag")), structure(list(structure("NA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" value in their ", class = c("TEXT", "tag")), structure(list(structure("Spine", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field, because they are considerd to not belong to any spine.\n", class = c("TEXT", "tag")), structure("Any spine path splits (", class = c("TEXT", "tag")), structure(list(structure("\"*^\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" from the main spines form subspines, which we call ", class = c("TEXT", "tag")), structure(list(structure("Paths", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Every spine's paths are numbered, from right to left, starting from ", class = c("TEXT", "tag")), structure(list(structure("0L", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("A spine with no splits will have all ", class = c("TEXT", "tag")), structure(list(structure("0L", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s in its ", class = c("TEXT", "tag")), structure(list(structure("Path", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Columns", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("It is very useful to sometimes turn humdrum data into a true two dimensional structure, with no ragged edges.\n", class = c("TEXT", "tag")), structure("(This always requires removing global records.)\n", class = c("TEXT", "tag")), structure("In order to do this, while maintaining a sensible relationship between spine which have spine paths,\n", class = c("TEXT", "tag")), structure(list(structure("humRead", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" automatically ", class = c("TEXT", "tag")), structure(list(structure("pads", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" humdrum data into a complete, non-ragged 2d table.\n", class = c("TEXT", "tag")), structure("For instance, given this file", class = c("TEXT", "tag")), structure(list(structure("**kern **kern\n", class = c("VERB", "tag")), structure("A E\n", class = c("VERB", "tag")), structure("*^ *\n", class = c("VERB", "tag")), structure("A C E\n", class = c("VERB", "tag")), structure("G B D\n", class = c("VERB", "tag")), structure("*v *v *\n", class = c("VERB", "tag")), structure("A C \n", class = c("VERB", "tag")), structure("*- *-\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("humRead", class = c("TEXT", "tag" ))), class = c("tag_link", "tag")), structure(" pads the file as so:", class = c("TEXT", "tag")), structure(list(structure("**kern _P **kern\n", class = c("VERB", "tag")), structure("A _P E\n", class = c("VERB", "tag")), structure("*^ _P *\n", class = c("VERB", "tag")), structure("A C E\n", class = c("VERB", "tag")), structure("G B D\n", class = c("VERB", "tag")), structure("*v *v *\n", class = c("VERB", "tag")), structure("A _P C \n", class = c("VERB", "tag")), structure("*- _P *-\n", class = c("VERB", "tag")), structure("\n", class = c("VERB", "tag" )), structure("##########################################\n", class = c("VERB", "tag")), structure("1 1 2 Spine\n", class = c("VERB", "tag")), structure("0 1 0 Path\n", class = c("VERB", "tag")), structure("1 2 3 Column\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("(In this example, the ", class = c("TEXT", "tag")), structure(list(structure("Spine", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("Path", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", and ", class = c("TEXT", "tag")), structure(list(structure("Column", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" values are shown below the data.)\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag")), structure(list(structure("\"_P\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" tokens stand for \"padded path.\"\n", class = c("TEXT", "tag")), structure("This appraoch assures that every ", class = c("TEXT", "tag")), structure(list(structure("Spine", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" is a contiguous block of tokens, of constant width.\n", class = c("TEXT", "tag")), structure("In most humdrumR use cases, these padding tokens (and the ", class = c("TEXT", "tag")), structure(list(structure("Column", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field) can be safely ignored.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Corpus padding", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humRead", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" automatically pads spine paths ", class = c("TEXT", "tag")), structure(list(structure("within pieces", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("However, as mentioned above, there is also (sometimes) a need to pad across pieces, in order\n", class = c("TEXT", "tag")), structure("to create a logical, clean 2d structure.\n", class = c("TEXT", "tag")), structure("Consider this example, with humdrum data from two pieces:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Piece 1", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(":", class = c("TEXT", "tag")), structure(list(structure("**kern **kern **kern\n", class = c("VERB", "tag")), structure("E D C\n", class = c("VERB", "tag")), structure("D . .\n", class = c("VERB", "tag")), structure("C C E\n", class = c("VERB", "tag")), structure("*- *- *-\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag" )), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Piece 2", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(":", class = c("TEXT", "tag")), structure(list(structure("**kern **kern\n", class = c("VERB", "tag")), structure("A A\n", class = c("VERB", "tag")), structure(". B\n", class = c("VERB", "tag")), structure("C C\n", class = c("VERB", "tag")), structure("*- *-\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag" ))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("In this example, we have two pieces, one with three spines, the other with two.\n", class = c("TEXT", "tag")), structure("There is no way to squish these two pieces into one regular 2d table.\n", class = c("TEXT", "tag")), structure("But we ", class = c("TEXT", "tag")), structure(list(structure("could", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" pad any missing columns, as so:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Piece 1", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(":", class = c("TEXT", "tag")), structure(list(structure("**kern **kern **kern\n", class = c("VERB", "tag")), structure("E D C\n", class = c("VERB", "tag")), structure("D . .\n", class = c("VERB", "tag")), structure("C C E\n", class = c("VERB", "tag")), structure("*- *- *-\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag" )), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Piece 2", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(":", class = c("TEXT", "tag")), structure(list(structure("**kern **kern _C\n", class = c("VERB", "tag")), structure("A A _C\n", class = c("VERB", "tag")), structure(". B _C\n", class = c("VERB", "tag")), structure("C C _C\n", class = c("VERB", "tag")), structure("*- *- _C\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag" ))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("The function ", class = c("TEXT", "tag")), structure(list(structure("alignColumns", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is used to achieve just this effect.\n", class = c("TEXT", "tag")), structure("In this example, the ", class = c("TEXT", "tag")), structure(list(structure("\"_C\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" token stands for \"padded column.\"\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("The presence of spine paths makes padding columns across pieces a bit more complicated.\n", class = c("TEXT", "tag")), structure("What ", class = c("TEXT", "tag")), structure(list(structure("alignColumns", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will do, is match up all pieces in a corpus so that\n", class = c("TEXT", "tag")), structure("every ", class = c("TEXT", "tag")), structure(list(structure("Spine", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure("/", class = c("TEXT", "tag")), structure(list( structure("Path", class = c("TEXT", "tag" ))), class = c("tag_strong", "tag")), structure(" field pair allign in the same column.\n", class = c("TEXT", "tag")), structure("Here is an example, with its paths already padded:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Piece 1", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(":", class = c("TEXT", "tag")), structure(list(structure("**kern _P **kern\n", class = c("VERB", "tag")), structure("A _P E\n", class = c("VERB", "tag")), structure("B _P D\n", class = c("VERB", "tag")), structure("*^ _P *\n", class = c("VERB", "tag")), structure("A C E\n", class = c("VERB", "tag")), structure("G# B E\n", class = c("VERB", "tag")), structure("*v *v *\n", class = c("VERB", "tag")), structure("A _P E\n", class = c("VERB", "tag")), structure("*- _P *-\n", class = c("VERB", "tag")), structure("#################################################\n", class = c("VERB", "tag")), structure("1 1 2 Spine\n", class = c("VERB", "tag")), structure("0 1 0 Path\n", class = c("VERB", "tag")), structure("1 2 3 Column\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag" )), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Piece 2", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(":", class = c("TEXT", "tag")), structure(list(structure("**kern **kern _P\n", class = c("VERB", "tag")), structure("A E _P\n", class = c("VERB", "tag")), structure("* *^ _P\n", class = c("VERB", "tag")), structure("G# D F\n", class = c("VERB", "tag")), structure("A C E\n", class = c("VERB", "tag")), structure("* *v *v\n", class = c("VERB", "tag")), structure("E D _P\n", class = c("VERB", "tag")), structure("*- *- _P \n", class = c("VERB", "tag")), structure("#################################################\n", class = c("VERB", "tag")), structure("1 2 2 Spine\n", class = c("VERB", "tag")), structure("0 0 1 Path\n", class = c("VERB", "tag")), structure("1 2 3 Column\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag" ))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("We have two pieces, each with two spines,\n", class = c("TEXT", "tag")), structure("but in the first piece, the first spine splits, while in the second piece, the\n", class = c("TEXT", "tag")), structure("second spine splits. Thus, the padded output will have four columns:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Piece 1", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(":", class = c("TEXT", "tag")), structure(list(structure("**kern _P **kern _C\n", class = c("VERB", "tag")), structure("A _P E _C\n", class = c("VERB", "tag")), structure("B _P D _C\n", class = c("VERB", "tag")), structure("*^ _P * _C\n", class = c("VERB", "tag")), structure("A C E _C\n", class = c("VERB", "tag")), structure("G# B E _C\n", class = c("VERB", "tag")), structure("*v *v * _C\n", class = c("VERB", "tag")), structure("A _P E _C\n", class = c("VERB", "tag")), structure("*- _P *- _C \n", class = c("VERB", "tag")), structure("###########################################################\n", class = c("VERB", "tag")), structure("1 1 2 2 Spine\n", class = c("VERB", "tag")), structure("0 1 0 1 Path\n", class = c("VERB", "tag")), structure("1 2 3 4 Column\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag" )), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Piece 2", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(":", class = c("TEXT", "tag")), structure(list(structure("**kern _C **kern _P\n", class = c("VERB", "tag")), structure("A _C E _P\n", class = c("VERB", "tag")), structure("* _C *^ _P\n", class = c("VERB", "tag")), structure("G# _C D F\n", class = c("VERB", "tag")), structure("A _C C E\n", class = c("VERB", "tag")), structure("* _C *v *v\n", class = c("VERB", "tag")), structure("E _C D _P\n", class = c("VERB", "tag")), structure("*- _C *- _P \n", class = c("VERB", "tag")), structure("######################################################### \n", class = c("VERB", "tag")), structure("1 1 2 2 Spine\n", class = c("VERB", "tag")), structure("0 1 0 1 Path\n", class = c("VERB", "tag")), structure("1 2 3 4 Column\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag" ))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Note that ", class = c("TEXT", "tag")), structure(list(structure("alignColumns", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" actually adds rows to the ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" object's\n", class = c("TEXT", "tag")), structure("internal ", class = c("TEXT", "tag")), structure(list(structure("humdrum tables", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humFormulae.Rd = structure(list(structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Formulae.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("data", class = c("TEXT", "tag"))), class = c("tag_docType", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("humFormulae", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("humFormulae", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("ditto", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("Standard humdrumR formulae.", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("An object of class ", class = c("TEXT", "tag")), structure(list(structure("list", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" of length 3.\n", class = c("TEXT", "tag"))), class = c("tag_format", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("ditto\n", class = c("RCODE", "tag" ))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" predefines a few ", class = c("TEXT", "tag")), structure(list(structure("with(in)humdrum", class = c("TEXT", "tag"))), Rd_option = structure("=withinHumdrum", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" command combinations, as R formulae or lists of formulae.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag" )), structure(" ", class = c("TEXT", "tag")), structure(list( structure("ditto", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" calls ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("fillThru()", class = c("TEXT", "tag"))), Rd_option = structure("=fillThru", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(" across pieces/spines/paths, replicating the classic humdrum toolkit ditto command.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("datasets", class = c("TEXT", "tag"))), class = c("tag_keyword", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humInterpretations.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Summary.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humInterpretations", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humInterpretations", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("interpretations", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("print.humInterpretations", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Summarize humdrum corpus interpretations.", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("interpretations(humdrumR)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("print", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humInterpretations", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(interps, showEach = TRUE, screenWidth = options(\"width\")$width - 10L)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("This function provides a summary of the interpretations in the pieces of a humdrumR corpus.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Other humdrum data summary functions: \n", class = c("TEXT", "tag")), structure(list(structure(list(structure("humCensus", class = c("TEXT", "tag"))), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag" )), structure(list(structure(list(structure("humSpines", class = c("TEXT", "tag"))), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag" )), structure(list(structure(list(structure("humSummary", class = c("TEXT", "tag"))), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrum data summary functions", class = c("TEXT", "tag"))), class = c("tag_concept", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humMerge.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/humdrumR-class.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humMerge", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humMerge", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("mergeHumdrum", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Merge two (or more) humdrumR datasets", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("mergeHumdrum(...)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("-------------------------------------------&gt; NEEDS DOCUMENTATION &lt;-------------------------------------------\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humMeter.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/rhythmInterval.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humMeter", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humMeter", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Tools for analyzing rhythm and meter.", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" includes a number of useful\n", class = c("TEXT", "tag")), structure("functions for working with rhythms and meter.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure(list(structure("rhythmDecompose()", class = c("TEXT", "tag"))), Rd_option = structure("=rhythmDecompose", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(" decomposes a series of rhythms in terms of desired pulses.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("rhythmOffset()", class = c("TEXT", "tag"))), Rd_option = structure("=rhythmOffset", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(" Calculates the cummulative offset of durations from a starting point.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humPipe.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Piping.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humPipe", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humPipe", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("%hum&gt;%", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("%hum&lt;%", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("%humT%", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("%s&gt;%", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("%hums&gt;%", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("%hums&lt;%", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("%humsT%", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("%hums[]%", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Piping humdrumR data", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("humdrumR %hum&gt;% formula\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdrumR %hum&lt;% formula\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdrumR %humT% formula\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("e1 %s&gt;% e2\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("list %hums&gt;% formula\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("list %hums&lt;% formula\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("list %humsT% formula\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("list %hums[]% formula\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("These infix operators make it possible to use\n", class = c("TEXT", "tag")), structure("the ", class = c("TEXT", "tag" )), structure(list(structure("[humdrumR:with-in-Humdrum][with(in)Humdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("\n", class = c("TEXT", "tag")), structure("functions in a piping style, similar to the ", class = c("TEXT", "tag")), structure(list(structure("|", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (pipe)\n", class = c("TEXT", "tag")), structure("in unix-style terminals, or the ", class = c("TEXT", "tag")), structure(list(structure("|&gt;", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" pipe operator.\n", class = c("TEXT", "tag")), structure("from the R package ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://cran.r-project.org/web/packages/magrittr/index.html", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("magrittr", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(".\n", class = c("TEXT", "tag" ))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("The key is that the function ", class = c("TEXT", "tag")), structure(list(structure("[withinHumdrum][withinHumdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" always returns a new\n", class = c("TEXT", "tag")), structure(list(structure("[humdrumR][humdrumR]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" data object. Thus, you can always send the output\n", class = c("TEXT", "tag")), structure("of ", class = c("TEXT", "tag" )), structure(list(structure("[withinHumdrum][withinHumdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" back in to a new call of ", class = c("TEXT", "tag")), structure(list(structure("[withinHumdrum][withinHumdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("This is exactly what the ", class = c("TEXT", "tag")), structure(list(structure("%hum&gt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" is for: on the left-hand side,\n", class = c("TEXT", "tag")), structure("input a ", class = c("TEXT", "tag")), structure(list(structure("[humdrumR][humdrumR]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" object, on the right-hand side suitable\n", class = c("TEXT", "tag")), structure("arguments to ", class = c("TEXT", "tag")), structure(list(structure("[withinHumdrum][withinHumdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" (i.e., a formula, a function, or list of formulae,\n", class = c("TEXT", "tag")), structure("functions, and named arguments). You can then chain this call with another call to\n", class = c("TEXT", "tag")), structure(list(structure("%hum&gt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" and more ", class = c("TEXT", "tag")), structure(list(structure("[withinHumdrum][withinHumdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" arguments.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("%hum&lt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" acts the same way as ", class = c("TEXT", "tag")), structure(list(structure("%hum&gt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" except it calls ", class = c("TEXT", "tag")), structure(list(structure("[withHumdrum][withinHumdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Since ", class = c("TEXT", "tag")), structure(list(structure("[withHumdrum][withinHumdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" does ", class = c("TEXT", "tag")), structure(list(structure("not", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" return a ", class = c("TEXT", "tag")), structure(list(structure("[humdrumR][humdrumR]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(",\n", class = c("TEXT", "tag")), structure("the output can't be piped any further (using ", class = c("TEXT", "tag")), structure(list(structure("%hum&gt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("%hum&lt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(").\n", class = c("TEXT", "tag")), structure("Thus, ", class = c("TEXT", "tag")), structure(list(structure("\\%hum&lt;\\%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" should only be used as the last step in a pipe---you would do this\n", class = c("TEXT", "tag")), structure("if you want to extract the last step in your pipe from the data's ", class = c("TEXT", "tag")), structure(list(structure("[humdrumR:humtable][Humdrum Table]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" into\n", class = c("TEXT", "tag")), structure("a normal vector or list of R data.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("' ", class = c("TEXT", "tag")), structure(list(structure("\\%humT\\%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" creates a \"T\" in the pipe, applying the desired expression but not keeping the result---the unaltered\n", class = c("TEXT", "tag")), structure("humdrumR input object is returned. This works simply by replacing all ", class = c("TEXT", "tag")), structure(list(structure("do~", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" with ", class = c("TEXT", "tag")), structure(list(structure("doplot~", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" in a call to\n", class = c("TEXT", "tag")), structure(list(structure("[withinHumdrum][withinHumdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(". The purpose of this option, is if you want to apply expressions for their\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Side_effect_(computer_science)", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("side effects", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(",\n", class = c("TEXT", "tag" )), structure("for instance, for plotting.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(structure("%hum[]%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" is similar to ", class = c("TEXT", "tag")), structure(list(structure("%hum&gt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" except it apply the formulae on its right-hand\n", class = c("TEXT", "tag")), structure("side using ", class = c("TEXT", "tag")), structure(list(structure("[humdrumR][filterHumdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(". Thus, it can be used to filter/index\n", class = c("TEXT", "tag")), structure("a ", class = c("TEXT", "tag" )), structure(list(structure("[humdrumR][humdrumR]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" data object on the fly.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Plural pipes", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("In R we often apply the same function to a ", class = c("TEXT", "tag")), structure(list(structure("list", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" of data.\n", class = c("TEXT", "tag")), structure("\"Plural pipes\" expand this idea to piping: take a ", class = c("TEXT", "tag")), structure(list(structure("list", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" of data\n", class = c("TEXT", "tag")), structure("and pipe each element in the list to an expression/function.\n", class = c("TEXT", "tag")), structure("There are plural pipe versions of each singular pipe operator.\n", class = c("TEXT", "tag")), structure("Just add an \"s\" to make them plural:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("|&gt;", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" (singular) : ", class = c("TEXT", "tag")), structure(list(structure("%s&gt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" (plural);\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("%hum&gt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" (singular) : ", class = c("TEXT", "tag")), structure(list(structure("%hums&gt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" (plural);\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("%hum&lt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" (singular) : ", class = c("TEXT", "tag")), structure(list(structure("%hums&lt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" (plural);\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("%humT%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" (singular) : ", class = c("TEXT", "tag")), structure(list(structure("%humsT%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" (plural);\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("%hum[]%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" (singular) : ", class = c("TEXT", "tag")), structure(list(structure("%hums[]%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" (plural);\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Note: ", class = c("TEXT", "tag" )), structure(list(structure("%s&gt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" is an expansion of the ", class = c("TEXT", "tag")), structure(list(structure("\\&gt;", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" pipe operator, which\n", class = c("TEXT", "tag")), structure("makes use of some clever meta-programming---we can't guarantee it will\n", class = c("TEXT", "tag")), structure("always behave the way we might like!\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag")), structure("humdata &lt;- readHumdrum('path*.krn')\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdata %hum&gt;% ~table(.)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdata %hum&gt;%\n", class = c("RCODE", "tag")), structure(" c(by~Spine, do ~ table(.)) %hum&gt;%\n", class = c("RCODE", "tag")), structure(" c(mfcol ~ c(2,2), doplot~barplot(.))\n", class = c("RCODE", "tag")), structure(" \n", class = c("RCODE", "tag")), structure("humdata %hum&gt;%\n", class = c("RCODE", "tag")), structure(" c(by ~ Spine, do ~ table(.)) %hum&lt;%\n", class = c("RCODE", "tag")), structure(" (do ~ sort(.)) \n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" ))), class = c("tag_examples", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humPrint.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/humdrumR-class.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humPrint", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humPrint", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("print_humtab", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("-------------------------------------------&gt; NEEDS DOCUMENTATION &lt;-------------------------------------------", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure(list(structure(list(structure("show", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(object)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("print_humtab(\n", class = c("RCODE", "tag")), structure(" humdrumR,\n", class = c("RCODE", "tag")), structure(" dataTypes = \"GLIMDd\",\n", class = c("RCODE", "tag")), structure(" firstAndLast = FALSE,\n", class = c("RCODE", "tag")), structure(" max.records.file = 40L,\n", class = c("RCODE", "tag")), structure(" max.token.length = 30L,\n", class = c("RCODE", "tag")), structure(" collapseNull = 10L\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" ))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("-------------------------------------------&gt; NEEDS DOCUMENTATION &lt;-------------------------------------------\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Show a ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" object in the terminal.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humReference.Rd = structure(list(structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Summary.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("humReference", class = c("VERB", "tag" ))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humReference", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("reference", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("reference.character", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("reference.humdrumR", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[.humReference", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("print.humReference", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Summarize reference records in a humdrumR corpus", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("reference(x)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag")), structure("reference('OTL')\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("reference(humdata)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("[", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humReference", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(refTable, i, j, drop = FALSE)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("reference", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is one of ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("'s\n", class = c("TEXT", "tag")), structure(list(structure("summary functions", class = c("TEXT", "tag"))), Rd_option = structure("=humSummary", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(", used to\n", class = c("TEXT", "tag" )), structure("tabulate the reference records\n", class = c("TEXT", "tag")), structure("present in a ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" corpus.\n", class = c("TEXT", "tag" )), structure(list(structure("reference", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" takes a ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" object\n", class = c("TEXT", "tag" )), structure("and and returns a ", class = c("TEXT", "tag")), structure(list(structure("humReference", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" table.\n", class = c("TEXT", "tag")), structure("Alternatively, ", class = c("TEXT", "tag")), structure(list(structure("reference", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" can take a ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" string,\n", class = c("TEXT", "tag")), structure("which it will check against known reference codes and print a\n", class = c("TEXT", "tag")), structure("information about matching codes. For instance, ", class = c("TEXT", "tag")), structure(list(structure("reference('OTL')", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("returns a description of the standard humdrum ", class = c("TEXT", "tag")), structure(list(structure("!!!OTL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" reference record\n", class = c("TEXT", "tag")), structure("(original title metadata).\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("A ", class = c("TEXT", "tag")), structure(list( structure("humReference", class = c("RCODE", "tag" ))), class = c("tag_code", "tag")), structure(" table has one column for\n", class = c("TEXT", "tag")), structure("each reference code that appears in a ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" corpus.\n", class = c("TEXT", "tag" )), structure("Since reference records can be long (too much to print on one screen),\n", class = c("TEXT", "tag")), structure("and humdrum files can have multiple of the same type of reference code\n", class = c("TEXT", "tag")), structure("(for instance multiple composers annotated with \"!!!COM\"),\n", class = c("TEXT", "tag")), structure("by default, a ", class = c("TEXT", "tag")), structure(list(structure("humReference", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" only prints the number of each type of\n", class = c("TEXT", "tag")), structure("reference record to appear in each file.\n", class = c("TEXT", "tag")), structure("However, if only one type of reference code is present in a\n", class = c("TEXT", "tag")), structure(list(structure("humReference", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" table, the complete reference records for that code\n", class = c("TEXT", "tag")), structure("will be printed for each file. Likewise, if only one file is present\n", class = c("TEXT", "tag")), structure("in the table, all of that file's complete reference records are printed.\n", class = c("TEXT", "tag")), structure("Thus, if you want to see actualy reference records, try indexing the\n", class = c("TEXT", "tag")), structure(list(structure("humReference", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" table down to one column or row (see below).\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("A ", class = c("TEXT", "tag")), structure(list(structure("humReference", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" table has one row for each file in the corpus.\n", class = c("TEXT", "tag")), structure("Rows are labeled with each file's corresponding\n", class = c("TEXT", "tag")), structure("number (from the ", class = c("TEXT", "tag")), structure(list(structure("humTable", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("'s ", class = c("TEXT", "tag")), structure(list(structure("File", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" field) and name (the ", class = c("TEXT", "tag")), structure(list(structure("Filename", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" field).\n", class = c("TEXT", "tag")), structure("In addition, when a ", class = c("TEXT", "tag")), structure(list(structure("humReference", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object is printed,\n", class = c("TEXT", "tag")), structure("three different summary totals are printed for each reference code:\n", class = c("TEXT", "tag")), structure(list(structure("Any", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" indicates how many files in the corpus have at least\n", class = c("TEXT", "tag")), structure("one example of each code in them.\n", class = c("TEXT", "tag")), structure(list(structure("Sum", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" indicates the total number of each reference code to appear\n", class = c("TEXT", "tag")), structure("in the corpus, including multiple appearances in one file (like multiple \"!!!COM\"\n", class = c("TEXT", "tag")), structure("records).\n", class = c("TEXT", "tag" )), structure("Finally, ", class = c("TEXT", "tag")), structure(list(structure("Unique", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" tabulates the number of unique tokens in each reference\n", class = c("TEXT", "tag")), structure("code---if your corpus only hase two unique composers (encoded in \"!!!COM\"),\n", class = c("TEXT", "tag")), structure("the ", class = c("TEXT", "tag" )), structure(list(structure("Unique", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" total will be ", class = c("TEXT", "tag")), structure(list(structure("2", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Indexing", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humReference", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" tables can be indexed much like base ", class = c("TEXT", "tag")), structure(list(structure("R", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("[data.frames][base::data.frame()], with two arguments: ", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("i", class = c("TEXT", "tag")), structure(list(structure("(rows) and", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("j", class = c("TEXT", "tag")), structure(list(structure("(columns). If", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("i", class = c("TEXT", "tag")), structure(list(structure("or", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("j", class = c("TEXT", "tag")), structure(list(structure("are", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("numeric", class = c("TEXT", "tag")), structure(list(structure(", they select rows or columns respectively, ordinally. If ", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("i", class = c("TEXT", "tag")), structure(list(structure("is a", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("character", class = c("TEXT", "tag")), structure(list(structure(", it is matched as a regular expression against filenames in the corpus. If ", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("j", class = c("TEXT", "tag")), structure(list(structure("is a", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("character`, it is ", class = c("TEXT", "tag")), structure(list(structure("partially matched", class = c("TEXT", "tag"))), Rd_option = structure("base:pmatch", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag")), structure("against column names.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("A ", class = c("TEXT", "tag")), structure(list(structure("drop", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument is also available. If ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", a plain\n", class = c("TEXT", "tag")), structure(list(structure("[data.table][data.table::data.table()]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" is returned.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humShape.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/humdrumR-class.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humShape", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humShape", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("foldHumdrum", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("foldStops", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("foldPaths", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("foldRecords", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("spinePipe", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("HumdrumR data \"Shape\"", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("foldHumdrum(humdrumR, byfields, foldAtomic = TRUE, sep = \" \", padPaths = FALSE)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("foldStops(humdrumR, foldAtomic = TRUE, sep = \" \")\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("foldPaths(humdrumR, foldAtomic = TRUE, sep = \" \")\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("foldRecords(humdrumR, foldAtomic = TRUE, sep = \" \", padPaths = FALSE)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("spinePipe(humdrumR, targetSpines, destinationSpines)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" data object.\n", class = c("TEXT", "tag")), structure("(see the ", class = c("TEXT", "tag")), structure(list(structure("humdrum table", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" documentation ", class = c("TEXT", "tag")), structure(list(structure("Fields", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" section for explanation.).", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("foldAtomic", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure(list( structure("logical", class = c("RCODE", "tag" ))), class = c("tag_code", "tag")), structure(". If ", class = c("TEXT", "tag")), structure(list(structure("foldAtomic == TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", each stop is collapsed to a single string\n", class = c("TEXT", "tag")), structure(list(structure("foldAtomic == FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", each stop is collapsed to a list of tokens.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("sep", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure(list( structure("character", class = c("RCODE", "tag" ))), class = c("tag_code", "tag")), structure(". If ", class = c("TEXT", "tag")), structure(list(structure("foldAtomic == TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", collapsed tokens are separated by this string.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("pad", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure(list( structure("logical", class = c("RCODE", "tag" ))), class = c("tag_code", "tag")), structure(". Should ", class = c("TEXT", "tag")), structure(list(structure("path/column padding tokens", class = c("TEXT", "tag"))), Rd_option = structure("=humColumns", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" be included?", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" ))), class = c("tag_arguments", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("These functions are used to change the \"shape\"\n", class = c("TEXT", "tag")), structure("of data stored in ", class = c("TEXT", "tag")), structure(list(structure("humdrum tables", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag")), structure("(held within ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" objects of course).\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("-------------------------------------------&gt; NEEDS DOCUMENTATION &lt;-------------------------------------------\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag")), structure(list(structure("foldXXX", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" family allows you collapse all\n", class = c("TEXT", "tag")), structure(list(structure("user fields", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("across groups in another field.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humSize.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/humdrumR-class.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humSize", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humSize", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("nrecords", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("ntokens", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("npieces", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("anySubcorpora", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("namesSubcorpora", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("nfiles", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("is.empty", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("anyPaths", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("anyStops", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR size and shape", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("nrecords(humdrumR, dataTypes = \"D\")\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("ntokens(humdrumR, dataTypes = \"D\")\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("npieces(humdrumR)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("anySubcorpora(humdrumR)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("namesSubcorpora(humdrumR)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("nfiles(humdrumR)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("length", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(x)\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure(list( structure(list(structure("nrow", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(x)\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("is.empty(humdrumR)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("anyPaths(humdrumR)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("anyStops(humdrumR)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("These functions can be used to quickly\n", class = c("TEXT", "tag")), structure("get basic information about the size and \"shape\" of\n", class = c("TEXT", "tag")), structure("a ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" corpus.\n", class = c("TEXT", "tag")), structure("For more details, use the ", class = c("TEXT", "tag")), structure(list(structure("census", class = c("TEXT", "tag"))), Rd_option = structure("=humSummary", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" function.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(structure("HumdrumR", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" objects can be divided into \"subcorpora.\"\n", class = c("TEXT", "tag")), structure(list(structure("anySubcorpora", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("namesSubcorpora", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" functions tell us if there are any subcorpora and, if so, what they are called.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure("A few common base ", class = c("TEXT", "tag")), structure(list(structure("R", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" methods are defined\n", class = c("TEXT", "tag")), structure("as synonyms for the humdrumR-specific sizing functions:\n", class = c("TEXT", "tag")), structure(list(structure("length(humdata)", class = c("TEXT", "tag"))), Rd_option = structure("base:length", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" is equivalent to ", class = c("TEXT", "tag")), structure(list(structure("npieces(humdata)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(";\n", class = c("TEXT", "tag")), structure(list(structure("nrow(humdata)", class = c("TEXT", "tag"))), Rd_option = structure("base:nrow", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" is shortand for ", class = c("TEXT", "tag")), structure(list(structure("nrecords(., dataTypes = 'LIMDd')", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (i.e., local records only).\n", class = c("TEXT", "tag")), structure(list(structure("ncol(humdata)", class = c("TEXT", "tag"))), Rd_option = structure("base:nrow", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" returns the ", class = c("TEXT", "tag")), structure(list(structure("maximum", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" value of the ", class = c("TEXT", "tag")), structure(list(structure("Column", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" field---the maximum number of\n", class = c("TEXT", "tag")), structure("tab-delineated columns in the humdrum files (irrespective of Spines/Paths).\n", class = c("TEXT", "tag")), structure("The results of ", class = c("TEXT", "tag")), structure(list(structure("nrow", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("ncol", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will match\n", class = c("TEXT", "tag")), structure("up with the dimensions of matrices/data.frames produced by calls to ", class = c("TEXT", "tag")), structure(list(structure("as.matrix/as.data.frame", class = c("TEXT", "tag"))), Rd_option = structure("=as.matrix", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure(list(structure("dim(humdata)", class = c("TEXT", "tag"))), Rd_option = structure("base:dim", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" returns ", class = c("TEXT", "tag")), structure(list(structure("c(nrow(humdata), ncol(humdata))", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", as usual.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(structure("is.empty(humdata)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" asks if ", class = c("TEXT", "tag")), structure(list(structure("ntokens(humdata, dataTypes = 'D') == 0L", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humSpines.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Summary.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humSpines", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humSpines", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("spines", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[.humSpines", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("print.humSpines", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Summarize spines in humdrum dataset", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("spines(humdrumR)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("[", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humSpines", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(spines, i, j)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("print", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humSpines", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(spineTable, showEach = TRUE)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("This function provides summary of the spines and spine paths in the pieces of a humdrumR corpus.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Other humdrum data summary functions: \n", class = c("TEXT", "tag")), structure(list(structure(list(structure("humCensus", class = c("TEXT", "tag"))), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag" )), structure(list(structure(list(structure("humInterpretations", class = c("TEXT", "tag"))), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag" )), structure(list(structure(list(structure("humSummary", class = c("TEXT", "tag"))), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrum data summary functions", class = c("TEXT", "tag"))), class = c("tag_concept", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humSummary.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Summary.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humSummary", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humSummary", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Summarize humdrumR corpora", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure(list(structure(list(structure("summary", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(object, ...)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" includes a number of built in functions for creating quick summaries of ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag")), structure("corpora:\n", class = c("TEXT", "tag" ))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("census", class = c("TEXT", "tag"))), Rd_option = structure("=humCensus", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Tabulates the raw size of the humdrumR corpus.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("reference", class = c("TEXT", "tag"))), Rd_option = structure("=humReference", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Tabulates reference records (metadata) for each file.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("spines", class = c("TEXT", "tag"))), Rd_option = structure("=humSpines", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Tabulates the number of spines and spine paths in files in the corpus.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("interpretations", class = c("TEXT", "tag"))), Rd_option = structure("=humInterpretations", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Tabulates the types of exclusive and tandem interpretations in the corpus.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("sections", class = c("TEXT", "tag"))), Rd_option = structure("=humSections", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Tabulates any formal data (", class = c("TEXT", "tag")), structure(list(structure("*&gt;", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(") in the corpus.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_enumerate", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Each function takes a ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" object and returns a\n", class = c("TEXT", "tag")), structure("special class of data.table.\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag")), structure(list(structure("summary", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" method for ", class = c("TEXT", "tag")), structure(list(structure("humdrumR objects", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" calls all of the above functions and prints a condensed version of each.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Other humdrum data summary functions: \n", class = c("TEXT", "tag")), structure(list(structure(list(structure("humCensus", class = c("TEXT", "tag"))), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag" )), structure(list(structure(list(structure("humInterpretations", class = c("TEXT", "tag"))), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag" )), structure(list(structure(list(structure("humSpines", class = c("TEXT", "tag"))), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrum data summary functions", class = c("TEXT", "tag"))), class = c("tag_concept", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humTable.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/humdrumR-class.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humTable", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humTable", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("getHumtab", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Humdrum Tables", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("getHumtab(humdrumR, dataTypes = c(\"G\", \"L\", \"I\", \"M\", \"D\", \"d\"))\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("dataTypes", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" vector. Specifies which types of data tokens/records to extract.\n", class = c("TEXT", "tag")), structure("See the ", class = c("TEXT", "tag")), structure(list(structure("humTable", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" documentation and/or the humdrum syntax vignette for clarification!\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("For ", class = c("TEXT", "tag")), structure(list(structure("dataTypes", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", values can be:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("\"G\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(": global comments\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("\"L\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(": local comments\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("\"I\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(": interpretations\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("\"M\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(": barlines\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("\"D\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(": non-null data\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("\"d\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(": null data\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Multiple types can be specified as a vector, or smooshed into a single string: e.g., ", class = c("TEXT", "tag")), structure(list(structure("\"GLIMD\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" ))), class = c("tag_arguments", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("In the ", class = c("TEXT", "tag" )), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" package, the fundamental data structure is called a ", class = c("TEXT", "tag")), structure(list(structure("Humdrum Table", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("A humdrum table encodes all the information in a collection of one or more humdrum-syntax files\n", class = c("TEXT", "tag")), structure("as a single ", class = c("TEXT", "tag")), structure(list(structure("data.table", class = c("TEXT", "tag"))), Rd_option = structure("data.table:data.table", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag")), structure("(A ", class = c("TEXT", "tag")), structure(list( structure("data.table", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is an \"enhanced\" version of R's standard ", class = c("TEXT", "tag")), structure(list(structure("data.frame", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(").\n", class = c("TEXT", "tag")), structure("Humdrum tables are stored \"inside\" every ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" object that you will work with, and various ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("functions allow you to study or manipulate the them.\n", class = c("TEXT", "tag")), structure("If you want to directly access the humdrum table within a ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" object, use the ", class = c("TEXT", "tag")), structure(list(structure("getHumtab", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" function.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(structure("getHumtab", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" extracts a ", class = c("TEXT", "tag")), structure(list(structure("humdrum table", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" from a ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" object.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure("In a humdrum table, each row represents a single \"token\"\n", class = c("TEXT", "tag")), structure("in the original humdrum data. Even multistops---tokens separated by spaces---are broken onto\n", class = c("TEXT", "tag")), structure("their own rows. Meanwhile, each column in the humdrum table represents a single\n", class = c("TEXT", "tag")), structure("piece of information associated with each token, which we call a ", class = c("TEXT", "tag")), structure(list(structure("field", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Throughout this documentation, you should keep in mind that a \"token\" refers\n", class = c("TEXT", "tag")), structure("to a ", class = c("TEXT", "tag")), structure(list(structure("row", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" in the humdrum table while a \"field\" refers to a ", class = c("TEXT", "tag")), structure(list(structure("column", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(":\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("Token = Row", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(), class = c("tag_item", "tag" )), structure(" ", class = c("TEXT", "tag")), structure(list(structure(list(structure("Field = Column", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Fields:", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("There are five types of fields in a humdrum table:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Data fields\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Structure fields\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Interpretation fields\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Formal fields\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Reference fields\n", class = c("TEXT", "tag"))), class = c("tag_enumerate", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("When first created by a call to ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" every\n", class = c("TEXT", "tag")), structure("humdrum table has at least nineteen fields: one data field (", class = c("TEXT", "tag")), structure(list(structure("Token", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("), two interpretation\n", class = c("TEXT", "tag")), structure("fields (", class = c("TEXT", "tag")), structure(list(structure("Tandem", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("Exclusive", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("), three formal fields, and fifteen structure fields. Additional\n", class = c("TEXT", "tag")), structure("interpretation or reference fields\n", class = c("TEXT", "tag")), structure("may be present depending on the content of the humdrum file(s), and users can create additional data fields\n", class = c("TEXT", "tag")), structure("by ", class = c("TEXT", "tag" )), structure(list(structure("assigning to the object", class = c("TEXT", "tag"))), Rd_option = structure("=humAssignment", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure(list(structure(list(structure("Data fields:", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Data fields are used to describe individual data points\n", class = c("TEXT", "tag")), structure("in humdrum data (as opposed to groups of points).\n", class = c("TEXT", "tag")), structure("Every humdrum table starts with a data\n", class = c("TEXT", "tag")), structure("field called ", class = c("TEXT", "tag")), structure(list(structure("Token", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(", which\n", class = c("TEXT", "tag")), structure("contains character strings representing the original strings read from the humdrum files.\n", class = c("TEXT", "tag")), structure("Users can create as many additional data fields as they like. Every call to\n", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("---which can also be called using the\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR:humPipe", class = c("TEXT", "tag"))), Rd_option = structure("=\\%hum&gt;\\%", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" piping\n", class = c("TEXT", "tag")), structure("operator---generates one or ", class = c("TEXT", "tag")), structure(list(structure(list(structure("N", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(" new data fields named ", class = c("TEXT", "tag")), structure(list(structure(list(structure("{Pipe1, Pipe2, ..., PipeN}", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure("These fields can be renamed using the ", class = c("TEXT", "tag")), structure(list(structure("$&lt;-", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" operator.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Structure fields:", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Every humdrum table starts with fifteen Structure fields,\n", class = c("TEXT", "tag")), structure("which describe where each data token was \"located\" in the original humdrum data: which file, which spine, which record, etc.\n", class = c("TEXT", "tag")), structure("See the vignette on humdrum syntax to fully understand the terms here.\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("File info", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(":\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Filename", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" The unique name of the humdrum file. This may include an appended path\n", class = c("TEXT", "tag")), structure("if more than one file with the same name were read from different directories (see the ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" docs).\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Filepath", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" The full file name (always includes its full path).\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Label", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" A label specified during the call to ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(", associated with a particular\n", class = c("TEXT", "tag")), structure(list(structure("readHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" \"REpath-pattern.\" If no label was specified, patterns are just labeled ", class = c("TEXT", "tag")), structure(list(structure("\"_n\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", where \"", class = c("TEXT", "tag")), structure(list(structure("n", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\" is the\n", class = c("TEXT", "tag")), structure("number of the pattern. (Labels can also be created when ", class = c("TEXT", "tag")), structure(list(structure("merging two humdrumR objects", class = c("TEXT", "tag"))), Rd_option = structure("=humMerge", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".)\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("File", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("integer", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" A unique number associated with each file (ordered alphabetically, starting from ", class = c("TEXT", "tag")), structure(list(structure("1", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Piece", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("integer", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" A number specifying the number of the ", class = c("TEXT", "tag")), structure(list(structure("piece", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" in the corpus.\n", class = c("TEXT", "tag")), structure("This is identical to the ", class = c("TEXT", "tag")), structure(list(structure("File", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field except when\n", class = c("TEXT", "tag")), structure("more than one piece were read from the same file.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Location info", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(":\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Spine", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("integer", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" The spine, numbered (from left-to-right) starting from ", class = c("TEXT", "tag")), structure(list(structure("1", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" This field is ", class = c("TEXT", "tag")), structure(list(structure("NA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" wherever ", class = c("TEXT", "tag")), structure(list(structure("Global == TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Path", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("integer", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" The \"spine path.\" Any time a ", class = c("TEXT", "tag")), structure(list(structure("*^", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" spine path split occurs in\n", class = c("TEXT", "tag")), structure("the humdrum data, the right side of the split becomes a new \"path.\" The original path\n", class = c("TEXT", "tag")), structure("is numbered ", class = c("TEXT", "tag")), structure(list(structure("0", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" with additional paths numbered with integers to the right.\n", class = c("TEXT", "tag")), structure("(If there are no spine path splits, the ", class = c("TEXT", "tag")), structure(list(structure("Path", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field is all zeros.)\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" This field is always ", class = c("TEXT", "tag")), structure(list(structure("NA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" when ", class = c("TEXT", "tag")), structure(list(structure("Global == TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Read the ", class = c("TEXT", "tag")), structure(list(structure("humdrum columns documentation", class = c("TEXT", "tag"))), Rd_option = structure("=humColumns", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" for a more thorough explanation\n", class = c("TEXT", "tag")), structure("of spine paths.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Column", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("integer", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" The tab-delineated column in the humdrum file---irrespective of Spine/Paths---, numbered starting from ", class = c("TEXT", "tag")), structure(list(structure("1", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" This field is always ", class = c("TEXT", "tag")), structure(list(structure("NA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" when ", class = c("TEXT", "tag")), structure(list(structure("Global == TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" See this ", class = c("TEXT", "tag")), structure(list(structure("explanation of columns in humdrumR", class = c("TEXT", "tag"))), Rd_option = structure("=humColumns", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" ))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Record", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("integer", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" The record (i.e., line) number in the original file.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("NData", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("integer", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" The ", class = c("TEXT", "tag")), structure(list(structure("data", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" record enumeration in the file, starting from ", class = c("TEXT", "tag")), structure(list(structure("1", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Stop", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("integer", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Which token in a multistop token, numbered starting from ", class = c("TEXT", "tag")), structure(list(structure("1", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" In files with no multistops, the ", class = c("TEXT", "tag")), structure(list(structure("Stop", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field is all ", class = c("TEXT", "tag")), structure(list(structure("1", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" This field is always ", class = c("TEXT", "tag")), structure(list(structure("NA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" when ", class = c("TEXT", "tag")), structure(list(structure("Global == TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Global", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("logical", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Did the token come from a global record (as opposed to a local record)?\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" When ", class = c("TEXT", "tag")), structure(list(structure("Global == TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the ", class = c("TEXT", "tag")), structure(list(structure("Spine", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("Column", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", and ", class = c("TEXT", "tag")), structure(list(structure("Stop", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" fields are always ", class = c("TEXT", "tag")), structure(list(structure("NA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Token info", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(":\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Type", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" What type of record is it?\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("\"D\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" = non-null data\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("\"d\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" = null data\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("\"I\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" = interpretation\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("\"M\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" = measure/barline\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("\"L\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" = local comment\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("\"G\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" = global comment.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("\"P\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" = null \"non-tokens\" (see the ", class = c("TEXT", "tag")), structure(list(structure("humdrumR columns", class = c("TEXT", "tag"))), Rd_option = structure("=humColumns", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" documentation for an explanation.)\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Null", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("logical", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Is the ", class = c("TEXT", "tag")), structure(list(structure("active", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumR", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" data field null?\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" See the detailed discussion below, in the section of this documentation called \"Null Data.\"\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Filter", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("logical", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Has this record/token been ", class = c("TEXT", "tag")), structure(list(structure("filtered out", class = c("TEXT", "tag"))), Rd_option = structure("=filterHumdrum", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("?\n", class = c("TEXT", "tag" ))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Interpretation fields:", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Interpretation fields describe interpretation metadata in the humdrum file(s).\n", class = c("TEXT", "tag")), structure("Humdrum interpretations are tokens that \"carry forward\" to data points after them, unless cancelled out by a\n", class = c("TEXT", "tag")), structure("subsequent interpretation. (See the humdrum syntax vignette for a detailed explanation.)\n", class = c("TEXT", "tag")), structure(list(structure("All", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" humdrum data must have an ", class = c("TEXT", "tag")), structure(list(structure("exclusive", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" interpretation\n", class = c("TEXT", "tag")), structure("so humdrum tables always have an ", class = c("TEXT", "tag")), structure(list(structure("Exclusive", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (:: ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") field indicating the\n", class = c("TEXT", "tag")), structure("exclusive interpretation associated with each token/row of the ", class = c("TEXT", "tag")), structure(list(structure("active", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumR", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" field.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Humdrum data may, or may not, include additional ", class = c("TEXT", "tag")), structure(list(structure("tandem", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" interpretations. A universal rule for parsing\n", class = c("TEXT", "tag")), structure("tandem intepretations is impossible, because A) tandem interpretations can \"overwrite\" each other and B)\n", class = c("TEXT", "tag")), structure("users can create their own tandem interpretations. The best we can do in all cases is\n", class = c("TEXT", "tag")), structure("identify ", class = c("TEXT", "tag")), structure(list(structure("all", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" tandem interpretations that have appeared previously in the spine\n", class = c("TEXT", "tag")), structure("(counting most recent first). All these previous interpretations are encoded in a single\n", class = c("TEXT", "tag")), structure("character string in the ", class = c("TEXT", "tag")), structure(list(structure("Tandem", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field.\n", class = c("TEXT", "tag")), structure("If working with non-standard intrepretations, users can parse the ", class = c("TEXT", "tag")), structure(list(structure("Tandem", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field using the\n", class = c("TEXT", "tag")), structure(list(structure("getTandem", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" function.\n", class = c("TEXT", "tag")), structure("If no tandem interpretations occur in a file, the ", class = c("TEXT", "tag")), structure(list(structure("Tandem", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field is full of empty strings (", class = c("TEXT", "tag")), structure(list(structure("\"\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Fortunately, many tandem interpretations are widely used and standardized, and these\n", class = c("TEXT", "tag")), structure("interpretations are known by ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". Recognized interpretations (such as ", class = c("TEXT", "tag")), structure(list(structure("*clefG4", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("*k[b-]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(")\n", class = c("TEXT", "tag")), structure("are automatically parsed into their own fields by a call to ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("See the ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" documentation for more details.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Formal fields:", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Formal fields indicate musical sections, or time windows within\n", class = c("TEXT", "tag")), structure("a piece, including formal designations (\"verse\", \"chorus\", etc.) and measures/bars.\n", class = c("TEXT", "tag")), structure("Humdrum data may or may not include formal metadata fields, indicated by the token ", class = c("TEXT", "tag")), structure(list(structure("\"*&gt;\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Classified formal marks are put into fields matching their name.\n", class = c("TEXT", "tag")), structure("Unclassified formal marks are placed in a field called ", class = c("TEXT", "tag")), structure(list(structure("Formal", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" as a default.\n", class = c("TEXT", "tag")), structure("Nested formal categories are appended with an underscore and a number for each level of descent:\n", class = c("TEXT", "tag")), structure(list(structure("Formal_1, Formal_2, ..., Formal_N", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("If part of a section is not given a name in a lower hierarchical level, the field is simply\n", class = c("TEXT", "tag")), structure("empty (", class = c("TEXT", "tag")), structure(list(structure("\"\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") at that point.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Humdrum data may, or may not, also include barlines (tokens beginning ", class = c("TEXT", "tag")), structure(list(structure("\"=\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag")), structure("Humdrum tables ", class = c("TEXT", "tag")), structure(list(structure("always", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" include three formal fields related to barlines:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Bar", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("integer", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" How many barline records (single or double) have passed before this token?\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" If no ", class = c("TEXT", "tag")), structure(list(structure("\"=\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" tokens occur in a file, ", class = c("TEXT", "tag")), structure(list(structure("Bar", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is all zeros.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Note that this field is independent of whether the barlines are labeled with numbers in the humdrum file!\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("DoubleBar", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("integer", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" How many ", class = c("TEXT", "tag")), structure(list(structure("double", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure("-barline records have passed before this token?\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" If no ", class = c("TEXT", "tag")), structure(list(structure("\"==\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" tokens occur in a file, ", class = c("TEXT", "tag")), structure(list(structure("DoubleBar", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is all zeros.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("BarLabel", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Any characters that occur in a barline-token ", class = c("TEXT", "tag")), structure(list(structure("after", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" an initial ", class = c("TEXT", "tag")), structure(list(structure("\"=\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("\"==\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("These include the ", class = c("TEXT", "tag")), structure(list(structure("\"-\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" in the common \"implied barline token ", class = c("TEXT", "tag")), structure(list(structure("\"=-\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag")), structure("repeat tokens (like ", class = c("TEXT", "tag")), structure(list(structure("\"=:||\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("), and also any ", class = c("TEXT", "tag")), structure(list(structure("explicit", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" bar numbers.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Note that the ", class = c("TEXT", "tag")), structure(list(structure("Bar", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field always enumerate ", class = c("TEXT", "tag")), structure(list(structure("every", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" bar record, while\n", class = c("TEXT", "tag")), structure("measure-number labels in humdrum data (which appear in the ", class = c("TEXT", "tag")), structure(list(structure("BarLabel", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field) may\n", class = c("TEXT", "tag")), structure("do weird things like skipping numbers, repeating numbers, or having suffixes (e.g., ", class = c("TEXT", "tag")), structure(list(structure("\"19a\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag")), structure("If no barline tokens appear in the file, ", class = c("TEXT", "tag")), structure(list(structure("BarLabel", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is all empty strings (", class = c("TEXT", "tag")), structure(list(structure("\"\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Reference fields:", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Reference fields describe any ", class = c("TEXT", "tag")), structure(list(structure("Reference Records", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure("\n", class = c("TEXT", "tag")), structure("in the humdrum data. Every reference record (records beginning ", class = c("TEXT", "tag")), structure(list(structure("\"!!!\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") in any\n", class = c("TEXT", "tag")), structure("humdrum file in a corpus read by ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" is parsed into a field named\n", class = c("TEXT", "tag")), structure("by the reference code: ", class = c("TEXT", "tag")), structure(list(structure("\"XXX\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" in ", class = c("TEXT", "tag")), structure(list(structure("\"!!!XXX\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Reference tokens are all identical throughout\n", class = c("TEXT", "tag")), structure("any humdrum piece. If a reference code appears in one file but not another, the field is\n", class = c("TEXT", "tag")), structure(list(structure("NA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" in the file which does not have the code. If no reference records appear in any\n", class = c("TEXT", "tag")), structure("files read by ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(", no reference fields are created.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Examples of common reference records are ", class = c("TEXT", "tag")), structure(list(structure("\"!!!COM:\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (composer) and ", class = c("TEXT", "tag")), structure(list(structure("\"!!!OTL:\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (original title).\n", class = c("TEXT", "tag")), structure("Any humdrum data with these records will end up having ", class = c("TEXT", "tag")), structure(list(structure("COM", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("OTL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" fields in its humdrum table.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag" ))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Null Data:", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("In humdrum syntax, there is no requirement that every spine-path contains data\n", class = c("TEXT", "tag")), structure("in every record. Rather, spines are often padded with ", class = c("TEXT", "tag")), structure(list(structure("null tokens", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("In some cases, entire records may be padded with null tokens.\n", class = c("TEXT", "tag")), structure("Each type of humdrum record uses a different null token:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Intepretation", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(": ", class = c("TEXT", "tag")), structure(list(structure("*", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Comment", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(": ", class = c("TEXT", "tag")), structure(list(structure("!", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Barline", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(": ", class = c("TEXT", "tag")), structure(list(structure("=", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Data", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(": ", class = c("TEXT", "tag")), structure(list(structure(".", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Null tokens in a humdrum table are identified in the logical ", class = c("TEXT", "tag")), structure(list(structure("Null", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field.\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag")), structure(list(structure("Null", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field is set when a humdrum table is created (by ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(") and is updated everytime\n", class = c("TEXT", "tag")), structure("a new ", class = c("TEXT", "tag")), structure(list(structure("active", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumR", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" field is set.\n", class = c("TEXT", "tag")), structure(list(structure("Null", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is set to ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" wherever, either\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" the active field is ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data and the token is a single ", class = c("TEXT", "tag")), structure(list(structure("\".\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("\"!\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("\"=\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", or ", class = c("TEXT", "tag")), structure(list(structure("\"*\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(";\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" the active field is ", class = c("TEXT", "tag")), structure(list(structure("NA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (including ", class = c("TEXT", "tag")), structure(list(structure("NA_character_", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("In parallel to the ", class = c("TEXT", "tag")), structure(list(structure("Null", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field, null ", class = c("TEXT", "tag")), structure(list(structure("data", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" tokens (", class = c("TEXT", "tag")), structure(list(structure("\".\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") are identified as their own record type: ", class = c("TEXT", "tag")), structure(list(structure("\"d\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("All updates/changes to the ", class = c("TEXT", "tag")), structure(list(structure("Null", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field are also propogated to the ", class = c("TEXT", "tag")), structure(list(structure("Type", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field---i.e., setting ", class = c("TEXT", "tag")), structure(list(structure("Type == d", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" wherever\n", class = c("TEXT", "tag")), structure("a data record is ", class = c("TEXT", "tag")), structure(list(structure("Null", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("This is important/useful because ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" routines are, by default, only applied to ", class = c("TEXT", "tag")), structure(list(structure("\"D\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data, ignoring ", class = c("TEXT", "tag")), structure(list(structure("\"d\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Whenever you ", class = c("TEXT", "tag")), structure(list(structure("print", class = c("TEXT", "tag"))), Rd_option = structure("=humPrint", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("export", class = c("TEXT", "tag"))), Rd_option = structure("=writeHumdrum", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" a ", class = c("TEXT", "tag" )), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" object, null data in the active field\n", class = c("TEXT", "tag")), structure("(i.e., ", class = c("TEXT", "tag")), structure(list(structure("Null == TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") print as ", class = c("TEXT", "tag")), structure(list(structure("\".\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Thus, if you are working with numeric data, with ", class = c("TEXT", "tag")), structure(list(structure("NA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" values, these ", class = c("TEXT", "tag")), structure(list(structure("NA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" values will print as ", class = c("TEXT", "tag")), structure(list(structure("\".\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Reshaping:", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Breaking the complex syntax of humdrum data into the \"flat\" structure of a humdrum table, with every single token on one line\n", class = c("TEXT", "tag")), structure("of a ", class = c("TEXT", "tag")), structure(list(structure("data.table", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", makes humdrum data easier to analyze.\n", class = c("TEXT", "tag")), structure("Of course, thanks to the structure fields, we can easily\n", class = c("TEXT", "tag")), structure("regroup and reform the original humdrum data or use the structure of the data (like spines) in our analyses.\n", class = c("TEXT", "tag")), structure("However, in some cases, you might want to work with humdrum data in a different structure or \"shape.\"\n", class = c("TEXT", "tag")), structure("HumdrumR has several options for ", class = c("TEXT", "tag")), structure(list(structure("\"folding\"", class = c("TEXT", "tag"))), Rd_option = structure("=humShape", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" tokens within humdrum tables,\n", class = c("TEXT", "tag")), structure("or otherwise ", class = c("TEXT", "tag")), structure(list(structure("reshaping humdrum data", class = c("TEXT", "tag"))), Rd_option = structure("=humCoercion", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" into data formats/structures you might prefer.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humValidation.Rd = structure(list(structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Validation.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("humValidation", class = c("VERB", "tag" ))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humValidation", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("validateHumdrum", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Validate humdrum files", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("validateHumdrum(\n", class = c("RCODE", "tag")), structure(" ...,\n", class = c("RCODE", "tag" )), structure(" contains = NULL,\n", class = c("RCODE", "tag")), structure(" recursive = FALSE,\n", class = c("RCODE", "tag")), structure(" errorReport.path = NULL\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("recursive", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure(list( structure("logical", class = c("RCODE", "tag" ))), class = c("tag_code", "tag")), structure(". If ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the final part of the search pattern (i.e., the file search)\n", class = c("TEXT", "tag")), structure("is searched for recursively through all sub directories.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("errorReport.path", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure(list( structure("character", class = c("RCODE", "tag" ))), class = c("tag_code", "tag")), structure(". A directory path which, if not ", class = c("TEXT", "tag")), structure(list(structure("NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", an error report is written\n", class = c("TEXT", "tag")), structure("in the file ", class = c("TEXT", "tag")), structure(list(structure("'humdrumR_syntaxErrorReport_date.txt'", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". In addition, all files with errors\n", class = c("TEXT", "tag")), structure("are written to this directory (with ", class = c("TEXT", "tag")), structure(list(structure("'errorMarkup'", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" appended to their names), with\n", class = c("TEXT", "tag")), structure("errors annotated inline.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("patterns", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure(list( structure("character", class = c("RCODE", "tag" ))), class = c("tag_code", "tag")), structure(" vector. Search pattern(s) for identifying files\n", class = c("TEXT", "tag")), structure("(see ", class = c("TEXT", "tag")), structure(list(structure("[readHumdrum][readHumdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(").", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("files", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A list of character strings, each representing a record in a file.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_arguments", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure("This function checks files for violations of the\n", class = c("TEXT", "tag")), structure("humdrum syntax.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humWindows.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Windows.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humWindows", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humWindows", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("windows", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("hop", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("nest", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Applying functions across arbitrary windows.\n", class = c("TEXT", "tag")), structure("----------------------------------------------&gt; NEEDS DOCUMENTATION &lt;----------------------------------------------------", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("windows(\n", class = c("RCODE", "tag")), structure(" df,\n", class = c("RCODE", "tag")), structure(" form,\n", class = c("RCODE", "tag")), structure(" with = list(),\n", class = c("RCODE", "tag")), structure(" ...,\n", class = c("RCODE", "tag")), structure(" start = 1L,\n", class = c("RCODE", "tag")), structure(" end = nrow(df),\n", class = c("RCODE", "tag")), structure(" bounds = \"exclude\"\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("hop(vec, pattern, start = 1L, end = length(vec))\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("nest(vec, open, close, depth = 1)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Applying functions across arbitrary windows.\n", class = c("TEXT", "tag")), structure("----------------------------------------------&gt; NEEDS DOCUMENTATION &lt;----------------------------------------------------\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humdrumDispatch.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Compose.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumDispatch", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumDispatch", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("makeDispatchDF", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("makeHumdrumDispatcher", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("print.humdrumDispatch", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Regular expression method dispatch and function application", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("humdrumDispatch(\n", class = c("RCODE", "tag")), structure(" str,\n", class = c("RCODE", "tag")), structure(" dispatchDF,\n", class = c("RCODE", "tag")), structure(" Exclusive = NULL,\n", class = c("RCODE", "tag")), structure(" multiDispatch = FALSE,\n", class = c("RCODE", "tag")), structure(" ...,\n", class = c("RCODE", "tag")), structure(" outputClass = \"character\"\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("makeDispatchDF(...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("makeHumdrumDispatcher(\n", class = c("RCODE", "tag")), structure(" ...,\n", class = c("RCODE", "tag")), structure(" funcName = \"humdrum-dispatch\",\n", class = c("RCODE", "tag")), structure(" outputClass = \"character\",\n", class = c("RCODE", "tag")), structure(" args = alist()\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure(list( structure(list(structure("print", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humdrumDispatch", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x)\n", class = c("RCODE", "tag" ))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("str", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("The input ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" string, on which dispatch is called.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("dispatchDF", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A data.frame which describes what function should be called for\n", class = c("TEXT", "tag")), structure("which regex input. (See details).", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Exclusive", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("Defaults to ", class = c("TEXT", "tag")), structure(list(structure("NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". If ", class = c("TEXT", "tag")), structure(list(structure("NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", only the regexes are used for dispatch.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("multiDispatch", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure(list( structure("logical", class = c("RCODE", "tag" ))), class = c("tag_code", "tag")), structure(", length 1. If ", class = c("TEXT", "tag")), structure(list(structure("FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (the default) the \"best\" regex/exclusive match\n", class = c("TEXT", "tag")), structure("is dispatched for each Exclusive segment. If ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", differenet functions can be dispatched\n", class = c("TEXT", "tag")), structure("within the same input vector.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("...", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("Arguments to pass to dispatch functions.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("outputClass", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("Character string: the default output class which the function should return.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Generally, to make sense, all dispatched functions should return the same type, which you should explicitly\n", class = c("TEXT", "tag")), structure("indicate with the ", class = c("TEXT", "tag")), structure(list(structure("outputClass", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument.\n", class = c("TEXT", "tag")), structure("Dispatch functions should also be ", class = c("TEXT", "tag")), structure(list(structure("vectorized", class = c("TEXT", "tag"))), Rd_option = structure("base:Vectorize", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".", class = c("TEXT", "tag" ))), class = "tag")), class = c("tag_item", "tag" )), structure("\n", class = c("TEXT", "tag"))), class = c("tag_arguments", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag" )), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("regular-expression method dispatch system", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure("\n", class = c("TEXT", "tag")), structure("is a simple system for making new functions which can by smartly\n", class = c("TEXT", "tag")), structure("applied to a variety of character strings.\n", class = c("TEXT", "tag")), structure("Humdrum dispatch works like normal R method dispatch, but instead of dispatching specific methods\n", class = c("TEXT", "tag")), structure("based on their class (", class = c("TEXT", "tag")), structure(list(structure("integer", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", etc.) it dispatches based on regular expressions.\n", class = c("TEXT", "tag")), structure("In addition, exclusive interpretations can be used to guide dispatch.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Many ", class = c("TEXT", "tag" )), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" functions are in fact, humdrum-dispatch functions: for example, ", class = c("TEXT", "tag")), structure(list(structure(list(structure("tonalInterval.character()", class = c("TEXT", "tag"))), Rd_option = structure("=tonalInterval.character", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("If you call ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval('ee-')", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the function will recognize that the input string is a token in the ", class = c("TEXT", "tag")), structure(list(structure("**kern", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("\n", class = c("TEXT", "tag")), structure("representation, and call the appropriate parser.\n", class = c("TEXT", "tag")), structure("If you instead call ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval('me')", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the function will recognize that the input string is a token in the ", class = c("TEXT", "tag")), structure(list(structure("**solfa", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("\n", class = c("TEXT", "tag")), structure("representation, and call the appropriate parser for that.\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("dispatchDF", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag")), structure(list(structure("dispatchDF", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" must be a ", class = c("TEXT", "tag")), structure(list(structure(list(structure("data.table::data.table()", class = c("TEXT", "tag"))), Rd_option = structure("data.table:data.table", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(" created using the ", class = c("TEXT", "tag")), structure(list(structure("makeDispatchDF", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" function.\n", class = c("TEXT", "tag")), structure(list(structure("makeDispatchDF", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" takes one or more arguments, each a list with three components (ordered, not nameed):\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" A character vector of exclusive interpretations. (Specify ", class = c("TEXT", "tag")), structure(list(structure("\"any\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" if you don't want exclusive dispatch).\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" A regular expression (character string) or a function which can generate a regular expression, which accepts ", class = c("TEXT", "tag")), structure(list(structure("...", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("arguments at the time of dispatch.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" A function to dispatch.\n", class = c("TEXT", "tag"))), class = c("tag_enumerate", "tag")), structure("\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("makeHumdrumDispatcher", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("makeHumdrumDispatcher", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is a function which creates a new function which automatically performs humdrum-dispatch.\n", class = c("TEXT", "tag")), structure("A number of important ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" functions are created with ", class = c("TEXT", "tag")), structure(list(structure("makeHumdrumDispatcher", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(":\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("tonalInterval.character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("diatonicSet.character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("tertianSet.character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("rhythmInterval.character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag")), structure("u &lt;- c('A', 'B', 'CD', 'E', 'F', 'gh', 'L', 'KX')\n", class = c("RCODE", "tag")), structure("l &lt;- c('a', 'b', 'cd', 'e', 'f', 'gh', 'l', 'kx')\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("lowercasefunc &lt;- \\(x) 5L - nchar(x)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdrumDispatch(l, outputClass = 'integer',\n", class = c("RCODE", "tag")), structure(" makeDispatchDF(list('any', '[a-z]+', lowercasefunc),\n", class = c("RCODE", "tag")), structure(" list('any', '[A-Z]+', nchar)))\n", class = c("RCODE", "tag")), structure(" # lowercasefunc will be called on l, nchar on u\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" ))), class = c("tag_examples", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humdrumPitch.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/humdrumR-package.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumPitch", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumPitch", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR and pitch", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumR", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" includes a number of intertwined data structures, and associated functions, for representing and manipulating musical pitch information.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Tonality", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("There are four data types extensively used in ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" to encode/process ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Tonality", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("tonal", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" musical information:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("integers", class = c("TEXT", "tag"))), Rd_option = structure("base:integer", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" --- used to encode \"", class = c("TEXT", "tag")), structure(list(structure("line-of-fifths", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("\" tonal information\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("tonalInterval", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" --- embeds line-of-fifth tonal integers alongside ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Octave", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("octave", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure(list(structure("\"https://en.wikipedia.org/wiki/Cent_(music)\"", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("cent", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" information to encode most tonal pitch representations (solfege, intervals, letternames, etc.)\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("diatonicSet", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" --- combines line-of-fifth tonal integer representations to represent diatonic tonality, including alterations of basic diatonic scale(s).\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("tertianSet", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" --- an extension of ", class = c("TEXT", "tag")), structure(list(structure("diatonicSet", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" used to encode ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Tertian", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("tertian", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" diatonic harmonies.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("For a detailed explanation of the theory and specifics of ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("'s treatment of tonality, see the ", class = c("TEXT", "tag")), structure(list(structure("Tonality in humdrumR", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" vignette.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Atonality", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure("THIS SECTION IS INCOMPLETE", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("In addition, there are xxx data types used to encode non-tonal (or ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Atonality", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("atonal", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(") pitch information.\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("integers", class = c("TEXT", "tag"))), Rd_option = structure("base:integer", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" --- used to encode ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Semitone", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("semitones", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" (as well as ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/MIDI", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("MIDI", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" numbers).\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("xxx", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" --- sets?\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("xxx", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" --- 12-tone rows?\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humdrumR.Rd = structure(list(structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/humdrumR-package.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("package", class = c("TEXT", "tag"))), class = c("tag_docType", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("humdrumR", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("humdrumR", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("humdrumR", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure(list( structure("humdrumR", class = c("RCODE", "tag" ))), class = c("tag_code", "tag")), structure(" is a toolkit for the analysis of data encoded in the ", class = c("TEXT", "tag")), structure(list(structure(list(structure("http://www.humdrum.org/guide/ch05/", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("humdrum syntax", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure("The humdrum syntax is an incredibly flexible, and powerful, scheme for encoding musical data.\n", class = c("TEXT", "tag")), structure("Tens of thousands of musical scores (and other musical data) have been encoded in the humdrum syntax, many available online through repositories such as\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("http://kern.ccarh.org/", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("KernScores", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(".\n", class = c("TEXT", "tag" ))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is intended as a modernized replacement for the original ", class = c("TEXT", "tag")), structure(list(structure(list(structure("http://www.humdrum.org/", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("humdrum toolkit", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag" )), structure(", levaraging\n", class = c("TEXT", "tag" )), structure("the power of R to give us enprecedented power to manipulate and analyze humdrum data using concise, expressive syntax.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Package design", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("The package ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" has XXX main components:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag" )), structure(" To represent humdrum data in R, we have the ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list( structure(list(structure("http://adv-r.had.co.nz/S4.html", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("S4 class", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(", and it's core component\n", class = c("TEXT", "tag")), structure("the ", class = c("TEXT", "tag")), structure(list(structure("humdrum table", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure(list(), class = c("tag_item", "tag" )), structure(" To create ", class = c("TEXT", "tag" )), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data, a sophisticated humdrum data parser: ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data can also be written back to humdrum-syntax text files using ", class = c("TEXT", "tag")), structure(list(structure("writeHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" To filter and \"index\" ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data, we have the ", class = c("TEXT", "tag")), structure(list(structure("filterHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" function, which can also be called in a variety of\n", class = c("TEXT", "tag")), structure("short hands using R's standard ", class = c("TEXT", "tag")), structure(list(structure("indexing operators", class = c("TEXT", "tag"))), Rd_option = structure("base:Extract", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(": ", class = c("TEXT", "tag")), structure(list(structure("[]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("[[]]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" To manipulate and modify ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data, we have the ", class = c("TEXT", "tag")), structure(list(structure("with(in)Humdrum", class = c("TEXT", "tag"))), Rd_option = structure("=with-in-Humdrum", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" and ", class = c("TEXT", "tag" )), structure(list(structure("humApply", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" functions.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" A set of ", class = c("TEXT", "tag")), structure(list(structure("\"pipe\" operators", class = c("TEXT", "tag"))), Rd_option = structure("=humPipe", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" (", class = c("TEXT", "tag")), structure(list(structure("%hum&gt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("%hum&lt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(", etc.), so that ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data can be manipulated and filtered in concise,\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Vertical_bar#Pipe", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("bash-style pipes", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure(list(), class = c("tag_item", "tag" )), structure(" To facilate the development of functions to work with humdrum tokens---which are simple character strings packed with information---,\n", class = c("TEXT", "tag")), structure("a useful API we call our ", class = c("TEXT", "tag")), structure(list(structure("regular-expression dispatch system", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumDispatch", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure(list(), class = c("tag_item", "tag" )), structure(" Several ", class = c("TEXT", "tag" )), structure(list(structure("modules", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumPitch", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" for representing and manipulating musical pitch information,\n", class = c("TEXT", "tag")), structure("including our core ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" class to represent tonal pitch.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" A ", class = c("TEXT", "tag" )), structure(list(structure("module", class = c("TEXT", "tag"))), Rd_option = structure("=humRhythm", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" for representing and manipulating musical rhythm information,\n", class = c("TEXT", "tag")), structure("with a core ", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" class to represent rhythms.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("internal", class = c("TEXT", "tag"))), class = c("tag_keyword", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humdrumRclass.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/humdrumR-class.R, R/Filter.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("class", class = c("TEXT", "tag"))), class = c("tag_docType", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("makeHumdrumR", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumRS4", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("is.humdrumR", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("$,humdrumR-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("fields", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("$&lt;-,humdrumR,vector-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("$&lt;-,humdrumR,humdrumR-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[&lt;-,humdrumR,character,ANY,vector-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[&lt;-,humdrumR,character,ANY,humdrumR-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[[,humdrumR,missing,character-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[[,humdrumR,missing,missing-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[[,humdrumR,formula,missing-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[[,humdrumR,missing,formula-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("HumdrumR class", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("is.humdrumR(x)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("$", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(x, name)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("fields(\n", class = c("RCODE", "tag" )), structure(" humdrumR,\n", class = c("RCODE", "tag")), structure(" fieldTypes = c(\"Data\", \"Structure\", \"Interpretation\", \"Formal\", \"Reference\")\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure(list( structure(list(structure("$", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humdrumR,vector", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(x, name) &lt;- value\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("$", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humdrumR,humdrumR", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(x, name) &lt;- value\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("[", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humdrumR,character,ANY,vector", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(x, i, j) &lt;- value\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("[", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humdrumR,character,ANY,humdrumR", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(x, i, j) &lt;- value\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdata[[ , 'regex']]\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdata[[ , , ~expression]] or humdata [[ , , 'regex']] or humdata[[z = ~expression]] or humdata[[z = 'regex']]\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdata[[~expression]]\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdata[[ , ~expression]]\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("This ", class = c("TEXT", "tag" )), structure(list(structure("S4", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" class is the basic unit of the\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" package.\n", class = c("TEXT", "tag")), structure("Each ", class = c("TEXT", "tag" )), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object represents data ", class = c("TEXT", "tag")), structure(list(structure("read", class = c("TEXT", "tag"))), Rd_option = structure("=readHumdrum", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" from one or\n", class = c("TEXT", "tag")), structure("more humdrum files.\n", class = c("TEXT", "tag")), structure("In the documentation we refer to the collection of files within a ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" object\n", class = c("TEXT", "tag")), structure("as a \"", class = c("TEXT", "tag" )), structure(list(structure("corpus", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(",\" and each file as a \"", class = c("TEXT", "tag")), structure(list(structure("piece", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(".\"\n", class = c("TEXT", "tag")), structure("However, though humdrum data is ", class = c("TEXT", "tag")), structure(list(structure("usually", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" encoded as one \"piece\" per file, this is not necessarily the case:\n", class = c("TEXT", "tag")), structure("files might represent movements within a piece, or even just a part of a score. Still, we tend to refer\n", class = c("TEXT", "tag")), structure("to them as \"pieces.\"\n", class = c("TEXT", "tag")), structure("In coding examples, we name humdrumR objects \"", class = c("TEXT", "tag")), structure(list(structure("humdata", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\"\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("The most imporant part of a ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object is the\n", class = c("TEXT", "tag")), structure(list(structure("humdrum tables", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" it holds within it.\n", class = c("TEXT", "tag")), structure("In essence, an ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object is simply a wrapper around these\n", class = c("TEXT", "tag")), structure("humdrum tables, which helps users to\n", class = c("TEXT", "tag")), structure("to visualize, index, ", class = c("TEXT", "tag")), structure(list(structure("summarize", class = c("TEXT", "tag"))), Rd_option = structure("=humSummary", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(", and ", class = c("TEXT", "tag" )), structure(list(structure("manipulate", class = c("TEXT", "tag"))), Rd_option = structure("=withinHumdrum", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag")), structure("the table in a variety of ways.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Basic information about the size and shape of ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data can be\n", class = c("TEXT", "tag")), structure("obtained with calls to ", class = c("TEXT", "tag")), structure(list(structure("nrecords, npieces, length, ncol, etc.", class = c("TEXT", "tag"))), Rd_option = structure("=humSize", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure("More detailed summary information can be obtained with the humdrumR ", class = c("TEXT", "tag")), structure(list(structure("corpus summary functions", class = c("TEXT", "tag"))), Rd_option = structure("=humSummary", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure("HumdrumR data can also be coerced to more basic R data types using ", class = c("TEXT", "tag")), structure(list(structure("as.matrix, as.data.frame, etc.", class = c("TEXT", "tag"))), Rd_option = structure("=humCoercion", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure("A number of helpful functions are also defined to ", class = c("TEXT", "tag")), structure(list(structure("reshape", class = c("TEXT", "tag"))), Rd_option = structure("=humShape", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" humdrumR data.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("The most powerful features of ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" are the tools it gives you to\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Filter humdrum data, using ", class = c("TEXT", "tag")), structure(list(structure("filterHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" and the standard R ", class = c("TEXT", "tag")), structure(list(structure("indexing operators", class = c("TEXT", "tag"))), Rd_option = structure("base:Extract", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(": ", class = c("TEXT", "tag" )), structure(list(structure("[]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("[[]]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Apply functions and arbitrary commands to humdrum data using the ", class = c("TEXT", "tag")), structure(list(structure("with(in)Humdrum", class = c("TEXT", "tag"))), Rd_option = structure("=withinHumdrum", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" routines,\n", class = c("TEXT", "tag")), structure("and their associated ", class = c("TEXT", "tag")), structure(list(structure("piping operators", class = c("TEXT", "tag"))), Rd_option = structure("=humPipe", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" ))), class = c("tag_enumerate", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Slots", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure(list( structure("Humtable", class = c("RCODE", "tag" ))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("A list of ", class = c("TEXT", "tag")), structure(list(structure("humdrum tables", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(", each having the same fields\n", class = c("TEXT", "tag")), structure("but containing data from different types of records (e.g., interpretations, data, barlines, comments).", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure(list( structure("Files", class = c("RCODE", "tag" ))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("A list of two elements. The first, \"Search\", contains a single character representing\n", class = c("TEXT", "tag")), structure("the ", class = c("TEXT", "tag")), structure(list(structure("pattern", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" used in the call to ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" which created this humdrumR object.\n", class = c("TEXT", "tag")), structure("The second, \"Names\", is a vector of strings representing all the files which matched the ", class = c("TEXT", "tag")), structure(list(structure("pattern", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("and were read into the ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure(list( structure("Fields", class = c("RCODE", "tag" ))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("A list containing strings corresponding to the existing fields in the ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object.\n", class = c("TEXT", "tag")), structure("The fields are divided into five categories: \"Data\", \"Structure\", \"Interpretation\", \"Formal\", and \"Reference\"---see\n", class = c("TEXT", "tag")), structure("the ", class = c("TEXT", "tag")), structure(list(structure("humdrum table", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" documentation.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure(list( structure("Active", class = c("RCODE", "tag" ))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("A quosure expression which\n", class = c("TEXT", "tag")), structure("extracts data from field(s) in the ", class = c("TEXT", "tag")), structure(list(structure("humdrum table", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(": the \"active expression.\"", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure(list( structure("LoadTime", class = c("RCODE", "tag"))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("A ", class = c("TEXT", "tag")), structure(list(structure("POSIXct", class = c("TEXT", "tag"))), Rd_option = structure("base:DateTimeClasses", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" value, indicating the time at which ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" was\n", class = c("TEXT", "tag" )), structure("called to create this ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure(list( structure("Patterns", class = c("RCODE", "tag"))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("A character vector of the original search patterns used to match files in the system.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_describe", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Active field", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag")), structure(list(structure("Active", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" slot of a ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" object contains an ", class = c("TEXT", "tag")), structure(list(structure("expression", class = c("TEXT", "tag"))), Rd_option = structure("rlang:quosure", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag")), structure("which refers to fields in the internal ", class = c("TEXT", "tag")), structure(list(structure("humdrum table", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Go to the dedicated ", class = c("TEXT", "tag")), structure(list(structure("active field", class = c("TEXT", "tag"))), Rd_option = structure("=humActive", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" documentation to learn more about this important slot!\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humdrumRroot.Rd = structure(list(structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/humdrumR-package.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("data", class = c("TEXT", "tag"))), class = c("tag_docType", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("humdrumRroot", class = c("VERB", "tag" ))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumRroot", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("'s root directory on your machine.", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("An object of class ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" of length 1.\n", class = c("TEXT", "tag"))), class = c("tag_format", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("humdrumRroot\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumRroot", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is the path to where the ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" package is install on your machine.\n", class = c("TEXT", "tag")), structure("A few simple humdrum files are stored here.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("datasets", class = c("TEXT", "tag"))), class = c("tag_keyword", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), interpolateArguments.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Apply.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("interpolateArguments", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("interpolateArguments", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Change or insert values in an expression", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("interpolateArguments(quo, namedArgs)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("namedArgs", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A list of named arguments. Unnamed arguments are simply ignored.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("expr", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A unevaluated expression object.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" ))), class = c("tag_arguments", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("This function can be used to modify arguments to a functions\n", class = c("TEXT", "tag")), structure("within an existing expression (or quosure/formula).\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("interpolateArguments", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" inteprets named value in its ", class = c("TEXT", "tag")), structure(list(structure("namedArgs", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("argument in one of two ways: If the named value is a list, it interprets\n", class = c("TEXT", "tag")), structure("the name of the list as a function call, and inserts/swaps any arguments\n", class = c("TEXT", "tag")), structure("in that list into any instances of that function call within the ", class = c("TEXT", "tag")), structure(list(structure("expr", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Named arguments are inserted or substituted if already present in expression.\n", class = c("TEXT", "tag")), structure("Unnamed argmuments are simply added to the call.\n", class = c("TEXT", "tag")), structure("Examples:", class = c("TEXT", "tag")), structure(list(structure("myexpr &lt;- quote(dnorm(x, mean = 5))\n", class = c("VERB", "tag")), structure("interpolateArguments(myexpr, list(dnorm = list(mean = 2, sd = 5, TRUE)))\n", class = c("VERB", "tag")), structure("\n", class = c("VERB", "tag")), structure("# result is new expresson: dnorm(x, mean = 2, sd = 5, TRUE)\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("If a named valued in the ", class = c("TEXT", "tag")), structure(list(structure("namedArgs", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument is not a list,\n", class = c("TEXT", "tag")), structure("that name/value pair is substituted anywhere it is present in the expression.\n", class = c("TEXT", "tag")), structure("This approach is often more conscise, but arguments cannot be added to an\n", class = c("TEXT", "tag")), structure("expression this way, only substituted if already present.\n", class = c("TEXT", "tag")), structure("Examples:", class = c("TEXT", "tag")), structure(list(structure("myexpr &lt;- quote(dnorm(x, mean = 5))\n", class = c("VERB", "tag")), structure("interpolateArguments(myexpr, mean = 2)\n", class = c("VERB", "tag")), structure("\n", class = c("VERB", "tag")), structure("# result is new expression: dnorm(x, mean = 2)\n", class = c("VERB", "tag")), structure("}\n", class = c("VERB", "tag" ))), class = c("tag_preformatted", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("myexpr2 &lt;- quote(A + b*x + rnorm(length(a), mean(Z), sd = 2))\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("interpolateArguments(myexpr2,\n", class = c("RCODE", "tag")), structure(" list(sd = 10, mean = list(na.rm = TRUE)))\n", class = c("RCODE", "tag")), structure(" \n", class = c("RCODE", "tag")), structure("# result is new expression: \n", class = c("RCODE", "tag")), structure("# a + b*x + rnorm(length(a), mean(Z, na.rm = TRUE), sd = 10)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag"))), class = c("tag_examples", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), intervalCalculus.Rd = structure(list(structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/tools.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("intervalCalculus", class = c("VERB", "tag" ))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("intervalCalculus", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("integrate", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("sigma", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("derive", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("delta", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("calculus", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Interval \"calculus\"", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("integrate(intervals, skip = list(is.na))\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag")), structure("sigma(intervals, skip = list(is.na))\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("derive(intervals, skip = list(is.na))\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("delta(intervals, skip = list(is.na))\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("calculus(x, n, skip = list(na))\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Interval \"calculus\"\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), keyTransformer.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/diatonicSet.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("keyTransformer", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("keyTransformer", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("key", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Parsing and deparsing key information", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("key(x, ..., Key = NULL, parseArgs = list(), memoize = TRUE, deparse = TRUE)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("XXX\n", class = c("TEXT", "tag" ))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), lag.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/tools.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("lag", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("lag", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("lead", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Shift data within a vector/matrix/data.frame", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("lag(x, n = 1, fill = NA, wrap = FALSE, windows = NULL, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("lead(x, n, ...)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("x", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("The input argument. Should be vector (including lists), array, or data.frame", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("n", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("The amount to lag/lead the data.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("fill", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("If ", class = c("TEXT", "tag")), structure(list(structure("wrap = FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and/or ", class = c("TEXT", "tag")), structure(list(structure("windows = NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", parts of the output are padded with the ", class = c("TEXT", "tag")), structure(list(structure("fill", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument. Defaults to ", class = c("TEXT", "tag")), structure(list(structure("NA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("wrap", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("If ", class = c("TEXT", "tag")), structure(list(structure("wrap = TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", data from the end (head or tail) is copied to the other end of the output, \"wrapping\" the data\n", class = c("TEXT", "tag")), structure("within the data structure.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("windows", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A vector or list of vectors, all of th same length as ", class = c("TEXT", "tag")), structure(list(structure("x", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". Lags crossing the boundaries indicated in ", class = c("TEXT", "tag")), structure(list(structure("windows", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("are filled.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("margin", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("Arrays and data.frames can be lagged lead in multiple dimensions using the ", class = c("TEXT", "tag")), structure(list(structure("margin", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" ))), class = c("tag_arguments", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag" )), structure(list(structure("lag", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("lead", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" functions take input vectors, matrices, or data.frames and shifts their data\n", class = c("TEXT", "tag")), structure("by ", class = c("TEXT", "tag" )), structure(list(structure("n", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" indices.\n", class = c("TEXT", "tag")), structure("They are similiar to the ", class = c("TEXT", "tag")), structure(list(structure("data.table::shift", class = c("TEXT", "tag"))), Rd_option = structure("data.table:shift", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" function, but with a few additional options:\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("data.table::shift()", class = c("TEXT", "tag"))), Rd_option = structure("data.table:shift", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), metricPosition.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/rhythmInterval.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("metricPosition", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("metricPosition", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Calculate metric positions from duration data.", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("metricPosition(rints, bars = NULL, beats = rint(c(2, 4, 8, 16, 32)))\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Calculate metric positions from duration data.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Other rhythm analysis tools: \n", class = c("TEXT", "tag")), structure(list(structure(list(structure("rhythmDecompose", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("()", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("rhythmOffset", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("()", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythm analysis tools", class = c("TEXT", "tag"))), class = c("tag_concept", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), pitchFunctions.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/tonalInterval.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("pitchFunctions", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("pitchFunctions", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("semit", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("midi", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("pitch", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("kern", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("lilypond", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("interval", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("degree", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("solfa", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Manipulate pitch data", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("semit(\n", class = c("RCODE", "tag")), structure(" x,\n", class = c("RCODE", "tag" )), structure(" ...,\n", class = c("RCODE", "tag" )), structure(" Key = NULL,\n", class = c("RCODE", "tag")), structure(" Exclusive = NULL,\n", class = c("RCODE", "tag")), structure(" parseArgs = list(),\n", class = c("RCODE", "tag")), structure(" transposeArgs = list(),\n", class = c("RCODE", "tag")), structure(" inPlace = FALSE,\n", class = c("RCODE", "tag")), structure(" memoize = TRUE,\n", class = c("RCODE", "tag")), structure(" deparse = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("midi(\n", class = c("RCODE", "tag")), structure(" x,\n", class = c("RCODE", "tag" )), structure(" ...,\n", class = c("RCODE", "tag" )), structure(" Key = NULL,\n", class = c("RCODE", "tag")), structure(" Exclusive = NULL,\n", class = c("RCODE", "tag")), structure(" parseArgs = list(),\n", class = c("RCODE", "tag")), structure(" transposeArgs = list(),\n", class = c("RCODE", "tag")), structure(" inPlace = FALSE,\n", class = c("RCODE", "tag")), structure(" memoize = TRUE,\n", class = c("RCODE", "tag")), structure(" deparse = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("pitch(\n", class = c("RCODE", "tag")), structure(" x,\n", class = c("RCODE", "tag" )), structure(" ...,\n", class = c("RCODE", "tag" )), structure(" Key = NULL,\n", class = c("RCODE", "tag")), structure(" Exclusive = NULL,\n", class = c("RCODE", "tag")), structure(" parseArgs = list(),\n", class = c("RCODE", "tag")), structure(" transposeArgs = list(),\n", class = c("RCODE", "tag")), structure(" inPlace = FALSE,\n", class = c("RCODE", "tag")), structure(" memoize = TRUE,\n", class = c("RCODE", "tag")), structure(" deparse = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("kern(\n", class = c("RCODE", "tag")), structure(" x,\n", class = c("RCODE", "tag" )), structure(" ...,\n", class = c("RCODE", "tag" )), structure(" Key = NULL,\n", class = c("RCODE", "tag")), structure(" Exclusive = NULL,\n", class = c("RCODE", "tag")), structure(" parseArgs = list(),\n", class = c("RCODE", "tag")), structure(" transposeArgs = list(),\n", class = c("RCODE", "tag")), structure(" inPlace = FALSE,\n", class = c("RCODE", "tag")), structure(" memoize = TRUE,\n", class = c("RCODE", "tag")), structure(" deparse = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("lilypond(\n", class = c("RCODE", "tag")), structure(" x,\n", class = c("RCODE", "tag" )), structure(" ...,\n", class = c("RCODE", "tag" )), structure(" Key = NULL,\n", class = c("RCODE", "tag")), structure(" Exclusive = NULL,\n", class = c("RCODE", "tag")), structure(" parseArgs = list(),\n", class = c("RCODE", "tag")), structure(" transposeArgs = list(),\n", class = c("RCODE", "tag")), structure(" inPlace = FALSE,\n", class = c("RCODE", "tag")), structure(" memoize = TRUE,\n", class = c("RCODE", "tag")), structure(" deparse = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("interval(\n", class = c("RCODE", "tag")), structure(" x,\n", class = c("RCODE", "tag" )), structure(" ...,\n", class = c("RCODE", "tag" )), structure(" Key = NULL,\n", class = c("RCODE", "tag")), structure(" Exclusive = NULL,\n", class = c("RCODE", "tag")), structure(" parseArgs = list(),\n", class = c("RCODE", "tag")), structure(" transposeArgs = list(),\n", class = c("RCODE", "tag")), structure(" inPlace = FALSE,\n", class = c("RCODE", "tag")), structure(" memoize = TRUE,\n", class = c("RCODE", "tag")), structure(" deparse = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("degree(\n", class = c("RCODE", "tag")), structure(" x,\n", class = c("RCODE", "tag" )), structure(" ...,\n", class = c("RCODE", "tag" )), structure(" Key = NULL,\n", class = c("RCODE", "tag")), structure(" Exclusive = NULL,\n", class = c("RCODE", "tag")), structure(" parseArgs = list(),\n", class = c("RCODE", "tag")), structure(" transposeArgs = list(),\n", class = c("RCODE", "tag")), structure(" inPlace = FALSE,\n", class = c("RCODE", "tag")), structure(" memoize = TRUE,\n", class = c("RCODE", "tag")), structure(" deparse = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("solfa(\n", class = c("RCODE", "tag")), structure(" x,\n", class = c("RCODE", "tag" )), structure(" ...,\n", class = c("RCODE", "tag" )), structure(" Key = NULL,\n", class = c("RCODE", "tag")), structure(" Exclusive = NULL,\n", class = c("RCODE", "tag")), structure(" parseArgs = list(),\n", class = c("RCODE", "tag")), structure(" transposeArgs = list(),\n", class = c("RCODE", "tag")), structure(" inPlace = FALSE,\n", class = c("RCODE", "tag")), structure(" memoize = TRUE,\n", class = c("RCODE", "tag")), structure(" deparse = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" ))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Manipulate pitch data\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("tonalInterval\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), plotRhythm.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Graphics.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("plotRhythm", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("plotRhythm", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("plotRhythm.default", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("plotRhythm.rhythmInterval", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("-------------------------------------------&gt; NEEDS DOCUMENTATION &lt;-------------------------------------------\n", class = c("TEXT", "tag")), structure("Plotting rhythmic symbols in R base graphics", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("plotRhythm(x, y, notes, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("plotRhythm", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("default", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x, y, notes, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("plotRhythm", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x, y, notes, ...)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("-------------------------------------------&gt; NEEDS DOCUMENTATION &lt;-------------------------------------------\n", class = c("TEXT", "tag")), structure("Plotting rhythmic symbols in R base graphics\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), rational.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/tools.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rational", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rational", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("as.rational", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("fraction", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("as.fraction", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Rational numbers", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("rational(numerator, denominator = 1)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("as.rational(x, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("fraction(numerator, denominator, sep = \"/\")\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("as.fraction(x, sep, ...)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("R has no built in rational number representation; ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" defines one.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("as.decimal()", class = c("TEXT", "tag"))), Rd_option = structure("=as.decimal", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure(list(structure("as.numeric()", class = c("TEXT", "tag"))), Rd_option = structure("=as.numeric", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Other ", class = c("TEXT", "tag")), structure(list(structure("humdrumR numeric functions", class = c("TEXT", "tag"))), class = c("LIST", "tag")), structure(": \n", class = c("TEXT", "tag")), structure(list(structure(list(structure("decimal", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("()", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("humdrumR numeric functions", class = c("TEXT", "tag"))), class = c("LIST", "tag"))), class = c("tag_concept", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), readHumdrum.Rd = structure(list(structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Read.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("readHumdrum", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("readHumdrum", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("findHumdrum", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("Find and read humdrum files into R", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("findHumdrum(\n", class = c("RCODE", "tag")), structure(" ...,\n", class = c("RCODE", "tag" )), structure(" contains = NULL,\n", class = c("RCODE", "tag")), structure(" recursive = FALSE,\n", class = c("RCODE", "tag")), structure(" allowDuplicates = FALSE,\n", class = c("RCODE", "tag")), structure(" verbose = FALSE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag")), structure("readHumdrum(\n", class = c("RCODE", "tag")), structure(" ...,\n", class = c("RCODE", "tag")), structure(" recursive = FALSE,\n", class = c("RCODE", "tag")), structure(" contains = NULL,\n", class = c("RCODE", "tag")), structure(" allowDuplicates = FALSE,\n", class = c("RCODE", "tag")), structure(" verbose = FALSE,\n", class = c("RCODE", "tag")), structure(" tandems = \"known\",\n", class = c("RCODE", "tag")), structure(" reference = \"all\"\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" ))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("...", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("character: One or more patterns used to identify files to read.\n", class = c("TEXT", "tag")), structure("For details: see the \"REpath-patterns\" section below.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("contains", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure(list( structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". If ", class = c("TEXT", "tag")), structure(list(structure("!is.null(contains)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the ", class = c("TEXT", "tag")), structure(list(structure("contains", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument is\n", class = c("TEXT", "tag")), structure("is treated as regular expressions: only files which contain matches to\n", class = c("TEXT", "tag")), structure(list(structure("all", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" of these regular expressions are read.\n", class = c("TEXT", "tag")), structure("Thus, ", class = c("TEXT", "tag" )), structure(list(structure("readHumdrum('.*krn$', contains = \"EEE\")", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will only read kern files which contain matches\n", class = c("TEXT", "tag")), structure("to ", class = c("TEXT", "tag" )), structure(list(structure("\"EE\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("---which is kern for the E two octaves below middle C (or lower).", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("recursive", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("logical: If ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the final part of the search pattern (i.e., the file search) is searched for\n", class = c("TEXT", "tag")), structure("recursively through all sub directories.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("allowDuplicates", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure(list( structure("logical", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" of length one, indicating what should happen if multiple search patterns match the same files.\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag")), structure(list(structure("allowDuplicates = TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag")), structure("any such files are read multiple times, grouped into their respective corpora by the ", class = c("TEXT", "tag")), structure(list(structure("Label", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field.\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag" )), structure(list(structure("allowDuplicates = FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", any redundant files are only read into the corpus of the first pattern they\n", class = c("TEXT", "tag")), structure("match.", class = c("TEXT", "tag" ))), class = "tag")), class = c("tag_item", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("verbose", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("logical: If ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the names of matching files are printed before parsing begins. This is very\n", class = c("TEXT", "tag")), structure("useful as a check to make sure you aren't reading the wrong files!", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("tandems", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure(list( structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". This argument controls which, if any, tandem interpretations\n", class = c("TEXT", "tag")), structure("are parsed into their own fields. The default value is ", class = c("TEXT", "tag")), structure(list(structure("\"known\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("reference", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure(list( structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". This argument controls which, if any, reference records\n", class = c("TEXT", "tag")), structure("are parsed into their own fields. The default value is ", class = c("TEXT", "tag")), structure(list(structure("\"all\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag" )), structure("\n", class = c("TEXT", "tag"))), class = c("tag_arguments", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure("These functions find valid humdrum files on your local machine and read them into ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("findHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" does the work of finding and reading the text files into R.\n", class = c("TEXT", "tag")), structure(list(structure("readHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" utilizes ", class = c("TEXT", "tag")), structure(list(structure("findHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" to read files, then parses them to\n", class = c("TEXT", "tag")), structure("create a ", class = c("TEXT", "tag" )), structure(list(structure("humTable", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" and build\n", class = c("TEXT", "tag")), structure("a ", class = c("TEXT", "tag")), structure(list( structure("humdrumR", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" data object around the table.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("REpath-patterns", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\"REpath-patterns\" are specified using ", class = c("TEXT", "tag")), structure(list(structure("...", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" arguments.\n", class = c("TEXT", "tag")), structure("In combination, all the ", class = c("TEXT", "tag")), structure(list(structure("...", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" arguments are used to search for file paths.\n", class = c("TEXT", "tag")), structure("Each part of the search path you specify (", class = c("TEXT", "tag")), structure(list(structure("\"dirpart/dirpart/filepart\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", etc) are matched as regular expressions\n", class = c("TEXT", "tag")), structure("against directories/files on your disc.\n", class = c("TEXT", "tag")), structure("Thus, we can say things like ", class = c("TEXT", "tag")), structure(list(structure("findHumdrum(\"../^A.*/.*krn$\")", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", which would\n", class = c("TEXT", "tag")), structure("match any kern files in any directory beginning with a capital ", class = c("TEXT", "tag")), structure(list(structure("\"A\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" in the\n", class = c("TEXT", "tag")), structure("directory above the current working directory.\n", class = c("TEXT", "tag")), structure("For conveniance, you can break the path across multiple arguments instead of using delimited strings: For example, the code\n", class = c("TEXT", "tag")), structure(list(structure("findHumdrum(\"..\", \"^A.*\", \".*krn$\")", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will give an identical result as the previous example\n", class = c("TEXT", "tag")), structure("(", class = c("TEXT", "tag")), structure(list( structure("findHumdrum(\"../^A.*/,*krn$\")", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag")), structure("This is useful when searching for more than one pattern (see next paragraph) in the same directory.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("If you want to search for ", class = c("TEXT", "tag")), structure(list(structure("more than one", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" pattern, you can input them as a character vector:\n", class = c("TEXT", "tag")), structure("For instance, ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum(c(\"mozart\", \"beethoven\")", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("---this command will search for\n", class = c("TEXT", "tag")), structure("filenames containing \"mozart\" OR \"beethoven.\"\n", class = c("TEXT", "tag")), structure("This works for directories too: ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum(c(\"Mozart\", \"Beethoven\"), \".*krn$\")", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will\n", class = c("TEXT", "tag")), structure("look for any kern files in directories containing \"Mozart\" OR \"Beethoven.\"\n", class = c("TEXT", "tag")), structure("If patterns are named, these names will show up as identifying patterns in the ", class = c("TEXT", "tag")), structure(list(structure("[humdrumR][humdrumR]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" object's\n", class = c("TEXT", "tag")), structure(list(structure("Label", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field. Unnamed patterns are simply labeled with numbers.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Normal (system appropriate) conventions (i.e., directories separated by ", class = c("TEXT", "tag")), structure(list(structure("\"/\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag")), structure(list(structure("'~'", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" at beginning to indicate home, ", class = c("TEXT", "tag")), structure(list(structure("\"..\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" to indicate directory above working directory, etc.)\n", class = c("TEXT", "tag")), structure("are followed.\n", class = c("TEXT", "tag")), structure("If a pattern contains a solo dot followed by a file sep---e.g., ", class = c("TEXT", "tag")), structure(list(structure("\"./\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("\"x/./y\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("---this is\n", class = c("TEXT", "tag")), structure("treated as the current directory, not a regular expression.\n", class = c("TEXT", "tag")), structure("If a pattern contains two dots---e.g., ", class = c("TEXT", "tag")), structure(list(structure("\"../\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("---this is treated as the directory above, not a regular expression.\n", class = c("TEXT", "tag")), structure("If you want to create a regular expression to match any directory, use ", class = c("TEXT", "tag")), structure(list(structure("\".*/\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("The regex pattern ", class = c("TEXT", "tag")), structure(list(structure("\"\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" matches any file (it is changed to ", class = c("TEXT", "tag")), structure(list(structure("\".*\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("). If you don't specifiy any ", class = c("TEXT", "tag")), structure(list(structure("...", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument,\n", class = c("TEXT", "tag")), structure(list(structure("findHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (or ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") will default to ", class = c("TEXT", "tag")), structure(list(structure("\".*\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" as well.\n", class = c("TEXT", "tag")), structure("Thus, ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum()", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will read any humdrum files in the working directory.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("(If two or more files in different directories share the same name, a unique name is created for\n", class = c("TEXT", "tag")), structure("each file by appending the names of the directories they occupy, recursively\n", class = c("TEXT", "tag")), structure("until the names are unique.)\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("If a single humdrum file has multiple pieces in it---meaning that all spine paths close with ", class = c("TEXT", "tag")), structure(list(structure("*-", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(", then\n", class = c("TEXT", "tag")), structure("open again with ", class = c("TEXT", "tag")), structure(list(structure("**", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("---then they are parsed separetely.\n", class = c("TEXT", "tag")), structure("They are distinguished in the ", class = c("TEXT", "tag")), structure(list(structure("Piece", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field.\n", class = c("TEXT", "tag")), structure("If there are no multi-piece files, ", class = c("TEXT", "tag")), structure(list(structure("Piece", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("File", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will be identical.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Validity", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("findHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" automatically ignore non-text files.\n", class = c("TEXT", "tag")), structure("Whatsmore, any files which contain humdrum syntax errors (checked by ", class = c("TEXT", "tag")), structure(list(structure("[validateHumdrum][validateHumdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(") are automatically\n", class = c("TEXT", "tag")), structure("skipped. If you want to see specifically what errors occured, call ", class = c("TEXT", "tag")), structure(list(structure("[validateHumdrum][validateHumdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("\n", class = c("TEXT", "tag")), structure("directly and its ", class = c("TEXT", "tag")), structure(list(structure("errorReport.path", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Tandem Interpretations", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag")), structure(list(structure("tandems", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument controls which tandem interpretations\n", class = c("TEXT", "tag")), structure("parsed into their own fields. This can be helpful to either save processing time and memory\n", class = c("TEXT", "tag")), structure("by ", class = c("TEXT", "tag" )), structure(list(structure("not", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" parsing interpretations you won't need, or to parse interpretations that\n", class = c("TEXT", "tag")), structure("humdrumR doesn't recognize.\n", class = c("TEXT", "tag")), structure("The \"known\" tandem interpretations that humdrumR recognizes are encoded in a build humdrumR\n", class = c("TEXT", "tag")), structure("table called ", class = c("TEXT", "tag")), structure(list(structure("knownInterpretations", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Each interpretation has a humdrumR name (\"Clef\", \"TimeSignature\", etc.) as well as a regular expression\n", class = c("TEXT", "tag")), structure("associated with it.\n", class = c("TEXT", "tag")), structure("The default value for the ", class = c("TEXT", "tag")), structure(list(structure("tandems", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument is ", class = c("TEXT", "tag")), structure(list(structure("\"known\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". If the ", class = c("TEXT", "tag")), structure(list(structure("tandems", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument\n", class = c("TEXT", "tag")), structure("contains ", class = c("TEXT", "tag")), structure(list(structure("\"known\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("all", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" tandem interpretations in the built-in ", class = c("TEXT", "tag")), structure(list(structure("knownInterpretations", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("table are parsed.\n", class = c("TEXT", "tag")), structure("Users may specify different interpretations to parse in two ways:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" character strings\n", class = c("TEXT", "tag")), structure("matching one of the name values from the ", class = c("TEXT", "tag")), structure(list(structure("Name", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" column of ", class = c("TEXT", "tag")), structure(list(structure("knownInterpretations", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("For instance, if you specify ", class = c("TEXT", "tag")), structure(list(structure("tandems = c('Clef', 'TimeSignature')", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", only clef (e.g., ", class = c("TEXT", "tag")), structure(list(structure("\"*clefG2\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("),\n", class = c("TEXT", "tag")), structure("and time signature (e.g., ", class = c("TEXT", "tag")), structure(list(structure("\"*M3/4\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") intepretations will be parsed.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" if the chracter string(s) in ", class = c("TEXT", "tag")), structure(list(structure("tandem", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" do not exactly match one of the names in\n", class = c("TEXT", "tag")), structure(list(structure("knownInterpretations$Name", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", they are treated as regular expressions and used to match\n", class = c("TEXT", "tag")), structure("tandem interpretations in the data. This allows users to parse non-standard tandem interpretations\n", class = c("TEXT", "tag")), structure("that humdrumR doesn't already know about.\n", class = c("TEXT", "tag"))), class = c("tag_enumerate", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("If any values in ", class = c("TEXT", "tag")), structure(list(structure("tandems", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" are named, these names will be used for resulting fields.\n", class = c("TEXT", "tag")), structure("If no matches to an given interpretation are found, no field is created for that interpretation.\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag" )), structure(list(structure("tandems = NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", then no tandem interpretations are parsed.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Reference Records", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("By default (", class = c("TEXT", "tag")), structure(list(structure("reference = \"all\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("), humdrumR reads all reference records in the data.\n", class = c("TEXT", "tag")), structure("The reference code for each record (e.g, the \"OTL\", in \"!!!OTL: xxx\") is used as the name of\n", class = c("TEXT", "tag")), structure("an associated field.\n", class = c("TEXT", "tag")), structure("(If a reference record has no reference code (i.e., it lacks a colon), the field is called \"Unkeyed.\")\n", class = c("TEXT", "tag")), structure("In large datasets with many reference records, the reference data can actually make up a large portion\n", class = c("TEXT", "tag")), structure("of the humdrum table, and eat up a lot of memory. In these cases, we might not want to read\n", class = c("TEXT", "tag")), structure("all (or any) reference records---we can instead read only the reference records that we are planning to use\n", class = c("TEXT", "tag")), structure("in our analyses (if any).\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag")), structure(list(structure("reference = NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", no reference records are parsed.\n", class = c("TEXT", "tag")), structure("Otherwise, the character values of ", class = c("TEXT", "tag")), structure(list(structure("reference", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" are treated as reference codes and only\n", class = c("TEXT", "tag")), structure("matching reference records are parsed.\n", class = c("TEXT", "tag")), structure("For instance, ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum(_, reference = \"OTL\")", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" will ", class = c("TEXT", "tag")), structure(list(structure("only", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" parse OTL reference records.\n", class = c("TEXT", "tag")), structure("If the values of ", class = c("TEXT", "tag")), structure(list(structure("reference", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" are named, these names are used to name associated fields.\n", class = c("TEXT", "tag")), structure("Thus, by specifing ", class = c("TEXT", "tag")), structure(list(structure("reference = c(Title = 'OTL')", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", you can use \"OTL\" reference records to populate\n", class = c("TEXT", "tag")), structure("a field called \"Title\".\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("If there are more than one reference records with the same reference code,\n", class = c("TEXT", "tag")), structure("either explicitely numbered (e.g., \"!!!COM1:\", \"!!!COM2:\") all are read and rather than making two\n", class = c("TEXT", "tag")), structure("or more fields, a single field is created (\"COM\" in this) with the multiple values separated by \";\".\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Result", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("findHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" returns a \"fileFrame\" (", class = c("TEXT", "tag")), structure(list(structure("data.table", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("), listing all file names,\n", class = c("TEXT", "tag")), structure("the patterns they match, the directories they were found in, ", class = c("TEXT", "tag")), structure(list(structure("and", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" the raw text content of these files.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("readHumdrum", class = c("RCODE", "tag" ))), class = c("tag_code", "tag")), structure(" returns a fully parsed ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag")), structure("readHumdrum() # loads all valid humdrum files in the current directory.\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("readHumdrum(\".*krn$\") # loads all files ending with \"krn\" in the currect directory\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("readHumdrum(\"^Composers$/^Be|^Mo/.*/^Joined$/.*krn$\") \n", class = c("RCODE", "tag")), structure("# Goes inside the directory \"Composers\".\n", class = c("RCODE", "tag")), structure("# Inside \"Composers\" looks for directories that start with \"Be\" or \"Mo\".\n", class = c("RCODE", "tag")), structure("# If there are any \"Be|Mo\" matching directories within \"Composers\", matches all directories within them.\n", class = c("RCODE", "tag")), structure("# Within these directories, looks for directories called \"Joined\".\n", class = c("RCODE", "tag")), structure("# If there are any directories called \"Joined\", loads all files (if any) that end with \"krn\".\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("readHumdrum(\"^Composers$\", \"^Be|^Mo\", \".*\", \"^Joined$\", \".*krn$\")\n", class = c("RCODE", "tag")), structure("# exactly the same as the previous!\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("readHumdrum(\"^Composers$\", c(Beethoven = \"^Be\", Mozart = \"^Mo\"), \".*\", \"^Joined$\", \".*krn$\") \n", class = c("RCODE", "tag")), structure("# exactly the same as the previous, except now the two matching patterns (\"^Be\", or \"^Mo\") will be grouped\n", class = c("RCODE", "tag")), structure("# in the Label field as \"Beethoven\" and \"Mozart\" respectively.\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" ))), class = c("tag_examples", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), regexConstruction.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Regex.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("regexConstruction", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("regexConstruction", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("captureRE", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("captureUniq", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("orRE", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Making Regular Expressions", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("captureRE(strs, n = \"\")\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("captureUniq(strs, zero = TRUE)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("orRE(...)\n", class = c("RCODE", "tag" ))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" includes some helpful functions for creating new regular expressions which work with the\n", class = c("TEXT", "tag")), structure(list(structure("stringr", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" package.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("captureRE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will take a character vector and collapse it to a \"capture group.\"\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag" )), structure(list(structure("n", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument can be used to append a number tag, for instance ", class = c("TEXT", "tag")), structure(list(structure("'*'", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (zero or more) to the group.\n", class = c("TEXT", "tag")), structure("I.e., ", class = c("TEXT", "tag" )), structure(list(structure("captureRE(c(\"a\", \"b\", \"c\"), '*')", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will output ", class = c("TEXT", "tag")), structure(list(structure("\"[abc]*\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("captureUniq", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will make a similar capture group to ", class = c("TEXT", "tag")), structure(list(structure("captureRE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", but with an expression\n", class = c("TEXT", "tag")), structure("that makes sure that only 1 or more ", class = c("TEXT", "tag")), structure(list(structure("of the same character", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" repeats.\n", class = c("TEXT", "tag")), structure("For instance, ", class = c("TEXT", "tag")), structure(list(structure("captureUniq(c('a', 'b','c'))", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will return ", class = c("TEXT", "tag")), structure(list(structure("\"([abc])\\\\1*\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("---this expression will match\n", class = c("TEXT", "tag")), structure(list(structure("\"aaa\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("\"bb\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" but not ", class = c("TEXT", "tag")), structure(list(structure("\"aabb\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), rhythmDecompose.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/rhythmInterval.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmDecompose", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmDecompose", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Decompose durations in terms of other durations", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("rhythmDecompose(rhythmInterval, into = rint(c(1, 2, 4, 8, 16, 32)))\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Decompose durations in terms of other durations\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Other rhythm analysis tools: \n", class = c("TEXT", "tag")), structure(list(structure(list(structure("metricPosition", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("()", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("rhythmOffset", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("()", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythm analysis tools", class = c("TEXT", "tag"))), class = c("tag_concept", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), rhythmFunctions.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/rhythmInterval.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmFunctions", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmFunctions", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("recip", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("duration", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Manipulate pitch data", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("recip(\n", class = c("RCODE", "tag")), structure(" x,\n", class = c("RCODE", "tag" )), structure(" ...,\n", class = c("RCODE", "tag" )), structure(" Exclusive = NULL,\n", class = c("RCODE", "tag")), structure(" parseArgs = list(),\n", class = c("RCODE", "tag")), structure(" timeArgs = list(),\n", class = c("RCODE", "tag")), structure(" inPlace = FALSE,\n", class = c("RCODE", "tag")), structure(" memoize = TRUE,\n", class = c("RCODE", "tag")), structure(" deparse = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("duration(\n", class = c("RCODE", "tag")), structure(" x,\n", class = c("RCODE", "tag" )), structure(" ...,\n", class = c("RCODE", "tag" )), structure(" Exclusive = NULL,\n", class = c("RCODE", "tag")), structure(" parseArgs = list(),\n", class = c("RCODE", "tag")), structure(" timeArgs = list(),\n", class = c("RCODE", "tag")), structure(" inPlace = FALSE,\n", class = c("RCODE", "tag")), structure(" memoize = TRUE,\n", class = c("RCODE", "tag")), structure(" deparse = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" ))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Manipulate pitch data\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("rhythmInterval\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), rhythmInterval.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/rhythmInterval.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rint", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("as.character,rhythmInterval-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("as.double.rhythmInterval", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("is.rhythmInterval", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("is.numeric,rhythmInterval-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("order.rhythmInterval", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Compare,rhythmInterval,rhythmInterval-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Summary,rhythmInterval-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval.logical", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval.NULL", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval.numeric", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval.rational", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval.fraction", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval.integer", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval.character", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Representation of rhythmic information", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("rhythmInterval(x, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("rint(denominator, numerator = 1L)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("as.character", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(x)\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure(list( structure(list(structure("as.double", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x)\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("is.rhythmInterval(x)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("is.numeric", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(x)\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("order.rhythmInterval(\n", class = c("RCODE", "tag")), structure(" x,\n", class = c("RCODE", "tag" )), structure(" ...,\n", class = c("RCODE", "tag" )), structure(" na.last = TRUE,\n", class = c("RCODE", "tag")), structure(" decreasing = FALSE,\n", class = c("RCODE", "tag")), structure(" method = c(\"auto\", \"shell\", \"radix\")\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure(list( structure(list(structure("Compare", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("rhythmInterval,rhythmInterval", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(e1, e2)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("Summary", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(x)\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("rhythmInterval(x, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("logical", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("`NULL`", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("numeric", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(n)\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure(list( structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("rational", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x)\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure(list( structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("fraction", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x)\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure(list( structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("integer", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x)\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure(list( structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("character", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(str, Exclusive = NULL, ..., multiDispatch = FALSE)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("This ", class = c("TEXT", "tag" )), structure(list(structure("S4", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" class is the core rhythm representation in the ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" package.\n", class = c("TEXT", "tag")), structure("The object is used to represent rhythmic durations\n", class = c("TEXT", "tag")), structure("and metric positions.\n", class = c("TEXT", "tag")), structure("Each duration is represented in\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Whole_note", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("whole note", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" units.\n", class = c("TEXT", "tag")), structure("Numerically, these whole note units are represented as a ratio\n", class = c("TEXT", "tag")), structure("between integers, held in the slots ", class = c("TEXT", "tag")), structure(list(structure("@Numerator", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("@Denominator", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("This allows use to represent any rational number with no loss of precision\n", class = c("TEXT", "tag")), structure("due to rounding errors and weak decimal expansions (like ", class = c("TEXT", "tag")), structure(list(structure("0.333333", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag")), structure("Rhythm intervals are similar to standard musical\n", class = c("TEXT", "tag")), structure("termoniology (i.e, \"three eighth-notes\" is the ratio (3/8).\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Slots", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure(list( structure("Numerator", class = c("RCODE", "tag" ))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("Integers", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure(list( structure("Octave", class = c("RCODE", "tag" ))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("Integers", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_describe", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Vectorization", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" inherits from the virtual class\n", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("This means you can apply normal vectorized commands to ", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s,\n", class = c("TEXT", "tag")), structure("and even put them in ", class = c("TEXT", "tag")), structure(list(structure(list(structure("base::data.frame()", class = c("TEXT", "tag"))), Rd_option = structure("base:data.frame", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Arithmetic", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" objects have arithmetic operations defined.\n", class = c("TEXT", "tag")), structure("Addition and subtraction are straightword and intuitive (i.e., (1/8) + (3/8) = (1/2)).\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Multiplication and division are slightly more complicated:\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Scalar_multiplication", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("scalar multiplication", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure("\n", class = c("TEXT", "tag")), structure("is defined ", class = c("TEXT", "tag")), structure(list(structure("for rational numbers", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(": (3/8) * 2 = (3/4)\n", class = c("TEXT", "tag")), structure("(the result is always a new ", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag")), structure("However, note that a ", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" cannot be multiplied by another\n", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("---afterall, what would a quarter-note times a quarter-note be?\n", class = c("TEXT", "tag")), structure("A ", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" can be divided by another ", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" to produce\n", class = c("TEXT", "tag")), structure("a real number: (1/2) / (1/4) = 2.\n", class = c("TEXT", "tag")), structure("Like other rational values in ", class = c("TEXT", "tag")), structure(list(structure("R", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" we can also do either\n", class = c("TEXT", "tag")), structure("``true'' (rational) division (using the ", class = c("TEXT", "tag")), structure(list(structure("/", class = c("TEXT", "tag"))), Rd_option = structure("base:Arithmetic", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" operator)\n", class = c("TEXT", "tag")), structure(list(structure("or", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Euclidean_division", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("Euclidean", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure("\n", class = c("TEXT", "tag")), structure("division (using the ", class = c("TEXT", "tag")), structure(list(structure("%%", class = c("TEXT", "tag"))), Rd_option = structure("base:Arithmetic", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" operator).\n", class = c("TEXT", "tag")), structure("Rational division (", class = c("TEXT", "tag")), structure(list(structure("/", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") of a `rhythmInterval` by another `rhythmInterval`\n", class = c("TEXT", "tag")), structure("results in a rational number. For instance, $(1/2) / (1/4) = 2$.\n", class = c("TEXT", "tag")), structure("Rational division of a `rhythmInterval` by a rational number results in a\n", class = c("TEXT", "tag")), structure("new `rhythmInterval`: $(1/2) / 2 = (1/4)$.\n", class = c("TEXT", "tag")), structure("Eucliean (a.k.a., integer) division can only be applied between `rhythmInterval`s\n", class = c("TEXT", "tag")), structure("resulting in an integer quotient---the remainder, which is a `rhythmInterval`,\n", class = c("TEXT", "tag")), structure("can be calculated with the ", class = c("TEXT", "tag")), structure(list(structure("%%", class = c("TEXT", "tag"))), Rd_option = structure("base:Arithmetic", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" operator.\n", class = c("TEXT", "tag")), structure("The remainder (a.k.a., ", class = c("TEXT", "tag")), structure(list(structure("modulo", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(") operator (`%%`) is especially\n", class = c("TEXT", "tag")), structure("useful, for instance in calculating metric positions.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Relational Operators", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s can be compared using the standard\n", class = c("TEXT", "tag")), structure(list(structure("relational operators", class = c("TEXT", "tag"))), Rd_option = structure("base:Comparison", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("---", class = c("TEXT", "tag")), structure(list(structure("==", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("!=", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("&gt;", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("&gt;=", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", etc.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("core rhythm representation", class = c("TEXT", "tag"))), class = c("LIST", "tag"))), class = c("tag_concept", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), rhythmOffset.Rd = structure(list(structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/rhythmInterval.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("rhythmOffset", class = c("VERB", "tag" ))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmOffset", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Calculate rhythmic \"offset\"", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("rhythmOffset(durations, start = 0, bars = NULL, tatum = 1, as = as.decimal)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("durations", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A vector of numeric values representing durations.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("start", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A duration value (coerced to same class as ", class = c("TEXT", "tag")), structure(list(structure("durations", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("), from which the\n", class = c("TEXT", "tag")), structure("offset begins.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("groups", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A vector of equal length as ", class = c("TEXT", "tag")), structure(list(structure("durations", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" representing a grouping factor,\n", class = c("TEXT", "tag")), structure("usable by ", class = c("TEXT", "tag" )), structure(list(structure("[base][tapply]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(". If ", class = c("TEXT", "tag")), structure(list(structure("!is.null(groups)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", offsets are calculated\n", class = c("TEXT", "tag")), structure("for duration values within each group. The ", class = c("TEXT", "tag")), structure(list(structure("start", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument is recycle to match\n", class = c("TEXT", "tag")), structure("the length of the number of groups, so a different start value can be applied to each group.\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag")), structure(list(structure("is.null(groups)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", offsets are calculated for the whole ", class = c("TEXT", "tag")), structure(list(structure("durations", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" vector, from the\n", class = c("TEXT", "tag")), structure("first ", class = c("TEXT", "tag" )), structure(list(structure("start", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" value.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_arguments", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure("Borrowing the term from ", class = c("TEXT", "tag")), structure(list(structure("music21", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", rhythmic \"offset\"\n", class = c("TEXT", "tag")), structure("refers to a duration of time since a starting point (usually, the beginning\n", class = c("TEXT", "tag")), structure("of a piece).\n", class = c("TEXT", "tag")), structure(list(structure("rhythmOffset", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" takes a vector of numbers representing durations\n", class = c("TEXT", "tag")), structure("(maybe ", class = c("TEXT", "tag" )), structure(list(structure("[rhythmInterval][rhythmInterval]s", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(", maybe other\n", class = c("TEXT", "tag")), structure("numeric values) and cummulatively sums them from a starting value.\n", class = c("TEXT", "tag")), structure("The output is a vector of durations of the same type as the input\n", class = c("TEXT", "tag")), structure("where each output value corresponds to the duration of time elapsed\n", class = c("TEXT", "tag")), structure("at that point.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Other rhythm analysis tools: \n", class = c("TEXT", "tag")), structure(list(structure(list(structure("metricPosition", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("()", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("rhythmDecompose", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("()", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythm analysis tools", class = c("TEXT", "tag"))), class = c("tag_concept", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), romanNumerals.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/diatonicSet.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("romanNumerals", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("romanNumerals", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Roman Numeral", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Roman numerals can be calculated for diatonicSets (keys) and\n", class = c("TEXT", "tag")), structure("for tertian sets (chords).\n", class = c("TEXT", "tag")), structure("The later case is the standard meaning of \"roman numeral.\"\n", class = c("TEXT", "tag")), structure("However, the former case is used as well, for instance\n", class = c("TEXT", "tag")), structure("to represent modulation schemes in\n", class = c("TEXT", "tag")), structure("analyses of classical music. For instance, modulate from I-V,\n", class = c("TEXT", "tag")), structure("the to vi/V.\n", class = c("TEXT", "tag")), structure("More importantly, many \"roman numerals\" in harmonic analyses\n", class = c("TEXT", "tag")), structure("implicitely combine tertian and diatonic roman numerals:\n", class = c("TEXT", "tag")), structure("in \"applied\" roman numerals.\n", class = c("TEXT", "tag")), structure("Given a roman numeral like \"V65/V\", the \"V65\" represents a\n", class = c("TEXT", "tag")), structure("chord while the \"/V\" represents a key.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), struct.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Vector.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("is.struct", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("is.struct(x)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Virtual class to help create atomic-vector-like composite data objects.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" defines a number of ", class = c("TEXT", "tag")), structure(list(structure(list(structure("http://adv-r.had.co.nz/S4.html", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("S4 classes", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" which are, underneath the surface, ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Composite_data_type", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("composite data types", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure("\n", class = c("TEXT", "tag")), structure("made up of collections of ", class = c("TEXT", "tag")), structure(list(structure("base-R atomic vectors", class = c("TEXT", "tag"))), Rd_option = structure("base:vector", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(", stuck together.\n", class = c("TEXT", "tag")), structure("The \"vectorized\" nature of R's atomic types is one of R's key strengths, so in ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" we try to A) mostly use the standard atomic types B)\n", class = c("TEXT", "tag")), structure("make all the new types we ", class = c("TEXT", "tag")), structure(list(structure("do", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" define act as much like atomic vectors as possible.\n", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is a ", class = c("TEXT", "tag")), structure(list(structure("virtual", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" S4 class which serves this purpose: creating composite atomic vectors which act (mostly) like base-R atomic vectors.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("As a \"virtual class\" ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s themselves don't really exist as independent objects, but the ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" class defines (abstractly) all the necessarry methods to treat a collection of\n", class = c("TEXT", "tag")), structure("atomic vectors as a single vector/matrix-like object---simply make your new subclass ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("inherit", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("and it is all taken care of. (To do this, specify ", class = c("TEXT", "tag")), structure(list(structure("contains = \"struct\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" in your call to ", class = c("TEXT", "tag")), structure(list(structure("setClass", class = c("TEXT", "tag"))), Rd_option = structure("methods:setClass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".)\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Important ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" classes which inherit from ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" include:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("tonalInterval", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("diatonicSet", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("tertianSet", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Be warned, R's S4 object-system is limited in this regard: you can't really define S4 classes that act ", class = c("TEXT", "tag")), structure(list(structure("fully", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" like R atomics, as\n", class = c("TEXT", "tag")), structure("many of their features are hard-coded into R itself and can't be replicated.\n", class = c("TEXT", "tag")), structure("The most important limitation of ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" that you may encounter is that, though ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" classes work (ok) in ", class = c("TEXT", "tag")), structure(list(structure("data.frames", class = c("TEXT", "tag"))), Rd_option = structure("base:data.frame", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(",\n", class = c("TEXT", "tag" )), structure(list(structure("data.tables", class = c("TEXT", "tag"))), Rd_option = structure("data.table:data.table", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("tibbles", class = c("TEXT", "tag"))), Rd_option = structure("tibble:tibble", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" will either not work or give strange behaviors if you put ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s into them.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Slots", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure(list( structure("dim", class = c("RCODE", "tag"))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("Either ", class = c("TEXT", "tag")), structure(list(structure("NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or a non-negative ", class = c("TEXT", "tag")), structure(list(structure("integer-vector", class = c("TEXT", "tag"))), Rd_option = structure("base:integer", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" of ", class = c("TEXT", "tag")), structure(list(structure("length == 2L", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", representing the number of rows and columns respectively. Dimensions ", class = c("TEXT", "tag")), structure(list(structure("can", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" be zero.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure(list( structure("rownames", class = c("RCODE", "tag"))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("Either ", class = c("TEXT", "tag")), structure(list(structure("NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or a ", class = c("TEXT", "tag" )), structure(list(structure("integer", class = c("TEXT", "tag"))), Rd_option = structure("base:integer", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("/", class = c("TEXT", "tag")), structure(list(structure("character", class = c("TEXT", "tag"))), Rd_option = structure("base:character", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("-vector which is the same length as either\n", class = c("TEXT", "tag")), structure("A) if ", class = c("TEXT", "tag")), structure(list(structure("dim == NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the length of the ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" B) if ", class = c("TEXT", "tag")), structure(list(structure("dim != NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the number of rows in the ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure(list( structure("colnames", class = c("RCODE", "tag"))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("Either ", class = c("TEXT", "tag")), structure(list(structure("NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (it ", class = c("TEXT", "tag" )), structure(list(structure("must", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" be ", class = c("TEXT", "tag" )), structure(list(structure("NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" if ", class = c("TEXT", "tag" )), structure(list(structure("dim == NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") or a ", class = c("TEXT", "tag")), structure(list(structure("integer", class = c("TEXT", "tag"))), Rd_option = structure("base:integer", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("/", class = c("TEXT", "tag")), structure(list(structure("character", class = c("TEXT", "tag"))), Rd_option = structure("base:character", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("-vector of length equal to the number of columns in the ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_describe", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Behavior", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" subclasses (i.e., classes which inherit from ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") behave very similarly to normal ", class = c("TEXT", "tag")), structure(list(structure("R atomic vectors/matrices", class = c("TEXT", "tag"))), Rd_option = structure("base:vector", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("However, they do differ in a few respects, mostly in ways that are intended to avoid some of the quirky behaviors of R matrices:\n", class = c("TEXT", "tag")), structure("In general, the distinction between dimensionless vectors and dimensioned vectors (", class = c("TEXT", "tag")), structure(list(structure("matrices", class = c("TEXT", "tag"))), Rd_option = structure("base:matrix", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(") is slightly weaker in ", class = c("TEXT", "tag")), structure(list(structure("structs", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" than with normal R atomic vectors/matrices.\n", class = c("TEXT", "tag")), structure("Most importantly, dimensioned ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s won't drop their dimensions under various common operations (", class = c("TEXT", "tag")), structure(list(structure("c", class = c("TEXT", "tag"))), Rd_option = structure("base:c", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("[]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(", etc.), the way base-R matrices do.\n", class = c("TEXT", "tag")), structure("In general, it is easier to interact with a multi-column (matrix-)", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" in the same way as a dimensionless (vector-)", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("For example, if the struct has dimensions then ", class = c("TEXT", "tag")), structure(list(structure("length(struct) == nrow(struct)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", instead of ", class = c("TEXT", "tag")), structure(list(structure("length(matrix) == nrow(matrix) * ncol(matrix)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("---i.e., the \"height\"\n", class = c("TEXT", "tag")), structure("of the ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (the number of rows) is its length.\n", class = c("TEXT", "tag")), structure("Another big difference is in the behaviors of ", class = c("TEXT", "tag")), structure(list(structure("c", class = c("TEXT", "tag"))), Rd_option = structure("base:c", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(": ", class = c("TEXT", "tag")), structure(list(structure("c", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" doesn't always cause ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s to lose their dimensions and ", class = c("TEXT", "tag")), structure(list(structure("c", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" can be used to concatinated multi-column ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s,\n", class = c("TEXT", "tag")), structure("or even mixes of dimensionless and dimensioned ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s:\n", class = c("TEXT", "tag")), structure("If any ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" arguments to ", class = c("TEXT", "tag")), structure(list(structure("c", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" have dimensions, the ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s are concatinated via a call to ", class = c("TEXT", "tag")), structure(list(structure("rbind", class = c("TEXT", "tag"))), Rd_option = structure("base:cbind", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(", with any dimensionless vectors coerced to\n", class = c("TEXT", "tag")), structure("1-column matrices.\n", class = c("TEXT", "tag")), structure("Of course, the (resulting) number of columns must all be the same or an error will occur!\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Other differences:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s can have either no dimensions (", class = c("TEXT", "tag")), structure(list(structure("dim(struct) == NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") or two dimensions. Higher dimensional ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s are not supported (yet).\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("rowSums", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("colSums", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will coerce a dimensionless struct to a column matrix.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s always throw an error if you try to index them with a index value that is greater than the length/nrow of the ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("This is different than atomic vectors, which will pad the vector up to the length of the index you give---a sometimes useful but quirky behavior.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s with two dimensions have a ", class = c("TEXT", "tag")), structure(list(structure("cartesian", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" indexing argument.\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag")), structure(list(structure("cartesian = TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the ", class = c("TEXT", "tag")), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" arguments are treated as cartesian coordinates.\n", class = c("TEXT", "tag")), structure("(This behavior can be achieved with base R matrices (or ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s) by inputing a matrix with two columns.)\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Requirements", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("To work, ", class = c("TEXT", "tag" )), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" makes a few assumptions about your class.\n", class = c("TEXT", "tag")), structure("Your class must have one or more slots which are vectors, all of which are the same length.\n", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("'s indexing method will cause all of these vectors to be indexed as one.\n", class = c("TEXT", "tag")), structure("When you define a new subclass of ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", it will inherit a\n", class = c("TEXT", "tag")), structure(list(structure("validObject", class = c("TEXT", "tag"))), Rd_option = structure("methods:validObject", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" method which assures that all elements are the same dimension.\n", class = c("TEXT", "tag")), structure("Thus, if you are writing your own ", class = c("TEXT", "tag")), structure(list(structure("validObject", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" method (using ", class = c("TEXT", "tag")), structure(list(structure("setValidity", class = c("TEXT", "tag"))), Rd_option = structure("methods:validObject", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(")\n", class = c("TEXT", "tag")), structure("you just have to worry specifically about the validity of the information in your slots,\n", class = c("TEXT", "tag")), structure("not that the slots are all the same length.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Initialize", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("An initialize method which automatically makes all slots the same length is predefined\n", class = c("TEXT", "tag")), structure("for ", class = c("TEXT", "tag")), structure(list(structure("structs", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". If you want to make a more specialized ", class = c("TEXT", "tag")), structure(list(structure("initialize", class = c("TEXT", "tag"))), Rd_option = structure("methods:new", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" method,\n", class = c("TEXT", "tag")), structure("you can still take advantage of the inherited method by using ", class = c("TEXT", "tag")), structure(list(structure("callNextMethod", class = c("TEXT", "tag"))), Rd_option = structure("methods:NextMethod", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" at the\n", class = c("TEXT", "tag")), structure("beginning of your method.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Predefined methods", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("The main purpose of the ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" virtual class is that it defines many of the basic methods you need to manipulate subclass objects.\n", class = c("TEXT", "tag")), structure("Most importantly, ", class = c("TEXT", "tag")), structure(list(structure("indexing", class = c("TEXT", "tag"))), Rd_option = structure("base:Extract", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" methods are fully defined (that mimic base-R atomic vector/matrix indexing), as well as\n", class = c("TEXT", "tag")), structure("basic \"structural\" methods like ", class = c("TEXT", "tag")), structure(list(structure("(col/row)names", class = c("TEXT", "tag"))), Rd_option = structure("base:colnames", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("dim", class = c("TEXT", "tag"))), Rd_option = structure("base:dim", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("length", class = c("TEXT", "tag"))), Rd_option = structure("base:length", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("ncol, nrow", class = c("TEXT", "tag"))), Rd_option = structure("base:nrow", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(", etc.\n", class = c("TEXT", "tag")), structure("In addition:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" If you define ", class = c("TEXT", "tag")), structure(list(structure("&gt; and &gt;=", class = c("TEXT", "tag"))), Rd_option = structure("base:Comparison", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("&lt;", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("&lt;=", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will be automatically defined.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" If you define ", class = c("TEXT", "tag")), structure(list(structure("as.character", class = c("TEXT", "tag"))), Rd_option = structure("base:character", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" for your subclass, ", class = c("TEXT", "tag")), structure(list(structure("show", class = c("TEXT", "tag"))), Rd_option = structure("methods:show", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("format", class = c("TEXT", "tag"))), Rd_option = structure("base:format", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" methods are automatically defined.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("What's more, default arithmetic methods for addition, subtraction, (scalar-integer) multiplication, and negation (", class = c("TEXT", "tag")), structure(list(structure("-x", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") are defined.\n", class = c("TEXT", "tag")), structure("The default addition behavior is that each numeric (", class = c("TEXT", "tag")), structure(list(structure("base::integer", class = c("TEXT", "tag"))), Rd_option = structure("base:integer", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("base::numeric", class = c("TEXT", "tag"))), Rd_option = structure("base:numeric", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(") slot from your subclasses will be added together.\n", class = c("TEXT", "tag")), structure("Thus, ", class = c("TEXT", "tag")), structure(list(structure("struct1 + struct2", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will extract each numeric/integer slot from each ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", add them together and create a new ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" from the result.\n", class = c("TEXT", "tag")), structure(list(structure("-struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will negate all numeric fields, and subtraction is simply defined as adding the negation.\n", class = c("TEXT", "tag")), structure("Since ", class = c("TEXT", "tag")), structure(list(structure("scalar", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" multiplication is defined, two ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s cannot be multiplied, but a struct can be multiplied by an integer (all numeric fields are multiplied by the integer(s)).\n", class = c("TEXT", "tag")), structure("If these definitions don't work for your subclass, you'll need to create your own, more specific, method!\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("RCODE", "tag")), structure("setClass('mynewsubclass', contains = 'struct', slots = c(X= 'numeric', Y = 'numeric'))\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("test &lt;- new('mynewsubclass', X = 1:10, Y = 10:1)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("# all of these should work:\n", class = c("RCODE", "tag")), structure("test[1:5]\n", class = c("RCODE", "tag")), structure("rev(test) == test\n", class = c("RCODE", "tag")), structure("cbind(test, test)\n", class = c("RCODE", "tag")), structure("c(test, test)\n", class = c("RCODE", "tag")), structure("test * 3\n", class = c("RCODE", "tag")), structure("test - test\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag"))), class = c("tag_examples", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Examples of ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" subclasses: ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("diatonicSet", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("tertianSet", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), tertianSet.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/tertianSet.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tertianSet", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tertianSet", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tset", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("is.tertianSet", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Tertian set", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("tertianSet(...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("tset(\n", class = c("RCODE", "tag" )), structure(" root = 0L,\n", class = c("RCODE", "tag")), structure(" signature = 0L,\n", class = c("RCODE", "tag")), structure(" alterations = 0L,\n", class = c("RCODE", "tag")), structure(" cardinality = 3L,\n", class = c("RCODE", "tag")), structure(" extension = NULL,\n", class = c("RCODE", "tag")), structure(" inversion = 0L\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("is.tertianSet(x)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("tertianSet", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is one of ", class = c("TEXT", "tag")), structure(list(structure("humdrumR's", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumR", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag")), structure("types of tonal data, representing Western tertian harmonies.\n", class = c("TEXT", "tag")), structure(list(structure("tertianSet", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is a subclass of ", class = c("TEXT", "tag")), structure(list(structure("diatonicSet", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (and thence, ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure("The only structural addition, compared to ", class = c("TEXT", "tag")), structure(list(structure("diatonicSet", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", is the ", class = c("TEXT", "tag")), structure(list(structure("Extensions", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" slot.\n", class = c("TEXT", "tag")), structure("This slot indicates which tertian chord members are active in the chord.\n", class = c("TEXT", "tag")), structure("There are seven possible chord members:\n", class = c("TEXT", "tag")), structure("the root, third, fifth, seventh, ninth, eleventh, and thirteenth.\n", class = c("TEXT", "tag")), structure("Every possible combination of these seven degrees is represented by a single integer, corresponding\n", class = c("TEXT", "tag")), structure("to the 7-bit representation of on/offs on the seven degrees in reverse order (13, 11, 9, 7, 5, 3, 1).\n", class = c("TEXT", "tag")), structure("For example, the integer ", class = c("TEXT", "tag")), structure(list(structure("15", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" corresponds to a seventh chord: in binary, 15 is ", class = c("TEXT", "tag")), structure(list(structure("0001111", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("The initial three zeros indicate that the 13th, 11th, and 9th are ", class = c("TEXT", "tag")), structure(list(structure("not", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" part of the harmony, while the four ones\n", class = c("TEXT", "tag")), structure("indicate that the root, third, fifth, and seventh ", class = c("TEXT", "tag")), structure(list(structure("are", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" part of the harmony.\n", class = c("TEXT", "tag")), structure("Ultimately, adding or removing a chord degree from a harmony can be achieved by adding the power of\n", class = c("TEXT", "tag")), structure("two associated with that degree:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Root", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(": ", class = c("TEXT", "tag")), structure(list(structure(list(structure("\\pm 1", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(), class = c("tag_item", "tag" )), structure(" ", class = c("TEXT", "tag")), structure(list(structure("Third", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(": ", class = c("TEXT", "tag")), structure(list(structure(list(structure("\\pm 2", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Fifth", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(": ", class = c("TEXT", "tag")), structure(list(structure(list(structure("\\pm 4", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Seventh", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(": ", class = c("TEXT", "tag")), structure(list(structure(list(structure("\\pm 8", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Ninth", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(": ", class = c("TEXT", "tag")), structure(list(structure(list(structure("\\pm 16", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Eleventh", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(": ", class = c("TEXT", "tag")), structure(list(structure(list(structure("\\pm 32", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Thirteenth", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(": ", class = c("TEXT", "tag")), structure(list(structure(list(structure("\\pm 64", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tertianSet", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" has many specific methods defined for reading/writing harmonic information.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("diatonicSet humTonality\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), time.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/rhythmInterval.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("time", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("time", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("bpm2ms", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("ms2bpm", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Time transformations", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("bpm2ms(bpm)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("ms2bpm(ms)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Time transformations\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), tonalInterval.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/tonalInterval.R, R/rhythmInterval.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tint", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("is.tonalInterval", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tonalInterval.tonalInterval", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tonalInterval.logical", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tonalInterval.NULL", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tonalInterval.numeric", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tonalInterval.rational", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tonalInterval.fraction", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tonalInterval.integer", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tonalInterval.character", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval.rhythmInterval", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Representation of tonal pitch information", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("tonalInterval(...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("tint(\n", class = c("RCODE", "tag" )), structure(" octave,\n", class = c("RCODE", "tag" )), structure(" LO5th = 0L,\n", class = c("RCODE", "tag")), structure(" cent = numeric(length(octave)),\n", class = c("RCODE", "tag")), structure(" partition = FALSE,\n", class = c("RCODE", "tag")), structure(" Key = NULL,\n", class = c("RCODE", "tag")), structure(" roundContour = floor\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("is.tonalInterval(x)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("tonalInterval(...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("tonalInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("tonalInterval", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("tonalInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("logical", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("tonalInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("`NULL`", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("tonalInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("numeric", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(\n", class = c("RCODE", "tag" )), structure(" x,\n", class = c("RCODE", "tag")), structure(" tonalHarmonic = 3,\n", class = c("RCODE", "tag")), structure(" centMargin = 10,\n", class = c("RCODE", "tag")), structure(" accidental.melodic = FALSE,\n", class = c("RCODE", "tag")), structure(" ...\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("tonalInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("rational", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x, tonalHarmonic = 3, accidental.melodic = FALSE, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("tonalInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("fraction", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x, tonalHarmonic = 3)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("tonalInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("integer", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(n, accidental.melodic = FALSE, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("tonalInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("character", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(str, Exclusive = NULL, ..., multiDispatch = FALSE)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x, ...)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag" )), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is the core tonal pitch representation in ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumR", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure("A ", class = c("TEXT", "tag")), structure(list( structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is an abstract representation of tonal pitch, which can be translated to/from all standard \"concrete\" pitch representations:\n", class = c("TEXT", "tag")), structure("solfege, scientific pitch, semitones, frequencies, scale degrees, intervals, etc.\n", class = c("TEXT", "tag")), structure("For the most part, users should not need to interact with ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s directly---rather, ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s work behind the scene in numerous ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" pitch functions.\n", class = c("TEXT", "tag")), structure("See the ", class = c("TEXT", "tag")), structure(list(structure("pitchRepresentations", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("tonalTransformations", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" documentation for details of usage and functionality or the ", class = c("TEXT", "tag")), structure(list(structure("Tonality in humdrumR", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" vignette for\n", class = c("TEXT", "tag")), structure("a detailed explanation of the theory and specifics of ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag" )), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is a ", class = c("TEXT", "tag")), structure(list(structure(list(structure("http://adv-r.had.co.nz/S4.html", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("S4", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" subclass of ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("'s virtual class ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(", from which it inherits a lot of useful \"vector-like\" behaviors/functionality.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("The constructor function ", class = c("TEXT", "tag")), structure(list(structure("tint", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" can be used to create ", class = c("TEXT", "tag")), structure(list(structure("tonalIntervals", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" directly.\n", class = c("TEXT", "tag")), structure("The three arguments corespond to the three slots: ", class = c("TEXT", "tag")), structure(list(structure("octave", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("LO5th", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (Fifth), and ", class = c("TEXT", "tag")), structure(list(structure("cent", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("All inputs will be coerced to match in length.\n", class = c("TEXT", "tag")), structure("What's more, the ", class = c("TEXT", "tag")), structure(list(structure("octave", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument can be left blank, in which case the appropriate octave will automatically be computed\n", class = c("TEXT", "tag")), structure("to place the interval in the octave above middle-C.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("By default, the ", class = c("TEXT", "tag")), structure(list(structure("as.character", class = c("TEXT", "tag"))), Rd_option = structure("base:character", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" method, and thus (via ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(") the ", class = c("TEXT", "tag")), structure(list(structure("show", class = c("TEXT", "tag"))), Rd_option = structure("methods:show", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" method, for ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s call ", class = c("TEXT", "tag")), structure(list(structure("kern()", class = c("TEXT", "tag"))), Rd_option = structure("=pitchRepresentations", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure("Thus, if you return a ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" on the command line (or call ", class = c("TEXT", "tag")), structure(list(structure("print", class = c("TEXT", "tag"))), Rd_option = structure("base:print", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" one one) you'll see the ", class = c("TEXT", "tag")), structure(list(structure("kern pitch", class = c("TEXT", "tag"))), Rd_option = structure("=pitchRepresentations", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" representation printed.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Slots", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure(list( structure("Octave", class = c("RCODE", "tag" ))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("integers representing the octave offset.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure(list( structure("Fifth", class = c("RCODE", "tag" ))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("integers representing the \"line-of-fifths\" value.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure(list( structure("Cent", class = c("RCODE", "tag" ))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("numeric values representing cents (1200th of an octave).", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_describe", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Arithmetic", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("Technically, ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s are examples of algebraic ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Module_(mathematics)", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("modules over integers", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("This means that certain arithmetic operations are defined for ", class = c("TEXT", "tag")), structure(list(structure("tonalIntervals", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and can be called using standard arithmetic operators (", class = c("TEXT", "tag")), structure(list(structure("+", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("-", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", etc.):\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Addition: ", class = c("TEXT", "tag")), structure(list(structure("tonalIntervals", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" can be added together, acting exactly as you'd expect (i.e., ", class = c("TEXT", "tag")), structure(list(structure(list(structure("M3 + m3 = P5", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(").\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Subtraction: ", class = c("TEXT", "tag")), structure(list(structure("tonalIntervals", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" can be subtracted just as they are added. Also, they can be negated with a single ", class = c("TEXT", "tag")), structure(list(structure("-", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("operator (like ", class = c("TEXT", "tag")), structure(list(structure("-M3", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Multiplication: ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s can ", class = c("TEXT", "tag")), structure(list(structure("not", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" be multiplied together.\n", class = c("TEXT", "tag")), structure("However, ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Scalar_multiplication", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("scalar (integer) multiplication", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" is defined:\n", class = c("TEXT", "tag")), structure("thus, ", class = c("TEXT", "tag")), structure(list(structure("tonalIntervals", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" can be multiplied by integers to create new ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s: e.g., ", class = c("TEXT", "tag")), structure(list(structure(list(structure("M2 * 3L = A4", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Division: as the natural inverse of scale multiplication, ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Euclidean_division", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("Euclidean division", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure("\n", class = c("TEXT", "tag")), structure("is defined for ", class = c("TEXT", "tag")), structure(list(structure("tonalIntervals", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("---i.e., division by/into whole (integer) pieces, often with leftover \"remainders\" (modulo).\n", class = c("TEXT", "tag")), structure("In R, Euclidean division is achieved with the ", class = c("TEXT", "tag")), structure(list(structure("%/%", class = c("TEXT", "tag"))), Rd_option = structure("base:Arithmetic", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" operator---", class = c("TEXT", "tag")), structure(list(structure("not", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("/", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("---, with the associated ", class = c("TEXT", "tag")), structure(list(structure("%%", class = c("TEXT", "tag"))), Rd_option = structure("base:Arithmetic", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" used for the remainder/modulo.\n", class = c("TEXT", "tag")), structure("Two ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s can be divided to produced an integer; Conversely, a ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" can be divided by an integer to produce a ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Take note that the way ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" defines Euclidean division is based in ", class = c("TEXT", "tag")), structure(list(structure("tonal space", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure("---i.e., the line-of-fifths---not frequency or atonal-semitone space.\n", class = c("TEXT", "tag")), structure("For example, an augmented-fourth divided by a major-second ", class = c("TEXT", "tag")), structure(list(structure("is", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("3L", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", but a diminished-fifth divided by a major-second is ", class = c("TEXT", "tag")), structure(list(structure("not", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" 3L---", class = c("TEXT", "tag")), structure(list(structure("d5 %/% M2", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" equals ", class = c("TEXT", "tag")), structure(list(structure("-3L", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" with a remainder of ", class = c("TEXT", "tag")), structure(list(structure("P8", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (plus an octave)!\n", class = c("TEXT", "tag")), structure("The division algorithm works by applying standard Euclidean division to the ", class = c("TEXT", "tag")), structure(list(structure("@Fifth", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" slot (line-of-fifths tonal space), and shifting the ", class = c("TEXT", "tag")), structure(list(structure("@Octave", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" value in\n", class = c("TEXT", "tag")), structure("the remainder to the match the appropriate octave.\n", class = c("TEXT", "tag")), structure("This definition has the useful properties that ", class = c("TEXT", "tag")), structure(list(structure("specificinterval %% A1 = genericinterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("interval %% d2 = enharmonicinterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Since basic data types can be parsed into ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (see below), ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will attempt to automatically ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Type_conversion", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("coerce", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure("\n", class = c("TEXT", "tag")), structure("data to tonalIntervals when asked to perform arithmetic.\n", class = c("TEXT", "tag")), structure("This means that arithmetic can be applied when one of the two arguments is a ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and the other is a coercable atomic.\n", class = c("TEXT", "tag")), structure("For instance, ", class = c("TEXT", "tag")), structure(list(structure("M3 + 2L", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will interpret ", class = c("TEXT", "tag")), structure(list(structure("2L", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" as two semitones and add a major-second to the major-third!\n", class = c("TEXT", "tag")), structure("The clever ", class = c("TEXT", "tag")), structure(list(structure("dispatch system", class = c("TEXT", "tag"))), Rd_option = structure("=regexDispatch", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" will even ignore character strings that are not recognized (see examples)!\n", class = c("TEXT", "tag")), structure("This is useful when combined with the \"Predifined Intervals\" (like ", class = c("TEXT", "tag")), structure(list(structure("M3", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("), described below.\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Relational Operators", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s can be compared using the standard ", class = c("TEXT", "tag")), structure(list(structure("relational operations", class = c("TEXT", "tag"))), Rd_option = structure("base:Comparison", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("---", class = c("TEXT", "tag")), structure(list(structure("==", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("!=", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("&gt;", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("&gt;=", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", etc.\n", class = c("TEXT", "tag")), structure("Two ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s are equal (according to ", class = c("TEXT", "tag")), structure(list(structure("==", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") only if all their slots (", class = c("TEXT", "tag")), structure(list(structure("Octave", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("Fifth", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", and ", class = c("TEXT", "tag")), structure(list(structure("Cent", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(")\n", class = c("TEXT", "tag")), structure("are exactly identical.\n", class = c("TEXT", "tag")), structure("Thus, enharmonic notes (like C# and Db) are ", class = c("TEXT", "tag")), structure(list(structure("not", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" equal.\n", class = c("TEXT", "tag")), structure("In contrast, ordinal comparisons (e.g., ", class = c("TEXT", "tag")), structure(list(structure("&gt;", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("&lt;=", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") between ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s are based on their semitone (equal temperament) size, so enharmonicity is irrelevant.\n", class = c("TEXT", "tag")), structure("Thus, ", class = c("TEXT", "tag")), structure(list(structure("m3 &gt;= A2", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("A2 &gt;= m3", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" are both ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", even though ", class = c("TEXT", "tag")), structure(list(structure("m3 == A2", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is not.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Predefined Intervals:", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" automatically exports a bunch of ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s, named by their musical interval representation.\n", class = c("TEXT", "tag")), structure("Every generic interval from 1 to 15 is combined with every interval quality ", class = c("TEXT", "tag")), structure(list(structure("dd", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (doubly diminished), ", class = c("TEXT", "tag")), structure(list(structure("d", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (diminished), ", class = c("TEXT", "tag")), structure(list(structure("m", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (minor), ", class = c("TEXT", "tag")), structure(list(structure("M", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (major), ", class = c("TEXT", "tag")), structure(list(structure("A", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (augumented)\n", class = c("TEXT", "tag")), structure(list(structure("AA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (doubly augmented).\n", class = c("TEXT", "tag")), structure("Thus, after loading ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", you can type things like ", class = c("TEXT", "tag")), structure(list(structure("M3 + M3", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and get ", class = c("TEXT", "tag")), structure(list(structure("A5", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("In addition, the variables ", class = c("TEXT", "tag")), structure(list(structure("unison", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (", class = c("TEXT", "tag")), structure(list(structure("= P1 = tint(0, 0)", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("), ", class = c("TEXT", "tag")), structure(list(structure("pythagorean.comma", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (", class = c("TEXT", "tag")), structure(list(structure("= d2 = tint(-19,12)", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("), and ", class = c("TEXT", "tag")), structure(list(structure("octave", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (", class = c("TEXT", "tag")), structure(list(structure("tint(1, 0)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") are exported as well.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Parsing", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" includes a easy-to-use but powerful system for parsing pitch information into the ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" representation.\n", class = c("TEXT", "tag")), structure("Basic methods are defined for numeric values representing atonal pitch information:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("integer", class = c("TEXT", "tag"))), Rd_option = structure("base:integer", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" values are interpreted as semitones. Watch out! In R, you need to append an ", class = c("TEXT", "tag")), structure(list(structure("L", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" to a number to make it an explicit integer:\n", class = c("TEXT", "tag")), structure("For example, ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval(3L)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("numeric", class = c("TEXT", "tag"))), Rd_option = structure("base:numeric", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("/", class = c("TEXT", "tag" )), structure(list(structure(list(structure("decimal()", class = c("TEXT", "tag"))), Rd_option = structure("=decimal", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure(list(structure("rational()", class = c("TEXT", "tag"))), Rd_option = structure("=rational", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(" values are interpreted as frequency ratios, assuming a ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Pythagorean_tuning", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("Pythagorean tuning", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("For example, the value ", class = c("TEXT", "tag")), structure(list(structure("2.0", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will be interpreted as an octave (two to one ratio.)\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("However, the most useful tool for humdrum data is parsing pitch representations encoded in ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" tokens.\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" regex/exclusive parsing system is used to interpret character strings as tonalIntervals.\n", class = c("TEXT", "tag")), structure("This includes character tokens with pitch information embedded alongside other information, like ", class = c("TEXT", "tag")), structure(list(structure("\"4.ee", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" in a kern token.\n", class = c("TEXT", "tag")), structure("There are six regex-patterns that ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" known how to parse automatically:", class = c("TEXT", "tag")), structure(list(structure(list(structure("lcr", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure(" Representation ", class = c("TEXT", "tag")), structure(list(), class = c("tag_tab", "tag")), structure(" Exclusive ", class = c("TEXT", "tag")), structure(list(), class = c("tag_tab", "tag")), structure(" Example ", class = c("TEXT", "tag")), structure(list(), class = c("tag_cr", "tag")), structure("\n", class = c("TEXT", "tag")), structure(" Kern ", class = c("TEXT", "tag")), structure(list(), class = c("tag_tab", "tag")), structure(" **kern ", class = c("TEXT", "tag")), structure(list(), class = c("tag_tab", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("ee-", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(), class = c("tag_cr", "tag")), structure("\n", class = c("TEXT", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Scientific_pitch", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("Scientific Pitch", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(), class = c("tag_tab", "tag")), structure(" **pitch ", class = c("TEXT", "tag")), structure(list(), class = c("tag_tab", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Eb5", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(), class = c("tag_cr", "tag")), structure("\n", class = c("TEXT", "tag")), structure(" Interval ", class = c("TEXT", "tag")), structure(list(), class = c("tag_tab", "tag")), structure(" **hint/**mint/**int ", class = c("TEXT", "tag")), structure(list(), class = c("tag_tab", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("+m3", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(), class = c("tag_cr", "tag")), structure("\n", class = c("TEXT", "tag")), structure(" Scale degree ", class = c("TEXT", "tag")), structure(list(), class = c("tag_tab", "tag")), structure(" **deg ", class = c("TEXT", "tag")), structure(list(), class = c("tag_tab", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("b3", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(), class = c("tag_cr", "tag")), structure("\n", class = c("TEXT", "tag")), structure(" Solfege ", class = c("TEXT", "tag")), structure(list(), class = c("tag_tab", "tag")), structure(" **solfa ", class = c("TEXT", "tag")), structure(list(), class = c("tag_tab", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("me", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(), class = c("tag_cr", "tag")), structure("\n", class = c("TEXT", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://lilypond.org/doc/v2.22/Documentation/notation/pitches", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("Lilypond pitch", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(), class = c("tag_tab", "tag")), structure(" none ", class = c("TEXT", "tag")), structure(list(), class = c("tag_tab", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("ees'", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(), class = c("tag_cr", "tag")), structure("\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_tabular", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("If you call ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (or ", class = c("TEXT", "tag")), structure(list(structure("any function that uses tonalInterval as a parser", class = c("TEXT", "tag"))), Rd_option = structure("=pitch", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(") on a ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" string,\n", class = c("TEXT", "tag")), structure("the regex-system will automatically (attempt) to interpret the tokens as on the pitch types above---if there is a conflict\n", class = c("TEXT", "tag")), structure("the representations are favored in the order they are presented in the table above.\n", class = c("TEXT", "tag")), structure("If a matching exclusive interpretation (see table above) is provided using the ", class = c("TEXT", "tag")), structure(list(structure("Exclusive", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument,\n", class = c("TEXT", "tag")), structure("this choice overrides the regex-dispatch.\n", class = c("TEXT", "tag")), structure("If there is no match, an NA ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is returned.\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Parsing with Options", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("The six tonal representations listed above function through a common parsing interface.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag")), structure("M3 &lt;- tint( , 4L)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("M2 &lt;- tint( , 2L)\n", class = c("RCODE", "tag")), structure("M9 &lt;- tint(-1L, 2L)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("M9 - M2 \n", class = c("RCODE", "tag")), structure("# = octave\n", class = c("RCODE", "tag")), structure("M9 - 2L\n", class = c("RCODE", "tag")), structure("# = octave\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("M3 %/% M2 \n", class = c("RCODE", "tag")), structure("# = 2\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("###\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("cMajor &lt;- sort(tint( , -1:5))\n", class = c("RCODE", "tag")), structure("eMajor &lt;- cMajor + M3\n", class = c("RCODE", "tag")), structure("eMajor + 2L \n", class = c("RCODE", "tag")), structure("# f# g# a# b cc# dd# ee#\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("eMajor[4:5] - octave \n", class = c("RCODE", "tag")), structure("# = A B\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("\"4.ee\" + P5 \n", class = c("RCODE", "tag")), structure("# = \"4.bb\"\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag"))), class = c("tag_examples", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Other ", class = c("TEXT", "tag" )), structure(list(structure("core pitch representation", class = c("TEXT", "tag"))), class = c("LIST", "tag")), structure(": \n", class = c("TEXT", "tag")), structure(list(structure(list(structure("LO5th", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("()", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("core pitch representation", class = c("TEXT", "tag"))), class = c("LIST", "tag"))), class = c("tag_concept", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), tonalTransformations.Rd = structure(list(structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/tonalInterval.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("tonalTransformations", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tonalTransformations", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("invert", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Invert or transpose tonal intervals.", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("invert(tint, around, Key, ...)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Invert or transpose tonal intervals.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), transpose.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/tonalInterval.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("transpose", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("transpose", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Transpose pitches and keys", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("transpose(x, by, Key, to, real, relative, ...)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("x", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("The input pitch(es) to transpose. A ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or something intepretable as a ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("by", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or something intepretable as a ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("The input ", class = c("TEXT", "tag")), structure(list(structure("x", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is transposed by this interval.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Key", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A ", class = c("TEXT", "tag")), structure(list(structure("diatonicSet", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or something intepretable as a ", class = c("TEXT", "tag")), structure(list(structure("diatonicSet", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". For tonal and/or to transpositions,\n", class = c("TEXT", "tag")), structure("this is the \"from\" key. If this value is ", class = c("TEXT", "tag")), structure(list(structure("NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", it defaults to C major.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("to", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A ", class = c("TEXT", "tag")), structure(list(structure("diatonicSet", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or something intepretable as a ", class = c("TEXT", "tag")), structure(list(structure("diatonicSet", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". The input ", class = c("TEXT", "tag")), structure(list(structure("x", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is transposed\n", class = c("TEXT", "tag")), structure("to this key.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("real", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A logical. If ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (the default), transposition is real. If ", class = c("TEXT", "tag")), structure(list(structure("FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", transposition is tonal.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("relative", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A logical. If ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" transposition is relative. If ", class = c("TEXT", "tag")), structure(list(structure("FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (the default), transposition is parallel.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" ))), class = c("tag_arguments", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("This function ", class = c("TEXT", "tag")), structure(list(structure("transposes", class = c("TEXT", "tag"))), Rd_option = structure("=https://en.wikipedia.org/wiki/Transposition_(music)", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" pitches or keys\n", class = c("TEXT", "tag")), structure("by various intervals or to target keys.\n", class = c("TEXT", "tag")), structure("Inside the box, inputs and transpositions take place as ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s or ", class = c("TEXT", "tag")), structure(list(structure("diatonicSet", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s,\n", class = c("TEXT", "tag")), structure("but any numeric or character string representation of pitches can be transposed as well.\n", class = c("TEXT", "tag")), structure("This function is incorporated directly into ", class = c("TEXT", "tag")), structure(list(structure("tonalTransform", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(", and thence, all ", class = c("TEXT", "tag")), structure(list(structure("pitch translation", class = c("TEXT", "tag"))), Rd_option = structure("=pitchRepresentations", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag")), structure("functions, so you probably won't call it directly very often.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure("There are two distinct types of transposition (real and tonal).\n", class = c("TEXT", "tag")), structure("There are also two different approaches to ", class = c("TEXT", "tag")), structure(list(structure("specifying", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" transpositions: \"to\" and \"by\".\n", class = c("TEXT", "tag")), structure("\"To\" transpositions can also be either ", class = c("TEXT", "tag")), structure(list(structure("parallel", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("relative", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Types of Transposition", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("There are two different types of transposition: ", class = c("TEXT", "tag")), structure(list(structure("real", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" transposition and ", class = c("TEXT", "tag")), structure(list(structure("tonal", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" transposition.\n", class = c("TEXT", "tag")), structure("In ", class = c("TEXT", "tag" )), structure(list(structure("real", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" transposition, all inputs are transposed by the same ", class = c("TEXT", "tag")), structure(list(structure("specific", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" interval.\n", class = c("TEXT", "tag")), structure("For example, the pitches ", class = c("TEXT", "tag")), structure(list(structure("{C D E F G}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" could be transposed up a major second to ", class = c("TEXT", "tag")), structure(list(structure("{C D E F# G}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("In ", class = c("TEXT", "tag" )), structure(list(structure("tonal", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" transposition, inputs are transposed by ", class = c("TEXT", "tag")), structure(list(structure("generic", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" intervals, within a key.\n", class = c("TEXT", "tag")), structure("For example, the sequence ", class = c("TEXT", "tag")), structure(list(structure("{C D E F G}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(", in the key of C major, could be translated up a generic second\n", class = c("TEXT", "tag")), structure("to ", class = c("TEXT", "tag" )), structure(list(structure("{D E F G A}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("To choose between real and tonal transposition, use the ", class = c("TEXT", "tag")), structure(list(structure("real", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument:\n", class = c("TEXT", "tag")), structure(list(structure("real = TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" for real transposition, ", class = c("TEXT", "tag")), structure(list(structure("real = FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" for tonal transposition.\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Alterations", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Tonal transposition is complicated by the presence of any alterations in the input pitches.\n", class = c("TEXT", "tag")), structure("For instance, if we are given the pitches ", class = c("TEXT", "tag")), structure(list(structure("{C F# G D# E}`` in the key of C major, how should they by tonally transposed up a second, within C major? There is not one obvious, correct answer answer, which can be easily identified. The algorithm implemented by ", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("humdrumR` is as follows:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Alterations/accidentals in the input are identified. (In this case, F# and D#).\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" The generic pitches are transposed within the key, resulting in ", class = c("TEXT", "tag")), structure(list(structure("{D G A E F}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Alterations in the input are added to the output ", class = c("TEXT", "tag")), structure(list(structure("unless", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" the resulting pitches are interpreted as a comma\n", class = c("TEXT", "tag")), structure("by a call to ", class = c("TEXT", "tag")), structure(list(structure("tintPartion", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(", with a given enharmonic wrap value (the default is ", class = c("TEXT", "tag")), structure(list(structure("12", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag")), structure("In this example, adding the first accidental results in ", class = c("TEXT", "tag")), structure(list(structure("{G#}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" which is not a comma.\n", class = c("TEXT", "tag")), structure("However, the second accidental results in ", class = c("TEXT", "tag")), structure(list(structure("{E#}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" which ", class = c("TEXT", "tag")), structure(list(structure("is", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" a comma away from the natural ", class = c("TEXT", "tag")), structure(list(structure("{F}", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Thus, this accidental is not added to the output, resulting in ", class = c("TEXT", "tag")), structure(list(structure("{E}", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", not ", class = c("TEXT", "tag")), structure(list(structure("{E#}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("The resulting output is ", class = c("TEXT", "tag")), structure(list(structure("{D G# A E F}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_enumerate", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("The size of ", class = c("TEXT", "tag")), structure(list(structure("enharmonicWrap", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" effectively determines how extreme accidentals are allowed.\n", class = c("TEXT", "tag")), structure("The default value, ", class = c("TEXT", "tag")), structure(list(structure("12", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", assures that no output notes are enharmonically equivalent to notes in the key.\n", class = c("TEXT", "tag")), structure("To further illustrate, here is the sequence ", class = c("TEXT", "tag")), structure(list(structure("{C F# G D# E, B- A A- G C# D, B D- C}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" transposed\n", class = c("TEXT", "tag")), structure("tonally within C major by all seven possible generic intervals, with ", class = c("TEXT", "tag")), structure(list(structure("enharmonicWrap = 12", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(":\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag" ))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Specifying Transpositions", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("There are two approaches to specifying transpositions, the ", class = c("TEXT", "tag")), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("to", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" arguments.\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag")), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument must be an interval, and the input is translated by that interval.\n", class = c("TEXT", "tag")), structure("If the ", class = c("TEXT", "tag")), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" interval is specific but ", class = c("TEXT", "tag")), structure(list(structure("real = FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the input is treated as a generic interval,\n", class = c("TEXT", "tag")), structure("and tranposition takes place within the key indicated by the ", class = c("TEXT", "tag")), structure(list(structure("Key", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("The ", class = c("TEXT", "tag" )), structure(list(structure("to", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument translates an input ", class = c("TEXT", "tag")), structure(list(structure("to", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" a desired key.\n", class = c("TEXT", "tag")), structure("For example, if the input is in the key of E major but we want it transposed to G major, we could say ", class = c("TEXT", "tag")), structure(list(structure("to = '*E:'", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag" )), structure(list(structure("real = TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", input is simply translated to the root of the ", class = c("TEXT", "tag")), structure(list(structure("to", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" key, with all the exact same intervals.\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag" )), structure(list(structure("real = FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the input is translated to the root of the new key, with its intervals changed to match the new key as well.\n", class = c("TEXT", "tag")), structure("In either case, the result depends on what the input's key is, which is indicated by the ", class = c("TEXT", "tag")), structure(list(structure("standard", class = c("TEXT", "tag"))), Rd_option = structure("=tonalTransform", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Key", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument.\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag")), structure(list(structure("Key", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" arguments is like the \"from\" key.\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag" )), structure(list(structure("Key = NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the input key is interpreted as C major.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Consider the input notes ", class = c("TEXT", "tag")), structure(list(structure("{D B C A# B, D C# D E D}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" in the key of the G major.\n", class = c("TEXT", "tag")), structure("If we specify ", class = c("TEXT", "tag")), structure(list(structure("to = e:, real = TRUE", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(", the output will be ", class = c("TEXT", "tag")), structure(list(structure("{B G# A F## G#, B A# B C# B}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("(Notice that even though the ", class = c("TEXT", "tag")), structure(list(structure("to", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" key is minor, the output is still clearly in E major).\n", class = c("TEXT", "tag")), structure("If we specify ", class = c("TEXT", "tag")), structure(list(structure("to = e:, real = FALSE", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(", the output will instead be ", class = c("TEXT", "tag")), structure(list(structure("{B G A F# G, B A# B C B}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Building off the previous example, consider how the input ", class = c("TEXT", "tag")), structure(list(structure("key", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" matters as well.\n", class = c("TEXT", "tag")), structure("If we use the same input notes (", class = c("TEXT", "tag")), structure(list(structure("{D B C A# B, D C# D E D}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(") but the input ", class = c("TEXT", "tag")), structure(list(structure("Key", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is C major, then:\n", class = c("TEXT", "tag")), structure("If we specify ", class = c("TEXT", "tag")), structure(list(structure("to = e:, real = TRUE", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(", the output will be ", class = c("TEXT", "tag")), structure(list(structure("{F# D# E C## D#, F# E# F# G# F#}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("If we specify ", class = c("TEXT", "tag")), structure(list(structure("to = e:, real = FALSE", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(", the output will instead be ", class = c("TEXT", "tag")), structure(list(structure("{F# D E C# D, F# E F# G F#}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("If ", class = c("TEXT", "tag")), structure(list(structure("both", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("to", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" are specified, the ", class = c("TEXT", "tag")), structure(list(structure("to", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" transposition is applied first, followed by the ", class = c("TEXT", "tag")), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" transposition.\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag")), structure(list(structure("real = FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the ", class = c("TEXT", "tag")), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" transposition happens within the ", class = c("TEXT", "tag")), structure(list(structure("to", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" key, not the ", class = c("TEXT", "tag")), structure(list(structure("Key", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" key.\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Relative vs Parallel", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("When transposing to, we have diferent approaches about to determining the relationship between the\n", class = c("TEXT", "tag")), structure("\"from\" key (", class = c("TEXT", "tag")), structure(list(structure("Key", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument) and the \"to\" key (", class = c("TEXT", "tag")), structure(list(structure("to", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument).\n", class = c("TEXT", "tag")), structure("If we think of \"parallel\" relationships between keys, we match the roots of the keys regardless of modes.\n", class = c("TEXT", "tag")), structure("For instance, C major and C minor are parallel keys.\n", class = c("TEXT", "tag")), structure("If we instead think of \"relative\" relationships between keys, we match the modes of the keys, not the roots.\n", class = c("TEXT", "tag")), structure("For instance, C major and A minor are relative keys.\n", class = c("TEXT", "tag")), structure("This is similar to the distinction between \"la-based minor\" solfege (relative) vs \"fixed-do\" solfege (parallel).\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("When transposing using a ", class = c("TEXT", "tag")), structure(list(structure("to", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument, if ", class = c("TEXT", "tag")), structure(list(structure("relative = FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" the input key (", class = c("TEXT", "tag")), structure(list(structure("Key", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument) is transposed to match the ", class = c("TEXT", "tag")), structure(list(structure("root", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure("\n", class = c("TEXT", "tag")), structure("of the ", class = c("TEXT", "tag")), structure(list(structure("to", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument.\n", class = c("TEXT", "tag")), structure("For example, if the input key is G minor and the ", class = c("TEXT", "tag")), structure(list(structure("to`` key is C major, the output is transposed to G minor. However, if ", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("relative = TRUE", class = c("TEXT", "tag")), structure(list(structure("the input key is transposed to match the mode of the", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("to", class = c("TEXT", "tag")), structure(list(structure("key: A G minor input with a C major", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("to", class = c("TEXT", "tag")), structure(list(structure("would be translated to A minor, the parallel minor of the", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("to", class = c("TEXT", "tag")), structure(list(structure("key. If the", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("Key", class = c("TEXT", "tag")), structure(list(structure("(from key) and", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("to` (to key) arguments have the same mode, the parallel and relative transpositions\n", class = c("TEXT", "tag")), structure("are the same.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Special Operators +-", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("As a note, real transposition ", class = c("TEXT", "tag")), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and interval can be achieved more concisely using the ", class = c("TEXT", "tag")), structure(list(structure("+", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("-", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" operators,\n", class = c("TEXT", "tag")), structure("as long as at least one side of the operators is an actual ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object.\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" preassigns all common tonalIntervals to objects in your global environment.\n", class = c("TEXT", "tag")), structure("Thus, you can type commands like ", class = c("TEXT", "tag")), structure(list(structure("\"c#\" + M2", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" to get ", class = c("TEXT", "tag")), structure(list(structure("d#", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", or ", class = c("TEXT", "tag")), structure(list(structure("c(\"C4\", \"E4\", \"C5\") - m6", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" to get ", class = c("TEXT", "tag")), structure(list(structure("\"E3\" \"G#3\" \"E4\"", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure("tonalTransformations\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), withinHumdrum.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Apply.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("withHumdrum", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("inHumdrum", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humApply", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("with(in)Humdrum", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("withinHumdrum(humdrumR, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("withHumdrum(humdrumR, ..., drop = TRUE)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("inHumdrum(humdrumR, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humApply(humdrumR, FUN, ..., within = TRUE, doplot = FALSE)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" data object.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("...", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("Any arguments which can be fed to\n", class = c("TEXT", "tag")), structure(list(structure("[humdrumR:with-in-Humdrum][with(in)Humdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" as formulae (except for\n", class = c("TEXT", "tag")), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expressions, which are replaced by the ", class = c("TEXT", "tag")), structure(list(structure("FUN", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument!).\n", class = c("TEXT", "tag")), structure("However, rather that writinging formula in the format ", class = c("TEXT", "tag")), structure(list(structure("Keyword ~ Expression", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag")), structure(list(structure("humApply", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" arguments should be written as normal ", class = c("TEXT", "tag")), structure(list(structure("R", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" arguments:\n", class = c("TEXT", "tag")), structure(list(structure("Keyword = Expression", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Unnamed arguments are ignored.\n", class = c("TEXT", "tag")), structure("#' @param within A logical. If ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (the default),\n", class = c("TEXT", "tag")), structure(list(structure("[humdrumR:with-in-Humdrum][withinHumdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" is used to apply the\n", class = c("TEXT", "tag")), structure("function---meaning that the output is reconstituted into a new field in the\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object. If ", class = c("TEXT", "tag")), structure(list(structure("within == FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag")), structure(list(structure("[humdrumR:with-in-Humdrum][withHumdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" is used instead,\n", class = c("TEXT", "tag")), structure("which results in the function's output being returned inprocessed.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("drop", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("This argument is concetually similar to the ", class = c("TEXT", "tag")), structure(list(structure("drop", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument in R matrices and data.frames.\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag" )), structure(list(structure("drop = TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the output of ", class = c("TEXT", "tag")), structure(list(structure("withHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is simplified as much as possible (trying to return\n", class = c("TEXT", "tag")), structure("the \"raw\" vector, list, table, etc. within it). If ", class = c("TEXT", "tag")), structure(list(structure("drop = FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the result is ", class = c("TEXT", "tag")), structure(list(structure("always", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure("\n", class = c("TEXT", "tag")), structure("a ", class = c("TEXT", "tag" )), structure(list(structure("data.table", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". The default value (", class = c("TEXT", "tag")), structure(list(structure("drop = TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") is usually what we want because it is more\n", class = c("TEXT", "tag")), structure("intuitive, but in more complex code, it can be helpful to set ", class = c("TEXT", "tag")), structure(list(structure("drop = FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" so that\n", class = c("TEXT", "tag")), structure("the output is consistent.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("FUN", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A function to apply to the ", class = c("TEXT", "tag")), structure(list(structure("humdrumR:humdrumR", class = c("TEXT", "tag"))), Rd_option = structure("=Active", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(list(structure("field(s) in the", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("humdrumR` object.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("doplot", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("Boolean. If ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" the ", class = c("TEXT", "tag")), structure(list(structure("FUN", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument is treated\n", class = c("TEXT", "tag")), structure("as a ", class = c("TEXT", "tag")), structure(list(structure("doplot", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression by ", class = c("TEXT", "tag")), structure(list(structure("[humdrumR:with-in-Humdrum][with(in)Humdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(",\n", class = c("TEXT", "tag")), structure("so the result is ignored (for plotting or side-effects purposes).", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" ))), class = c("tag_arguments", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("From ", class = c("TEXT", "tag" )), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("inHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", a new humdrumR data object.\n", class = c("TEXT", "tag")), structure("From ", class = c("TEXT", "tag" )), structure(list(structure("withHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", whatever value is returned by expression.\n", class = c("TEXT", "tag"))), class = c("tag_value", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Apply arbitrary expressions to fields within ", class = c("TEXT", "tag")), structure(list(structure("[S4class][humdrumRclass]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" data.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Overview", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("These functions are the primary means of working with\n", class = c("TEXT", "tag")), structure("humdrumR data. (They are analogous to the base functions\n", class = c("TEXT", "tag")), structure(list(structure("[base][with]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("[base][within]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("\n", class = c("TEXT", "tag")), structure("as applied to ", class = c("TEXT", "tag")), structure(list(structure("[base:data.frame][data.frames]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".)\n", class = c("TEXT", "tag")), structure("Specifically they allow you to evaluate arbitrary\n", class = c("TEXT", "tag")), structure("expressions involving fields in a humdrumR data object.\n", class = c("TEXT", "tag")), structure("They also includes a number of special evaluation options:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Evaluate an expression in only matching parts of the data.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Evaluate an expression separately in subsets of the data.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Evaluate an expression across windows in the data (e.g., ngrams, rolling windows).\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Evaluate an expression which produces a plot, with particular plotting parameters set using ", class = c("TEXT", "tag")), structure(list(structure("[graphics][par]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("The difference between ", class = c("TEXT", "tag")), structure(list(structure("withHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is\n", class = c("TEXT", "tag")), structure("analogous to the difference between ", class = c("TEXT", "tag")), structure(list(structure("[base][with]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("[base][within]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(structure("withHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" evaluates your expression(s) and then simply returns the result of\n", class = c("TEXT", "tag")), structure("the evaluation. ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" evaluates your expression(s) and then\n", class = c("TEXT", "tag")), structure("(attempts) to insert the results back into the humdrumR object, generating new\n", class = c("TEXT", "tag")), structure("fields called ", class = c("TEXT", "tag")), structure(list(structure("PipeX", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (see details).\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(structure("inHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is simply a short hand for ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure(list(structure("Formulae", class = c("RCODE", "tag"))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Every formula in the ", class = c("TEXT", "tag")), structure(list(structure("formulae", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument\n", class = c("TEXT", "tag")), structure("is treated as a ", class = c("TEXT", "tag")), structure(list(structure("Keyword ~ Expression(s)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("pairing. Multiple expressions can be input using multiple ", class = c("TEXT", "tag")), structure(list(structure("~", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" operators:\n", class = c("TEXT", "tag")), structure(list(structure("Keyword ~ Expression1 [~ Expression2 ~ ... ~ ExpressionN]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("(the leftmost expression is treated as the keyword.)\n", class = c("TEXT", "tag")), structure("If there is no leftmost expression (i.e., ", class = c("TEXT", "tag")), structure(list(structure("~ Expression", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("), the Keyword\n", class = c("TEXT", "tag")), structure("defaults to \"", class = c("TEXT", "tag")), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\" The keyword expression must be a single, simple name/symbol, following\n", class = c("TEXT", "tag")), structure("standard R rules (i.e., \"", class = c("TEXT", "tag")), structure(list(structure(".foobar", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\" is acceptable but \"", class = c("TEXT", "tag")), structure(list(structure("3 + foobar", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\" is not).\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Legal keywords, and their meanings are:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" An expression to be evaluated within the ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data object (see \"Expression evaluation\").\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("doplot", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" An expression to be evaluated within the ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data object while ignoring the result of the expression (see \"Expression evaluation\" and \"Plotting\".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" An expression used to break the data into groups, with the ", class = c("TEXT", "tag")), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression(s) evaluated\n", class = c("TEXT", "tag")), structure("separately in each group (see \"Partitioning\").\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("where", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" An expression indicating a subset of the data in which to evaluate the ", class = c("TEXT", "tag")), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression (see \"Partitioning\").\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("ngrams", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" A positive number ", class = c("TEXT", "tag")), structure(list(structure("n", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(". The expression is evaluated across overlapping length-", class = c("TEXT", "tag")), structure(list(structure("n", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" windows.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("recordtypes", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" A string or vector of characters drawn from ", class = c("TEXT", "tag")), structure(list(structure("c(\"D\", \"d\", \"I\", \"L\", \"M\",\"G\")", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". These characters\n", class = c("TEXT", "tag")), structure("correspond to types of humdrum records: ", class = c("TEXT", "tag")), structure(list(structure("D", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure("ata, null ", class = c("TEXT", "tag")), structure(list(structure("d", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure("ata, ", class = c("TEXT", "tag")), structure(list(structure("I", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure("nterpretations,\n", class = c("TEXT", "tag")), structure(list(structure("M", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure("easures, ", class = c("TEXT", "tag")), structure(list(structure("L", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure("ocal comments, and ", class = c("TEXT", "tag")), structure(list(structure("G", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure("lobal comments respectively. The expression\n", class = c("TEXT", "tag")), structure("is only evaluated on data drawn from the specified record types (defaults to ", class = c("TEXT", "tag")), structure(list(structure("\"D\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("pre", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" An expression to evaluate once before evaluating the do expression(s). Useful, for instance, for taking logs\n", class = c("TEXT", "tag")), structure("or opening a graphing window. The ", class = c("TEXT", "tag")), structure(list(structure("pre", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression is evaluated in the global environment.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("post", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" An expression evaluate once after evaluating the do expression(s). Always evaluated in the global environment.\n", class = c("TEXT", "tag"))), class = c("tag_enumerate", "tag")), structure("\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Expression evaluation", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("The right-hand side of any formula in the ", class = c("TEXT", "tag")), structure(list(structure("formulae", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument with the keyword ", class = c("TEXT", "tag")), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("doplot", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("(or with no keyword specified) is evaluated within the ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data object.\n", class = c("TEXT", "tag")), structure("The expression can, thus, refer to any field in the humdrumR object (Record, Token, File, etc.).\n", class = c("TEXT", "tag")), structure("You can also include a ", class = c("TEXT", "tag")), structure(list(structure(".", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" anywhere in the expression, which will be\n", class = c("TEXT", "tag")), structure("interpreted as the humdrumR object's current ", class = c("TEXT", "tag")), structure(list(structure("[dest=humdrumR][Active]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("\n", class = c("TEXT", "tag")), structure("expression.", class = c("TEXT", "tag")), structure(list(structure("humdata &lt;- readHumdrum('directorywithdata/*.krn') # read some data\n", class = c("VERB", "tag")), structure("\n", class = c("VERB", "tag")), structure("withinHumdrum(humdata, ~getPitch(Token)) # The most basic pattern\n", class = c("VERB", "tag")), structure("withinHumdrum(humdata, ~getPitch(.)) # Same as previous (unless `Active` field has been changed))\n", class = c("VERB", "tag")), structure("\n", class = c("VERB", "tag")), structure("withinHumdrum(humdata, ~solfa(getPitch(Token), key = Key)) \n", class = c("VERB", "tag")), structure("# Assumes that the Key field was parsed during the call to `[readHumdrum][readHumdrum]`\n", class = c("VERB", "tag")), structure("\n", class = c("VERB", "tag")), structure("withinHumdrum(humdata, ~getSemits(Token) - mean(getSemits(Token))) \n", class = c("VERB", "tag")), structure("\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag" )), structure("If multiple ", class = c("TEXT", "tag")), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expressions are provided, they are each evaluated one at a time,\n", class = c("TEXT", "tag")), structure("with the result of each piped into the next. Other, non-", class = c("TEXT", "tag")), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", formulae (like ", class = c("TEXT", "tag")), structure(list(structure("by~", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" or\n", class = c("TEXT", "tag")), structure(list(structure("ngrams~", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(") are reused for each expression evaluated.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Partitioning", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("A ", class = c("TEXT", "tag")), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression is used to break the data into subsets, with the ", class = c("TEXT", "tag")), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression(s) evaluated\n", class = c("TEXT", "tag")), structure("separately within each subset. This works the similarly to the ", class = c("TEXT", "tag")), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument in\n", class = c("TEXT", "tag")), structure(list(structure("[data.table][data.table]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("s, the ", class = c("TEXT", "tag")), structure(list(structure("INDEX", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("argument of ", class = c("TEXT", "tag")), structure(list(structure("[base][tapply]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(", or the ", class = c("TEXT", "tag")), structure(list(structure("INDICES", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument of ", class = c("TEXT", "tag")), structure(list(structure("[base][by]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Each ", class = c("TEXT", "tag")), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression must evaluate, within the ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data object, to a vector (or a list of vectors\n", class = c("TEXT", "tag")), structure("of equal length) of categories to group the data by.\n", class = c("TEXT", "tag")), structure("Most commonly, the ", class = c("TEXT", "tag")), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression(s) are simply field(s) in the data:\n", class = c("TEXT", "tag")), structure("for instance,", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum(humdata,\n", class = c("VERB", "tag")), structure(" do ~ table(Token),\n", class = c("VERB", "tag")), structure(" by ~ File)\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag" )), structure("will apply the function ", class = c("TEXT", "tag")), structure(list(structure("[base][table]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" to the ", class = c("TEXT", "tag")), structure(list(structure("Token", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field\n", class = c("TEXT", "tag")), structure(list(structure("separately", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" for each file in the ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data.\n", class = c("TEXT", "tag")), structure("However, we can also use more complex expressions like", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum(humdata,\n", class = c("VERB", "tag")), structure(" do ~ table(Token), \n", class = c("VERB", "tag")), structure(" by ~ Spine &gt; 3 | Record \\%\\% 2 == 0)\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag" )), structure("which will evaluate the do expression in two groups, one where either the spine number is\n", class = c("TEXT", "tag")), structure("three or less ", class = c("TEXT", "tag")), structure(list(structure("or", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" the record number is even, and another group where the opposite is true.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("If the ", class = c("TEXT", "tag")), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression evaluates to a list of grouping vectors,\n", class = c("TEXT", "tag")), structure("the ", class = c("TEXT", "tag")), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expressions are evaulated across every combination of categories in all the vectors.\n", class = c("TEXT", "tag")), structure("Thus,\n", class = c("TEXT", "tag")), structure("withinHumdrum(humdata,\n", class = c("TEXT", "tag")), structure("do ~ table(Token),\n", class = c("TEXT", "tag")), structure("by ~ list(File, Spine))\n", class = c("TEXT", "tag")), structure("will apply ", class = c("TEXT", "tag")), structure(list(structure("table", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" to ", class = c("TEXT", "tag")), structure(list(structure("Token", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" across each spine ", class = c("TEXT", "tag")), structure(list(structure("in", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" each file.\n", class = c("TEXT", "tag")), structure("As some ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Syntactic_sugarsyntactic", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("syntactic sugar", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(", if the\n", class = c("TEXT", "tag")), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression has more than two parts, all parts except\n", class = c("TEXT", "tag")), structure("the (leftmost) keyword part are combined in a list (i.e., ", class = c("TEXT", "tag")), structure(list(structure("by ~ File ~ Spine", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("becomes ", class = c("TEXT", "tag")), structure(list(structure("by ~ list(File, Spine)}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Thus the previous example can also be written:\n", class = c("TEXT", "tag")), structure("withinHumdrum(humdata,\n", class = c("TEXT", "tag")), structure("do ~ table(Token),\n", class = c("TEXT", "tag")), structure("by ~ File ~ Spine)\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("A ", class = c("TEXT", "tag")), structure(list(structure("where", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression is used to identify a subset of the data and evaluate\n", class = c("TEXT", "tag")), structure("the ", class = c("TEXT", "tag")), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression(s) ", class = c("TEXT", "tag")), structure(list(structure("only", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" in that subset.\n", class = c("TEXT", "tag")), structure(list(structure("where", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expressions must evaluated, within the ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data object, to\n", class = c("TEXT", "tag")), structure("a single logical vector. The ", class = c("TEXT", "tag")), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression(s) are only evaluated where this logical\n", class = c("TEXT", "tag")), structure("vector is ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Wherever the ", class = c("TEXT", "tag")), structure(list(structure("where", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression evaluates to ", class = c("TEXT", "tag")), structure(list(structure("FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the original ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data is\n", class = c("TEXT", "tag")), structure("kept unchanged.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("If multiple partitioning formulae (i.e, ", class = c("TEXT", "tag")), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("where", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") expressions\n", class = c("TEXT", "tag")), structure("are evaluated recursively, in order from left to right. Thus if you specify\n", class = c("TEXT", "tag")), structure("withinHumdrum(humdata,\n", class = c("TEXT", "tag")), structure("do ~ sd(semits),\n", class = c("TEXT", "tag")), structure("by ~ File,\n", class = c("TEXT", "tag")), structure("where ~ semits &gt; mean(semits))\n", class = c("TEXT", "tag")), structure("a the standard deviation of the ", class = c("TEXT", "tag")), structure(list(structure("semits", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field will be calculated only in each file,\n", class = c("TEXT", "tag")), structure("but only where the ", class = c("TEXT", "tag")), structure(list(structure("semits", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field is greater than the mean ", class = c("TEXT", "tag")), structure(list(structure("semits", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" value\n", class = c("TEXT", "tag")), structure(list(structure("within that file", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(". Contrast this with this call:\n", class = c("TEXT", "tag")), structure("withinHumdrum(humdata,\n", class = c("TEXT", "tag")), structure("do ~ sd(semits)\n", class = c("TEXT", "tag")), structure("where ~ semits &gt; mean(semits),\n", class = c("TEXT", "tag")), structure("by ~ File)\n", class = c("TEXT", "tag")), structure("wherein the standard deviation of ", class = c("TEXT", "tag")), structure(list(structure("semits", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is, again, calculated for each file,\n", class = c("TEXT", "tag")), structure("but this time wherever the ", class = c("TEXT", "tag")), structure(list(structure("semits", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field is greater than the mean value ", class = c("TEXT", "tag")), structure(list(structure("across all the data", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Plotting", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("The ", class = c("TEXT", "tag" )), structure(list(structure("doplot", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" keyword behaves exactly like the ", class = c("TEXT", "tag")), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" keyword, except that the result of the\n", class = c("TEXT", "tag")), structure("evaluation is ignored. This is useful for plotting ", class = c("TEXT", "tag")), structure(list(structure("as well as", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" other side-effects (like writing to a file).\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag" )), structure(list(structure("doplot", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is used with ", class = c("TEXT", "tag")), structure(list(structure("withHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the function simply returns ", class = c("TEXT", "tag")), structure(list(structure("NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (after executing the ", class = c("TEXT", "tag")), structure(list(structure("doplot", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("expression\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag" )), structure(list(structure("doplot", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is used with ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (or ", class = c("TEXT", "tag")), structure(list(structure("inHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("), the function simply returns the unaltered\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" also allows you to specify plotting options in line, without having to make a separate call\n", class = c("TEXT", "tag")), structure("to ", class = c("TEXT", "tag" )), structure(list(structure("[graphics][par]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(". Any ", class = c("TEXT", "tag")), structure(list(structure("[graphics][par]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" argument can be specified as a ", class = c("TEXT", "tag")), structure(list(structure("Keyword ~ Expression", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" pair\n", class = c("TEXT", "tag")), structure("in the ", class = c("TEXT", "tag")), structure(list(structure("formulae", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument. For instance, if you call a ", class = c("TEXT", "tag")), structure(list(structure("doplot", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression with a ", class = c("TEXT", "tag")), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression\n", class = c("TEXT", "tag")), structure("that creates four groups, R will create four plots---but you will only see the last one! Normally, you would need to\n", class = c("TEXT", "tag")), structure("call ", class = c("TEXT", "tag")), structure(list(structure("par(mfcol = c(2,2))", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("before", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" calling your plotting function. However, with ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" you can\n", class = c("TEXT", "tag")), structure("soecific ", class = c("TEXT", "tag")), structure(list(structure("mfcol = c(2,2)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" right in a ", class = c("TEXT", "tag")), structure(list(structure("formulae", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" formula:\n", class = c("TEXT", "tag")), structure("withinHumdrum(humdata,\n", class = c("TEXT", "tag")), structure("doplot ~ fooplot(.),\n", class = c("TEXT", "tag")), structure("by ~ list(Two, byTwo),\n", class = c("TEXT", "tag")), structure("mfcol ~ c(2, 2))\n", class = c("TEXT", "tag")), structure("The best part is ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will reset ", class = c("TEXT", "tag")), structure(list(structure("par", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" to it's previous state after ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is done.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Tandem interpretations", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("The function ", class = c("TEXT", "tag")), structure(list(structure("[readHumdrum][readHumdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" automatically parses\n", class = c("TEXT", "tag")), structure("tandem interpretations (that it recognizes) into\n", class = c("TEXT", "tag")), structure("their own fields in the resulting ", class = c("TEXT", "tag")), structure(list(structure("[humdrumR][humdrumRclass]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" data.\n", class = c("TEXT", "tag")), structure("For instance, data with a ", class = c("TEXT", "tag")), structure(list(structure("'*clefF4'", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will show\n", class = c("TEXT", "tag")), structure("up as a ", class = c("TEXT", "tag")), structure(list(structure("Clef", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field. However, users might read humdrum data with their\n", class = c("TEXT", "tag")), structure("own custom tandem interpretations that are not built into ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" includes the function ", class = c("TEXT", "tag")), structure(list(structure("[getTandem][getTandem]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" to help us\n", class = c("TEXT", "tag")), structure("extract arbitrary tandem intrpretation data.\n", class = c("TEXT", "tag")), structure("Luckily, ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" knows some\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Syntactic_sugarsyntactic", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("syntactic sugar", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure("\n", class = c("TEXT", "tag")), structure("which makes it easy to do this anywhere in our expressions, simply by putting a\n", class = c("TEXT", "tag")), structure("named object beginning with the symbol ", class = c("TEXT", "tag")), structure(list(structure("*", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". Of course, R doesn't normally\n", class = c("TEXT", "tag")), structure("allow names to begin with symbols like ", class = c("TEXT", "tag")), structure(list(structure("*", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", but you can force it by\n", class = c("TEXT", "tag")), structure("placing grave symbols around the name ", class = c("TEXT", "tag")), structure(list(structure("*name", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(". If you do this in a ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("expression, ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will treat this name as a\n", class = c("TEXT", "tag")), structure("regular expression and substitute a call ", class = c("TEXT", "tag")), structure(list(structure("getTandem(Tandem, 'regular expression')", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" in the expression.\n", class = c("TEXT", "tag")), structure("This means you can could do something like\n", class = c("TEXT", "tag")), structure("withinHumdrum(humdata,\n", class = c("TEXT", "tag")), structure("do ~ myFunction(Token, ", class = c("TEXT", "tag")), structure(list(structure("*mytandempattern", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("))\n", class = c("TEXT", "tag")), structure("and ", class = c("TEXT", "tag")), structure(list(structure("myFunction", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will be called with the first argument being the\n", class = c("TEXT", "tag")), structure(list(structure("Token", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field, and the second argument being tandem interpretations\n", class = c("TEXT", "tag")), structure("which match ", class = c("TEXT", "tag")), structure(list(structure("'mytandempattern'", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (extracted from the ", class = c("TEXT", "tag")), structure(list(structure("Tandem", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field).\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Splatting", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("(\"Splatting\" refers to feeding a function a list/vector of arguments.)\n", class = c("TEXT", "tag")), structure("Sometimes we want to divide our data into pieces (a l\\'a ", class = c("TEXT", "tag")), structure(list(structure("partition", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" option), but\n", class = c("TEXT", "tag")), structure("rather than applying the same expression to each piece, we want to feed\n", class = c("TEXT", "tag")), structure("the separate pieces as separate arguments to the same function.\n", class = c("TEXT", "tag")), structure("In ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" you can use some\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Syntactic_sugarsyntactic", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("syntactic sugar", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure("\n", class = c("TEXT", "tag")), structure("to do just this, using the ", class = c("TEXT", "tag")), structure(list(structure("@", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" symbol in the format ", class = c("TEXT", "tag")), structure(list(structure("myFunction(TargetExpr@GroupingExpr)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("If we make this call\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("withinHumdrum(humdata,\n", class = c("TEXT", "tag")), structure("do ~ myFunction(Token@Spine))\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("and there are four spines\n", class = c("TEXT", "tag")), structure("this is how ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will intepret the expression:\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("withinHumdrum(humData,\n", class = c("TEXT", "tag")), structure("do ~ myFunction(Token", class = c("TEXT", "tag")), structure(list(structure("Spine == 1", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(", # first argument when Spine == 1\n", class = c("TEXT", "tag")), structure("Token", class = c("TEXT", "tag")), structure(list(structure("Spine == 2", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(", # second argument when Spine == 2\n", class = c("TEXT", "tag")), structure("Token", class = c("TEXT", "tag")), structure(list(structure("Spine == 3", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(", # etc.\n", class = c("TEXT", "tag")), structure("Token", class = c("TEXT", "tag")), structure(list(structure("Spine == 4", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("))\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Argument interpolation", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("Any named arguments to ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" are ", class = c("TEXT", "tag")), structure(list(structure("[humdrumR:interpolateArguments][interpolated]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" into the\n", class = c("TEXT", "tag")), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expressions. This is useful if you've already created a list of formulas that you like, but would like\n", class = c("TEXT", "tag")), structure("to make small changes to a function call within the ", class = c("TEXT", "tag")), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expressions, without starting from scratch.\n", class = c("TEXT", "tag")), structure("Examples:", class = c("TEXT", "tag")), structure(list(structure("mycommand &lt;- c(do ~ mean(., na.rm = TRUE), by ~ Spine ~ File)\n", class = c("VERB", "tag")), structure("withinHumdrum(humdata,\n", class = c("VERB", "tag")), structure(" mycommand,\n", class = c("VERB", "tag")), structure(" na.rm = FALSE)\n", class = c("VERB", "tag")), structure("# mycommand is executed with na.rm changed to FALSE \n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag" ))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Piping", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("For calls to ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the result of each ", class = c("TEXT", "tag")), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression\n", class = c("TEXT", "tag")), structure("is insterted back into the ", class = c("TEXT", "tag")), structure(list(structure("[humtable][humdrum table]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(". The results\n", class = c("TEXT", "tag")), structure("are put into new field(s) labeled Pipe1, PipeX, ..., PipeN. If the results\n", class = c("TEXT", "tag")), structure("of the expression are shorter than the rows in the ", class = c("TEXT", "tag")), structure(list(structure("humtable", class = c("TEXT", "tag"))), Rd_option = structure("=humdrum table", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(",\n", class = c("TEXT", "tag")), structure("or an ", class = c("TEXT", "tag")), structure(list(structure("object", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the humdrum table is shrunk to fit them.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("RCODE", "tag")), structure("humdata &lt;- readHumdrum('directorywithdata/*.krn')\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("withinHumdrum(humdata, ~nchar(.)) # counts characters in each data token.\n", class = c("RCODE", "tag")), structure("withinHumdrum(humdata, ~table(.), by ~ Spine) # Tabulates data tokens in each Spine.\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" ))), class = c("tag_examples", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), writeHumdrum.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Write.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("writeHumdrum", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("writeHumdrum", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Write ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data to humdrum files.", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("writeHumdrum(\n", class = c("RCODE", "tag")), structure(" humdrumR,\n", class = c("RCODE", "tag")), structure(" fieldname = NULL,\n", class = c("RCODE", "tag")), structure(" affix = \"_humdrumR\",\n", class = c("RCODE", "tag")), structure(" prefix = \"\",\n", class = c("RCODE", "tag")), structure(" rename = NULL,\n", class = c("RCODE", "tag")), structure(" extension = NULL,\n", class = c("RCODE", "tag")), structure(" directory = NULL,\n", class = c("RCODE", "tag")), structure(" EMD = paste0(\"Edited in humdrumR \", packageVersion(\"humdrumR\"), \" on \", Sys.date()),\n", class = c("RCODE", "tag")), structure(" overwrite = FALSE,\n", class = c("RCODE", "tag")), structure(" verbose = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" ))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("----------NEEDS DOCUMENTATION------------\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag"))), source = list( LO5th.Rd = "R/tonalInterval.R", REparser.Rd = "R/Regex.R", RegexFind.Rd = "R/Regex.R", chordTransformer.Rd = "R/tertianSet.R", decimal.Rd = "R/tools.R", diatonicSet.Rd = c("R/diatonicSet.R", "R/tertianSet.R"), fillThru.Rd = "R/tools.R", filterHumdrum.Rd = "R/Filter.R", getFields.Rd = "R/humdrumR-class.R", getTandem.Rd = "R/Apply.R", humActive.Rd = "R/humdrumR-class.R", humAssignment.Rd = "R/humdrumR-class.R", humCensus.Rd = "R/Summary.R", humCoercion.Rd = "R/humdrumR-class.R", humColumns.Rd = "R/humdrumR-class.R", humFormulae.Rd = "R/Formulae.R", humInterpretations.Rd = "R/Summary.R", humMerge.Rd = "R/humdrumR-class.R", humMeter.Rd = "R/rhythmInterval.R", humPipe.Rd = "R/Piping.R", humPrint.Rd = "R/humdrumR-class.R", humReference.Rd = "R/Summary.R", humShape.Rd = "R/humdrumR-class.R", humSize.Rd = "R/humdrumR-class.R", humSpines.Rd = "R/Summary.R", humSummary.Rd = "R/Summary.R", humTable.Rd = "R/humdrumR-class.R", humValidation.Rd = "R/Validation.R", humWindows.Rd = "R/Windows.R", humdrumDispatch.Rd = "R/Compose.R", humdrumPitch.Rd = "R/humdrumR-package.R", humdrumR.Rd = "R/humdrumR-package.R", humdrumRclass.Rd = c("R/humdrumR-class.R", "R/Filter.R" ), humdrumRroot.Rd = "R/humdrumR-package.R", interpolateArguments.Rd = "R/Apply.R", intervalCalculus.Rd = "R/tools.R", keyTransformer.Rd = "R/diatonicSet.R", lag.Rd = "R/tools.R", metricPosition.Rd = "R/rhythmInterval.R", pitchFunctions.Rd = "R/tonalInterval.R", plotRhythm.Rd = "R/Graphics.R", rational.Rd = "R/tools.R", readHumdrum.Rd = "R/Read.R", regexConstruction.Rd = "R/Regex.R", rhythmDecompose.Rd = "R/rhythmInterval.R", rhythmFunctions.Rd = "R/rhythmInterval.R", rhythmInterval.Rd = "R/rhythmInterval.R", rhythmOffset.Rd = "R/rhythmInterval.R", romanNumerals.Rd = "R/diatonicSet.R", struct.Rd = "R/Vector.R", tertianSet.Rd = "R/tertianSet.R", time.Rd = "R/rhythmInterval.R", tonalInterval.Rd = c("R/tonalInterval.R", "R/rhythmInterval.R"), tonalTransformations.Rd = "R/tonalInterval.R", transpose.Rd = "R/tonalInterval.R", withinHumdrum.Rd = "R/Apply.R", writeHumdrum.Rd = "R/Write.R"), keywords = list(character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), "datasets", character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), "internal", character(0), "datasets", character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0)), concepts = list("core pitch representation", character(0), character(0), character(0), "humdrumR numeric functions", character(0), character(0), character(0), character(0), character(0), character(0), character(0), "humdrum data summary functions", character(0), character(0), character(0), "humdrum data summary functions", character(0), character(0), character(0), character(0), character(0), character(0), character(0), "humdrum data summary functions", "humdrum data summary functions", character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), "rhythm analysis tools", character(0), character(0), "humdrumR numeric functions", character(0), character(0), "rhythm analysis tools", character(0), "core rhythm representation", "rhythm analysis tools", character(0), character(0), character(0), character(0), "core pitch representation", character(0), character(0), character(0), character(0)), internal = c(FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE )), class = c("tbl_df", "tbl", "data.frame"), row.names = c(NA, -57L)), tutorials = structure(list(name = character(0), file_out = character(0), title = character(0), pagetitle = character(0), url = character(0)), class = c("tbl_df", "tbl", "data.frame"), row.names = integer(0)), vignettes = structure(list( name = structure(c("GettingStarted", "HumdrumSyntax", "Intervals", "IntroForCoders", "KeysAndChord", "Overview", "PitchAndTonality", "ReadWrite", "RhythmAndMeter", "Validation" ), class = c("fs_path", "character")), file_in = structure(c("vignettes/GettingStarted.Rmd", "vignettes/HumdrumSyntax.Rmd", "vignettes/Intervals.Rmd", "vignettes/IntroForCoders.Rmd", "vignettes/KeysAndChord.Rmd", "vignettes/Overview.Rmd", "vignettes/PitchAndTonality.Rmd", "vignettes/ReadWrite.Rmd", "vignettes/RhythmAndMeter.Rmd", "vignettes/Validation.Rmd"), class = c("fs_path", "character" )), file_out = structure(c("articles/GettingStarted.html", "articles/HumdrumSyntax.html", "articles/Intervals.html", "articles/IntroForCoders.html", "articles/KeysAndChord.html", "articles/Overview.html", "articles/PitchAndTonality.html", "articles/ReadWrite.html", "articles/RhythmAndMeter.html", "articles/Validation.html"), class = c("fs_path", "character" )), title = c("Getting started with humdrumR", "The Humdrum Syntax", "Rhythm and Pitch Intervals", "HumdrumR for Coders", "Diatonic and Tertian Sets in humdrumR", "Overview of humdrumR", "Pitch and Tonality in humdrumR", "Reading and writing data with humdrumR", "Rhythm and Meter in humdrumR", "Validating Humdrum Data" ), description = c(NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, NA_character_), depth = c(1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L)), class = c("tbl_df", "tbl", "data.frame"), row.names = c(NA, -10L)), bs_version = 5L, prefix = ""), class = "pkgdown")), examples = base::quote(TRUE), run_dont_run = base::quote(FALSE), seed = base::quote(1014), lazy = base::quote(FALSE), override = base::quote(list()), install = base::quote(FALSE), preview = base::quote(FALSE), new_process = base::quote(FALSE), devel = base::quote(FALSE), crayon_enabled = base::quote(TRUE), crayon_colors = base::quote(256L), pkgdown_internet = base::quote(TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	      pkgdown::build_site(...)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	        build_site_local(pkg = pkg, examples = examples, run_dont_run = run_dont_run, seed = seed, lazy = lazy, override = override, preview = preview, devel = devel)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	          build_reference(pkg, lazy = lazy, examples = examples, run_dont_run = run_dont_run, seed = seed, override = override, preview = FALSE, devel = devel)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	            purrr::map(topics, build_reference_topic, pkg = pkg, lazy = lazy, examples_env = examples_env, run_dont_run = run_dont_run)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	              .f(.x[[i]], ...)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	                data_reference_topic(topic, pkg, examples_env = examples_env, run_dont_run = run_dont_run)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	                  run_examples(tags$tag_examples[[1]], env = if (is.null(examples_env)) NULL else new.env(parent = examples_env), topic = tools::file_path_sans_ext(topic$file_in), run_dont_run = run_dont_run)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	                    highlight_examples(code, topic, env = env)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	                      downlit::evaluate_and_highlight(code, fig_save = fig_save_topic, env = child_env(env), output_handler = evaluate::new_output_handler(value = pkgdown_print))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	                        evaluate::evaluate(code, child_env(env), new_device = TRUE, output_handler = output_handler)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	                          evaluate_call(expr, parsed$src[[i]], envir = envir, enclos = enclos, debug = debug, last = i == length(out), use_try = stop_on_error != 2L, keep_warning = keep_warning, keep_message = keep_message, output_handler = output_handler, include_timing = include_timing)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	                            eval(expr, envir, enclos)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	                              withinHumdrum(humdata, ~nchar(.))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	                                .withHumdrum(humdrumR, ..., withfunc = "withinHumdrum")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	                                  checkhumdrumR(humdrumR, withfunc)</span>
<span class="r-err co"><span class="r-pr">#&gt;</span> <span class="error">Error:</span> In the call withinHumdrum(humdrumR = _), the argument humdrumR must be a humdrumR object.</span>
<span class="r-in"><span class="fu">withinHumdrum</span><span class="op">(</span><span class="va">humdata</span>, <span class="op">~</span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">.</span><span class="op">)</span>, <span class="va">by</span> <span class="op">~</span> <span class="va">Spine</span><span class="op">)</span> <span class="co"># Tabulates data tokens in each Spine.</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> HumdrumR error in call stack:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	  NULL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	    (function (..., crayon_enabled, crayon_colors, pkgdown_internet) { options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, pkgdown.internet = pkgdown_internet) pkgdown::build_site(...) })(pkg = base::quote(structure(list(package = "humdrumR", version = "0.3.0.9000", lang = "en", src_path = structure("/home/nat/Bridge/Coding/R/Packages/humdrumR", class = c("fs_path", "character")), dst_path = structure("/home/nat/Bridge/Coding/R/Packages/humdrumR/docs", class = c("fs_path", "character")), install_metadata = FALSE, desc = &lt;environment&gt;, meta = list(authors = list(`Nathaniel Condit-Schultz` = list( href = "http://fathermckenzie.net/"), `Claire Arthur` = list( href = "https://clairearthur.com/")), url = "https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR", home = list(sidebar = list(structure = c("links", "license", "community", "citation", "authors", "dev", "toc"))), template = list(bootstrap = 5L, bootswatch = "flatly"), reference = list(list(title = "Musical Tools", desc = "These pages describe the classes and functions that directly represent or engage musical/music-theoretic concepts.\n", contents = "intervalCalculus"), list(subtitle = "Pitch", desc = "Pitch and tonality classes and functions.", contents = c("humdrumPitch", "pitch", "tonalInterval", "tonalTransformations", "LO5th", "diatonicSet", "tertianSet", "romanNumerals", "transpose", "chordTransformer", "keyTransformer", "pitchFunctions")), list(subtitle = "Rhythm", desc = "Rhythm and meter classes and functions.", contents = c("humMeter", "rhythmInterval", "time", "metricPosition", "rhythmDecompose", "rhythmFunctions", "rhythmOffset", "plotRhythm")), list(title = "Reading and Summarizing Data", desc = "These tools allow you to import, validate, and abstractly summarize the content of humdrum data."), list(subtitle = "Reading and Writing", contents = c("humValidation", "readHumdrum", "writeHumdrum")), list(subtite = "Summarizing", contents = c("humSummary", "humCensus", "humReference", "humSpines")), list(title = "Working with Data", desc = "These pages describe tools used to manipulate the musical data ensconced within humdrumR data structures.\n"), list(subtitle = "Manipulating Humdrum Data", contents = c("withinHumdrum", "humPipe", "filterHumdrum", "humWindows", "interpolateArguments", "humFormulae")), list(subtitle = "Manipulating Vectors", contents = c("fillThru", "lag")), list(subtitle = "Regular Expressions", desc = "[Regular Expressions](https://en.wikipedia.org/wiki/Regular_expression) are essential tools for working with humdrum data. These functions provide functionality for working with regular expressions.\n", contents = c("RegexFind", "humdrumDispatch", "regexConstruction", "REparser")), list(title = "Data Structures", desc = "These are pages describe the data structures of humdrumR---which contain the musical data.\n", contents = c("humdrumRclass", "getFields", "getTandem", "humActive", "humAssignment", "humCoercion", "humColumns", "humMerge", "humInterpretations", "humPrint", "humShape", "humSize", "humTable", "struct")), list(title = "Other Functions", desc = "Other useful tools"), list(subtitle = "Numeric values", contents = c("rational", "decimal", "humdrumRroot")))), figures = structure(list( dev = "ragg::agg_png", dpi = 96L, dev.args = list(), fig.ext = "png", fig.width = 7.29166666666667, fig.height = NULL, fig.retina = 2L, fig.asp = 0.618046971569839, bg = NULL, other.parameters = list()), class = "print_yaml"), repo = list( url = list(home = "https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/", source = "https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/blob/HEAD/", issue = "https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/issues/", user = "https://github.com/")), development = list( destination = "dev", mode = "default", version_label = "muted", in_dev = FALSE), topics = structure(list(name = c(LO5th.Rd = "LO5th", REparser.Rd = "REparser", RegexFind.Rd = "RegexFind", chordTransformer.Rd = "chordTransformer", decimal.Rd = "decimal", diatonicSet.Rd = "diatonicSet", fillThru.Rd = "fillThru", filterHumdrum.Rd = "filterHumdrum", getFields.Rd = "getFields", getTandem.Rd = "getTandem", humActive.Rd = "humActive", humAssignment.Rd = "humAssignment", humCensus.Rd = "humCensus", humCoercion.Rd = "humCoercion", humColumns.Rd = "humColumns", humFormulae.Rd = "humFormulae", humInterpretations.Rd = "humInterpretations", humMerge.Rd = "humMerge", humMeter.Rd = "humMeter", humPipe.Rd = "humPipe", humPrint.Rd = "humPrint", humReference.Rd = "humReference", humShape.Rd = "humShape", humSize.Rd = "humSize", humSpines.Rd = "humSpines", humSummary.Rd = "humSummary", humTable.Rd = "humTable", humValidation.Rd = "humValidation", humWindows.Rd = "humWindows", humdrumDispatch.Rd = "humdrumDispatch", humdrumPitch.Rd = "humdrumPitch", humdrumR.Rd = "humdrumR", humdrumRclass.Rd = "humdrumRclass", humdrumRroot.Rd = "humdrumRroot", interpolateArguments.Rd = "interpolateArguments", intervalCalculus.Rd = "intervalCalculus", keyTransformer.Rd = "keyTransformer", lag.Rd = "lag", metricPosition.Rd = "metricPosition", pitchFunctions.Rd = "pitchFunctions", plotRhythm.Rd = "plotRhythm", rational.Rd = "rational", readHumdrum.Rd = "readHumdrum", regexConstruction.Rd = "regexConstruction", rhythmDecompose.Rd = "rhythmDecompose", rhythmFunctions.Rd = "rhythmFunctions", rhythmInterval.Rd = "rhythmInterval", rhythmOffset.Rd = "rhythmOffset", romanNumerals.Rd = "romanNumerals", struct.Rd = "struct", tertianSet.Rd = "tertianSet", time.Rd = "time", tonalInterval.Rd = "tonalInterval", tonalTransformations.Rd = "tonalTransformations", transpose.Rd = "transpose", withinHumdrum.Rd = "withinHumdrum", writeHumdrum.Rd = "writeHumdrum"), file_in = c("LO5th.Rd", "REparser.Rd", "RegexFind.Rd", "chordTransformer.Rd", "decimal.Rd", "diatonicSet.Rd", "fillThru.Rd", "filterHumdrum.Rd", "getFields.Rd", "getTandem.Rd", "humActive.Rd", "humAssignment.Rd", "humCensus.Rd", "humCoercion.Rd", "humColumns.Rd", "humFormulae.Rd", "humInterpretations.Rd", "humMerge.Rd", "humMeter.Rd", "humPipe.Rd", "humPrint.Rd", "humReference.Rd", "humShape.Rd", "humSize.Rd", "humSpines.Rd", "humSummary.Rd", "humTable.Rd", "humValidation.Rd", "humWindows.Rd", "humdrumDispatch.Rd", "humdrumPitch.Rd", "humdrumR.Rd", "humdrumRclass.Rd", "humdrumRroot.Rd", "interpolateArguments.Rd", "intervalCalculus.Rd", "keyTransformer.Rd", "lag.Rd", "metricPosition.Rd", "pitchFunctions.Rd", "plotRhythm.Rd", "rational.Rd", "readHumdrum.Rd", "regexConstruction.Rd", "rhythmDecompose.Rd", "rhythmFunctions.Rd", "rhythmInterval.Rd", "rhythmOffset.Rd", "romanNumerals.Rd", "struct.Rd", "tertianSet.Rd", "time.Rd", "tonalInterval.Rd", "tonalTransformations.Rd", "transpose.Rd", "withinHumdrum.Rd", "writeHumdrum.Rd"), file_out = c("LO5th.html", "REparser.html", "RegexFind.html", "chordTransformer.html", "decimal.html", "diatonicSet.html", "fillThru.html", "filterHumdrum.html", "getFields.html", "getTandem.html", "humActive.html", "humAssignment.html", "humCensus.html", "humCoercion.html", "humColumns.html", "humFormulae.html", "humInterpretations.html", "humMerge.html", "humMeter.html", "humPipe.html", "humPrint.html", "humReference.html", "humShape.html", "humSize.html", "humSpines.html", "humSummary.html", "humTable.html", "humValidation.html", "humWindows.html", "humdrumDispatch.html", "humdrumPitch.html", "humdrumR.html", "humdrumRclass.html", "humdrumRroot.html", "interpolateArguments.html", "intervalCalculus.html", "keyTransformer.html", "lag.html", "metricPosition.html", "pitchFunctions.html", "plotRhythm.html", "rational.html", "readHumdrum.html", "regexConstruction.html", "rhythmDecompose.html", "rhythmFunctions.html", "rhythmInterval.html", "rhythmOffset.html", "romanNumerals.html", "struct.html", "tertianSet.html", "time.html", "tonalInterval.html", "tonalTransformations.html", "transpose.html", "withinHumdrum.html", "writeHumdrum.html" ), alias = list(LO5th.Rd = "LO5th", REparser.Rd = c("REparser", "REparse"), RegexFind.Rd = c("RegexFind", "%~l%", "%~i%", "%~n%", "%~m%", "%~%"), chordTransformer.Rd = c("chordTransformer", "figuredBass"), decimal.Rd = c("decimal", "as.decimal"), diatonicSet.Rd = c("diatonicSet", "dset", "as.character,diatonicSet-method", "is.diatonicSet", "order.diatonicSet", "==,diatonicSet,diatonicSet-method", "Compare,diatonicSet,diatonicSet-method", "diatonicSet.diatonicSet", "diatonicSet.logical", "diatonicSet.numeric", "diatonicSet.integer", "diatonicSet.character"), fillThru.Rd = c("fillThru", "fillForward", "fillBackwards"), filterHumdrum.Rd = c("filterHumdrum", "removeEmptyFiles", "removeEmptySpines", "removeEmptyRecords", "[,humdrumR,missing,ANY-method", "[,humdrumR,numeric,ANY-method", "[,humdrumR,character,ANY-method", "[,humdrumR,formula,ANY-method", "[[,humdrumR,numeric,missing-method", "[[,humdrumR,missing,numeric-method", "[[,humdrumR,character,missing-method", "[[,humdrumR,ANY,ANY-method" ), getFields.Rd = "getFields", getTandem.Rd = "getTandem", humActive.Rd = c("humActive", "evalActive", "getActive", "setActive", "setActiveFields"), humAssignment.Rd = "humAssignment", humCensus.Rd = c("humCensus", "census", "[.humCensus", "print.humCensus"), humCoercion.Rd = c("humCoercion", "as.lines", "as.matrix.humdrumR", "as.matrices", "as.data.frames" ), humColumns.Rd = "humColumns", humFormulae.Rd = c("humFormulae", "ditto"), humInterpretations.Rd = c("humInterpretations", "interpretations", "print.humInterpretations"), humMerge.Rd = c("humMerge", "mergeHumdrum"), humMeter.Rd = "humMeter", humPipe.Rd = c("humPipe", "%hum&gt;%", "%hum&lt;%", "%humT%", "%s&gt;%", "%hums&gt;%", "%hums&lt;%", "%humsT%", "%hums[]%"), humPrint.Rd = c("humPrint", "print_humtab" ), humReference.Rd = c("humReference", "reference", "reference.character", "reference.humdrumR", "[.humReference", "print.humReference" ), humShape.Rd = c("humShape", "foldHumdrum", "foldStops", "foldPaths", "foldRecords", "spinePipe"), humSize.Rd = c("humSize", "nrecords", "ntokens", "npieces", "anySubcorpora", "namesSubcorpora", "nfiles", "is.empty", "anyPaths", "anyStops"), humSpines.Rd = c("humSpines", "spines", "[.humSpines", "print.humSpines"), humSummary.Rd = "humSummary", humTable.Rd = c("humTable", "getHumtab"), humValidation.Rd = c("humValidation", "validateHumdrum"), humWindows.Rd = c("humWindows", "windows", "hop", "nest"), humdrumDispatch.Rd = c("humdrumDispatch", "makeDispatchDF", "makeHumdrumDispatcher", "print.humdrumDispatch" ), humdrumPitch.Rd = "humdrumPitch", humdrumR.Rd = "humdrumR", humdrumRclass.Rd = c("humdrumRclass", "makeHumdrumR", "humdrumRS4", "is.humdrumR", "$,humdrumR-method", "fields", "$&lt;-,humdrumR,vector-method", "$&lt;-,humdrumR,humdrumR-method", "[&lt;-,humdrumR,character,ANY,vector-method", "[&lt;-,humdrumR,character,ANY,humdrumR-method", "[[,humdrumR,missing,character-method", "[[,humdrumR,missing,missing-method", "[[,humdrumR,formula,missing-method", "[[,humdrumR,missing,formula-method" ), humdrumRroot.Rd = "humdrumRroot", interpolateArguments.Rd = "interpolateArguments", intervalCalculus.Rd = c("intervalCalculus", "integrate", "sigma", "derive", "delta", "calculus"), keyTransformer.Rd = c("keyTransformer", "key"), lag.Rd = c("lag", "lead"), metricPosition.Rd = "metricPosition", pitchFunctions.Rd = c("pitchFunctions", "semit", "midi", "pitch", "kern", "lilypond", "interval", "degree", "solfa" ), plotRhythm.Rd = c("plotRhythm", "plotRhythm.default", "plotRhythm.rhythmInterval"), rational.Rd = c("rational", "as.rational", "fraction", "as.fraction"), readHumdrum.Rd = c("readHumdrum", "findHumdrum"), regexConstruction.Rd = c("regexConstruction", "captureRE", "captureUniq", "orRE"), rhythmDecompose.Rd = "rhythmDecompose", rhythmFunctions.Rd = c("rhythmFunctions", "recip", "duration" ), rhythmInterval.Rd = c("rhythmInterval", "rint", "as.character,rhythmInterval-method", "as.double.rhythmInterval", "is.rhythmInterval", "is.numeric,rhythmInterval-method", "order.rhythmInterval", "Compare,rhythmInterval,rhythmInterval-method", "Summary,rhythmInterval-method", "rhythmInterval.logical", "rhythmInterval.NULL", "rhythmInterval.numeric", "rhythmInterval.rational", "rhythmInterval.fraction", "rhythmInterval.integer", "rhythmInterval.character"), rhythmOffset.Rd = "rhythmOffset", romanNumerals.Rd = "romanNumerals", struct.Rd = c("struct", "is.struct"), tertianSet.Rd = c("tertianSet", "tset", "is.tertianSet"), time.Rd = c("time", "bpm2ms", "ms2bpm" ), tonalInterval.Rd = c("tonalInterval", "tint", "is.tonalInterval", "tonalInterval.tonalInterval", "tonalInterval.logical", "tonalInterval.NULL", "tonalInterval.numeric", "tonalInterval.rational", "tonalInterval.fraction", "tonalInterval.integer", "tonalInterval.character", "rhythmInterval.rhythmInterval"), tonalTransformations.Rd = c("tonalTransformations", "invert"), transpose.Rd = "transpose", withinHumdrum.Rd = c("withinHumdrum", "withHumdrum", "inHumdrum", "humApply"), writeHumdrum.Rd = "writeHumdrum"), funs = list(LO5th.Rd = "LO5th()", REparser.Rd = c("REparser()", "REparse()"), RegexFind.Rd = c("`%~l%`", "`%~i%`", "`%~n%`", "`%~m%`", "`%~%`"), chordTransformer.Rd = "figuredBass()", decimal.Rd = c("decimal()", "as.decimal()"), diatonicSet.Rd = c("dset()", "as.character(&lt;i&gt;&amp;lt;diatonicSet&amp;gt;&lt;/i&gt;)", "is.diatonicSet()", "order.diatonicSet()", "`==`(&lt;i&gt;&amp;lt;diatonicSet&amp;gt;&lt;/i&gt;,&lt;i&gt;&amp;lt;diatonicSet&amp;gt;&lt;/i&gt;)", "Compare(&lt;i&gt;&amp;lt;diatonicSet&amp;gt;&lt;/i&gt;,&lt;i&gt;&amp;lt;diatonicSet&amp;gt;&lt;/i&gt;)", "diatonicSet(&lt;i&gt;&amp;lt;diatonicSet&amp;gt;&lt;/i&gt;)", "diatonicSet(&lt;i&gt;&amp;lt;logical&amp;gt;&lt;/i&gt;)", "diatonicSet(&lt;i&gt;&amp;lt;numeric&amp;gt;&lt;/i&gt;)", "diatonicSet(&lt;i&gt;&amp;lt;integer&amp;gt;&lt;/i&gt;)", "diatonicSet(&lt;i&gt;&amp;lt;character&amp;gt;&lt;/i&gt;)", "as.character(&lt;i&gt;&amp;lt;tertianSet&amp;gt;&lt;/i&gt;)", "`==`(&lt;i&gt;&amp;lt;tertianSet&amp;gt;&lt;/i&gt;,&lt;i&gt;&amp;lt;tertianSet&amp;gt;&lt;/i&gt;)" ), fillThru.Rd = c("fillThru()", "fillForward()", "fillBackwards()"), filterHumdrum.Rd = c("filterHumdrum()", "removeEmptyFiles()", "removeEmptySpines()", "removeEmptyRecords()", "`[`", "`[`", "`[`", "`[`", "`[[`", "`[[`", "`[[`", "`[[`"), getFields.Rd = "getFields()", getTandem.Rd = "getTandem()", humActive.Rd = c("evalActive()", "getActive()", "setActive()", "setActiveFields()"), humAssignment.Rd = character(0), humCensus.Rd = c("census()", "`[`", "print(&lt;i&gt;&amp;lt;humCensus&amp;gt;&lt;/i&gt;)" ), humCoercion.Rd = c("as.vector(&lt;i&gt;&amp;lt;humdrumR&amp;gt;&lt;/i&gt;)", "as.lines()", "as.matrix(&lt;i&gt;&amp;lt;humdrumR&amp;gt;&lt;/i&gt;)", "as.data.frame(&lt;i&gt;&amp;lt;humdrumR&amp;gt;&lt;/i&gt;)", "as.matrices()", "as.data.frames()"), humColumns.Rd = character(0), humFormulae.Rd = "ditto", humInterpretations.Rd = c("interpretations()", "print(&lt;i&gt;&amp;lt;humInterpretations&amp;gt;&lt;/i&gt;)"), humMerge.Rd = "mergeHumdrum()", humMeter.Rd = character(0), humPipe.Rd = c("`%hum&amp;gt;%`", "`%hum&amp;lt;%`", "`%humT%`", "`%s&amp;gt;%`", "`%hums&amp;gt;%`", "`%hums&amp;lt;%`", "`%humsT%`", "`%hums[]%`"), humPrint.Rd = c("show(&lt;i&gt;&amp;lt;humdrumR&amp;gt;&lt;/i&gt;)", "print_humtab()"), humReference.Rd = c("reference()", "reference()", "reference()", "`[`(&lt;i&gt;&amp;lt;humReference&amp;gt;&lt;/i&gt;)" ), humShape.Rd = c("foldHumdrum()", "foldStops()", "foldPaths()", "foldRecords()", "spinePipe()"), humSize.Rd = c("nrecords()", "ntokens()", "npieces()", "anySubcorpora()", "namesSubcorpora()", "nfiles()", "length(&lt;i&gt;&amp;lt;humdrumR&amp;gt;&lt;/i&gt;)", "nrow(&lt;i&gt;&amp;lt;humdrumR&amp;gt;&lt;/i&gt;)", "is.empty()", "anyPaths()", "anyStops()"), humSpines.Rd = c("spines()", "`[`(&lt;i&gt;&amp;lt;humSpines&amp;gt;&lt;/i&gt;)", "print(&lt;i&gt;&amp;lt;humSpines&amp;gt;&lt;/i&gt;)" ), humSummary.Rd = "summary(&lt;i&gt;&amp;lt;humdrumR&amp;gt;&lt;/i&gt;)", humTable.Rd = "getHumtab()", humValidation.Rd = "validateHumdrum()", humWindows.Rd = c("windows()", "hop()", "nest()"), humdrumDispatch.Rd = c("humdrumDispatch()", "makeDispatchDF()", "makeHumdrumDispatcher()", "print(&lt;i&gt;&amp;lt;humdrumDispatch&amp;gt;&lt;/i&gt;)" ), humdrumPitch.Rd = character(0), humdrumR.Rd = character(0), humdrumRclass.Rd = character(0), humdrumRroot.Rd = "humdrumRroot", interpolateArguments.Rd = "interpolateArguments()", intervalCalculus.Rd = c("integrate()", "sigma()", "derive()", "delta()", "calculus()"), keyTransformer.Rd = "key()", lag.Rd = c("lag()", "lead()"), metricPosition.Rd = "metricPosition()", pitchFunctions.Rd = c("semit()", "midi()", "pitch()", "kern()", "lilypond()", "interval()", "degree()", "solfa()"), plotRhythm.Rd = "plotRhythm()", rational.Rd = c("rational()", "as.rational()", "fraction()", "as.fraction()"), readHumdrum.Rd = c("findHumdrum()", "readHumdrum()" ), regexConstruction.Rd = c("captureRE()", "captureUniq()", "orRE()"), rhythmDecompose.Rd = "rhythmDecompose()", rhythmFunctions.Rd = c("recip()", "duration()"), rhythmInterval.Rd = character(0), rhythmOffset.Rd = "rhythmOffset()", romanNumerals.Rd = character(0), struct.Rd = "is.struct()", tertianSet.Rd = c("tertianSet()", "tset()", "is.tertianSet()" ), time.Rd = c("bpm2ms()", "ms2bpm()"), tonalInterval.Rd = character(0), tonalTransformations.Rd = "invert()", transpose.Rd = "transpose()", withinHumdrum.Rd = c("withinHumdrum()", "withHumdrum()", "inHumdrum()", "humApply()"), writeHumdrum.Rd = "writeHumdrum()"), title = c(LO5th.Rd = "Line of Fifths", REparser.Rd = "Parse String Using Regular expressions", RegexFind.Rd = "Match strings against regular expression", chordTransformer.Rd = "Parsing and deparsing chord information.", decimal.Rd = "Decimal numbers", diatonicSet.Rd = "Tonal (diatonic) sets", fillThru.Rd = "Propogate data points to \"fill\" null data.", filterHumdrum.Rd = "Filter humdrum data", getFields.Rd = "-------------------------------------------&amp;gt; NEEDS DOCUMENTATION &amp;lt;-------------------------------------------\nGet named", getTandem.Rd = "Get tandem interpretation information from humdrum data.", humActive.Rd = "The \"Active expression\" of a humdrumR object.", humAssignment.Rd = "Assigning new fields", humCensus.Rd = "Tabulate records and tokens in a humdrumR corpus", humCoercion.Rd = "humdrumR Coercion.", humColumns.Rd = "Spines vs Paths vs Columns", humFormulae.Rd = "Standard humdrumR formulae.", humInterpretations.Rd = "Summarize humdrum corpus interpretations.", humMerge.Rd = "Merge two (or more) humdrumR datasets", humMeter.Rd = "Tools for analyzing rhythm and meter.", humPipe.Rd = "Piping humdrumR data", humPrint.Rd = "-------------------------------------------&amp;gt; NEEDS DOCUMENTATION &amp;lt;-------------------------------------------", humReference.Rd = "Summarize reference records in a humdrumR corpus", humShape.Rd = "HumdrumR data \"Shape\"", humSize.Rd = "humdrumR size and shape", humSpines.Rd = "Summarize spines in humdrum dataset", humSummary.Rd = "Summarize humdrumR corpora", humTable.Rd = "Humdrum Tables", humValidation.Rd = "Validate humdrum files", humWindows.Rd = "Applying functions across arbitrary windows.\n----------------------------------------------&amp;gt; NEEDS DOCUMENTATION &amp;lt;----------------------------------------------------", humdrumDispatch.Rd = "Regular expression method dispatch and function application", humdrumPitch.Rd = "humdrumR and pitch", humdrumR.Rd = "humdrumR", humdrumRclass.Rd = "HumdrumR class", humdrumRroot.Rd = "&lt;code&gt;humdrumR&lt;/code&gt;'s root directory on your machine.", interpolateArguments.Rd = "Change or insert values in an expression", intervalCalculus.Rd = "Interval \"calculus\"", keyTransformer.Rd = "Parsing and deparsing key information", lag.Rd = "Shift data within a vector/matrix/data.frame", metricPosition.Rd = "Calculate metric positions from duration data.", pitchFunctions.Rd = "Manipulate pitch data", plotRhythm.Rd = "-------------------------------------------&amp;gt; NEEDS DOCUMENTATION &amp;lt;-------------------------------------------\nPlotting rhythmic symbols in R base graphics", rational.Rd = "Rational numbers", readHumdrum.Rd = "Find and read humdrum files into R", regexConstruction.Rd = "Making Regular Expressions", rhythmDecompose.Rd = "Decompose durations in terms of other durations", rhythmFunctions.Rd = "Manipulate pitch data", rhythmInterval.Rd = "Representation of rhythmic information", rhythmOffset.Rd = "Calculate rhythmic \"offset\"", romanNumerals.Rd = "Roman Numeral", struct.Rd = "struct", tertianSet.Rd = "Tertian set", time.Rd = "Time transformations", tonalInterval.Rd = "Representation of tonal pitch information", tonalTransformations.Rd = "Invert or transpose tonal intervals.", transpose.Rd = "Transpose pitches and keys", withinHumdrum.Rd = "with(in)Humdrum", writeHumdrum.Rd = "Write &lt;code&gt;humdrumR&lt;/code&gt; data to humdrum files." ), rd = list(LO5th.Rd = structure(list(structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/tonalInterval.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("LO5th", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("LO5th", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("Line of Fifths", class = c("TEXT", "tag" ))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("LO5th(x, generic = FALSE, ...)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Returns an integer vector or array, matching the input.\n", class = c("TEXT", "tag"))), class = c("tag_value", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("The function ", class = c("TEXT", "tag")), structure(list(structure("LO5th", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is a S3-generic function with methods to extract\n", class = c("TEXT", "tag")), structure("the \"line-of-fifths\" value from various pitch objects and representations.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("The Line of Fifths", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Every interval in Western music is associated with a integer on the line of fifths:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag" )), structure(" Bb = m7 = -2\n", class = c("TEXT", "tag" )), structure(list(), class = c("tag_item", "tag")), structure(" F = P4 = -1\n", class = c("TEXT", "tag" )), structure(list(), class = c("tag_item", "tag" )), structure(" C = P1 = 0\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" G = P5 = 1\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" D = M2 = 2\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" A = M6 = 3\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" E = M3 = 4\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" B = M7 = 5\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" F# = A4 = 6\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" etc.\n", class = c("TEXT", "tag" ))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("The natural notes of (C) major scale---which we also call the ", class = c("TEXT", "tag")), structure(list(structure("generic intervals", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure("---fall in the range ", class = c("TEXT", "tag")), structure(list(structure("-1:5", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("In fact, any diatonic key is a block of seven consecutive numbers of the line-of-fifths: for example, Eb major is ", class = c("TEXT", "tag")), structure(list(structure("-4:2", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("\"Sharps\" and \"flats\" represent ", class = c("TEXT", "tag")), structure(list(structure("+7", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("-7", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" on the line-of-fifths respectively.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("tint()", class = c("TEXT", "tag"))), Rd_option = structure("=tint", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Other ", class = c("TEXT", "tag")), structure(list( structure("core pitch representation", class = c("TEXT", "tag"))), class = c("LIST", "tag")), structure(": \n", class = c("TEXT", "tag")), structure(list(structure(list(structure("tonalInterval", class = c("TEXT", "tag"))), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("core pitch representation", class = c("TEXT", "tag"))), class = c("LIST", "tag"))), class = c("tag_concept", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), REparser.Rd = structure(list(structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Regex.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("REparser", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("REparser", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("REparse", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("Parse String Using Regular expressions", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("REparser(\n", class = c("RCODE", "tag")), structure(" res,\n", class = c("RCODE", "tag" )), structure(" parse.strict = TRUE,\n", class = c("RCODE", "tag")), structure(" parse.exhaust = TRUE,\n", class = c("RCODE", "tag")), structure(" parse.lead = FALSE,\n", class = c("RCODE", "tag")), structure(" parse.rest = FALSE,\n", class = c("RCODE", "tag")), structure(" toEnv = FALSE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag")), structure("REparse(\n", class = c("RCODE", "tag")), structure(" str,\n", class = c("RCODE", "tag")), structure(" res,\n", class = c("RCODE", "tag")), structure(" parse.strict = TRUE,\n", class = c("RCODE", "tag")), structure(" parse.exhaust = TRUE,\n", class = c("RCODE", "tag")), structure(" parse.lead = FALSE,\n", class = c("RCODE", "tag")), structure(" parse.rest = FALSE,\n", class = c("RCODE", "tag")), structure(" reverse = FALSE,\n", class = c("RCODE", "tag")), structure(" sep = NULL,\n", class = c("RCODE", "tag")), structure(" toEnv = FALSE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" ))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Takes an input string and parses it into a sequence of regular expressions.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag")), structure(list(structure("exhaustive", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is TRUE, the string must be exhaustively broken up by the matching regular expressions.\n", class = c("TEXT", "tag")), structure("Superfluous (non-match) characters at the begginning, end, or in bettween matches, will result in\n", class = c("TEXT", "tag")), structure("all ", class = c("TEXT", "tag" )), structure(list(structure("NA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" being returned.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), RegexFind.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Regex.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("RegexFind", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("RegexFind", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("%~l%", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("%~i%", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("%~n%", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("%~m%", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("%~%", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Match strings against regular expression", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("x %~l% pattern\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("x %~i% pattern\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("x %~n% pattern\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("x %~m% pattern\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("x %~% pattern\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("These infix functions are simply syntactic sugar for\n", class = c("TEXT", "tag")), structure("existing ", class = c("TEXT", "tag")), structure(list(structure("R", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" regular expression matching functions.\n", class = c("TEXT", "tag")), structure("If the a vector of regexes is given as the right argument, matches to ", class = c("TEXT", "tag")), structure(list(structure("any", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" of the regexes are returned.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("%~l%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(": Matches ", class = c("TEXT", "tag")), structure(list(structure("pattern", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" in ", class = c("TEXT", "tag")), structure(list(structure("x", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and returns ", class = c("TEXT", "tag")), structure(list(structure("logical", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". Shorthand for ", class = c("TEXT", "tag")), structure(list(structure(list(structure("base::grepl()", class = c("TEXT", "tag"))), Rd_option = structure("base:grep", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("%~%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(": The \"default\"---same as ", class = c("TEXT", "tag")), structure(list(structure("%~l%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("%~i%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(": Matches ", class = c("TEXT", "tag")), structure(list(structure("pattern", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" in ", class = c("TEXT", "tag")), structure(list(structure("x", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and returns ", class = c("TEXT", "tag")), structure(list(structure("integer", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" indices. Shorthand for ", class = c("TEXT", "tag")), structure(list(structure(list(structure("base::grep()", class = c("TEXT", "tag"))), Rd_option = structure("base:grep", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("%~n%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(": Matches ", class = c("TEXT", "tag")), structure(list(structure("pattern", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" in ", class = c("TEXT", "tag")), structure(list(structure("x", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and returns ", class = c("TEXT", "tag")), structure(list(structure("integer", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" counts (can be greater than one if more\n", class = c("TEXT", "tag")), structure("than one match occurs in the same token). Shorthand for ", class = c("TEXT", "tag")), structure(list(structure(list(structure("stringi::stri_count_regex()", class = c("TEXT", "tag"))), Rd_option = structure("stringi:stri_count", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("%~m%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(": Matches ", class = c("TEXT", "tag")), structure(list(structure("pattern", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" in ", class = c("TEXT", "tag")), structure(list(structure("x", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and returns matching strings (or NA if no match). Shorthand for ", class = c("TEXT", "tag")), structure(list(structure(list(structure("stringi::stri_extract_first_regex()", class = c("TEXT", "tag"))), Rd_option = structure("stringi:stri_extract", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), chordTransformer.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/tertianSet.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("chordTransformer", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("chordTransformer", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("figuredBass", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Parsing and deparsing chord information.", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("figuredBass(\n", class = c("RCODE", "tag")), structure(" x,\n", class = c("RCODE", "tag" )), structure(" ...,\n", class = c("RCODE", "tag" )), structure(" Key = NULL,\n", class = c("RCODE", "tag")), structure(" Exclusive = NULL,\n", class = c("RCODE", "tag")), structure(" parseArgs = list(),\n", class = c("RCODE", "tag")), structure(" transposeArgs = list(),\n", class = c("RCODE", "tag")), structure(" figurationArgs = list(),\n", class = c("RCODE", "tag")), structure(" inPlace = FALSE,\n", class = c("RCODE", "tag")), structure(" memoize = TRUE,\n", class = c("RCODE", "tag")), structure(" deparse = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" ))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("These functions are used to work with chord information.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("xxx\n", class = c("TEXT", "tag" )), structure("Tertian sets can be read/wrote in various ways.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), decimal.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/tools.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("decimal", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("decimal", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("as.decimal", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Decimal numbers", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("decimal(x)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("as.decimal(x, ...)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("These functions create decimal numbers that are identical to base R\n", class = c("TEXT", "tag")), structure(list(structure("numeric", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (real) numbers.\n", class = c("TEXT", "tag")), structure("However, these numbers are understood by the ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("rational numbers", class = c("TEXT", "tag"))), Rd_option = structure("=rational", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" ))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("rational()", class = c("TEXT", "tag"))), Rd_option = structure("=rational", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Other ", class = c("TEXT", "tag")), structure(list(structure("humdrumR numeric functions", class = c("TEXT", "tag"))), class = c("LIST", "tag")), structure(": \n", class = c("TEXT", "tag")), structure(list(structure(list(structure("rational", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("()", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("humdrumR numeric functions", class = c("TEXT", "tag"))), class = c("LIST", "tag"))), class = c("tag_concept", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), diatonicSet.Rd = structure(list(structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/diatonicSet.R, R/tertianSet.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("diatonicSet", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("diatonicSet", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("dset", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("as.character,diatonicSet-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("is.diatonicSet", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("order.diatonicSet", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("==,diatonicSet,diatonicSet-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Compare,diatonicSet,diatonicSet-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("diatonicSet.diatonicSet", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("diatonicSet.logical", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("diatonicSet.numeric", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("diatonicSet.integer", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("diatonicSet.character", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Tonal (diatonic) sets", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("dset(root = 0L, signature = root, alterations = 0L)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag")), structure(list(structure(list(structure("as.character", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("diatonicSet", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(x)\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("is.diatonicSet(x)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("order.diatonicSet(\n", class = c("RCODE", "tag")), structure(" x,\n", class = c("RCODE", "tag" )), structure(" ...,\n", class = c("RCODE", "tag" )), structure(" parallel = TRUE,\n", class = c("RCODE", "tag")), structure(" na.last = TRUE,\n", class = c("RCODE", "tag")), structure(" decreasing = FALSE,\n", class = c("RCODE", "tag")), structure(" method = c(\"auto\", \"shell\", \"radix\")\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure(list( structure(list(structure("==", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("diatonicSet,diatonicSet", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(e1, e2)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("Compare", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("diatonicSet,diatonicSet", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(e1, e2)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("diatonicSet", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("diatonicSet", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("diatonicSet", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("logical", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("diatonicSet", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("numeric", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x)\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure(list( structure(list(structure("diatonicSet", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("integer", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x)\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure(list( structure(list(structure("diatonicSet", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("character", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(str, Exclusive = NULL, Key = NULL, ..., multiDispatch = FALSE)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("as.character", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("tertianSet", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(x)\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure(list( structure(list(structure("==", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("tertianSet,tertianSet", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(e1, e2)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("diatonicSet", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is one of ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("'s\n", class = c("TEXT", "tag")), structure("types of tonal data, representing Western diatonic keys.\n", class = c("TEXT", "tag")), structure("For the most part, users should not need to interact with diatonicSets directly---rather, diatonicSets work behind the scene in numerous ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" pitch functions.\n", class = c("TEXT", "tag")), structure("See the ", class = c("TEXT", "tag" )), structure(list(structure("keyRepresentations", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("keyTransformations", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" documentation for details of usage and functionality or the ", class = c("TEXT", "tag")), structure(list(structure("Tonality in humdrumR", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" vignette for\n", class = c("TEXT", "tag")), structure("a detailed explanation of the theory and specifics of diatonicSets.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("diatonicSet", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is a ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://adv-r.had.co.nz/S4.html", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("S4", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag" )), structure(" subclass of ", class = c("TEXT", "tag" )), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("'s virtual class ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(",\n", class = c("TEXT", "tag")), structure("from which it inherits a lot of useful \"vector-like\" behaviors/functionality.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("The constructor function ", class = c("TEXT", "tag")), structure(list(structure("dset", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" can be used to create ", class = c("TEXT", "tag")), structure(list(structure("diatonicSets", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" directly.\n", class = c("TEXT", "tag")), structure("The three arguments corespond to the three slots: ", class = c("TEXT", "tag")), structure(list(structure("root", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("mode", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", and ", class = c("TEXT", "tag")), structure(list(structure("alteration", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("All inputs will be coerced to match in length.\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag")), structure(list(structure("root", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument will attempt to coerce character strings to ", class = c("TEXT", "tag")), structure(list(structure("tonalIntervals", class = c("TEXT", "tag"))), Rd_option = structure("=tonalInterval", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(", and use their ", class = c("TEXT", "tag")), structure(list(structure("LO5th", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" value as the root.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("By default, the ", class = c("TEXT", "tag" )), structure(list(structure("as.character", class = c("TEXT", "tag"))), Rd_option = structure("base:character", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" method, and thus (via ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(") the ", class = c("TEXT", "tag")), structure(list(structure("show", class = c("TEXT", "tag"))), Rd_option = structure("methods:show", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" method,\n", class = c("TEXT", "tag")), structure("for diatonicSets call ", class = c("TEXT", "tag")), structure(list(structure("key()", class = c("TEXT", "tag"))), Rd_option = structure("=diatonicRepresentations", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure("Thus, if you return a ", class = c("TEXT", "tag")), structure(list(structure("diatonicSet", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" on the command line (or call ", class = c("TEXT", "tag")), structure(list(structure("print", class = c("TEXT", "tag"))), Rd_option = structure("base:print", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" one one),\n", class = c("TEXT", "tag")), structure("you'll see the ", class = c("TEXT", "tag")), structure(list(structure("key interpretation", class = c("TEXT", "tag"))), Rd_option = structure("=diatonicRepresentations", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" representation printed.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Slots", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure(list(structure("Root", class = c("RCODE", "tag"))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("integers representing the root of the key on the line-of-fifths", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure(list(structure("Signature", class = c("RCODE", "tag"))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("integers representing the signature (number of accidentals) of the key.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure(list(structure("Alteration", class = c("RCODE", "tag"))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("integers representing alterations of the diatonic set\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("A key is represented by two integers, ", class = c("TEXT", "tag")), structure(list(structure("Root", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("Signature", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Root is simply the tonic note of the key on the circle of fifths.\n", class = c("TEXT", "tag")), structure("Signature is a value on the circle of fifths, indicating the diatonic mode.\n", class = c("TEXT", "tag")), structure("You can think of the ", class = c("TEXT", "tag")), structure(list(structure("Signature", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" value as indicating the number of accidentals, with negative numbers\n", class = c("TEXT", "tag")), structure("for flats and positive numbers for sharps.\n", class = c("TEXT", "tag")), structure("You can also think of the signature as indicating how much the \"natural key\" (C major) is\n", class = c("TEXT", "tag")), structure("slid up and down the line-of-fifths.\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Mode_(music)", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("traditional diatonic modes", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" of Western music occur wherever ", class = c("TEXT", "tag")), structure(list(structure("Signature - Tonic", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is in the range ", class = c("TEXT", "tag")), structure(list(structure("-5:1", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(":\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("Signature - Tonic = +1 \\rightarrow", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(" Lydian\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("Signature - Tonic = +0 \\rightarrow", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(" Major (Ionian)\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("Signature - Tonic = -1 \\rightarrow", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(" Mixolydian\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("Signature - Tonic = -2 \\rightarrow", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(" Dorian\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("Signature - Tonic = -3 \\rightarrow", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(" Minor (Aeolian)\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("Signature - Tonic = -5 \\rightarrow", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(" Locrian\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("Signature - Tonic = -4 \\rightarrow", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(" Phyrgian\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(structure("Note that you can make diatonicSets where the ", class = c("TEXT", "tag")), structure(list(structure("Root", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is outside the ", class = c("TEXT", "tag")), structure(list(structure("Key", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". This is unusual, and may result in sets you wouldn't predict.", class = c("TEXT", "tag"))), class = c("tag_emph", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_describe", "tag"))), class = "tag")), class = c("tag_section", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Alterations", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag")), structure(list(structure("Alteration", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" slots (also integer) can be used to represent various\n", class = c("TEXT", "tag")), structure("\"altered\" scales.\n", class = c("TEXT", "tag")), structure("The integer values are interpreted as a seven-trit ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Balanced_ternary", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("balanced ternary", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" string.\n", class = c("TEXT", "tag")), structure("(\"trits\" are the ternary equivalent of binary \"bits.\")\n", class = c("TEXT", "tag")), structure("Balanced ternary allows for three digits, ", class = c("TEXT", "tag")), structure(list(structure("0", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (unaltered degree), ", class = c("TEXT", "tag")), structure(list(structure("1", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (sharpened degree), and ", class = c("TEXT", "tag")), structure(list(structure("-1", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (flattened degree).\n", class = c("TEXT", "tag")), structure("The seven trits correspond to the seven scale degrees on the line-of-fifth indicated by the ", class = c("TEXT", "tag")), structure(list(structure("signature", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure("---i.e., ordered from\n", class = c("TEXT", "tag")), structure("lowest to hightest on the line-of-fifths, not relative to the root.\n", class = c("TEXT", "tag")), structure("(For instance, when ", class = c("TEXT", "tag")), structure(list(structure("Signature == 0", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the degrees are ", class = c("TEXT", "tag")), structure(list(structure("c(-1, 0, 1, 2, 3, 4, 5)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".)\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("The ternary arrangement maps powers of three to each scale degree, as so that in the ", class = c("TEXT", "tag")), structure(list(structure("Alteration", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" integer:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure(list(structure("\\pm 1", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(": raise or flatten the ", class = c("TEXT", "tag")), structure(list(structure("7th", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" scale degree.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("\\pm 3", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(": raise or flatten the ", class = c("TEXT", "tag")), structure(list(structure("3rd", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" scale degree.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("\\pm 9", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(": raise or flatten the ", class = c("TEXT", "tag")), structure(list(structure("6th", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" scale degree.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("\\pm 27", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(": raise or flatten the ", class = c("TEXT", "tag")), structure(list(structure("2nd", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" scale degree.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("\\pm 81", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(": raise or flatten the ", class = c("TEXT", "tag")), structure(list(structure("5th", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" scale degree.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("\\pm 243", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(": raise or flatten the ", class = c("TEXT", "tag")), structure(list(structure("1st", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" scale degree.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("\\pm 749", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(": raise or flatten the ", class = c("TEXT", "tag")), structure(list(structure("4th", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" scale degree.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("For example, consider ", class = c("TEXT", "tag")), structure(list(structure("Alteration == 26", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(":\n", class = c("TEXT", "tag")), structure("In a balanced ternary representation, the decimal integer 26 is represented as ", class = c("TEXT", "tag")), structure(list(structure("1 0 0 1 0 -1 0", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("(In other words 1 in the \"27s place\" and -1 in the \"ones place\"---i.e., 27 - 1).\n", class = c("TEXT", "tag")), structure("This represents a raised 2nd (the 27) and a lowered 7th (the -1).\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag")), structure(list( structure("Alteration", class = c("RCODE", "tag" ))), class = c("tag_code", "tag")), structure(" integer allows us to concisely represent all the 2,187 possible combinations of raised and lowered diatonic scale degrees!\n", class = c("TEXT", "tag")), structure("However, combined with the ", class = c("TEXT", "tag")), structure(list(structure("Signature", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" slot, there is some redundancy in scale representation.\n", class = c("TEXT", "tag")), structure("For example, a melodic minor scale can be represented as a major scale (", class = c("TEXT", "tag")), structure(list(structure("Signature - Root == 0", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") with a lowered third degree (", class = c("TEXT", "tag")), structure(list(structure("Alteration == -3", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") ", class = c("TEXT", "tag")), structure(list(structure("or", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" as\n", class = c("TEXT", "tag")), structure("minor scale (", class = c("TEXT", "tag")), structure(list(structure("Signature - Root == -3", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") with raised 6ths and 7ths (", class = c("TEXT", "tag")), structure(list(structure("Alteration == 10", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag")), structure("However, though these two representations result in the same set on the line-of-fifths, some might consider them to be\n", class = c("TEXT", "tag")), structure("conceptually different in some contexts, so we consider the redundancy acceptable.\n", class = c("TEXT", "tag")), structure("Another case of encoding redundancy ", class = c("TEXT", "tag")), structure(list(structure("is", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" that ", class = c("TEXT", "tag")), structure(list(structure("Alteration - 1", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (flatten the 7th) is exactly equivalent to ", class = c("TEXT", "tag")), structure(list(structure("Signature - 1", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Similarly, ", class = c("TEXT", "tag")), structure(list(structure("Alteration + 749", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (raise the 4th) is exactly equivalent to ", class = c("TEXT", "tag")), structure(list(structure("Signature + 1", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Double-flat and double-sharp degrees are ", class = c("TEXT", "tag")), structure(list(structure("not", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" encodable in ", class = c("TEXT", "tag")), structure(list(structure("diatonicSet", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("However, in combination with the ", class = c("TEXT", "tag")), structure(list(structure("Signature", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" slot, sets with double-flat/sharps (like doubly-diminished 7ths) can be encoded.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Arithmatic", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Arithmetic between diatonicSets is not defined.\n", class = c("TEXT", "tag")), structure("However, a number of useful arithmetic operations between diatonicSets and other data types ", class = c("TEXT", "tag")), structure(list(structure("are", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" defined:\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("XXXX Elaborate\n", class = c("TEXT", "tag")), structure("XXXX Need to implement special logic for adding Alterations! (Taking into account Signature addition.)\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Relational Operators", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("diatonicSets can be compared using the standard ", class = c("TEXT", "tag")), structure(list(structure("relational operations", class = c("TEXT", "tag"))), Rd_option = structure("base:Comparison", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list( structure("==", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", and ", class = c("TEXT", "tag")), structure(list(structure("!=", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Two diatonicSets are equal (according to ", class = c("TEXT", "tag")), structure(list(structure("==", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") only if all their slots (", class = c("TEXT", "tag")), structure(list(structure("Root", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("Signature", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", and ", class = c("TEXT", "tag")), structure(list(structure("Alteration", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(")\n", class = c("TEXT", "tag")), structure("are exactly identical.\n", class = c("TEXT", "tag")), structure("Ordinal comparisons (e.g., ", class = c("TEXT", "tag")), structure(list(structure("&gt;", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("&lt;=", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") between diatonicSets are on their ", class = c("TEXT", "tag")), structure(list(structure("Signature", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" only.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Coercion", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" knows how to ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Type_conversion", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("coerce", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag" )), structure(" several ", class = c("TEXT", "tag")), structure(list(structure("base-R atomic types", class = c("TEXT", "tag"))), Rd_option = structure("base:vector", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" into diatonicSets.\n", class = c("TEXT", "tag")), structure("This can be done using the ", class = c("TEXT", "tag")), structure(list(structure("as", class = c("TEXT", "tag"))), Rd_option = structure("methods:as", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" function---e.g., ", class = c("TEXT", "tag")), structure(list(structure("as(3, \"diatonicSet\")", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("---or more intuitively using the function ", class = c("TEXT", "tag")), structure(list(structure("diatonicSet()", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Coercision methods are defined for\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("integer", class = c("TEXT", "tag"))), Rd_option = structure("base:integer", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(": interpreted as root of major key\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("numeric", class = c("TEXT", "tag"))), Rd_option = structure("base:numeric", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(": rounded to nearest integer and intepreted as root of major key\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("character", class = c("TEXT", "tag"))), Rd_option = structure("base:character", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(": interpreted using ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s ", class = c("TEXT", "tag")), structure(list(structure("regular expression dispatch system", class = c("TEXT", "tag"))), Rd_option = structure("=regexDispatch", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(", as\n", class = c("TEXT", "tag")), structure("explained fully ", class = c("TEXT", "tag")), structure(list(structure("here", class = c("TEXT", "tag"))), Rd_option = structure("=diatonicRepresentations", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" ))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), fillThru.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/tools.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("fillThru", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("fillThru", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("fillForward", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("fillBackwards", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Propogate data points to \"fill\" null data.", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("fillThru(x, nonnull = function(x) !is.na(x) &amp; x != \".\", reverse = FALSE)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("fillForward(...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("fillBackwards(...)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("fillThru", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is a function that allow you to \"fill\" null values in a vector\n", class = c("TEXT", "tag")), structure("with non-null values from earlier/later in the same vector.\n", class = c("TEXT", "tag")), structure("The default, \"foward,\" behavior fills each null value with the previous (lower index) non-null value, if there are any.\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag" )), structure(list(structure("reverse", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument can be used to cause \"backeward\" filling, where the ", class = c("TEXT", "tag")), structure(list(structure("next", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" (higher index) non-null value is used.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Which values are considered \"non-null\" can be controlled using the ", class = c("TEXT", "tag")), structure(list(structure("nonnull", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument.\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag" )), structure(list(structure("nonnull", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument can either be a logical vector which is the same length as the input (", class = c("TEXT", "tag")), structure(list(structure("x", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") argument, a numeric\n", class = c("TEXT", "tag")), structure("vector of positive indices, or a function which, when applied to ", class = c("TEXT", "tag")), structure(list(structure("x", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" returns an appropriate logical/numeric vector.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), filterHumdrum.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Filter.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("filterHumdrum", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("filterHumdrum", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("removeEmptyFiles", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("removeEmptySpines", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("removeEmptyRecords", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[,humdrumR,missing,ANY-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[,humdrumR,numeric,ANY-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[,humdrumR,character,ANY-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[,humdrumR,formula,ANY-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[[,humdrumR,numeric,missing-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[[,humdrumR,missing,numeric-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[[,humdrumR,character,missing-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[[,humdrumR,ANY,ANY-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Filter humdrum data", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("filterHumdrum(humdrumR, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("removeEmptyFiles(humdrumR)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("removeEmptySpines(humdrumR)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("removeEmptyRecords(humdrumR)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdata[] # returns unchanged\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdata[x:y]\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdata['regex']\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdata[~expression]\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdata[[x:y]]\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdata[[ , x:y]]\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdata[['regex']]\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdata[[x:y, l:m]]\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("filterHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is a command used to filter a ", class = c("TEXT", "tag")), structure(list(structure("humdrumR corpus", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Indexing a humdrumR corpus (using the ", class = c("TEXT", "tag")), structure(list(structure("[]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("[[]]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" operators)\n", class = c("TEXT", "tag")), structure("uses calls to ", class = c("TEXT", "tag")), structure(list(structure("filterHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("!\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure(list( structure("filterHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is used in a similar manner as ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(",\n", class = c("TEXT", "tag")), structure("taking any number of \"do expressions\" (or functions) as arguments.\n", class = c("TEXT", "tag")), structure("(In fact, do expressions/function arguments are passed directly to an internal call to ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".)\n", class = c("TEXT", "tag")), structure("The only difference is that the expressions/functions fed to ", class = c("TEXT", "tag")), structure(list(structure("filterHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("must", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" be ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("predicate", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" expressions\n", class = c("TEXT", "tag")), structure("which return a logical (", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("/", class = c("TEXT", "tag")), structure(list(structure("FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") vector.\n", class = c("TEXT", "tag")), structure("The returned vector must also be the same length as the input data (the number\n", class = c("TEXT", "tag")), structure("of rows in the ", class = c("TEXT", "tag")), structure(list(structure("humdrum table", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(").\n", class = c("TEXT", "tag")), structure("(You can use a ", class = c("TEXT", "tag")), structure(list(structure("dofill~", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" expression if you want to \"expand\" shorter outputs for filtering pusposes.)\n", class = c("TEXT", "tag")), structure(list(structure("filterHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" updates the humdrum table's ", class = c("TEXT", "tag")), structure(list(structure("Filter", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field using an logical OR (", class = c("TEXT", "tag")), structure(list(structure("|", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") between the existing ", class = c("TEXT", "tag")), structure(list(structure("Filter", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field and the negation of your predicate: ", class = c("TEXT", "tag")), structure(list(structure("Filter | !Predicate", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("HumdrumR functions (mostly) ignore all data points where ", class = c("TEXT", "tag")), structure(list(structure("Filter == TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(": when you print a filtered ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" you'll see all the filtered data points turned to null data (", class = c("TEXT", "tag")), structure(list(structure(".", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("), and\n", class = c("TEXT", "tag")), structure("any calls to ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("TEXT", "tag"))), Rd_option = structure("=with(in)Humdrum", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" will ignore the filtered data.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("By default, ", class = c("TEXT", "tag")), structure(list(structure("filterHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" completely removes any files in the corpus where ", class = c("TEXT", "tag")), structure(list(structure("all", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" the data records are filtered out.\n", class = c("TEXT", "tag")), structure("However, you can stop this by specifying the ", class = c("TEXT", "tag")), structure(list(structure("removeEmptyFiles", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argumet as ", class = c("TEXT", "tag")), structure(list(structure("FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("If you ", class = c("TEXT", "tag")), structure(list(structure("want", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" to remove empty files, spines, or records, you should call ", class = c("TEXT", "tag")), structure(list(structure("removeEmptyFiles", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("removeEmptySpines", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", or ", class = c("TEXT", "tag")), structure(list(structure("removeEmptyRecords", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Indexing", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("In R, the basic ", class = c("TEXT", "tag")), structure(list(structure("indexing operators", class = c("TEXT", "tag"))), Rd_option = structure("base:Extract", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(", ", class = c("TEXT", "tag" )), structure(list(structure("[]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("[[]]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(",\n", class = c("TEXT", "tag")), structure("are used to select subsets of data.\n", class = c("TEXT", "tag")), structure("For many R data types (for instance, base R ", class = c("TEXT", "tag")), structure(list(structure("lists", class = c("TEXT", "tag"))), Rd_option = structure("base:list", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(")\n", class = c("TEXT", "tag" )), structure("the ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("single brackets", class = c("TEXT", "tag")), structure(list(structure("]", class = c("VERB", "tag"))), class = c("tag_verb", "tag"))), class = c("tag_strong", "tag")), structure(" are used for \"shallower\" extraction while the\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("[[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("double brackets", class = c("TEXT", "tag")), structure(list(structure("]]", class = c("VERB", "tag"))), class = c("tag_verb", "tag"))), class = c("tag_strong", "tag")), structure(" are used for \"deeper\" extraction.\n", class = c("TEXT", "tag")), structure(list(structure("HumdrumR corpus", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" indexing follows this same basic pattern:\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("single brackets", class = c("TEXT", "tag")), structure(list(structure("]", class = c("VERB", "tag"))), class = c("tag_verb", "tag"))), class = c("tag_strong", "tag")), structure(" are used to index ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" objects\n", class = c("TEXT", "tag")), structure(list(structure("by piece", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" while ", class = c("TEXT", "tag")), structure(list(structure(list(structure("[[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("double brackets", class = c("TEXT", "tag")), structure(list(structure("]]", class = c("VERB", "tag"))), class = c("tag_verb", "tag"))), class = c("tag_strong", "tag")), structure(" are used to index\n", class = c("TEXT", "tag")), structure(list(structure("within pieces", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(". (Accidentally writing ", class = c("TEXT", "tag")), structure(list(structure("[]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" when you need\n", class = c("TEXT", "tag")), structure(list(structure("[[]]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" is a very common error, so watch out!)\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Whether, indexing by piece or within, ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" objects can use\n", class = c("TEXT", "tag")), structure("three types of indexing arguments:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" By ", class = c("TEXT", "tag")), structure(list(structure("numeric", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (ordinal integers)\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" By ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" string (regular expressions)\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" By ", class = c("TEXT", "tag")), structure(list(structure("formula", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (arbitrary expressions)\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("The last option (by ", class = c("TEXT", "tag")), structure(list(structure("formula", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") is the most powerful option,\n", class = c("TEXT", "tag")), structure("and indeed, the first two options (", class = c("TEXT", "tag")), structure(list(structure("numeric", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" indexing)\n", class = c("TEXT", "tag")), structure("are just convenient shorthands for indexing that can be accomplished using\n", class = c("TEXT", "tag")), structure("the ", class = c("TEXT", "tag")), structure(list(structure("formula", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" method.\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Numeric indexing:", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Indexing ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" corpora with\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("single brackets", class = c("TEXT", "tag")), structure(list(structure("]", class = c("VERB", "tag"))), class = c("tag_verb", "tag"))), class = c("tag_strong", "tag")), structure(" will accept\n", class = c("TEXT", "tag")), structure("one numeric argument.\n", class = c("TEXT", "tag")), structure("This argument will be used to pick pieces within the ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object ordinally.\n", class = c("TEXT", "tag")), structure("Thus, ", class = c("TEXT", "tag")), structure(list(structure("humdata[1:10]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will select the first ten pieces in the data while ", class = c("TEXT", "tag")), structure(list(structure("humdata[42]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("will select only the 42nd piece.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Indexing ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" objects with\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("[[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("double brackets", class = c("TEXT", "tag")), structure(list(structure("]]", class = c("VERB", "tag"))), class = c("tag_verb", "tag"))), class = c("tag_strong", "tag")), structure(" will accept\n", class = c("TEXT", "tag")), structure("one or two numeric arguments, ", class = c("TEXT", "tag")), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", either of which can\n", class = c("TEXT", "tag")), structure("be used in isolation or in combination.\n", class = c("TEXT", "tag")), structure("(If ", class = c("TEXT", "tag")), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is used in isolation, it must be placed after a comma, as in ", class = c("TEXT", "tag")), structure(list(structure("humdata[[ , j ]]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".)\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is used to index data records (i.e., based on the humtable ", class = c("TEXT", "tag")), structure(list(structure("Record", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field) ordinally.\n", class = c("TEXT", "tag")), structure("Thus, ", class = c("TEXT", "tag")), structure(list(structure("humdata[[1:20]]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" indexes the first twenty records ", class = c("TEXT", "tag")), structure(list(structure("from each file", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure("\n", class = c("TEXT", "tag")), structure("in the corpus, and ", class = c("TEXT", "tag")), structure(list(structure("humdata[[42]]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" extracts the 42nd record ", class = c("TEXT", "tag")), structure(list(structure("from each file", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is used to index spines (i.e., based on the ", class = c("TEXT", "tag")), structure(list(structure("Spine", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field) ordinally.\n", class = c("TEXT", "tag")), structure("Thus, ", class = c("TEXT", "tag")), structure(list(structure("humdata[[ , 3:4]]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" returns the third and fourth spines ", class = c("TEXT", "tag")), structure(list(structure("from each", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure("\n", class = c("TEXT", "tag")), structure("file in the corpus.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("When indexing ", class = c("TEXT", "tag")), structure(list(structure("humdrumR corpora", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" with numbers,\n", class = c("TEXT", "tag")), structure("all ", class = c("TEXT", "tag")), structure(list(structure("numeric", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (double) inputs are converted to integers.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Note that numeric ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" indexing is entirely ", class = c("TEXT", "tag")), structure(list(structure("ordinal", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(", meaning\n", class = c("TEXT", "tag")), structure("that pieces/data records/spines are not matched based on their value in their\n", class = c("TEXT", "tag")), structure("respective fields, but rather on their order among all existing values.\n", class = c("TEXT", "tag")), structure("Thus, for ", class = c("TEXT", "tag")), structure(list(structure("[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("single-bracket", class = c("TEXT", "tag")), structure(list(structure("]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" indexing the $i_", class = c("TEXT", "tag")), structure(list(structure("th", class = c("TEXT", "tag"))), class = c("LIST", "tag")), structure("$ piece in the\n", class = c("TEXT", "tag")), structure("corpus is taken, regardless of that ", class = c("TEXT", "tag")), structure(list(structure("FileN", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field associated\n", class = c("TEXT", "tag")), structure("with that piece.\n", class = c("TEXT", "tag")), structure("For example,", class = c("TEXT", "tag")), structure(list(structure("humsubset &lt;- humdata[11:20]\n", class = c("VERB", "tag")), structure("humsubset[2]\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("will return the 12th piece from the original ", class = c("TEXT", "tag")), structure(list(structure("humdata", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object, ", class = c("TEXT", "tag")), structure(list(structure("not", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" the second piece.\n", class = c("TEXT", "tag")), structure("This is beacuse the first call to ", class = c("TEXT", "tag")), structure(list(structure("[]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" returns the 11th through 20th pieces, and the second call\n", class = c("TEXT", "tag")), structure("returns the ", class = c("TEXT", "tag")), structure(list(structure("second", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" piece that is still present (the 12th).\n", class = c("TEXT", "tag")), structure("Similarly,", class = c("TEXT", "tag")), structure(list(structure("humsubset2 &lt;- humdata[[ , 2:4]]\n", class = c("VERB", "tag")), structure("humsubset2[[ , 2]]\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag" )), structure("will return the third spine from the original data.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("As in normal R indexing, negative numbers can be used, causing corresponding elements to be\n", class = c("TEXT", "tag")), structure(list(structure("removed", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" instead of retained. Thus, ", class = c("TEXT", "tag")), structure(list(structure("humdata[-3:-5]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will remove the third, fourth, and fifth pieces from the data\n", class = c("TEXT", "tag")), structure("while ", class = c("TEXT", "tag")), structure(list(structure("humdata[[ , -3:-5]]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will remove the third, fourth, and fifth spines from each piece.\n", class = c("TEXT", "tag")), structure("Positive and negative indices cannot be mixed in a single argument.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("In all cases, indices outside of range (or of value ", class = c("TEXT", "tag")), structure(list(structure("0", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") are ignored.\n", class = c("TEXT", "tag")), structure("E.g., if you have a corpus of twenty files and you call ", class = c("TEXT", "tag")), structure(list(structure("corpus[21]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", there is no 21st piece, so ", class = c("TEXT", "tag")), structure(list(structure("21", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is \"out of range\".\n", class = c("TEXT", "tag")), structure("If all your input indices are ", class = c("TEXT", "tag")), structure(list(structure("0", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and error will result.\n", class = c("TEXT", "tag")), structure("If all your input indices are out of range then\n", class = c("TEXT", "tag")), structure("an empty ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object is returned.\n", class = c("TEXT", "tag")), structure("For instance, ", class = c("TEXT", "tag")), structure(list(structure("humdata[[401:500, ]]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will return an empty\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object if there are no pieces with more than 400\n", class = c("TEXT", "tag")), structure("data records.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Character indexing:", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Indexing ", class = c("TEXT", "tag")), structure(list(structure("humdrumR objects", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumR:humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" with\n", class = c("TEXT", "tag")), structure(list(structure("[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("single brackets", class = c("TEXT", "tag")), structure(list(structure("]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" will accept one\n", class = c("TEXT", "tag")), structure("vector of ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" strings. These strings are\n", class = c("TEXT", "tag")), structure("treated as\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Regular_expression", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("regular expressions", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" (regexes).\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("The tokens from the humdrumR object's ", class = c("TEXT", "tag")), structure(list(structure("Active", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" fields are searched\n", class = c("TEXT", "tag")), structure("for matches to any of the regular expressions you input. Any piece that contains\n", class = c("TEXT", "tag")), structure(list(structure("any", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" match to ", class = c("TEXT", "tag")), structure(list(structure("any", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" of the regular expressions is retained---all other pieces\n", class = c("TEXT", "tag")), structure("are filtered out. Note that (because this is ", class = c("TEXT", "tag")), structure(list(structure("[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("single-bracket", class = c("TEXT", "tag")), structure(list(structure("]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" indexing) the entire piece is retained, even if there is only one match.\n", class = c("TEXT", "tag")), structure("If no matches occur in any pieces, an empty ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object is returned.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Indexing ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" objects with ", class = c("TEXT", "tag")), structure(list(structure("[[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("double brackets", class = c("TEXT", "tag")), structure(list(structure("]]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" will\n", class = c("TEXT", "tag")), structure("accept one or two vectors of ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" strings, ", class = c("TEXT", "tag")), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag")), structure("either of which can\n", class = c("TEXT", "tag")), structure("be used in isolation or in combination.\n", class = c("TEXT", "tag")), structure("(If ", class = c("TEXT", "tag")), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is used in isolation, it must be placed after a comma,\n", class = c("TEXT", "tag")), structure("as in ", class = c("TEXT", "tag")), structure(list(structure("humdata[[ , j]]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".)\n", class = c("TEXT", "tag")), structure("These strings are\n", class = c("TEXT", "tag")), structure("treated as ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Regular_expression", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("regular expressions", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" (regexes).\n", class = c("TEXT", "tag")), structure("The tokens from the humdrumR object's ", class = c("TEXT", "tag")), structure(list(structure("Active", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" fields are searched\n", class = c("TEXT", "tag")), structure("for matches to any of the regular expressions you input.\n", class = c("TEXT", "tag")), structure("Any record which contains at least one token matching any regex in ", class = c("TEXT", "tag")), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("will be retained.\n", class = c("TEXT", "tag")), structure("Similarly, any spine which contains at least one token matching any\n", class = c("TEXT", "tag")), structure("regex in ", class = c("TEXT", "tag")), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is retained.\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag" )), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" are used together,\n", class = c("TEXT", "tag")), structure("matching spines (", class = c("TEXT", "tag")), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") are indexed first, so that\n", class = c("TEXT", "tag")), structure("tokens matching the regular expression(s) in ", class = c("TEXT", "tag")), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("must be found in the matching spines.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("A third argument, ", class = c("TEXT", "tag")), structure(list(structure("k", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", can also be used, but only if\n", class = c("TEXT", "tag")), structure("both the ", class = c("TEXT", "tag")), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" arguments are missing.\n", class = c("TEXT", "tag")), structure("In order for this to work, you need to put two commas to mark the \"missing\" ", class = c("TEXT", "tag")), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" arguments:\n", class = c("TEXT", "tag")), structure("e.g., ", class = c("TEXT", "tag")), structure(list(structure("humdata[[ , , '[Ee]-']]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("In the case of ", class = c("TEXT", "tag")), structure(list(structure("k", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", only matching tokens are retained,\n", class = c("TEXT", "tag")), structure("regardless of their spine or record number(s).\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Formula indexing:", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Indexing ", class = c("TEXT", "tag")), structure(list(structure("humdrumR objects", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumR:humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" with\n", class = c("TEXT", "tag")), structure(list(structure("formulae", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is the most powerful, flexible indexing option.\n", class = c("TEXT", "tag")), structure("Either ", class = c("TEXT", "tag")), structure(list(structure("[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("single", class = c("TEXT", "tag")), structure(list(structure("]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("[[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("double", class = c("TEXT", "tag")), structure(list(structure("]]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" brackets will accept\n", class = c("TEXT", "tag")), structure("a (single) formula. The formula are fed directly as arguments to\n", class = c("TEXT", "tag")), structure(list(structure("filterHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("---as such, they music evaluate to a logical vector of the same\n", class = c("TEXT", "tag")), structure("length as the input.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("In the case of ", class = c("TEXT", "tag")), structure(list(structure("[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("single-bracket", class = c("TEXT", "tag")), structure(list(structure("]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" indexing, only one ", class = c("TEXT", "tag")), structure(list(structure("formula", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("is accepted, and ", class = c("TEXT", "tag")), structure(list(structure("every piece", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" that evalues with at least one\n", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will be retained.\n", class = c("TEXT", "tag")), structure("For instance, ", class = c("TEXT", "tag")), structure(list(structure("humdata[~Spine &gt; 4]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will return all pieces\n", class = c("TEXT", "tag")), structure("which contain five (or more) spines.\n", class = c("TEXT", "tag")), structure(list(structure("[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("single-bracket", class = c("TEXT", "tag")), structure(list(structure("]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" formula indexing is especially useful for indexing\n", class = c("TEXT", "tag")), structure("meta-data properties like reference records:\n", class = c("TEXT", "tag")), structure("for instance, ", class = c("TEXT", "tag")), structure(list(structure("humdata[~COM == \"Paul McCartney\"]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will return\n", class = c("TEXT", "tag")), structure("all pieces with a ", class = c("TEXT", "tag")), structure(list(structure("!!!COM: Paul McCartney", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" reference record.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("In the case of ", class = c("TEXT", "tag")), structure(list(structure("[[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("double-bracket", class = c("TEXT", "tag")), structure(list(structure("]]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" indexing, one or two formulas are accepted,\n", class = c("TEXT", "tag")), structure("in arguments ", class = c("TEXT", "tag")), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", either of which can\n", class = c("TEXT", "tag")), structure("be used in isolation or in combination.\n", class = c("TEXT", "tag")), structure("(If ", class = c("TEXT", "tag")), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is used in isolation, it must be placed after a comma,\n", class = c("TEXT", "tag")), structure("as in ", class = c("TEXT", "tag")), structure(list(structure("humdata[[ , j]]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".)\n", class = c("TEXT", "tag")), structure("In the case of ", class = c("TEXT", "tag")), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" formulae, any record which evaluates to\n", class = c("TEXT", "tag")), structure("at least one ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" value is retained.\n", class = c("TEXT", "tag")), structure("In the case of ", class = c("TEXT", "tag")), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", any spine which evaluates to\n", class = c("TEXT", "tag")), structure("at least one ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" value is retained.\n", class = c("TEXT", "tag")), structure("Any piece which contains no matches is dropped entirely.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("For ", class = c("TEXT", "tag" )), structure(list(structure("[[", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("double-bracket", class = c("TEXT", "tag")), structure(list(structure("]]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" formula indexing, a third argument, ", class = c("TEXT", "tag")), structure(list(structure("k", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("may be used in the absence of ", class = c("TEXT", "tag")), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("In order for this to work, you need to put two commas to mark the \"missing\" ", class = c("TEXT", "tag")), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" arguments:\n", class = c("TEXT", "tag")), structure("e.g., ", class = c("TEXT", "tag")), structure(list(structure("humdata[[ , , ~formula]]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("In the case of ", class = c("TEXT", "tag")), structure(list(structure("k", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" all tokens which evaluate to ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("are retained, regardless of piece/spine/record.\n", class = c("TEXT", "tag")), structure("Pieces, spines, or records with no ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" values\n", class = c("TEXT", "tag")), structure("are simply dropped.\n", class = c("TEXT", "tag")), structure("Using the ", class = c("TEXT", "tag")), structure(list(structure("k", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument is exactly the same a \"plain\" call to ", class = c("TEXT", "tag")), structure(list(structure("filterHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag" ))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), getFields.Rd = structure(list(structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/humdrumR-class.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("getFields", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("getFields", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("-------------------------------------------&gt; NEEDS DOCUMENTATION &lt;-------------------------------------------\n", class = c("TEXT", "tag")), structure("Get named", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("getFields(humdrumR, fieldnames = NULL, dataTypes = \"D\")\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("-------------------------------------------&gt; NEEDS DOCUMENTATION &lt;-------------------------------------------\n", class = c("TEXT", "tag")), structure("Get named\n", class = c("TEXT", "tag" ))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), getTandem.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Apply.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("getTandem", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("getTandem", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Get tandem interpretation information from humdrum data.", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("getTandem(tandem, regex)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Every ", class = c("TEXT", "tag" )), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" object has a field called\n", class = c("TEXT", "tag")), structure(list(structure("Tandem", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" which is a vector of strings which accumulates\n", class = c("TEXT", "tag")), structure("tandem interpretations in each Spine. This function (", class = c("TEXT", "tag")), structure(list(structure("getTandem", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(")\n", class = c("TEXT", "tag")), structure("extracts tandem interpretations from this field, based on a matching\n", class = c("TEXT", "tag")), structure("regular expression. The obligatory ", class = c("TEXT", "tag")), structure(list(structure("'*'", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("does not", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" need to\n", class = c("TEXT", "tag")), structure("be included in the ", class = c("TEXT", "tag")), structure(list(structure("regex", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", as it is added automatically. Thus,\n", class = c("TEXT", "tag")), structure("if you want to find tandem interpretations that match '*clef..', you\n", class = c("TEXT", "tag")), structure("just have to write ", class = c("TEXT", "tag")), structure(list(structure("regex = 'clef..'", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humActive.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/humdrumR-class.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humActive", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humActive", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("evalActive", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("getActive", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("setActive", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("setActiveFields", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("The \"Active expression\" of a humdrumR object.", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("evalActive(\n", class = c("RCODE", "tag")), structure(" humdrumR,\n", class = c("RCODE", "tag")), structure(" dataTypes = \"D\",\n", class = c("RCODE", "tag")), structure(" forceVector = FALSE,\n", class = c("RCODE", "tag")), structure(" sep = \", \",\n", class = c("RCODE", "tag")), structure(" nullAs = NA\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("getActive(humdrumR)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("setActive(humdrumR, form)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("setActiveFields(humdrumR, fieldnames)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" data object.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("dataTypes", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("Which dataTypes of humdrum records to include. Legal values are ", class = c("TEXT", "tag")), structure(list(structure("'G', 'L', 'I', 'M', 'D', 'd', 'P'", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("\n", class = c("TEXT", "tag")), structure("or any combination of these in a single string (e.g., ", class = c("TEXT", "tag")), structure(list(structure("\"LIM\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag")), structure("(see the ", class = c("TEXT", "tag")), structure(list(structure("humdrum table", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" documentation ", class = c("TEXT", "tag")), structure(list(structure("Fields", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" section for an explanation.).", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("forceVector", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure(list( structure("logical", class = c("RCODE", "tag" ))), class = c("tag_code", "tag")), structure(". If ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the result is forced to be an atomic vector.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("sep", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A length-one ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" string. If ", class = c("TEXT", "tag")), structure(list(structure("forceVector == TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" this value is used as a separator\n", class = c("TEXT", "tag")), structure("between tokens that are collapsed.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("nullAsDot", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A single ", class = c("TEXT", "tag")), structure(list(structure("atomic", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" value. Any null tokens are coerced to this value (default is ", class = c("TEXT", "tag")), structure(list(structure(".", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" ))), class = c("tag_arguments", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("This \"Active\" expression is used as the default value in a lot of humdrumR code.\n", class = c("TEXT", "tag")), structure("For one, it is the data which is printed by ", class = c("TEXT", "tag")), structure(list(structure("show", class = c("TEXT", "tag"))), Rd_option = structure("methods:show", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" calls,\n", class = c("TEXT", "tag")), structure("i.e., whenever you return a ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object in the terminal.\n", class = c("TEXT", "tag")), structure("In any expression within a call to\n", class = c("TEXT", "tag")), structure(list(structure("with(in)Humdrum", class = c("TEXT", "tag"))), Rd_option = structure("=withinHumdrum", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(".", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is automatically replaced with the ", class = c("TEXT", "tag")), structure(list(structure("Active", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure("The active expression can be changed with the commands\n", class = c("TEXT", "tag")), structure(list(structure("setActive or the $ operator", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure("This is a handy way to quickly look at different fields in your data.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("The ", class = c("TEXT", "tag" )), structure(list(structure("Active", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression is often just the name of a\n", class = c("TEXT", "tag")), structure(list(structure("field", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(":\n", class = c("TEXT", "tag" )), structure("for instance, the default value is ", class = c("TEXT", "tag")), structure(list(structure("Token", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("However, it can actually be any complex expression which evaluates\n", class = c("TEXT", "tag")), structure("within the ", class = c("TEXT", "tag")), structure(list(structure("humdrum table", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure("For instance, the ", class = c("TEXT", "tag")), structure(list(structure("Active", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression could be:\n", class = c("TEXT", "tag")), structure(list(structure("paste0(Token, \" \", Record)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", which would automatically\n", class = c("TEXT", "tag")), structure("print each Token with its record number pasted to it.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Null data", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("HumdrumR identifies \"null data\" based on the active field.\n", class = c("TEXT", "tag")), structure("Anywhere the current active field evaluates to ", class = c("TEXT", "tag")), structure(list(structure("\".\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("NA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is considered Null data, and assigned the type ", class = c("TEXT", "tag")), structure(list(structure("\"d\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" in the internal\n", class = c("TEXT", "tag")), structure(list(structure("humdrum table", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure("As you work, there will often be data tokens which are null in one field, but not in another field.\n", class = c("TEXT", "tag")), structure("For example, if you load ", class = c("TEXT", "tag")), structure(list(structure("**kern", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" data, a token like ", class = c("TEXT", "tag")), structure(list(structure("\"4r\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (quarter-note rest) token will be ", class = c("TEXT", "tag")), structure(list(structure("NA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" if you call ", class = c("TEXT", "tag")), structure(list(structure("pitch", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", but\n", class = c("TEXT", "tag")), structure("not ", class = c("TEXT", "tag")), structure(list(structure("NA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" if you call ", class = c("TEXT", "tag")), structure(list(structure("recip", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (rhythm).", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("VERB", "tag")), structure("kerndata &lt;- readHumdrum(...)\n", class = c("VERB", "tag")), structure("\n", class = c("VERB", "tag" )), structure("kerndata$Token %hum&gt;% pitch -&gt; kerndata$Pitch\n", class = c("VERB", "tag")), structure("kerndata$Token %hum&gt;% recip -&gt; kerndata$Rhythm\n", class = c("VERB", "tag")), structure("\n", class = c("VERB", "tag" ))), class = c("tag_preformatted", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Now, if you change the active field between ", class = c("TEXT", "tag")), structure(list(structure("Pitch", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("Rhythm", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" you'll see that there\n", class = c("TEXT", "tag")), structure("are different numbers of (non-null) data tokens: ", class = c("TEXT", "tag")), structure(list(structure("ntokens(kerndata$Pitch)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" vs ", class = c("TEXT", "tag")), structure(list(structure("ntokens(kerndata$Rhythm)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will return different numbers!\n", class = c("TEXT", "tag")), structure("(The different would be the number of rest tokens.)\n", class = c("TEXT", "tag")), structure("Similarly, if you apply functions/expressions to this data (using ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" for example), the result will depend on\n", class = c("TEXT", "tag")), structure("what the active field is:", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("VERB", "tag")), structure("kerndata$Pitch %hum&lt;% ~length(Token)\n", class = c("VERB", "tag")), structure("kerndata$Rhythm %hum&lt;% ~length(Token)\n", class = c("VERB", "tag")), structure("\n", class = c("VERB", "tag" ))), class = c("tag_preformatted", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Once again, we'll get different numbers here! (Assuming there are rests in the data.)\n", class = c("TEXT", "tag")), structure("This is the case even though the do-expression isn't actually using the ", class = c("TEXT", "tag")), structure(list(structure("Pitch", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("Rhythm", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" fields!\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag" )), structure(list(structure("Pitch", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is the active field the rest tokens are null-data and will be ignored!\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humAssignment.Rd = structure(list(structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/humdrumR-class.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("humAssignment", class = c("VERB", "tag" ))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humAssignment", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Assigning new fields", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("R objects often have ways of assigning new values to\n", class = c("TEXT", "tag")), structure(list(structure("part", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" of the object using ", class = c("TEXT", "tag")), structure(list(structure("indexing operators", class = c("TEXT", "tag"))), Rd_option = structure("base:Extract", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(structure("HumdrumR objects", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumR:humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" objects are no different, as they allow us to insert\n", class = c("TEXT", "tag")), structure("new fields into them!\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("A new field can be inserted into a ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object in two ways:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag" )), structure(" A field can be copied from one humdrumR object to another if their\n", class = c("TEXT", "tag")), structure("internal ", class = c("TEXT", "tag" )), structure(list(structure("humdrum tables", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" have the exact same number of data tokens (i.e., rows).\n", class = c("TEXT", "tag")), structure("It might not seem obvious, but this mechanism is very useful because it can be used to ", class = c("TEXT", "tag")), structure(list(structure("rename", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" existing fields\n", class = c("TEXT", "tag")), structure("within a humdrumR object (explained below).\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag" )), structure(" A ", class = c("TEXT", "tag")), structure(list( structure("vector", class = c("TEXT", "tag"))), Rd_option = structure("base:vector", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("list of vectors", class = c("TEXT", "tag"))), Rd_option = structure("base:list", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" can be inserted as\n", class = c("TEXT", "tag")), structure("new fields in a humdrumR object.\n", class = c("TEXT", "tag"))), class = c("tag_enumerate", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Fields can be assigned using two syntaxes:", class = c("TEXT", "tag")), structure(list(structure("humdata['fieldname'] &lt;- x\n", class = c("VERB", "tag")), structure("# or\n", class = c("VERB", "tag")), structure("humdata[c('fieldname1', 'fieldname2')] &lt;- x\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("or", class = c("TEXT", "tag")), structure(list(structure("humdata$fieldname &lt;- x\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("where \"fieldname\" can be whatever you want it to be, of course!\n", class = c("TEXT", "tag")), structure(list(structure(list(structure(list( structure("humdrumR -&gt; humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" assignment:", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Assigning a field from one ", class = c("TEXT", "tag")), structure(list(structure("humdrumR object", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumR:humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("to another works like this:\n", class = c("TEXT", "tag")), structure("(Recall that the two objects must have the exact same numbers of data tokens.)\n", class = c("TEXT", "tag")), structure("The name(s) given in the indexing expression on the left side of the assignment (i.e., ", class = c("TEXT", "tag")), structure(list(structure("humdata[c('name1', 'name2')]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or\n", class = c("TEXT", "tag")), structure(list(structure("humdata$name", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") are used as new field names.\n", class = c("TEXT", "tag")), structure("How fields are extracted from the right side of the assignment is a little trickier:\n", class = c("TEXT", "tag")), structure("Any fields in the right-side ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object which are named $PipeN$ (where $N$ is an integer) are copied\n", class = c("TEXT", "tag")), structure("in descending order into the named fields on the left side.\n", class = c("TEXT", "tag")), structure("If there are no $PipeN$ fields on the right side, any fields used in the current Active formula (on the right side)\n", class = c("TEXT", "tag")), structure("are copied instead.\n", class = c("TEXT", "tag")), structure("This system might seem odd at first, but it is very useful in combination with the ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" function,\n", class = c("TEXT", "tag")), structure("or its convenient pipe operator ", class = c("TEXT", "tag")), structure(list(structure("%hum&gt;%", class = c("TEXT", "tag"))), Rd_option = structure("=humPipe", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("When ", class = c("TEXT", "tag" )), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" creates new fields, it calls them $Pipe1 ", class = c("TEXT", "tag")), structure(list(), class = c("tag_ldots", "tag")), structure(" Pipe2 ", class = c("TEXT", "tag")), structure(list(), class = c("tag_ldots", "tag")), structure(" PipeN$.\n", class = c("TEXT", "tag")), structure("Since the output of ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is always the same as the input except with these new \"Pipe\" fields,\n", class = c("TEXT", "tag")), structure("Byou can use ", class = c("TEXT", "tag")), structure(list(structure("humdrumR &lt;- humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" assignment to immediately assign these pipe fields more meaningful names in the original object.\n", class = c("TEXT", "tag")), structure("This makes the most sense with an example:", class = c("TEXT", "tag")), structure(list(structure("humdata$Semits &lt;- humdata %hum&gt;% ~semit(Token) \n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("In humdrumR, we actually favor the left-to-right \"piping\" style.\n", class = c("TEXT", "tag")), structure("Luckily, R allows you to assign left-to-right, so the proper humdrumR style is actually:", class = c("TEXT", "tag")), structure(list(structure("humdata %hum&gt;% ~semit(Token) -&gt; humdata$Semits\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Calls to ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (or ", class = c("TEXT", "tag")), structure(list(structure("%hum&gt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(") keep producing new pipe fields.\n", class = c("TEXT", "tag")), structure("If there are more than one pipe fields, you can assign multiple fields at once using the ", class = c("TEXT", "tag")), structure(list(structure("[]&lt;-", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" syntax:", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("VERB", "tag")), structure("humdata %hum&gt;% ~semit(Token) %hum&gt;% ~pitch(Token) -&gt; humdata[c('semit', 'pitch')]\n", class = c("VERB", "tag")), structure("\n", class = c("VERB", "tag" ))), class = c("tag_preformatted", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("#' ", class = c("TEXT", "tag")), structure(list(structure("IMPORTANT NOTE!", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(": Any \"PipeN\" fields in the humdrumR object you assign from\n", class = c("TEXT", "tag")), structure("that you don't assign field names are simply dropped.\n", class = c("TEXT", "tag")), structure("This is nice, because often you might proceed through a serious of piped steps, but you only\n", class = c("TEXT", "tag")), structure("want the last one (or two).\n", class = c("TEXT", "tag")), structure("If you want to keep all your pipe fields either don't re-assign them at all (i.e., keep the \"PipeN\" names)\n", class = c("TEXT", "tag")), structure("or assign them all names using the ", class = c("TEXT", "tag")), structure(list(structure("-&gt;[c(\"name1\", \"name2\", \"name3\", ...)]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" syntax.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure(list(structure("humdrumR -&gt; vector", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" assignment:", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("You can assign vectors or lists of vectors straight into a ", class = c("TEXT", "tag")), structure(list(structure("humdrumR object", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumR:humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure("All vectors must be the same length as the number of data tokens\n", class = c("TEXT", "tag")), structure("in the target object.\n", class = c("TEXT", "tag")), structure("If you provide multiple vectors to assign (as a ", class = c("TEXT", "tag")), structure(list(structure("list", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("data.frame", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" of vectors)\n", class = c("TEXT", "tag")), structure("you must provide the same number of fieldnames using the ", class = c("TEXT", "tag")), structure(list(structure("-&gt;[c('name1', 'name2', ...)]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" syntax.\n", class = c("TEXT", "tag")), structure("You can use the ", class = c("TEXT", "tag")), structure(list(structure("ntokens", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" command to determine the right length of vectors you need!\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humCensus.Rd = structure(list(structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Summary.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("humCensus", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("humCensus", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("census", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("[.humCensus", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("print.humCensus", class = c("VERB", "tag" ))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Tabulate records and tokens in a humdrumR corpus", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("census(humdrumR, dataTypes = \"GLIMDd\", by = \"Filename\", removeEmpty = FALSE)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag")), structure("census(humdata)[i]\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("print", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humCensus", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(censusTable, showEach = TRUE, screenWidth = options(\"width\")$width - 10L)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A humdrumR object", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("dataTypes", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" string of length 1.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("by", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" string of length 1. Must be a ", class = c("TEXT", "tag")), structure(list(structure("field", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" in the humdrumR object.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag" )), structure("\n", class = c("TEXT", "tag"))), class = c("tag_arguments", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure(list( structure("census", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is one of ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("'s\n", class = c("TEXT", "tag")), structure(list(structure("summary functions", class = c("TEXT", "tag"))), Rd_option = structure("=humSummary", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(", used to\n", class = c("TEXT", "tag")), structure("tabulate the raw size of a ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" corpus.\n", class = c("TEXT", "tag")), structure(list(structure("census", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" takes a ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" object\n", class = c("TEXT", "tag")), structure("and and returns a ", class = c("TEXT", "tag")), structure(list(structure("humCensus", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" table.\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag" )), structure(list(structure("dataType", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument controls what types of records to tabulate:\n", class = c("TEXT", "tag")), structure("legal values are ", class = c("TEXT", "tag")), structure(list(structure("'G', 'L', 'I', 'M', 'D', 'd'", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("\n", class = c("TEXT", "tag")), structure("or any combination of these (e.g., ", class = c("TEXT", "tag")), structure(list(structure("\"LIM\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag")), structure("The default is ", class = c("TEXT", "tag")), structure(list(structure("\"D\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("A ", class = c("TEXT", "tag")), structure(list( structure("humCensus", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" table has five columns of information:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag" )), structure(" Records\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" The total number of records.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Tokens\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" The total number of tokens.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" (unique)\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" The number of ", class = c("TEXT", "tag")), structure(list(structure("unique", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" tokens\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Characters\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" The total numder of characters. This includes humdrum control characters like ", class = c("TEXT", "tag")), structure(list(structure("*", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("!!", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" (per token)\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" This is simply ", class = c("TEXT", "tag")), structure(list(structure("Characters / Tokens", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", indicating the mean length of each token.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_enumerate", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("A ", class = c("TEXT", "tag")), structure(list(structure("humCensus", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" table has one row for each file in the corpus.\n", class = c("TEXT", "tag")), structure("Rows are labeled with each file's corresponding\n", class = c("TEXT", "tag")), structure("number (from the ", class = c("TEXT", "tag")), structure(list(structure("humTable's", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list( structure("File", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" field) and name (the ", class = c("TEXT", "tag")), structure(list(structure("Filename", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" field).\n", class = c("TEXT", "tag")), structure("In addition, when a ", class = c("TEXT", "tag")), structure(list(structure("humCensus", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object is printed,\n", class = c("TEXT", "tag")), structure("the totals across all files are printed as well---(unique) and (per token)\n", class = c("TEXT", "tag")), structure("across all files are calculated across all files as well, not summed.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Indexing", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Rows of a ", class = c("TEXT", "tag" )), structure(list(structure("humCensus", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object can be selected with a single argument ", class = c("TEXT", "tag")), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(": e.g., ", class = c("TEXT", "tag")), structure(list(structure("censusTable[i]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag")), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is ", class = c("TEXT", "tag")), structure(list(structure("numeric", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the corresponding rows are selected ordinally (not by ", class = c("TEXT", "tag")), structure(list(structure("File", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" number).\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag" )), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is a ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" string, this string is mached as a regular expression against file names.\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag" )), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is a formula, the right-hand side of the formula is evaluated within the table---if it evaluates to a logical vector,\n", class = c("TEXT", "tag")), structure("files are selected accordingly. For instance,\n", class = c("TEXT", "tag")), structure(list(structure("censusTable[~Tokens &gt; 100]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will select all files\n", class = c("TEXT", "tag")), structure("with more than 100 tokens. (The '(unique)' and '(per token)' columns\n", class = c("TEXT", "tag")), structure("must be referred to with their names enclosed in ", class = c("TEXT", "tag")), structure(list(structure("\\``---for example, ", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("censusTable", class = c("TEXT", "tag")), structure(list(structure("~\\verb", class = c("TEXT", "tag")), structure(list(structure("(unique)\\", class = c("TEXT", "tag"))), class = c("LIST", "tag")), structure(" &gt; 100", class = c("TEXT", "tag"))), Rd_option = structure("=~\\`(unique)\\` &gt; 100", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("` will return all files with\n", class = c("TEXT", "tag")), structure("more than 100 unique tokens.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("A ", class = c("TEXT", "tag")), structure(list( structure("drop", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument is also available. If ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", a plain\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("data.table::data.table()", class = c("TEXT", "tag"))), Rd_option = structure("data.table:data.table", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(" is returned.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Other humdrum data summary functions: \n", class = c("TEXT", "tag")), structure(list(structure(list(structure("humInterpretations", class = c("TEXT", "tag"))), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("humSpines", class = c("TEXT", "tag"))), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag" )), structure(list(structure(list(structure("humSummary", class = c("TEXT", "tag"))), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("humdrum data summary functions", class = c("TEXT", "tag"))), class = c("tag_concept", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humCoercion.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/humdrumR-class.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humCoercion", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humCoercion", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("as.lines", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("as.matrix.humdrumR", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("as.matrices", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("as.data.frames", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR Coercion.", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure(list(structure(list(structure("as.vector", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(x, mode = \"any\")\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("as.lines(\n", class = c("RCODE", "tag" )), structure(" humdrumR,\n", class = c("RCODE", "tag")), structure(" dataTypes = \"GLIMDd\",\n", class = c("RCODE", "tag")), structure(" fieldname = NULL,\n", class = c("RCODE", "tag")), structure(" alignColumns = FALSE,\n", class = c("RCODE", "tag")), structure(" padPaths = FALSE,\n", class = c("RCODE", "tag")), structure(" padder = \"\"\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure(list( structure(list(structure("as.matrix", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(\n", class = c("RCODE", "tag" )), structure(" x,\n", class = c("RCODE", "tag")), structure(" dataTypes = \"D\",\n", class = c("RCODE", "tag")), structure(" fieldnames = NULL,\n", class = c("RCODE", "tag")), structure(" alignColumns = TRUE,\n", class = c("RCODE", "tag")), structure(" padder = NA,\n", class = c("RCODE", "tag")), structure(" path.fold = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("as.data.frame", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(\n", class = c("RCODE", "tag")), structure(" x,\n", class = c("RCODE", "tag")), structure(" dataTypes = \"D\",\n", class = c("RCODE", "tag")), structure(" fieldname = NULL,\n", class = c("RCODE", "tag")), structure(" padder = NA,\n", class = c("RCODE", "tag")), structure(" fold.path = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("as.matrices(\n", class = c("RCODE", "tag")), structure(" humdrumR,\n", class = c("RCODE", "tag")), structure(" dataTypes = \"D\",\n", class = c("RCODE", "tag")), structure(" fieldnames = NULL,\n", class = c("RCODE", "tag")), structure(" padder = NA,\n", class = c("RCODE", "tag")), structure(" path.fold = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("as.data.frames(\n", class = c("RCODE", "tag")), structure(" humdrumR,\n", class = c("RCODE", "tag")), structure(" dataTypes = \"D\",\n", class = c("RCODE", "tag")), structure(" fieldnames = NULL,\n", class = c("RCODE", "tag")), structure(" padder = NA,\n", class = c("RCODE", "tag")), structure(" path.fold = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("mode", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("If the ", class = c("TEXT", "tag")), structure(list(structure("mode", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument is not ", class = c("TEXT", "tag")), structure(list(structure("'any'", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", it can be a single ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("string naming an atomic mode---the output will be coerced to this mode (if possible).", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("dataTypes", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("Which types of humdrum records to include. Legal values are ", class = c("TEXT", "tag")), structure(list(structure("'G', 'L', 'I', 'M', 'D', 'd'", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("\n", class = c("TEXT", "tag")), structure("or any combination of these (e.g., ", class = c("TEXT", "tag")), structure(list(structure("\"LIM\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag")), structure("(see the ", class = c("TEXT", "tag")), structure(list(structure("humdrum table", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" documentation ", class = c("TEXT", "tag")), structure(list(structure("Fields", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" section for explanation.).", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("padder", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("An atomic value of length one. If ", class = c("TEXT", "tag")), structure(list(structure("par.files", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("pad.paths", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" are true, the ", class = c("TEXT", "tag")), structure(list(structure("padder", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("argument is used to fill in the desired gaps.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("pad.files", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure(list( structure("logical", class = c("RCODE", "tag" ))), class = c("tag_code", "tag")), structure(" (default ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("). If any pieces in the ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" corpus have fewer\n", class = c("TEXT", "tag")), structure(list(structure("[humdrumR:humTable][spines/columns]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" than the maximum, should they be padded with the ", class = c("TEXT", "tag")), structure(list(structure("padder", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument (", class = c("TEXT", "tag")), structure(list(structure("par.files == TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") or\n", class = c("TEXT", "tag")), structure("should an an error occur (", class = c("TEXT", "tag")), structure(list(structure("pad.files == FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(")? Note that these \"padded\" points are not represented in the original humdrum data.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("pad.paths", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure(list( structure("logical", class = c("RCODE", "tag" ))), class = c("tag_code", "tag")), structure(" If any spine path splits (", class = c("TEXT", "tag")), structure(list(structure("'*^'", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") occur in the humdrumR data, should they be padded\n", class = c("TEXT", "tag")), structure("with the ", class = c("TEXT", "tag")), structure(list(structure("padder", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument (", class = c("TEXT", "tag")), structure(list(structure("par.files == TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") or\n", class = c("TEXT", "tag")), structure("should an an error occur (", class = c("TEXT", "tag")), structure(list(structure("pad.paths == FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(")?\n", class = c("TEXT", "tag")), structure("Note that these \"padded\" points are not represented in the original humdrum data.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("field(s)", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("If the ", class = c("TEXT", "tag")), structure(list(structure("field", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument is ", class = c("TEXT", "tag")), structure(list(structure("not", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", it can instead be a ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" string matching\n", class = c("TEXT", "tag")), structure("the ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" object's fields. If so, these fields are extracted instead of the\n", class = c("TEXT", "tag")), structure(list(structure("Active expression", class = c("TEXT", "tag"))), Rd_option = structure("=humActive", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure("For calls to ", class = c("TEXT", "tag")), structure(list(structure("as.vector", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("as.data.frame", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", only one field can be extracted.\n", class = c("TEXT", "tag")), structure("However, for calls to ", class = c("TEXT", "tag")), structure(list(structure("as.matrix", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", multiple fields can be extraced---these fields will be\n", class = c("TEXT", "tag")), structure("returned in a third matrix dimension, each field forming one rectangular slice.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" ))), class = c("tag_arguments", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Many users may wish to work with humdrum data without\n", class = c("TEXT", "tag")), structure("using the ", class = c("TEXT", "tag")), structure(list(structure("[humdrumR:humdrumR][humdrumR]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" API, instead using\n", class = c("TEXT", "tag")), structure("basic ", class = c("TEXT", "tag" )), structure(list(structure("R", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data types.\n", class = c("TEXT", "tag")), structure("For this purpose, ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" data objects can be coerced to\n", class = c("TEXT", "tag")), structure("basic ", class = c("TEXT", "tag" )), structure(list(structure("R", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data types.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("as.vector(humdata)", class = c("TEXT", "tag"))), Rd_option = structure("base:vector", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" evaluates the ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" object's\n", class = c("TEXT", "tag")), structure(list(structure("Active", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" expression, and (attempts) to force the result to a vector of mode. This\n", class = c("TEXT", "tag")), structure("method is essentially a wrapper for ", class = c("TEXT", "tag")), structure(list(structure("evalActive", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("as.matrix(humdata", class = c("TEXT", "tag"))), Rd_option = structure("base:matrix", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" also evaluates the ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" object's\n", class = c("TEXT", "tag")), structure(list(structure("Active", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" expression, but wraps it into a matrix of dimensions ", class = c("TEXT", "tag")), structure(list(structure("c([humdrumR:humSize][nrow(humdata), ncol(humdata)])", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Note that \"", class = c("TEXT", "tag")), structure(list(structure("[humdrumR:humTable][Columns]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("\" in humdrum data are not necesarily the same as spines.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(structure("as.data.frame(humdata)", class = c("TEXT", "tag"))), Rd_option = structure("base:as.data.frame", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" first calls ", class = c("TEXT", "tag")), structure(list(structure("as.matrix", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" then converts the matrix to a ", class = c("TEXT", "tag")), structure(list(structure("data.frame", class = c("TEXT", "tag"))), Rd_option = structure("base:data.frame", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure(list(structure("as.data.table(humdata)", class = c("TEXT", "tag"))), Rd_option = structure("data.table:as.data.table", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" first calls ", class = c("TEXT", "tag")), structure(list(structure("as.matrix", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" then converts the matrix to a ", class = c("TEXT", "tag")), structure(list(structure(list(structure("data.table::data.table()", class = c("TEXT", "tag"))), Rd_option = structure("data.table:data.table", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(structure("as.matrices", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("as.data.frames", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", and ", class = c("TEXT", "tag")), structure(list(structure("as.data.tables", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" call ", class = c("TEXT", "tag")), structure(list(structure("as.matrix", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("/", class = c("TEXT", "tag")), structure(list(structure("as.data.frame", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("/", class = c("TEXT", "tag")), structure(list(structure("as.data.table", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("on each individual file in a ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" corpus, returning a list of matices/data.frames/data.tables.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humColumns.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/humdrumR-class.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humColumns", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humColumns", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Spines vs Paths vs Columns", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("In the ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("http://www.humdrum.org/guide/ch05/", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("humdrum syntax", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(", data is placed in \"spines,\"\n", class = c("TEXT", "tag")), structure("which are not the same as \"columns\" in a spreadsheet. A \"column\" refers to a\n", class = c("TEXT", "tag")), structure("tab-delineated group of values.\n", class = c("TEXT", "tag")), structure("\"Spines\" can be a single column, or they may (at any time) split into multiple columns,\n", class = c("TEXT", "tag")), structure("which can in turn split again, using the ", class = c("TEXT", "tag")), structure(list(structure("\"*^\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" interpretation token. The reverse can happen as well,\n", class = c("TEXT", "tag")), structure("with two or more columns merging into a single column, using the ", class = c("TEXT", "tag")), structure(list(structure("\"v\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" token.\n", class = c("TEXT", "tag")), structure("This means that, while humdrum data at first glance looks like a simple two-dimensional table,\n", class = c("TEXT", "tag")), structure("it is actually a flexible tree structure. As spines split and merge, the total number of columns\n", class = c("TEXT", "tag")), structure("can change during a piece, creating a \"ragged\" edge.\n", class = c("TEXT", "tag")), structure("Another similar issue is that a corpus of humdrum files may have varying numbers of spines/columns, between pieces.\n", class = c("TEXT", "tag")), structure("(\"Global\" comment/reference records are also a special case, as that are always a single value, even if interspersed with\n", class = c("TEXT", "tag")), structure("multi-column local records.)\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("In ", class = c("TEXT", "tag" )), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(", spines, columns, and spine paths work like this.\n", class = c("TEXT", "tag")), structure("First of all, we actually assume a slightly more strict version of the humdrum syntax:\n", class = c("TEXT", "tag")), structure("we assume that all the spines which appear at the beginning of a file (headed with exlusive interpretations\n", class = c("TEXT", "tag")), structure("like ", class = c("TEXT", "tag" )), structure(list(structure("\"**kern\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") can never merge into each other. Thus, a humdrum file read into ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("must not end with fewer columns than it starts.\n", class = c("TEXT", "tag")), structure("Spine merges (", class = c("TEXT", "tag")), structure(list(structure("\"*v\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") can only happen within spine paths that originally split off the same spine.\n", class = c("TEXT", "tag")), structure("This extra-strict specification of spine paths in the humdrum syntax is, fortunately, something that has been\n", class = c("TEXT", "tag")), structure("informally followed in most humdrum datasets.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Our strict spine-path definition makes everything work fairly simply:\n", class = c("TEXT", "tag")), structure("Within a piece, the spines which appear at the beginning of the piece are the \"true\" spines through the rest of the piece, numbered\n", class = c("TEXT", "tag")), structure("from left to right, starting from ", class = c("TEXT", "tag")), structure(list(structure("1L", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("For each local token, the value in the ", class = c("TEXT", "tag")), structure(list(structure("Spine", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field is an integer indicating which of these\n", class = c("TEXT", "tag")), structure("\"true\" spines it belongs to---global tokens have a ", class = c("TEXT", "tag")), structure(list(structure("NA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" value in their ", class = c("TEXT", "tag")), structure(list(structure("Spine", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field, because they are considerd to not belong to any spine.\n", class = c("TEXT", "tag")), structure("Any spine path splits (", class = c("TEXT", "tag")), structure(list(structure("\"*^\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" from the main spines form subspines, which we call ", class = c("TEXT", "tag")), structure(list(structure("Paths", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Every spine's paths are numbered, from right to left, starting from ", class = c("TEXT", "tag")), structure(list(structure("0L", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("A spine with no splits will have all ", class = c("TEXT", "tag")), structure(list(structure("0L", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s in its ", class = c("TEXT", "tag")), structure(list(structure("Path", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Columns", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("It is very useful to sometimes turn humdrum data into a true two dimensional structure, with no ragged edges.\n", class = c("TEXT", "tag")), structure("(This always requires removing global records.)\n", class = c("TEXT", "tag")), structure("In order to do this, while maintaining a sensible relationship between spine which have spine paths,\n", class = c("TEXT", "tag")), structure(list(structure("humRead", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" automatically ", class = c("TEXT", "tag")), structure(list(structure("pads", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" humdrum data into a complete, non-ragged 2d table.\n", class = c("TEXT", "tag")), structure("For instance, given this file", class = c("TEXT", "tag")), structure(list(structure("**kern **kern\n", class = c("VERB", "tag")), structure("A E\n", class = c("VERB", "tag")), structure("*^ *\n", class = c("VERB", "tag")), structure("A C E\n", class = c("VERB", "tag")), structure("G B D\n", class = c("VERB", "tag")), structure("*v *v *\n", class = c("VERB", "tag")), structure("A C \n", class = c("VERB", "tag")), structure("*- *-\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("humRead", class = c("TEXT", "tag" ))), class = c("tag_link", "tag")), structure(" pads the file as so:", class = c("TEXT", "tag")), structure(list(structure("**kern _P **kern\n", class = c("VERB", "tag")), structure("A _P E\n", class = c("VERB", "tag")), structure("*^ _P *\n", class = c("VERB", "tag")), structure("A C E\n", class = c("VERB", "tag")), structure("G B D\n", class = c("VERB", "tag")), structure("*v *v *\n", class = c("VERB", "tag")), structure("A _P C \n", class = c("VERB", "tag")), structure("*- _P *-\n", class = c("VERB", "tag")), structure("\n", class = c("VERB", "tag" )), structure("##########################################\n", class = c("VERB", "tag")), structure("1 1 2 Spine\n", class = c("VERB", "tag")), structure("0 1 0 Path\n", class = c("VERB", "tag")), structure("1 2 3 Column\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("(In this example, the ", class = c("TEXT", "tag")), structure(list(structure("Spine", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("Path", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", and ", class = c("TEXT", "tag")), structure(list(structure("Column", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" values are shown below the data.)\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag")), structure(list(structure("\"_P\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" tokens stand for \"padded path.\"\n", class = c("TEXT", "tag")), structure("This appraoch assures that every ", class = c("TEXT", "tag")), structure(list(structure("Spine", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" is a contiguous block of tokens, of constant width.\n", class = c("TEXT", "tag")), structure("In most humdrumR use cases, these padding tokens (and the ", class = c("TEXT", "tag")), structure(list(structure("Column", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field) can be safely ignored.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Corpus padding", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humRead", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" automatically pads spine paths ", class = c("TEXT", "tag")), structure(list(structure("within pieces", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("However, as mentioned above, there is also (sometimes) a need to pad across pieces, in order\n", class = c("TEXT", "tag")), structure("to create a logical, clean 2d structure.\n", class = c("TEXT", "tag")), structure("Consider this example, with humdrum data from two pieces:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Piece 1", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(":", class = c("TEXT", "tag")), structure(list(structure("**kern **kern **kern\n", class = c("VERB", "tag")), structure("E D C\n", class = c("VERB", "tag")), structure("D . .\n", class = c("VERB", "tag")), structure("C C E\n", class = c("VERB", "tag")), structure("*- *- *-\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag" )), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Piece 2", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(":", class = c("TEXT", "tag")), structure(list(structure("**kern **kern\n", class = c("VERB", "tag")), structure("A A\n", class = c("VERB", "tag")), structure(". B\n", class = c("VERB", "tag")), structure("C C\n", class = c("VERB", "tag")), structure("*- *-\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag" ))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("In this example, we have two pieces, one with three spines, the other with two.\n", class = c("TEXT", "tag")), structure("There is no way to squish these two pieces into one regular 2d table.\n", class = c("TEXT", "tag")), structure("But we ", class = c("TEXT", "tag")), structure(list(structure("could", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" pad any missing columns, as so:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Piece 1", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(":", class = c("TEXT", "tag")), structure(list(structure("**kern **kern **kern\n", class = c("VERB", "tag")), structure("E D C\n", class = c("VERB", "tag")), structure("D . .\n", class = c("VERB", "tag")), structure("C C E\n", class = c("VERB", "tag")), structure("*- *- *-\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag" )), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Piece 2", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(":", class = c("TEXT", "tag")), structure(list(structure("**kern **kern _C\n", class = c("VERB", "tag")), structure("A A _C\n", class = c("VERB", "tag")), structure(". B _C\n", class = c("VERB", "tag")), structure("C C _C\n", class = c("VERB", "tag")), structure("*- *- _C\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag" ))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("The function ", class = c("TEXT", "tag")), structure(list(structure("alignColumns", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is used to achieve just this effect.\n", class = c("TEXT", "tag")), structure("In this example, the ", class = c("TEXT", "tag")), structure(list(structure("\"_C\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" token stands for \"padded column.\"\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("The presence of spine paths makes padding columns across pieces a bit more complicated.\n", class = c("TEXT", "tag")), structure("What ", class = c("TEXT", "tag")), structure(list(structure("alignColumns", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will do, is match up all pieces in a corpus so that\n", class = c("TEXT", "tag")), structure("every ", class = c("TEXT", "tag")), structure(list(structure("Spine", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure("/", class = c("TEXT", "tag")), structure(list( structure("Path", class = c("TEXT", "tag" ))), class = c("tag_strong", "tag")), structure(" field pair allign in the same column.\n", class = c("TEXT", "tag")), structure("Here is an example, with its paths already padded:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Piece 1", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(":", class = c("TEXT", "tag")), structure(list(structure("**kern _P **kern\n", class = c("VERB", "tag")), structure("A _P E\n", class = c("VERB", "tag")), structure("B _P D\n", class = c("VERB", "tag")), structure("*^ _P *\n", class = c("VERB", "tag")), structure("A C E\n", class = c("VERB", "tag")), structure("G# B E\n", class = c("VERB", "tag")), structure("*v *v *\n", class = c("VERB", "tag")), structure("A _P E\n", class = c("VERB", "tag")), structure("*- _P *-\n", class = c("VERB", "tag")), structure("#################################################\n", class = c("VERB", "tag")), structure("1 1 2 Spine\n", class = c("VERB", "tag")), structure("0 1 0 Path\n", class = c("VERB", "tag")), structure("1 2 3 Column\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag" )), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Piece 2", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(":", class = c("TEXT", "tag")), structure(list(structure("**kern **kern _P\n", class = c("VERB", "tag")), structure("A E _P\n", class = c("VERB", "tag")), structure("* *^ _P\n", class = c("VERB", "tag")), structure("G# D F\n", class = c("VERB", "tag")), structure("A C E\n", class = c("VERB", "tag")), structure("* *v *v\n", class = c("VERB", "tag")), structure("E D _P\n", class = c("VERB", "tag")), structure("*- *- _P \n", class = c("VERB", "tag")), structure("#################################################\n", class = c("VERB", "tag")), structure("1 2 2 Spine\n", class = c("VERB", "tag")), structure("0 0 1 Path\n", class = c("VERB", "tag")), structure("1 2 3 Column\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag" ))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("We have two pieces, each with two spines,\n", class = c("TEXT", "tag")), structure("but in the first piece, the first spine splits, while in the second piece, the\n", class = c("TEXT", "tag")), structure("second spine splits. Thus, the padded output will have four columns:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Piece 1", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(":", class = c("TEXT", "tag")), structure(list(structure("**kern _P **kern _C\n", class = c("VERB", "tag")), structure("A _P E _C\n", class = c("VERB", "tag")), structure("B _P D _C\n", class = c("VERB", "tag")), structure("*^ _P * _C\n", class = c("VERB", "tag")), structure("A C E _C\n", class = c("VERB", "tag")), structure("G# B E _C\n", class = c("VERB", "tag")), structure("*v *v * _C\n", class = c("VERB", "tag")), structure("A _P E _C\n", class = c("VERB", "tag")), structure("*- _P *- _C \n", class = c("VERB", "tag")), structure("###########################################################\n", class = c("VERB", "tag")), structure("1 1 2 2 Spine\n", class = c("VERB", "tag")), structure("0 1 0 1 Path\n", class = c("VERB", "tag")), structure("1 2 3 4 Column\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag" )), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Piece 2", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(":", class = c("TEXT", "tag")), structure(list(structure("**kern _C **kern _P\n", class = c("VERB", "tag")), structure("A _C E _P\n", class = c("VERB", "tag")), structure("* _C *^ _P\n", class = c("VERB", "tag")), structure("G# _C D F\n", class = c("VERB", "tag")), structure("A _C C E\n", class = c("VERB", "tag")), structure("* _C *v *v\n", class = c("VERB", "tag")), structure("E _C D _P\n", class = c("VERB", "tag")), structure("*- _C *- _P \n", class = c("VERB", "tag")), structure("######################################################### \n", class = c("VERB", "tag")), structure("1 1 2 2 Spine\n", class = c("VERB", "tag")), structure("0 1 0 1 Path\n", class = c("VERB", "tag")), structure("1 2 3 4 Column\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag" ))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Note that ", class = c("TEXT", "tag")), structure(list(structure("alignColumns", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" actually adds rows to the ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" object's\n", class = c("TEXT", "tag")), structure("internal ", class = c("TEXT", "tag")), structure(list(structure("humdrum tables", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humFormulae.Rd = structure(list(structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Formulae.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("data", class = c("TEXT", "tag"))), class = c("tag_docType", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("humFormulae", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("humFormulae", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("ditto", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("Standard humdrumR formulae.", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("An object of class ", class = c("TEXT", "tag")), structure(list(structure("list", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" of length 3.\n", class = c("TEXT", "tag"))), class = c("tag_format", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("ditto\n", class = c("RCODE", "tag" ))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" predefines a few ", class = c("TEXT", "tag")), structure(list(structure("with(in)humdrum", class = c("TEXT", "tag"))), Rd_option = structure("=withinHumdrum", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" command combinations, as R formulae or lists of formulae.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag" )), structure(" ", class = c("TEXT", "tag")), structure(list( structure("ditto", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" calls ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("fillThru()", class = c("TEXT", "tag"))), Rd_option = structure("=fillThru", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(" across pieces/spines/paths, replicating the classic humdrum toolkit ditto command.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("datasets", class = c("TEXT", "tag"))), class = c("tag_keyword", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humInterpretations.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Summary.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humInterpretations", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humInterpretations", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("interpretations", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("print.humInterpretations", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Summarize humdrum corpus interpretations.", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("interpretations(humdrumR)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("print", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humInterpretations", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(interps, showEach = TRUE, screenWidth = options(\"width\")$width - 10L)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("This function provides a summary of the interpretations in the pieces of a humdrumR corpus.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Other humdrum data summary functions: \n", class = c("TEXT", "tag")), structure(list(structure(list(structure("humCensus", class = c("TEXT", "tag"))), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag" )), structure(list(structure(list(structure("humSpines", class = c("TEXT", "tag"))), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag" )), structure(list(structure(list(structure("humSummary", class = c("TEXT", "tag"))), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrum data summary functions", class = c("TEXT", "tag"))), class = c("tag_concept", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humMerge.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/humdrumR-class.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humMerge", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humMerge", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("mergeHumdrum", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Merge two (or more) humdrumR datasets", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("mergeHumdrum(...)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("-------------------------------------------&gt; NEEDS DOCUMENTATION &lt;-------------------------------------------\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humMeter.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/rhythmInterval.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humMeter", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humMeter", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Tools for analyzing rhythm and meter.", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" includes a number of useful\n", class = c("TEXT", "tag")), structure("functions for working with rhythms and meter.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure(list(structure("rhythmDecompose()", class = c("TEXT", "tag"))), Rd_option = structure("=rhythmDecompose", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(" decomposes a series of rhythms in terms of desired pulses.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("rhythmOffset()", class = c("TEXT", "tag"))), Rd_option = structure("=rhythmOffset", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(" Calculates the cummulative offset of durations from a starting point.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humPipe.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Piping.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humPipe", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humPipe", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("%hum&gt;%", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("%hum&lt;%", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("%humT%", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("%s&gt;%", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("%hums&gt;%", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("%hums&lt;%", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("%humsT%", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("%hums[]%", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Piping humdrumR data", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("humdrumR %hum&gt;% formula\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdrumR %hum&lt;% formula\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdrumR %humT% formula\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("e1 %s&gt;% e2\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("list %hums&gt;% formula\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("list %hums&lt;% formula\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("list %humsT% formula\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("list %hums[]% formula\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("These infix operators make it possible to use\n", class = c("TEXT", "tag")), structure("the ", class = c("TEXT", "tag" )), structure(list(structure("[humdrumR:with-in-Humdrum][with(in)Humdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("\n", class = c("TEXT", "tag")), structure("functions in a piping style, similar to the ", class = c("TEXT", "tag")), structure(list(structure("|", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (pipe)\n", class = c("TEXT", "tag")), structure("in unix-style terminals, or the ", class = c("TEXT", "tag")), structure(list(structure("|&gt;", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" pipe operator.\n", class = c("TEXT", "tag")), structure("from the R package ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://cran.r-project.org/web/packages/magrittr/index.html", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("magrittr", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(".\n", class = c("TEXT", "tag" ))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("The key is that the function ", class = c("TEXT", "tag")), structure(list(structure("[withinHumdrum][withinHumdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" always returns a new\n", class = c("TEXT", "tag")), structure(list(structure("[humdrumR][humdrumR]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" data object. Thus, you can always send the output\n", class = c("TEXT", "tag")), structure("of ", class = c("TEXT", "tag" )), structure(list(structure("[withinHumdrum][withinHumdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" back in to a new call of ", class = c("TEXT", "tag")), structure(list(structure("[withinHumdrum][withinHumdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("This is exactly what the ", class = c("TEXT", "tag")), structure(list(structure("%hum&gt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" is for: on the left-hand side,\n", class = c("TEXT", "tag")), structure("input a ", class = c("TEXT", "tag")), structure(list(structure("[humdrumR][humdrumR]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" object, on the right-hand side suitable\n", class = c("TEXT", "tag")), structure("arguments to ", class = c("TEXT", "tag")), structure(list(structure("[withinHumdrum][withinHumdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" (i.e., a formula, a function, or list of formulae,\n", class = c("TEXT", "tag")), structure("functions, and named arguments). You can then chain this call with another call to\n", class = c("TEXT", "tag")), structure(list(structure("%hum&gt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" and more ", class = c("TEXT", "tag")), structure(list(structure("[withinHumdrum][withinHumdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" arguments.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("%hum&lt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" acts the same way as ", class = c("TEXT", "tag")), structure(list(structure("%hum&gt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" except it calls ", class = c("TEXT", "tag")), structure(list(structure("[withHumdrum][withinHumdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Since ", class = c("TEXT", "tag")), structure(list(structure("[withHumdrum][withinHumdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" does ", class = c("TEXT", "tag")), structure(list(structure("not", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" return a ", class = c("TEXT", "tag")), structure(list(structure("[humdrumR][humdrumR]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(",\n", class = c("TEXT", "tag")), structure("the output can't be piped any further (using ", class = c("TEXT", "tag")), structure(list(structure("%hum&gt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("%hum&lt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(").\n", class = c("TEXT", "tag")), structure("Thus, ", class = c("TEXT", "tag")), structure(list(structure("\\%hum&lt;\\%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" should only be used as the last step in a pipe---you would do this\n", class = c("TEXT", "tag")), structure("if you want to extract the last step in your pipe from the data's ", class = c("TEXT", "tag")), structure(list(structure("[humdrumR:humtable][Humdrum Table]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" into\n", class = c("TEXT", "tag")), structure("a normal vector or list of R data.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("' ", class = c("TEXT", "tag")), structure(list(structure("\\%humT\\%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" creates a \"T\" in the pipe, applying the desired expression but not keeping the result---the unaltered\n", class = c("TEXT", "tag")), structure("humdrumR input object is returned. This works simply by replacing all ", class = c("TEXT", "tag")), structure(list(structure("do~", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" with ", class = c("TEXT", "tag")), structure(list(structure("doplot~", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" in a call to\n", class = c("TEXT", "tag")), structure(list(structure("[withinHumdrum][withinHumdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(". The purpose of this option, is if you want to apply expressions for their\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Side_effect_(computer_science)", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("side effects", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(",\n", class = c("TEXT", "tag" )), structure("for instance, for plotting.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(structure("%hum[]%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" is similar to ", class = c("TEXT", "tag")), structure(list(structure("%hum&gt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" except it apply the formulae on its right-hand\n", class = c("TEXT", "tag")), structure("side using ", class = c("TEXT", "tag")), structure(list(structure("[humdrumR][filterHumdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(". Thus, it can be used to filter/index\n", class = c("TEXT", "tag")), structure("a ", class = c("TEXT", "tag" )), structure(list(structure("[humdrumR][humdrumR]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" data object on the fly.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Plural pipes", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("In R we often apply the same function to a ", class = c("TEXT", "tag")), structure(list(structure("list", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" of data.\n", class = c("TEXT", "tag")), structure("\"Plural pipes\" expand this idea to piping: take a ", class = c("TEXT", "tag")), structure(list(structure("list", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" of data\n", class = c("TEXT", "tag")), structure("and pipe each element in the list to an expression/function.\n", class = c("TEXT", "tag")), structure("There are plural pipe versions of each singular pipe operator.\n", class = c("TEXT", "tag")), structure("Just add an \"s\" to make them plural:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("|&gt;", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" (singular) : ", class = c("TEXT", "tag")), structure(list(structure("%s&gt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" (plural);\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("%hum&gt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" (singular) : ", class = c("TEXT", "tag")), structure(list(structure("%hums&gt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" (plural);\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("%hum&lt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" (singular) : ", class = c("TEXT", "tag")), structure(list(structure("%hums&lt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" (plural);\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("%humT%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" (singular) : ", class = c("TEXT", "tag")), structure(list(structure("%humsT%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" (plural);\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("%hum[]%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" (singular) : ", class = c("TEXT", "tag")), structure(list(structure("%hums[]%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" (plural);\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Note: ", class = c("TEXT", "tag" )), structure(list(structure("%s&gt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" is an expansion of the ", class = c("TEXT", "tag")), structure(list(structure("\\&gt;", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" pipe operator, which\n", class = c("TEXT", "tag")), structure("makes use of some clever meta-programming---we can't guarantee it will\n", class = c("TEXT", "tag")), structure("always behave the way we might like!\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag")), structure("humdata &lt;- readHumdrum('path*.krn')\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdata %hum&gt;% ~table(.)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdata %hum&gt;%\n", class = c("RCODE", "tag")), structure(" c(by~Spine, do ~ table(.)) %hum&gt;%\n", class = c("RCODE", "tag")), structure(" c(mfcol ~ c(2,2), doplot~barplot(.))\n", class = c("RCODE", "tag")), structure(" \n", class = c("RCODE", "tag")), structure("humdata %hum&gt;%\n", class = c("RCODE", "tag")), structure(" c(by ~ Spine, do ~ table(.)) %hum&lt;%\n", class = c("RCODE", "tag")), structure(" (do ~ sort(.)) \n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" ))), class = c("tag_examples", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humPrint.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/humdrumR-class.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humPrint", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humPrint", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("print_humtab", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("-------------------------------------------&gt; NEEDS DOCUMENTATION &lt;-------------------------------------------", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure(list(structure(list(structure("show", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(object)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("print_humtab(\n", class = c("RCODE", "tag")), structure(" humdrumR,\n", class = c("RCODE", "tag")), structure(" dataTypes = \"GLIMDd\",\n", class = c("RCODE", "tag")), structure(" firstAndLast = FALSE,\n", class = c("RCODE", "tag")), structure(" max.records.file = 40L,\n", class = c("RCODE", "tag")), structure(" max.token.length = 30L,\n", class = c("RCODE", "tag")), structure(" collapseNull = 10L\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" ))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("-------------------------------------------&gt; NEEDS DOCUMENTATION &lt;-------------------------------------------\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Show a ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" object in the terminal.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humReference.Rd = structure(list(structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Summary.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("humReference", class = c("VERB", "tag" ))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humReference", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("reference", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("reference.character", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("reference.humdrumR", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[.humReference", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("print.humReference", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Summarize reference records in a humdrumR corpus", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("reference(x)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag")), structure("reference('OTL')\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("reference(humdata)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("[", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humReference", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(refTable, i, j, drop = FALSE)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("reference", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is one of ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("'s\n", class = c("TEXT", "tag")), structure(list(structure("summary functions", class = c("TEXT", "tag"))), Rd_option = structure("=humSummary", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(", used to\n", class = c("TEXT", "tag" )), structure("tabulate the reference records\n", class = c("TEXT", "tag")), structure("present in a ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" corpus.\n", class = c("TEXT", "tag" )), structure(list(structure("reference", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" takes a ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" object\n", class = c("TEXT", "tag" )), structure("and and returns a ", class = c("TEXT", "tag")), structure(list(structure("humReference", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" table.\n", class = c("TEXT", "tag")), structure("Alternatively, ", class = c("TEXT", "tag")), structure(list(structure("reference", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" can take a ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" string,\n", class = c("TEXT", "tag")), structure("which it will check against known reference codes and print a\n", class = c("TEXT", "tag")), structure("information about matching codes. For instance, ", class = c("TEXT", "tag")), structure(list(structure("reference('OTL')", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("returns a description of the standard humdrum ", class = c("TEXT", "tag")), structure(list(structure("!!!OTL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" reference record\n", class = c("TEXT", "tag")), structure("(original title metadata).\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("A ", class = c("TEXT", "tag")), structure(list( structure("humReference", class = c("RCODE", "tag" ))), class = c("tag_code", "tag")), structure(" table has one column for\n", class = c("TEXT", "tag")), structure("each reference code that appears in a ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" corpus.\n", class = c("TEXT", "tag" )), structure("Since reference records can be long (too much to print on one screen),\n", class = c("TEXT", "tag")), structure("and humdrum files can have multiple of the same type of reference code\n", class = c("TEXT", "tag")), structure("(for instance multiple composers annotated with \"!!!COM\"),\n", class = c("TEXT", "tag")), structure("by default, a ", class = c("TEXT", "tag")), structure(list(structure("humReference", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" only prints the number of each type of\n", class = c("TEXT", "tag")), structure("reference record to appear in each file.\n", class = c("TEXT", "tag")), structure("However, if only one type of reference code is present in a\n", class = c("TEXT", "tag")), structure(list(structure("humReference", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" table, the complete reference records for that code\n", class = c("TEXT", "tag")), structure("will be printed for each file. Likewise, if only one file is present\n", class = c("TEXT", "tag")), structure("in the table, all of that file's complete reference records are printed.\n", class = c("TEXT", "tag")), structure("Thus, if you want to see actualy reference records, try indexing the\n", class = c("TEXT", "tag")), structure(list(structure("humReference", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" table down to one column or row (see below).\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("A ", class = c("TEXT", "tag")), structure(list(structure("humReference", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" table has one row for each file in the corpus.\n", class = c("TEXT", "tag")), structure("Rows are labeled with each file's corresponding\n", class = c("TEXT", "tag")), structure("number (from the ", class = c("TEXT", "tag")), structure(list(structure("humTable", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("'s ", class = c("TEXT", "tag")), structure(list(structure("File", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" field) and name (the ", class = c("TEXT", "tag")), structure(list(structure("Filename", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" field).\n", class = c("TEXT", "tag")), structure("In addition, when a ", class = c("TEXT", "tag")), structure(list(structure("humReference", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object is printed,\n", class = c("TEXT", "tag")), structure("three different summary totals are printed for each reference code:\n", class = c("TEXT", "tag")), structure(list(structure("Any", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" indicates how many files in the corpus have at least\n", class = c("TEXT", "tag")), structure("one example of each code in them.\n", class = c("TEXT", "tag")), structure(list(structure("Sum", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" indicates the total number of each reference code to appear\n", class = c("TEXT", "tag")), structure("in the corpus, including multiple appearances in one file (like multiple \"!!!COM\"\n", class = c("TEXT", "tag")), structure("records).\n", class = c("TEXT", "tag" )), structure("Finally, ", class = c("TEXT", "tag")), structure(list(structure("Unique", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" tabulates the number of unique tokens in each reference\n", class = c("TEXT", "tag")), structure("code---if your corpus only hase two unique composers (encoded in \"!!!COM\"),\n", class = c("TEXT", "tag")), structure("the ", class = c("TEXT", "tag" )), structure(list(structure("Unique", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" total will be ", class = c("TEXT", "tag")), structure(list(structure("2", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Indexing", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humReference", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" tables can be indexed much like base ", class = c("TEXT", "tag")), structure(list(structure("R", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("[data.frames][base::data.frame()], with two arguments: ", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("i", class = c("TEXT", "tag")), structure(list(structure("(rows) and", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("j", class = c("TEXT", "tag")), structure(list(structure("(columns). If", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("i", class = c("TEXT", "tag")), structure(list(structure("or", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("j", class = c("TEXT", "tag")), structure(list(structure("are", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("numeric", class = c("TEXT", "tag")), structure(list(structure(", they select rows or columns respectively, ordinally. If ", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("i", class = c("TEXT", "tag")), structure(list(structure("is a", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("character", class = c("TEXT", "tag")), structure(list(structure(", it is matched as a regular expression against filenames in the corpus. If ", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("j", class = c("TEXT", "tag")), structure(list(structure("is a", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("character`, it is ", class = c("TEXT", "tag")), structure(list(structure("partially matched", class = c("TEXT", "tag"))), Rd_option = structure("base:pmatch", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag")), structure("against column names.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("A ", class = c("TEXT", "tag")), structure(list(structure("drop", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument is also available. If ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", a plain\n", class = c("TEXT", "tag")), structure(list(structure("[data.table][data.table::data.table()]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" is returned.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humShape.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/humdrumR-class.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humShape", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humShape", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("foldHumdrum", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("foldStops", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("foldPaths", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("foldRecords", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("spinePipe", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("HumdrumR data \"Shape\"", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("foldHumdrum(humdrumR, byfields, foldAtomic = TRUE, sep = \" \", padPaths = FALSE)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("foldStops(humdrumR, foldAtomic = TRUE, sep = \" \")\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("foldPaths(humdrumR, foldAtomic = TRUE, sep = \" \")\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("foldRecords(humdrumR, foldAtomic = TRUE, sep = \" \", padPaths = FALSE)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("spinePipe(humdrumR, targetSpines, destinationSpines)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" data object.\n", class = c("TEXT", "tag")), structure("(see the ", class = c("TEXT", "tag")), structure(list(structure("humdrum table", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" documentation ", class = c("TEXT", "tag")), structure(list(structure("Fields", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" section for explanation.).", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("foldAtomic", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure(list( structure("logical", class = c("RCODE", "tag" ))), class = c("tag_code", "tag")), structure(". If ", class = c("TEXT", "tag")), structure(list(structure("foldAtomic == TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", each stop is collapsed to a single string\n", class = c("TEXT", "tag")), structure(list(structure("foldAtomic == FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", each stop is collapsed to a list of tokens.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("sep", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure(list( structure("character", class = c("RCODE", "tag" ))), class = c("tag_code", "tag")), structure(". If ", class = c("TEXT", "tag")), structure(list(structure("foldAtomic == TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", collapsed tokens are separated by this string.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("pad", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure(list( structure("logical", class = c("RCODE", "tag" ))), class = c("tag_code", "tag")), structure(". Should ", class = c("TEXT", "tag")), structure(list(structure("path/column padding tokens", class = c("TEXT", "tag"))), Rd_option = structure("=humColumns", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" be included?", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" ))), class = c("tag_arguments", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("These functions are used to change the \"shape\"\n", class = c("TEXT", "tag")), structure("of data stored in ", class = c("TEXT", "tag")), structure(list(structure("humdrum tables", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag")), structure("(held within ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" objects of course).\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("-------------------------------------------&gt; NEEDS DOCUMENTATION &lt;-------------------------------------------\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag")), structure(list(structure("foldXXX", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" family allows you collapse all\n", class = c("TEXT", "tag")), structure(list(structure("user fields", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("across groups in another field.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humSize.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/humdrumR-class.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humSize", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humSize", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("nrecords", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("ntokens", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("npieces", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("anySubcorpora", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("namesSubcorpora", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("nfiles", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("is.empty", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("anyPaths", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("anyStops", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR size and shape", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("nrecords(humdrumR, dataTypes = \"D\")\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("ntokens(humdrumR, dataTypes = \"D\")\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("npieces(humdrumR)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("anySubcorpora(humdrumR)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("namesSubcorpora(humdrumR)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("nfiles(humdrumR)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("length", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(x)\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure(list( structure(list(structure("nrow", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(x)\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("is.empty(humdrumR)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("anyPaths(humdrumR)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("anyStops(humdrumR)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("These functions can be used to quickly\n", class = c("TEXT", "tag")), structure("get basic information about the size and \"shape\" of\n", class = c("TEXT", "tag")), structure("a ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" corpus.\n", class = c("TEXT", "tag")), structure("For more details, use the ", class = c("TEXT", "tag")), structure(list(structure("census", class = c("TEXT", "tag"))), Rd_option = structure("=humSummary", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" function.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(structure("HumdrumR", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" objects can be divided into \"subcorpora.\"\n", class = c("TEXT", "tag")), structure(list(structure("anySubcorpora", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("namesSubcorpora", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" functions tell us if there are any subcorpora and, if so, what they are called.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure("A few common base ", class = c("TEXT", "tag")), structure(list(structure("R", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" methods are defined\n", class = c("TEXT", "tag")), structure("as synonyms for the humdrumR-specific sizing functions:\n", class = c("TEXT", "tag")), structure(list(structure("length(humdata)", class = c("TEXT", "tag"))), Rd_option = structure("base:length", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" is equivalent to ", class = c("TEXT", "tag")), structure(list(structure("npieces(humdata)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(";\n", class = c("TEXT", "tag")), structure(list(structure("nrow(humdata)", class = c("TEXT", "tag"))), Rd_option = structure("base:nrow", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" is shortand for ", class = c("TEXT", "tag")), structure(list(structure("nrecords(., dataTypes = 'LIMDd')", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (i.e., local records only).\n", class = c("TEXT", "tag")), structure(list(structure("ncol(humdata)", class = c("TEXT", "tag"))), Rd_option = structure("base:nrow", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" returns the ", class = c("TEXT", "tag")), structure(list(structure("maximum", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" value of the ", class = c("TEXT", "tag")), structure(list(structure("Column", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" field---the maximum number of\n", class = c("TEXT", "tag")), structure("tab-delineated columns in the humdrum files (irrespective of Spines/Paths).\n", class = c("TEXT", "tag")), structure("The results of ", class = c("TEXT", "tag")), structure(list(structure("nrow", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("ncol", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will match\n", class = c("TEXT", "tag")), structure("up with the dimensions of matrices/data.frames produced by calls to ", class = c("TEXT", "tag")), structure(list(structure("as.matrix/as.data.frame", class = c("TEXT", "tag"))), Rd_option = structure("=as.matrix", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure(list(structure("dim(humdata)", class = c("TEXT", "tag"))), Rd_option = structure("base:dim", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" returns ", class = c("TEXT", "tag")), structure(list(structure("c(nrow(humdata), ncol(humdata))", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", as usual.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(structure("is.empty(humdata)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" asks if ", class = c("TEXT", "tag")), structure(list(structure("ntokens(humdata, dataTypes = 'D') == 0L", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humSpines.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Summary.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humSpines", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humSpines", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("spines", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[.humSpines", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("print.humSpines", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Summarize spines in humdrum dataset", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("spines(humdrumR)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("[", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humSpines", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(spines, i, j)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("print", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humSpines", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(spineTable, showEach = TRUE)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("This function provides summary of the spines and spine paths in the pieces of a humdrumR corpus.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Other humdrum data summary functions: \n", class = c("TEXT", "tag")), structure(list(structure(list(structure("humCensus", class = c("TEXT", "tag"))), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag" )), structure(list(structure(list(structure("humInterpretations", class = c("TEXT", "tag"))), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag" )), structure(list(structure(list(structure("humSummary", class = c("TEXT", "tag"))), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrum data summary functions", class = c("TEXT", "tag"))), class = c("tag_concept", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humSummary.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Summary.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humSummary", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humSummary", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Summarize humdrumR corpora", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure(list(structure(list(structure("summary", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(object, ...)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" includes a number of built in functions for creating quick summaries of ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag")), structure("corpora:\n", class = c("TEXT", "tag" ))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("census", class = c("TEXT", "tag"))), Rd_option = structure("=humCensus", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Tabulates the raw size of the humdrumR corpus.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("reference", class = c("TEXT", "tag"))), Rd_option = structure("=humReference", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Tabulates reference records (metadata) for each file.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("spines", class = c("TEXT", "tag"))), Rd_option = structure("=humSpines", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Tabulates the number of spines and spine paths in files in the corpus.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("interpretations", class = c("TEXT", "tag"))), Rd_option = structure("=humInterpretations", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Tabulates the types of exclusive and tandem interpretations in the corpus.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("sections", class = c("TEXT", "tag"))), Rd_option = structure("=humSections", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Tabulates any formal data (", class = c("TEXT", "tag")), structure(list(structure("*&gt;", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(") in the corpus.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_enumerate", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Each function takes a ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" object and returns a\n", class = c("TEXT", "tag")), structure("special class of data.table.\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag")), structure(list(structure("summary", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" method for ", class = c("TEXT", "tag")), structure(list(structure("humdrumR objects", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" calls all of the above functions and prints a condensed version of each.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Other humdrum data summary functions: \n", class = c("TEXT", "tag")), structure(list(structure(list(structure("humCensus", class = c("TEXT", "tag"))), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag" )), structure(list(structure(list(structure("humInterpretations", class = c("TEXT", "tag"))), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag" )), structure(list(structure(list(structure("humSpines", class = c("TEXT", "tag"))), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrum data summary functions", class = c("TEXT", "tag"))), class = c("tag_concept", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humTable.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/humdrumR-class.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humTable", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humTable", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("getHumtab", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Humdrum Tables", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("getHumtab(humdrumR, dataTypes = c(\"G\", \"L\", \"I\", \"M\", \"D\", \"d\"))\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("dataTypes", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" vector. Specifies which types of data tokens/records to extract.\n", class = c("TEXT", "tag")), structure("See the ", class = c("TEXT", "tag")), structure(list(structure("humTable", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" documentation and/or the humdrum syntax vignette for clarification!\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("For ", class = c("TEXT", "tag")), structure(list(structure("dataTypes", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", values can be:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("\"G\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(": global comments\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("\"L\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(": local comments\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("\"I\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(": interpretations\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("\"M\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(": barlines\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("\"D\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(": non-null data\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("\"d\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(": null data\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Multiple types can be specified as a vector, or smooshed into a single string: e.g., ", class = c("TEXT", "tag")), structure(list(structure("\"GLIMD\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" ))), class = c("tag_arguments", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("In the ", class = c("TEXT", "tag" )), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" package, the fundamental data structure is called a ", class = c("TEXT", "tag")), structure(list(structure("Humdrum Table", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("A humdrum table encodes all the information in a collection of one or more humdrum-syntax files\n", class = c("TEXT", "tag")), structure("as a single ", class = c("TEXT", "tag")), structure(list(structure("data.table", class = c("TEXT", "tag"))), Rd_option = structure("data.table:data.table", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag")), structure("(A ", class = c("TEXT", "tag")), structure(list( structure("data.table", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is an \"enhanced\" version of R's standard ", class = c("TEXT", "tag")), structure(list(structure("data.frame", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(").\n", class = c("TEXT", "tag")), structure("Humdrum tables are stored \"inside\" every ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" object that you will work with, and various ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("functions allow you to study or manipulate the them.\n", class = c("TEXT", "tag")), structure("If you want to directly access the humdrum table within a ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" object, use the ", class = c("TEXT", "tag")), structure(list(structure("getHumtab", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" function.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(structure("getHumtab", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" extracts a ", class = c("TEXT", "tag")), structure(list(structure("humdrum table", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" from a ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" object.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure("In a humdrum table, each row represents a single \"token\"\n", class = c("TEXT", "tag")), structure("in the original humdrum data. Even multistops---tokens separated by spaces---are broken onto\n", class = c("TEXT", "tag")), structure("their own rows. Meanwhile, each column in the humdrum table represents a single\n", class = c("TEXT", "tag")), structure("piece of information associated with each token, which we call a ", class = c("TEXT", "tag")), structure(list(structure("field", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Throughout this documentation, you should keep in mind that a \"token\" refers\n", class = c("TEXT", "tag")), structure("to a ", class = c("TEXT", "tag")), structure(list(structure("row", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" in the humdrum table while a \"field\" refers to a ", class = c("TEXT", "tag")), structure(list(structure("column", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(":\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure(list(structure("Token = Row", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(), class = c("tag_item", "tag" )), structure(" ", class = c("TEXT", "tag")), structure(list(structure(list(structure("Field = Column", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Fields:", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("There are five types of fields in a humdrum table:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Data fields\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Structure fields\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Interpretation fields\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Formal fields\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Reference fields\n", class = c("TEXT", "tag"))), class = c("tag_enumerate", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("When first created by a call to ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" every\n", class = c("TEXT", "tag")), structure("humdrum table has at least nineteen fields: one data field (", class = c("TEXT", "tag")), structure(list(structure("Token", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("), two interpretation\n", class = c("TEXT", "tag")), structure("fields (", class = c("TEXT", "tag")), structure(list(structure("Tandem", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("Exclusive", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("), three formal fields, and fifteen structure fields. Additional\n", class = c("TEXT", "tag")), structure("interpretation or reference fields\n", class = c("TEXT", "tag")), structure("may be present depending on the content of the humdrum file(s), and users can create additional data fields\n", class = c("TEXT", "tag")), structure("by ", class = c("TEXT", "tag" )), structure(list(structure("assigning to the object", class = c("TEXT", "tag"))), Rd_option = structure("=humAssignment", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure(list(structure(list(structure("Data fields:", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Data fields are used to describe individual data points\n", class = c("TEXT", "tag")), structure("in humdrum data (as opposed to groups of points).\n", class = c("TEXT", "tag")), structure("Every humdrum table starts with a data\n", class = c("TEXT", "tag")), structure("field called ", class = c("TEXT", "tag")), structure(list(structure("Token", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(", which\n", class = c("TEXT", "tag")), structure("contains character strings representing the original strings read from the humdrum files.\n", class = c("TEXT", "tag")), structure("Users can create as many additional data fields as they like. Every call to\n", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("---which can also be called using the\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR:humPipe", class = c("TEXT", "tag"))), Rd_option = structure("=\\%hum&gt;\\%", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" piping\n", class = c("TEXT", "tag")), structure("operator---generates one or ", class = c("TEXT", "tag")), structure(list(structure(list(structure("N", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(" new data fields named ", class = c("TEXT", "tag")), structure(list(structure(list(structure("{Pipe1, Pipe2, ..., PipeN}", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure("These fields can be renamed using the ", class = c("TEXT", "tag")), structure(list(structure("$&lt;-", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" operator.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Structure fields:", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Every humdrum table starts with fifteen Structure fields,\n", class = c("TEXT", "tag")), structure("which describe where each data token was \"located\" in the original humdrum data: which file, which spine, which record, etc.\n", class = c("TEXT", "tag")), structure("See the vignette on humdrum syntax to fully understand the terms here.\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("File info", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(":\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Filename", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" The unique name of the humdrum file. This may include an appended path\n", class = c("TEXT", "tag")), structure("if more than one file with the same name were read from different directories (see the ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" docs).\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Filepath", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" The full file name (always includes its full path).\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Label", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" A label specified during the call to ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(", associated with a particular\n", class = c("TEXT", "tag")), structure(list(structure("readHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" \"REpath-pattern.\" If no label was specified, patterns are just labeled ", class = c("TEXT", "tag")), structure(list(structure("\"_n\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", where \"", class = c("TEXT", "tag")), structure(list(structure("n", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\" is the\n", class = c("TEXT", "tag")), structure("number of the pattern. (Labels can also be created when ", class = c("TEXT", "tag")), structure(list(structure("merging two humdrumR objects", class = c("TEXT", "tag"))), Rd_option = structure("=humMerge", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".)\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("File", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("integer", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" A unique number associated with each file (ordered alphabetically, starting from ", class = c("TEXT", "tag")), structure(list(structure("1", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Piece", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("integer", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" A number specifying the number of the ", class = c("TEXT", "tag")), structure(list(structure("piece", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" in the corpus.\n", class = c("TEXT", "tag")), structure("This is identical to the ", class = c("TEXT", "tag")), structure(list(structure("File", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field except when\n", class = c("TEXT", "tag")), structure("more than one piece were read from the same file.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Location info", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(":\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Spine", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("integer", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" The spine, numbered (from left-to-right) starting from ", class = c("TEXT", "tag")), structure(list(structure("1", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" This field is ", class = c("TEXT", "tag")), structure(list(structure("NA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" wherever ", class = c("TEXT", "tag")), structure(list(structure("Global == TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Path", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("integer", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" The \"spine path.\" Any time a ", class = c("TEXT", "tag")), structure(list(structure("*^", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" spine path split occurs in\n", class = c("TEXT", "tag")), structure("the humdrum data, the right side of the split becomes a new \"path.\" The original path\n", class = c("TEXT", "tag")), structure("is numbered ", class = c("TEXT", "tag")), structure(list(structure("0", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" with additional paths numbered with integers to the right.\n", class = c("TEXT", "tag")), structure("(If there are no spine path splits, the ", class = c("TEXT", "tag")), structure(list(structure("Path", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field is all zeros.)\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" This field is always ", class = c("TEXT", "tag")), structure(list(structure("NA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" when ", class = c("TEXT", "tag")), structure(list(structure("Global == TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Read the ", class = c("TEXT", "tag")), structure(list(structure("humdrum columns documentation", class = c("TEXT", "tag"))), Rd_option = structure("=humColumns", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" for a more thorough explanation\n", class = c("TEXT", "tag")), structure("of spine paths.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Column", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("integer", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" The tab-delineated column in the humdrum file---irrespective of Spine/Paths---, numbered starting from ", class = c("TEXT", "tag")), structure(list(structure("1", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" This field is always ", class = c("TEXT", "tag")), structure(list(structure("NA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" when ", class = c("TEXT", "tag")), structure(list(structure("Global == TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" See this ", class = c("TEXT", "tag")), structure(list(structure("explanation of columns in humdrumR", class = c("TEXT", "tag"))), Rd_option = structure("=humColumns", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" ))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Record", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("integer", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" The record (i.e., line) number in the original file.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("NData", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("integer", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" The ", class = c("TEXT", "tag")), structure(list(structure("data", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" record enumeration in the file, starting from ", class = c("TEXT", "tag")), structure(list(structure("1", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Stop", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("integer", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Which token in a multistop token, numbered starting from ", class = c("TEXT", "tag")), structure(list(structure("1", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" In files with no multistops, the ", class = c("TEXT", "tag")), structure(list(structure("Stop", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field is all ", class = c("TEXT", "tag")), structure(list(structure("1", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" This field is always ", class = c("TEXT", "tag")), structure(list(structure("NA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" when ", class = c("TEXT", "tag")), structure(list(structure("Global == TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Global", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("logical", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Did the token come from a global record (as opposed to a local record)?\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" When ", class = c("TEXT", "tag")), structure(list(structure("Global == TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the ", class = c("TEXT", "tag")), structure(list(structure("Spine", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("Column", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", and ", class = c("TEXT", "tag")), structure(list(structure("Stop", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" fields are always ", class = c("TEXT", "tag")), structure(list(structure("NA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Token info", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(":\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Type", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" What type of record is it?\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("\"D\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" = non-null data\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("\"d\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" = null data\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("\"I\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" = interpretation\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("\"M\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" = measure/barline\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("\"L\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" = local comment\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("\"G\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" = global comment.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("\"P\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" = null \"non-tokens\" (see the ", class = c("TEXT", "tag")), structure(list(structure("humdrumR columns", class = c("TEXT", "tag"))), Rd_option = structure("=humColumns", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" documentation for an explanation.)\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Null", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("logical", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Is the ", class = c("TEXT", "tag")), structure(list(structure("active", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumR", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" data field null?\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" See the detailed discussion below, in the section of this documentation called \"Null Data.\"\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Filter", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("logical", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Has this record/token been ", class = c("TEXT", "tag")), structure(list(structure("filtered out", class = c("TEXT", "tag"))), Rd_option = structure("=filterHumdrum", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("?\n", class = c("TEXT", "tag" ))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Interpretation fields:", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Interpretation fields describe interpretation metadata in the humdrum file(s).\n", class = c("TEXT", "tag")), structure("Humdrum interpretations are tokens that \"carry forward\" to data points after them, unless cancelled out by a\n", class = c("TEXT", "tag")), structure("subsequent interpretation. (See the humdrum syntax vignette for a detailed explanation.)\n", class = c("TEXT", "tag")), structure(list(structure("All", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" humdrum data must have an ", class = c("TEXT", "tag")), structure(list(structure("exclusive", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" interpretation\n", class = c("TEXT", "tag")), structure("so humdrum tables always have an ", class = c("TEXT", "tag")), structure(list(structure("Exclusive", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (:: ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") field indicating the\n", class = c("TEXT", "tag")), structure("exclusive interpretation associated with each token/row of the ", class = c("TEXT", "tag")), structure(list(structure("active", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumR", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" field.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Humdrum data may, or may not, include additional ", class = c("TEXT", "tag")), structure(list(structure("tandem", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" interpretations. A universal rule for parsing\n", class = c("TEXT", "tag")), structure("tandem intepretations is impossible, because A) tandem interpretations can \"overwrite\" each other and B)\n", class = c("TEXT", "tag")), structure("users can create their own tandem interpretations. The best we can do in all cases is\n", class = c("TEXT", "tag")), structure("identify ", class = c("TEXT", "tag")), structure(list(structure("all", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" tandem interpretations that have appeared previously in the spine\n", class = c("TEXT", "tag")), structure("(counting most recent first). All these previous interpretations are encoded in a single\n", class = c("TEXT", "tag")), structure("character string in the ", class = c("TEXT", "tag")), structure(list(structure("Tandem", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field.\n", class = c("TEXT", "tag")), structure("If working with non-standard intrepretations, users can parse the ", class = c("TEXT", "tag")), structure(list(structure("Tandem", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field using the\n", class = c("TEXT", "tag")), structure(list(structure("getTandem", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" function.\n", class = c("TEXT", "tag")), structure("If no tandem interpretations occur in a file, the ", class = c("TEXT", "tag")), structure(list(structure("Tandem", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field is full of empty strings (", class = c("TEXT", "tag")), structure(list(structure("\"\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Fortunately, many tandem interpretations are widely used and standardized, and these\n", class = c("TEXT", "tag")), structure("interpretations are known by ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". Recognized interpretations (such as ", class = c("TEXT", "tag")), structure(list(structure("*clefG4", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("*k[b-]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(")\n", class = c("TEXT", "tag")), structure("are automatically parsed into their own fields by a call to ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("See the ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" documentation for more details.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Formal fields:", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Formal fields indicate musical sections, or time windows within\n", class = c("TEXT", "tag")), structure("a piece, including formal designations (\"verse\", \"chorus\", etc.) and measures/bars.\n", class = c("TEXT", "tag")), structure("Humdrum data may or may not include formal metadata fields, indicated by the token ", class = c("TEXT", "tag")), structure(list(structure("\"*&gt;\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Classified formal marks are put into fields matching their name.\n", class = c("TEXT", "tag")), structure("Unclassified formal marks are placed in a field called ", class = c("TEXT", "tag")), structure(list(structure("Formal", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" as a default.\n", class = c("TEXT", "tag")), structure("Nested formal categories are appended with an underscore and a number for each level of descent:\n", class = c("TEXT", "tag")), structure(list(structure("Formal_1, Formal_2, ..., Formal_N", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("If part of a section is not given a name in a lower hierarchical level, the field is simply\n", class = c("TEXT", "tag")), structure("empty (", class = c("TEXT", "tag")), structure(list(structure("\"\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") at that point.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Humdrum data may, or may not, also include barlines (tokens beginning ", class = c("TEXT", "tag")), structure(list(structure("\"=\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag")), structure("Humdrum tables ", class = c("TEXT", "tag")), structure(list(structure("always", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" include three formal fields related to barlines:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Bar", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("integer", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" How many barline records (single or double) have passed before this token?\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" If no ", class = c("TEXT", "tag")), structure(list(structure("\"=\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" tokens occur in a file, ", class = c("TEXT", "tag")), structure(list(structure("Bar", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is all zeros.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Note that this field is independent of whether the barlines are labeled with numbers in the humdrum file!\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("DoubleBar", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("integer", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" How many ", class = c("TEXT", "tag")), structure(list(structure("double", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure("-barline records have passed before this token?\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" If no ", class = c("TEXT", "tag")), structure(list(structure("\"==\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" tokens occur in a file, ", class = c("TEXT", "tag")), structure(list(structure("DoubleBar", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is all zeros.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("BarLabel", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" :: ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Any characters that occur in a barline-token ", class = c("TEXT", "tag")), structure(list(structure("after", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" an initial ", class = c("TEXT", "tag")), structure(list(structure("\"=\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("\"==\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("These include the ", class = c("TEXT", "tag")), structure(list(structure("\"-\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" in the common \"implied barline token ", class = c("TEXT", "tag")), structure(list(structure("\"=-\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag")), structure("repeat tokens (like ", class = c("TEXT", "tag")), structure(list(structure("\"=:||\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("), and also any ", class = c("TEXT", "tag")), structure(list(structure("explicit", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" bar numbers.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Note that the ", class = c("TEXT", "tag")), structure(list(structure("Bar", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field always enumerate ", class = c("TEXT", "tag")), structure(list(structure("every", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" bar record, while\n", class = c("TEXT", "tag")), structure("measure-number labels in humdrum data (which appear in the ", class = c("TEXT", "tag")), structure(list(structure("BarLabel", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field) may\n", class = c("TEXT", "tag")), structure("do weird things like skipping numbers, repeating numbers, or having suffixes (e.g., ", class = c("TEXT", "tag")), structure(list(structure("\"19a\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag")), structure("If no barline tokens appear in the file, ", class = c("TEXT", "tag")), structure(list(structure("BarLabel", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is all empty strings (", class = c("TEXT", "tag")), structure(list(structure("\"\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Reference fields:", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Reference fields describe any ", class = c("TEXT", "tag")), structure(list(structure("Reference Records", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure("\n", class = c("TEXT", "tag")), structure("in the humdrum data. Every reference record (records beginning ", class = c("TEXT", "tag")), structure(list(structure("\"!!!\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") in any\n", class = c("TEXT", "tag")), structure("humdrum file in a corpus read by ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" is parsed into a field named\n", class = c("TEXT", "tag")), structure("by the reference code: ", class = c("TEXT", "tag")), structure(list(structure("\"XXX\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" in ", class = c("TEXT", "tag")), structure(list(structure("\"!!!XXX\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Reference tokens are all identical throughout\n", class = c("TEXT", "tag")), structure("any humdrum piece. If a reference code appears in one file but not another, the field is\n", class = c("TEXT", "tag")), structure(list(structure("NA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" in the file which does not have the code. If no reference records appear in any\n", class = c("TEXT", "tag")), structure("files read by ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(", no reference fields are created.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Examples of common reference records are ", class = c("TEXT", "tag")), structure(list(structure("\"!!!COM:\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (composer) and ", class = c("TEXT", "tag")), structure(list(structure("\"!!!OTL:\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (original title).\n", class = c("TEXT", "tag")), structure("Any humdrum data with these records will end up having ", class = c("TEXT", "tag")), structure(list(structure("COM", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("OTL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" fields in its humdrum table.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag" ))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Null Data:", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("In humdrum syntax, there is no requirement that every spine-path contains data\n", class = c("TEXT", "tag")), structure("in every record. Rather, spines are often padded with ", class = c("TEXT", "tag")), structure(list(structure("null tokens", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("In some cases, entire records may be padded with null tokens.\n", class = c("TEXT", "tag")), structure("Each type of humdrum record uses a different null token:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Intepretation", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(": ", class = c("TEXT", "tag")), structure(list(structure("*", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Comment", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(": ", class = c("TEXT", "tag")), structure(list(structure("!", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Barline", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(": ", class = c("TEXT", "tag")), structure(list(structure("=", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Data", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(": ", class = c("TEXT", "tag")), structure(list(structure(".", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Null tokens in a humdrum table are identified in the logical ", class = c("TEXT", "tag")), structure(list(structure("Null", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field.\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag")), structure(list(structure("Null", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field is set when a humdrum table is created (by ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(") and is updated everytime\n", class = c("TEXT", "tag")), structure("a new ", class = c("TEXT", "tag")), structure(list(structure("active", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumR", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" field is set.\n", class = c("TEXT", "tag")), structure(list(structure("Null", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is set to ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" wherever, either\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" the active field is ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data and the token is a single ", class = c("TEXT", "tag")), structure(list(structure("\".\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("\"!\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("\"=\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", or ", class = c("TEXT", "tag")), structure(list(structure("\"*\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(";\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" the active field is ", class = c("TEXT", "tag")), structure(list(structure("NA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (including ", class = c("TEXT", "tag")), structure(list(structure("NA_character_", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("In parallel to the ", class = c("TEXT", "tag")), structure(list(structure("Null", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field, null ", class = c("TEXT", "tag")), structure(list(structure("data", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" tokens (", class = c("TEXT", "tag")), structure(list(structure("\".\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") are identified as their own record type: ", class = c("TEXT", "tag")), structure(list(structure("\"d\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("All updates/changes to the ", class = c("TEXT", "tag")), structure(list(structure("Null", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field are also propogated to the ", class = c("TEXT", "tag")), structure(list(structure("Type", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field---i.e., setting ", class = c("TEXT", "tag")), structure(list(structure("Type == d", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" wherever\n", class = c("TEXT", "tag")), structure("a data record is ", class = c("TEXT", "tag")), structure(list(structure("Null", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("This is important/useful because ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" routines are, by default, only applied to ", class = c("TEXT", "tag")), structure(list(structure("\"D\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data, ignoring ", class = c("TEXT", "tag")), structure(list(structure("\"d\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Whenever you ", class = c("TEXT", "tag")), structure(list(structure("print", class = c("TEXT", "tag"))), Rd_option = structure("=humPrint", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("export", class = c("TEXT", "tag"))), Rd_option = structure("=writeHumdrum", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" a ", class = c("TEXT", "tag" )), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" object, null data in the active field\n", class = c("TEXT", "tag")), structure("(i.e., ", class = c("TEXT", "tag")), structure(list(structure("Null == TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") print as ", class = c("TEXT", "tag")), structure(list(structure("\".\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Thus, if you are working with numeric data, with ", class = c("TEXT", "tag")), structure(list(structure("NA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" values, these ", class = c("TEXT", "tag")), structure(list(structure("NA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" values will print as ", class = c("TEXT", "tag")), structure(list(structure("\".\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Reshaping:", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Breaking the complex syntax of humdrum data into the \"flat\" structure of a humdrum table, with every single token on one line\n", class = c("TEXT", "tag")), structure("of a ", class = c("TEXT", "tag")), structure(list(structure("data.table", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", makes humdrum data easier to analyze.\n", class = c("TEXT", "tag")), structure("Of course, thanks to the structure fields, we can easily\n", class = c("TEXT", "tag")), structure("regroup and reform the original humdrum data or use the structure of the data (like spines) in our analyses.\n", class = c("TEXT", "tag")), structure("However, in some cases, you might want to work with humdrum data in a different structure or \"shape.\"\n", class = c("TEXT", "tag")), structure("HumdrumR has several options for ", class = c("TEXT", "tag")), structure(list(structure("\"folding\"", class = c("TEXT", "tag"))), Rd_option = structure("=humShape", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" tokens within humdrum tables,\n", class = c("TEXT", "tag")), structure("or otherwise ", class = c("TEXT", "tag")), structure(list(structure("reshaping humdrum data", class = c("TEXT", "tag"))), Rd_option = structure("=humCoercion", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" into data formats/structures you might prefer.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humValidation.Rd = structure(list(structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Validation.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("humValidation", class = c("VERB", "tag" ))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humValidation", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("validateHumdrum", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Validate humdrum files", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("validateHumdrum(\n", class = c("RCODE", "tag")), structure(" ...,\n", class = c("RCODE", "tag" )), structure(" contains = NULL,\n", class = c("RCODE", "tag")), structure(" recursive = FALSE,\n", class = c("RCODE", "tag")), structure(" errorReport.path = NULL\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("recursive", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure(list( structure("logical", class = c("RCODE", "tag" ))), class = c("tag_code", "tag")), structure(". If ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the final part of the search pattern (i.e., the file search)\n", class = c("TEXT", "tag")), structure("is searched for recursively through all sub directories.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("errorReport.path", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure(list( structure("character", class = c("RCODE", "tag" ))), class = c("tag_code", "tag")), structure(". A directory path which, if not ", class = c("TEXT", "tag")), structure(list(structure("NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", an error report is written\n", class = c("TEXT", "tag")), structure("in the file ", class = c("TEXT", "tag")), structure(list(structure("'humdrumR_syntaxErrorReport_date.txt'", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". In addition, all files with errors\n", class = c("TEXT", "tag")), structure("are written to this directory (with ", class = c("TEXT", "tag")), structure(list(structure("'errorMarkup'", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" appended to their names), with\n", class = c("TEXT", "tag")), structure("errors annotated inline.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("patterns", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure(list( structure("character", class = c("RCODE", "tag" ))), class = c("tag_code", "tag")), structure(" vector. Search pattern(s) for identifying files\n", class = c("TEXT", "tag")), structure("(see ", class = c("TEXT", "tag")), structure(list(structure("[readHumdrum][readHumdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(").", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("files", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A list of character strings, each representing a record in a file.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_arguments", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure("This function checks files for violations of the\n", class = c("TEXT", "tag")), structure("humdrum syntax.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humWindows.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Windows.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humWindows", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humWindows", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("windows", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("hop", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("nest", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Applying functions across arbitrary windows.\n", class = c("TEXT", "tag")), structure("----------------------------------------------&gt; NEEDS DOCUMENTATION &lt;----------------------------------------------------", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("windows(\n", class = c("RCODE", "tag")), structure(" df,\n", class = c("RCODE", "tag")), structure(" form,\n", class = c("RCODE", "tag")), structure(" with = list(),\n", class = c("RCODE", "tag")), structure(" ...,\n", class = c("RCODE", "tag")), structure(" start = 1L,\n", class = c("RCODE", "tag")), structure(" end = nrow(df),\n", class = c("RCODE", "tag")), structure(" bounds = \"exclude\"\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("hop(vec, pattern, start = 1L, end = length(vec))\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("nest(vec, open, close, depth = 1)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Applying functions across arbitrary windows.\n", class = c("TEXT", "tag")), structure("----------------------------------------------&gt; NEEDS DOCUMENTATION &lt;----------------------------------------------------\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humdrumDispatch.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Compose.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumDispatch", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumDispatch", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("makeDispatchDF", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("makeHumdrumDispatcher", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("print.humdrumDispatch", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Regular expression method dispatch and function application", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("humdrumDispatch(\n", class = c("RCODE", "tag")), structure(" str,\n", class = c("RCODE", "tag")), structure(" dispatchDF,\n", class = c("RCODE", "tag")), structure(" Exclusive = NULL,\n", class = c("RCODE", "tag")), structure(" multiDispatch = FALSE,\n", class = c("RCODE", "tag")), structure(" ...,\n", class = c("RCODE", "tag")), structure(" outputClass = \"character\"\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("makeDispatchDF(...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("makeHumdrumDispatcher(\n", class = c("RCODE", "tag")), structure(" ...,\n", class = c("RCODE", "tag")), structure(" funcName = \"humdrum-dispatch\",\n", class = c("RCODE", "tag")), structure(" outputClass = \"character\",\n", class = c("RCODE", "tag")), structure(" args = alist()\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure(list( structure(list(structure("print", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humdrumDispatch", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x)\n", class = c("RCODE", "tag" ))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("str", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("The input ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" string, on which dispatch is called.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("dispatchDF", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A data.frame which describes what function should be called for\n", class = c("TEXT", "tag")), structure("which regex input. (See details).", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Exclusive", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("Defaults to ", class = c("TEXT", "tag")), structure(list(structure("NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". If ", class = c("TEXT", "tag")), structure(list(structure("NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", only the regexes are used for dispatch.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("multiDispatch", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure(list( structure("logical", class = c("RCODE", "tag" ))), class = c("tag_code", "tag")), structure(", length 1. If ", class = c("TEXT", "tag")), structure(list(structure("FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (the default) the \"best\" regex/exclusive match\n", class = c("TEXT", "tag")), structure("is dispatched for each Exclusive segment. If ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", differenet functions can be dispatched\n", class = c("TEXT", "tag")), structure("within the same input vector.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("...", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("Arguments to pass to dispatch functions.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("outputClass", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("Character string: the default output class which the function should return.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Generally, to make sense, all dispatched functions should return the same type, which you should explicitly\n", class = c("TEXT", "tag")), structure("indicate with the ", class = c("TEXT", "tag")), structure(list(structure("outputClass", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument.\n", class = c("TEXT", "tag")), structure("Dispatch functions should also be ", class = c("TEXT", "tag")), structure(list(structure("vectorized", class = c("TEXT", "tag"))), Rd_option = structure("base:Vectorize", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".", class = c("TEXT", "tag" ))), class = "tag")), class = c("tag_item", "tag" )), structure("\n", class = c("TEXT", "tag"))), class = c("tag_arguments", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag" )), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("regular-expression method dispatch system", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure("\n", class = c("TEXT", "tag")), structure("is a simple system for making new functions which can by smartly\n", class = c("TEXT", "tag")), structure("applied to a variety of character strings.\n", class = c("TEXT", "tag")), structure("Humdrum dispatch works like normal R method dispatch, but instead of dispatching specific methods\n", class = c("TEXT", "tag")), structure("based on their class (", class = c("TEXT", "tag")), structure(list(structure("integer", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", etc.) it dispatches based on regular expressions.\n", class = c("TEXT", "tag")), structure("In addition, exclusive interpretations can be used to guide dispatch.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Many ", class = c("TEXT", "tag" )), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" functions are in fact, humdrum-dispatch functions: for example, ", class = c("TEXT", "tag")), structure(list(structure(list(structure("tonalInterval.character()", class = c("TEXT", "tag"))), Rd_option = structure("=tonalInterval.character", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("If you call ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval('ee-')", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the function will recognize that the input string is a token in the ", class = c("TEXT", "tag")), structure(list(structure("**kern", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("\n", class = c("TEXT", "tag")), structure("representation, and call the appropriate parser.\n", class = c("TEXT", "tag")), structure("If you instead call ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval('me')", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the function will recognize that the input string is a token in the ", class = c("TEXT", "tag")), structure(list(structure("**solfa", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("\n", class = c("TEXT", "tag")), structure("representation, and call the appropriate parser for that.\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("dispatchDF", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag")), structure(list(structure("dispatchDF", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" must be a ", class = c("TEXT", "tag")), structure(list(structure(list(structure("data.table::data.table()", class = c("TEXT", "tag"))), Rd_option = structure("data.table:data.table", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(" created using the ", class = c("TEXT", "tag")), structure(list(structure("makeDispatchDF", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" function.\n", class = c("TEXT", "tag")), structure(list(structure("makeDispatchDF", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" takes one or more arguments, each a list with three components (ordered, not nameed):\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" A character vector of exclusive interpretations. (Specify ", class = c("TEXT", "tag")), structure(list(structure("\"any\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" if you don't want exclusive dispatch).\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" A regular expression (character string) or a function which can generate a regular expression, which accepts ", class = c("TEXT", "tag")), structure(list(structure("...", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("arguments at the time of dispatch.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" A function to dispatch.\n", class = c("TEXT", "tag"))), class = c("tag_enumerate", "tag")), structure("\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("makeHumdrumDispatcher", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("makeHumdrumDispatcher", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is a function which creates a new function which automatically performs humdrum-dispatch.\n", class = c("TEXT", "tag")), structure("A number of important ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" functions are created with ", class = c("TEXT", "tag")), structure(list(structure("makeHumdrumDispatcher", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(":\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("tonalInterval.character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("diatonicSet.character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("tertianSet.character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("rhythmInterval.character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag")), structure("u &lt;- c('A', 'B', 'CD', 'E', 'F', 'gh', 'L', 'KX')\n", class = c("RCODE", "tag")), structure("l &lt;- c('a', 'b', 'cd', 'e', 'f', 'gh', 'l', 'kx')\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("lowercasefunc &lt;- \\(x) 5L - nchar(x)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdrumDispatch(l, outputClass = 'integer',\n", class = c("RCODE", "tag")), structure(" makeDispatchDF(list('any', '[a-z]+', lowercasefunc),\n", class = c("RCODE", "tag")), structure(" list('any', '[A-Z]+', nchar)))\n", class = c("RCODE", "tag")), structure(" # lowercasefunc will be called on l, nchar on u\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" ))), class = c("tag_examples", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humdrumPitch.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/humdrumR-package.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumPitch", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumPitch", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR and pitch", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumR", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" includes a number of intertwined data structures, and associated functions, for representing and manipulating musical pitch information.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Tonality", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("There are four data types extensively used in ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" to encode/process ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Tonality", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("tonal", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" musical information:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("integers", class = c("TEXT", "tag"))), Rd_option = structure("base:integer", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" --- used to encode \"", class = c("TEXT", "tag")), structure(list(structure("line-of-fifths", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("\" tonal information\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("tonalInterval", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" --- embeds line-of-fifth tonal integers alongside ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Octave", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("octave", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure(list(structure("\"https://en.wikipedia.org/wiki/Cent_(music)\"", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("cent", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" information to encode most tonal pitch representations (solfege, intervals, letternames, etc.)\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("diatonicSet", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" --- combines line-of-fifth tonal integer representations to represent diatonic tonality, including alterations of basic diatonic scale(s).\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("tertianSet", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" --- an extension of ", class = c("TEXT", "tag")), structure(list(structure("diatonicSet", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" used to encode ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Tertian", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("tertian", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" diatonic harmonies.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("For a detailed explanation of the theory and specifics of ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("'s treatment of tonality, see the ", class = c("TEXT", "tag")), structure(list(structure("Tonality in humdrumR", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" vignette.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Atonality", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure("THIS SECTION IS INCOMPLETE", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("In addition, there are xxx data types used to encode non-tonal (or ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Atonality", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("atonal", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(") pitch information.\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("integers", class = c("TEXT", "tag"))), Rd_option = structure("base:integer", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" --- used to encode ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Semitone", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("semitones", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" (as well as ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/MIDI", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("MIDI", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" numbers).\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("xxx", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" --- sets?\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("xxx", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" --- 12-tone rows?\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humdrumR.Rd = structure(list(structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/humdrumR-package.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("package", class = c("TEXT", "tag"))), class = c("tag_docType", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("humdrumR", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("humdrumR", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("humdrumR", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure(list( structure("humdrumR", class = c("RCODE", "tag" ))), class = c("tag_code", "tag")), structure(" is a toolkit for the analysis of data encoded in the ", class = c("TEXT", "tag")), structure(list(structure(list(structure("http://www.humdrum.org/guide/ch05/", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("humdrum syntax", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure("The humdrum syntax is an incredibly flexible, and powerful, scheme for encoding musical data.\n", class = c("TEXT", "tag")), structure("Tens of thousands of musical scores (and other musical data) have been encoded in the humdrum syntax, many available online through repositories such as\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("http://kern.ccarh.org/", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("KernScores", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(".\n", class = c("TEXT", "tag" ))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is intended as a modernized replacement for the original ", class = c("TEXT", "tag")), structure(list(structure(list(structure("http://www.humdrum.org/", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("humdrum toolkit", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag" )), structure(", levaraging\n", class = c("TEXT", "tag" )), structure("the power of R to give us enprecedented power to manipulate and analyze humdrum data using concise, expressive syntax.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Package design", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("The package ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" has XXX main components:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag" )), structure(" To represent humdrum data in R, we have the ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list( structure(list(structure("http://adv-r.had.co.nz/S4.html", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("S4 class", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(", and it's core component\n", class = c("TEXT", "tag")), structure("the ", class = c("TEXT", "tag")), structure(list(structure("humdrum table", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure(list(), class = c("tag_item", "tag" )), structure(" To create ", class = c("TEXT", "tag" )), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data, a sophisticated humdrum data parser: ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data can also be written back to humdrum-syntax text files using ", class = c("TEXT", "tag")), structure(list(structure("writeHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" To filter and \"index\" ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data, we have the ", class = c("TEXT", "tag")), structure(list(structure("filterHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" function, which can also be called in a variety of\n", class = c("TEXT", "tag")), structure("short hands using R's standard ", class = c("TEXT", "tag")), structure(list(structure("indexing operators", class = c("TEXT", "tag"))), Rd_option = structure("base:Extract", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(": ", class = c("TEXT", "tag")), structure(list(structure("[]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("[[]]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" To manipulate and modify ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data, we have the ", class = c("TEXT", "tag")), structure(list(structure("with(in)Humdrum", class = c("TEXT", "tag"))), Rd_option = structure("=with-in-Humdrum", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" and ", class = c("TEXT", "tag" )), structure(list(structure("humApply", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" functions.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" A set of ", class = c("TEXT", "tag")), structure(list(structure("\"pipe\" operators", class = c("TEXT", "tag"))), Rd_option = structure("=humPipe", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" (", class = c("TEXT", "tag")), structure(list(structure("%hum&gt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("%hum&lt;%", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(", etc.), so that ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data can be manipulated and filtered in concise,\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Vertical_bar#Pipe", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("bash-style pipes", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure(list(), class = c("tag_item", "tag" )), structure(" To facilate the development of functions to work with humdrum tokens---which are simple character strings packed with information---,\n", class = c("TEXT", "tag")), structure("a useful API we call our ", class = c("TEXT", "tag")), structure(list(structure("regular-expression dispatch system", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumDispatch", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure(list(), class = c("tag_item", "tag" )), structure(" Several ", class = c("TEXT", "tag" )), structure(list(structure("modules", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumPitch", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" for representing and manipulating musical pitch information,\n", class = c("TEXT", "tag")), structure("including our core ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" class to represent tonal pitch.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" A ", class = c("TEXT", "tag" )), structure(list(structure("module", class = c("TEXT", "tag"))), Rd_option = structure("=humRhythm", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" for representing and manipulating musical rhythm information,\n", class = c("TEXT", "tag")), structure("with a core ", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" class to represent rhythms.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("internal", class = c("TEXT", "tag"))), class = c("tag_keyword", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humdrumRclass.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/humdrumR-class.R, R/Filter.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("class", class = c("TEXT", "tag"))), class = c("tag_docType", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("makeHumdrumR", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumRS4", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("is.humdrumR", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("$,humdrumR-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("fields", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("$&lt;-,humdrumR,vector-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("$&lt;-,humdrumR,humdrumR-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[&lt;-,humdrumR,character,ANY,vector-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[&lt;-,humdrumR,character,ANY,humdrumR-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[[,humdrumR,missing,character-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[[,humdrumR,missing,missing-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[[,humdrumR,formula,missing-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("[[,humdrumR,missing,formula-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("HumdrumR class", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("is.humdrumR(x)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("$", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(x, name)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("fields(\n", class = c("RCODE", "tag" )), structure(" humdrumR,\n", class = c("RCODE", "tag")), structure(" fieldTypes = c(\"Data\", \"Structure\", \"Interpretation\", \"Formal\", \"Reference\")\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure(list( structure(list(structure("$", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humdrumR,vector", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(x, name) &lt;- value\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("$", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humdrumR,humdrumR", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(x, name) &lt;- value\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("[", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humdrumR,character,ANY,vector", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(x, i, j) &lt;- value\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("[", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("humdrumR,character,ANY,humdrumR", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(x, i, j) &lt;- value\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdata[[ , 'regex']]\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdata[[ , , ~expression]] or humdata [[ , , 'regex']] or humdata[[z = ~expression]] or humdata[[z = 'regex']]\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdata[[~expression]]\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humdata[[ , ~expression]]\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("This ", class = c("TEXT", "tag" )), structure(list(structure("S4", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" class is the basic unit of the\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" package.\n", class = c("TEXT", "tag")), structure("Each ", class = c("TEXT", "tag" )), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object represents data ", class = c("TEXT", "tag")), structure(list(structure("read", class = c("TEXT", "tag"))), Rd_option = structure("=readHumdrum", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" from one or\n", class = c("TEXT", "tag")), structure("more humdrum files.\n", class = c("TEXT", "tag")), structure("In the documentation we refer to the collection of files within a ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" object\n", class = c("TEXT", "tag")), structure("as a \"", class = c("TEXT", "tag" )), structure(list(structure("corpus", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(",\" and each file as a \"", class = c("TEXT", "tag")), structure(list(structure("piece", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(".\"\n", class = c("TEXT", "tag")), structure("However, though humdrum data is ", class = c("TEXT", "tag")), structure(list(structure("usually", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" encoded as one \"piece\" per file, this is not necessarily the case:\n", class = c("TEXT", "tag")), structure("files might represent movements within a piece, or even just a part of a score. Still, we tend to refer\n", class = c("TEXT", "tag")), structure("to them as \"pieces.\"\n", class = c("TEXT", "tag")), structure("In coding examples, we name humdrumR objects \"", class = c("TEXT", "tag")), structure(list(structure("humdata", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\"\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("The most imporant part of a ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object is the\n", class = c("TEXT", "tag")), structure(list(structure("humdrum tables", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" it holds within it.\n", class = c("TEXT", "tag")), structure("In essence, an ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object is simply a wrapper around these\n", class = c("TEXT", "tag")), structure("humdrum tables, which helps users to\n", class = c("TEXT", "tag")), structure("to visualize, index, ", class = c("TEXT", "tag")), structure(list(structure("summarize", class = c("TEXT", "tag"))), Rd_option = structure("=humSummary", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(", and ", class = c("TEXT", "tag" )), structure(list(structure("manipulate", class = c("TEXT", "tag"))), Rd_option = structure("=withinHumdrum", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag")), structure("the table in a variety of ways.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Basic information about the size and shape of ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data can be\n", class = c("TEXT", "tag")), structure("obtained with calls to ", class = c("TEXT", "tag")), structure(list(structure("nrecords, npieces, length, ncol, etc.", class = c("TEXT", "tag"))), Rd_option = structure("=humSize", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure("More detailed summary information can be obtained with the humdrumR ", class = c("TEXT", "tag")), structure(list(structure("corpus summary functions", class = c("TEXT", "tag"))), Rd_option = structure("=humSummary", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure("HumdrumR data can also be coerced to more basic R data types using ", class = c("TEXT", "tag")), structure(list(structure("as.matrix, as.data.frame, etc.", class = c("TEXT", "tag"))), Rd_option = structure("=humCoercion", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure("A number of helpful functions are also defined to ", class = c("TEXT", "tag")), structure(list(structure("reshape", class = c("TEXT", "tag"))), Rd_option = structure("=humShape", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" humdrumR data.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("The most powerful features of ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" are the tools it gives you to\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Filter humdrum data, using ", class = c("TEXT", "tag")), structure(list(structure("filterHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" and the standard R ", class = c("TEXT", "tag")), structure(list(structure("indexing operators", class = c("TEXT", "tag"))), Rd_option = structure("base:Extract", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(": ", class = c("TEXT", "tag" )), structure(list(structure("[]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("[[]]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Apply functions and arbitrary commands to humdrum data using the ", class = c("TEXT", "tag")), structure(list(structure("with(in)Humdrum", class = c("TEXT", "tag"))), Rd_option = structure("=withinHumdrum", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" routines,\n", class = c("TEXT", "tag")), structure("and their associated ", class = c("TEXT", "tag")), structure(list(structure("piping operators", class = c("TEXT", "tag"))), Rd_option = structure("=humPipe", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" ))), class = c("tag_enumerate", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Slots", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure(list( structure("Humtable", class = c("RCODE", "tag" ))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("A list of ", class = c("TEXT", "tag")), structure(list(structure("humdrum tables", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(", each having the same fields\n", class = c("TEXT", "tag")), structure("but containing data from different types of records (e.g., interpretations, data, barlines, comments).", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure(list( structure("Files", class = c("RCODE", "tag" ))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("A list of two elements. The first, \"Search\", contains a single character representing\n", class = c("TEXT", "tag")), structure("the ", class = c("TEXT", "tag")), structure(list(structure("pattern", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" used in the call to ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" which created this humdrumR object.\n", class = c("TEXT", "tag")), structure("The second, \"Names\", is a vector of strings representing all the files which matched the ", class = c("TEXT", "tag")), structure(list(structure("pattern", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("and were read into the ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure(list( structure("Fields", class = c("RCODE", "tag" ))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("A list containing strings corresponding to the existing fields in the ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object.\n", class = c("TEXT", "tag")), structure("The fields are divided into five categories: \"Data\", \"Structure\", \"Interpretation\", \"Formal\", and \"Reference\"---see\n", class = c("TEXT", "tag")), structure("the ", class = c("TEXT", "tag")), structure(list(structure("humdrum table", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" documentation.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure(list( structure("Active", class = c("RCODE", "tag" ))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("A quosure expression which\n", class = c("TEXT", "tag")), structure("extracts data from field(s) in the ", class = c("TEXT", "tag")), structure(list(structure("humdrum table", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(": the \"active expression.\"", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure(list( structure("LoadTime", class = c("RCODE", "tag"))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("A ", class = c("TEXT", "tag")), structure(list(structure("POSIXct", class = c("TEXT", "tag"))), Rd_option = structure("base:DateTimeClasses", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" value, indicating the time at which ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" was\n", class = c("TEXT", "tag" )), structure("called to create this ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure(list( structure("Patterns", class = c("RCODE", "tag"))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("A character vector of the original search patterns used to match files in the system.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_describe", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Active field", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag")), structure(list(structure("Active", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" slot of a ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" object contains an ", class = c("TEXT", "tag")), structure(list(structure("expression", class = c("TEXT", "tag"))), Rd_option = structure("rlang:quosure", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag")), structure("which refers to fields in the internal ", class = c("TEXT", "tag")), structure(list(structure("humdrum table", class = c("TEXT", "tag"))), Rd_option = structure("=humTable", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Go to the dedicated ", class = c("TEXT", "tag")), structure(list(structure("active field", class = c("TEXT", "tag"))), Rd_option = structure("=humActive", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" documentation to learn more about this important slot!\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), humdrumRroot.Rd = structure(list(structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/humdrumR-package.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("data", class = c("TEXT", "tag"))), class = c("tag_docType", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("humdrumRroot", class = c("VERB", "tag" ))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumRroot", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("'s root directory on your machine.", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("An object of class ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" of length 1.\n", class = c("TEXT", "tag"))), class = c("tag_format", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("humdrumRroot\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumRroot", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is the path to where the ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" package is install on your machine.\n", class = c("TEXT", "tag")), structure("A few simple humdrum files are stored here.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("datasets", class = c("TEXT", "tag"))), class = c("tag_keyword", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), interpolateArguments.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Apply.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("interpolateArguments", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("interpolateArguments", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Change or insert values in an expression", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("interpolateArguments(quo, namedArgs)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("namedArgs", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A list of named arguments. Unnamed arguments are simply ignored.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("expr", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A unevaluated expression object.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" ))), class = c("tag_arguments", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("This function can be used to modify arguments to a functions\n", class = c("TEXT", "tag")), structure("within an existing expression (or quosure/formula).\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("interpolateArguments", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" inteprets named value in its ", class = c("TEXT", "tag")), structure(list(structure("namedArgs", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("argument in one of two ways: If the named value is a list, it interprets\n", class = c("TEXT", "tag")), structure("the name of the list as a function call, and inserts/swaps any arguments\n", class = c("TEXT", "tag")), structure("in that list into any instances of that function call within the ", class = c("TEXT", "tag")), structure(list(structure("expr", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Named arguments are inserted or substituted if already present in expression.\n", class = c("TEXT", "tag")), structure("Unnamed argmuments are simply added to the call.\n", class = c("TEXT", "tag")), structure("Examples:", class = c("TEXT", "tag")), structure(list(structure("myexpr &lt;- quote(dnorm(x, mean = 5))\n", class = c("VERB", "tag")), structure("interpolateArguments(myexpr, list(dnorm = list(mean = 2, sd = 5, TRUE)))\n", class = c("VERB", "tag")), structure("\n", class = c("VERB", "tag")), structure("# result is new expresson: dnorm(x, mean = 2, sd = 5, TRUE)\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("If a named valued in the ", class = c("TEXT", "tag")), structure(list(structure("namedArgs", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument is not a list,\n", class = c("TEXT", "tag")), structure("that name/value pair is substituted anywhere it is present in the expression.\n", class = c("TEXT", "tag")), structure("This approach is often more conscise, but arguments cannot be added to an\n", class = c("TEXT", "tag")), structure("expression this way, only substituted if already present.\n", class = c("TEXT", "tag")), structure("Examples:", class = c("TEXT", "tag")), structure(list(structure("myexpr &lt;- quote(dnorm(x, mean = 5))\n", class = c("VERB", "tag")), structure("interpolateArguments(myexpr, mean = 2)\n", class = c("VERB", "tag")), structure("\n", class = c("VERB", "tag")), structure("# result is new expression: dnorm(x, mean = 2)\n", class = c("VERB", "tag")), structure("}\n", class = c("VERB", "tag" ))), class = c("tag_preformatted", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("myexpr2 &lt;- quote(A + b*x + rnorm(length(a), mean(Z), sd = 2))\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("interpolateArguments(myexpr2,\n", class = c("RCODE", "tag")), structure(" list(sd = 10, mean = list(na.rm = TRUE)))\n", class = c("RCODE", "tag")), structure(" \n", class = c("RCODE", "tag")), structure("# result is new expression: \n", class = c("RCODE", "tag")), structure("# a + b*x + rnorm(length(a), mean(Z, na.rm = TRUE), sd = 10)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag"))), class = c("tag_examples", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), intervalCalculus.Rd = structure(list(structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/tools.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("intervalCalculus", class = c("VERB", "tag" ))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("intervalCalculus", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("integrate", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("sigma", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("derive", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("delta", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("calculus", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Interval \"calculus\"", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("integrate(intervals, skip = list(is.na))\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag")), structure("sigma(intervals, skip = list(is.na))\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("derive(intervals, skip = list(is.na))\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("delta(intervals, skip = list(is.na))\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("calculus(x, n, skip = list(na))\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Interval \"calculus\"\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), keyTransformer.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/diatonicSet.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("keyTransformer", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("keyTransformer", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("key", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Parsing and deparsing key information", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("key(x, ..., Key = NULL, parseArgs = list(), memoize = TRUE, deparse = TRUE)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("XXX\n", class = c("TEXT", "tag" ))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), lag.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/tools.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("lag", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("lag", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("lead", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Shift data within a vector/matrix/data.frame", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("lag(x, n = 1, fill = NA, wrap = FALSE, windows = NULL, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("lead(x, n, ...)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("x", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("The input argument. Should be vector (including lists), array, or data.frame", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("n", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("The amount to lag/lead the data.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("fill", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("If ", class = c("TEXT", "tag")), structure(list(structure("wrap = FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and/or ", class = c("TEXT", "tag")), structure(list(structure("windows = NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", parts of the output are padded with the ", class = c("TEXT", "tag")), structure(list(structure("fill", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument. Defaults to ", class = c("TEXT", "tag")), structure(list(structure("NA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("wrap", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("If ", class = c("TEXT", "tag")), structure(list(structure("wrap = TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", data from the end (head or tail) is copied to the other end of the output, \"wrapping\" the data\n", class = c("TEXT", "tag")), structure("within the data structure.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("windows", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A vector or list of vectors, all of th same length as ", class = c("TEXT", "tag")), structure(list(structure("x", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". Lags crossing the boundaries indicated in ", class = c("TEXT", "tag")), structure(list(structure("windows", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("are filled.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("margin", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("Arrays and data.frames can be lagged lead in multiple dimensions using the ", class = c("TEXT", "tag")), structure(list(structure("margin", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" ))), class = c("tag_arguments", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag" )), structure(list(structure("lag", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("lead", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" functions take input vectors, matrices, or data.frames and shifts their data\n", class = c("TEXT", "tag")), structure("by ", class = c("TEXT", "tag" )), structure(list(structure("n", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" indices.\n", class = c("TEXT", "tag")), structure("They are similiar to the ", class = c("TEXT", "tag")), structure(list(structure("data.table::shift", class = c("TEXT", "tag"))), Rd_option = structure("data.table:shift", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" function, but with a few additional options:\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("data.table::shift()", class = c("TEXT", "tag"))), Rd_option = structure("data.table:shift", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), metricPosition.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/rhythmInterval.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("metricPosition", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("metricPosition", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Calculate metric positions from duration data.", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("metricPosition(rints, bars = NULL, beats = rint(c(2, 4, 8, 16, 32)))\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Calculate metric positions from duration data.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Other rhythm analysis tools: \n", class = c("TEXT", "tag")), structure(list(structure(list(structure("rhythmDecompose", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("()", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("rhythmOffset", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("()", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythm analysis tools", class = c("TEXT", "tag"))), class = c("tag_concept", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), pitchFunctions.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/tonalInterval.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("pitchFunctions", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("pitchFunctions", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("semit", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("midi", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("pitch", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("kern", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("lilypond", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("interval", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("degree", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("solfa", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Manipulate pitch data", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("semit(\n", class = c("RCODE", "tag")), structure(" x,\n", class = c("RCODE", "tag" )), structure(" ...,\n", class = c("RCODE", "tag" )), structure(" Key = NULL,\n", class = c("RCODE", "tag")), structure(" Exclusive = NULL,\n", class = c("RCODE", "tag")), structure(" parseArgs = list(),\n", class = c("RCODE", "tag")), structure(" transposeArgs = list(),\n", class = c("RCODE", "tag")), structure(" inPlace = FALSE,\n", class = c("RCODE", "tag")), structure(" memoize = TRUE,\n", class = c("RCODE", "tag")), structure(" deparse = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("midi(\n", class = c("RCODE", "tag")), structure(" x,\n", class = c("RCODE", "tag" )), structure(" ...,\n", class = c("RCODE", "tag" )), structure(" Key = NULL,\n", class = c("RCODE", "tag")), structure(" Exclusive = NULL,\n", class = c("RCODE", "tag")), structure(" parseArgs = list(),\n", class = c("RCODE", "tag")), structure(" transposeArgs = list(),\n", class = c("RCODE", "tag")), structure(" inPlace = FALSE,\n", class = c("RCODE", "tag")), structure(" memoize = TRUE,\n", class = c("RCODE", "tag")), structure(" deparse = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("pitch(\n", class = c("RCODE", "tag")), structure(" x,\n", class = c("RCODE", "tag" )), structure(" ...,\n", class = c("RCODE", "tag" )), structure(" Key = NULL,\n", class = c("RCODE", "tag")), structure(" Exclusive = NULL,\n", class = c("RCODE", "tag")), structure(" parseArgs = list(),\n", class = c("RCODE", "tag")), structure(" transposeArgs = list(),\n", class = c("RCODE", "tag")), structure(" inPlace = FALSE,\n", class = c("RCODE", "tag")), structure(" memoize = TRUE,\n", class = c("RCODE", "tag")), structure(" deparse = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("kern(\n", class = c("RCODE", "tag")), structure(" x,\n", class = c("RCODE", "tag" )), structure(" ...,\n", class = c("RCODE", "tag" )), structure(" Key = NULL,\n", class = c("RCODE", "tag")), structure(" Exclusive = NULL,\n", class = c("RCODE", "tag")), structure(" parseArgs = list(),\n", class = c("RCODE", "tag")), structure(" transposeArgs = list(),\n", class = c("RCODE", "tag")), structure(" inPlace = FALSE,\n", class = c("RCODE", "tag")), structure(" memoize = TRUE,\n", class = c("RCODE", "tag")), structure(" deparse = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("lilypond(\n", class = c("RCODE", "tag")), structure(" x,\n", class = c("RCODE", "tag" )), structure(" ...,\n", class = c("RCODE", "tag" )), structure(" Key = NULL,\n", class = c("RCODE", "tag")), structure(" Exclusive = NULL,\n", class = c("RCODE", "tag")), structure(" parseArgs = list(),\n", class = c("RCODE", "tag")), structure(" transposeArgs = list(),\n", class = c("RCODE", "tag")), structure(" inPlace = FALSE,\n", class = c("RCODE", "tag")), structure(" memoize = TRUE,\n", class = c("RCODE", "tag")), structure(" deparse = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("interval(\n", class = c("RCODE", "tag")), structure(" x,\n", class = c("RCODE", "tag" )), structure(" ...,\n", class = c("RCODE", "tag" )), structure(" Key = NULL,\n", class = c("RCODE", "tag")), structure(" Exclusive = NULL,\n", class = c("RCODE", "tag")), structure(" parseArgs = list(),\n", class = c("RCODE", "tag")), structure(" transposeArgs = list(),\n", class = c("RCODE", "tag")), structure(" inPlace = FALSE,\n", class = c("RCODE", "tag")), structure(" memoize = TRUE,\n", class = c("RCODE", "tag")), structure(" deparse = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("degree(\n", class = c("RCODE", "tag")), structure(" x,\n", class = c("RCODE", "tag" )), structure(" ...,\n", class = c("RCODE", "tag" )), structure(" Key = NULL,\n", class = c("RCODE", "tag")), structure(" Exclusive = NULL,\n", class = c("RCODE", "tag")), structure(" parseArgs = list(),\n", class = c("RCODE", "tag")), structure(" transposeArgs = list(),\n", class = c("RCODE", "tag")), structure(" inPlace = FALSE,\n", class = c("RCODE", "tag")), structure(" memoize = TRUE,\n", class = c("RCODE", "tag")), structure(" deparse = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("solfa(\n", class = c("RCODE", "tag")), structure(" x,\n", class = c("RCODE", "tag" )), structure(" ...,\n", class = c("RCODE", "tag" )), structure(" Key = NULL,\n", class = c("RCODE", "tag")), structure(" Exclusive = NULL,\n", class = c("RCODE", "tag")), structure(" parseArgs = list(),\n", class = c("RCODE", "tag")), structure(" transposeArgs = list(),\n", class = c("RCODE", "tag")), structure(" inPlace = FALSE,\n", class = c("RCODE", "tag")), structure(" memoize = TRUE,\n", class = c("RCODE", "tag")), structure(" deparse = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" ))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Manipulate pitch data\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("tonalInterval\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), plotRhythm.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Graphics.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("plotRhythm", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("plotRhythm", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("plotRhythm.default", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("plotRhythm.rhythmInterval", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("-------------------------------------------&gt; NEEDS DOCUMENTATION &lt;-------------------------------------------\n", class = c("TEXT", "tag")), structure("Plotting rhythmic symbols in R base graphics", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("plotRhythm(x, y, notes, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("plotRhythm", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("default", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x, y, notes, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("plotRhythm", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x, y, notes, ...)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("-------------------------------------------&gt; NEEDS DOCUMENTATION &lt;-------------------------------------------\n", class = c("TEXT", "tag")), structure("Plotting rhythmic symbols in R base graphics\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), rational.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/tools.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rational", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rational", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("as.rational", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("fraction", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("as.fraction", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Rational numbers", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("rational(numerator, denominator = 1)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("as.rational(x, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("fraction(numerator, denominator, sep = \"/\")\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("as.fraction(x, sep, ...)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("R has no built in rational number representation; ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" defines one.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("as.decimal()", class = c("TEXT", "tag"))), Rd_option = structure("=as.decimal", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure(list(structure("as.numeric()", class = c("TEXT", "tag"))), Rd_option = structure("=as.numeric", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Other ", class = c("TEXT", "tag")), structure(list(structure("humdrumR numeric functions", class = c("TEXT", "tag"))), class = c("LIST", "tag")), structure(": \n", class = c("TEXT", "tag")), structure(list(structure(list(structure("decimal", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("()", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("humdrumR numeric functions", class = c("TEXT", "tag"))), class = c("LIST", "tag"))), class = c("tag_concept", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), readHumdrum.Rd = structure(list(structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Read.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("readHumdrum", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("readHumdrum", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("findHumdrum", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("Find and read humdrum files into R", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("findHumdrum(\n", class = c("RCODE", "tag")), structure(" ...,\n", class = c("RCODE", "tag" )), structure(" contains = NULL,\n", class = c("RCODE", "tag")), structure(" recursive = FALSE,\n", class = c("RCODE", "tag")), structure(" allowDuplicates = FALSE,\n", class = c("RCODE", "tag")), structure(" verbose = FALSE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag")), structure("readHumdrum(\n", class = c("RCODE", "tag")), structure(" ...,\n", class = c("RCODE", "tag")), structure(" recursive = FALSE,\n", class = c("RCODE", "tag")), structure(" contains = NULL,\n", class = c("RCODE", "tag")), structure(" allowDuplicates = FALSE,\n", class = c("RCODE", "tag")), structure(" verbose = FALSE,\n", class = c("RCODE", "tag")), structure(" tandems = \"known\",\n", class = c("RCODE", "tag")), structure(" reference = \"all\"\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" ))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("...", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("character: One or more patterns used to identify files to read.\n", class = c("TEXT", "tag")), structure("For details: see the \"REpath-patterns\" section below.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("contains", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure(list( structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". If ", class = c("TEXT", "tag")), structure(list(structure("!is.null(contains)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the ", class = c("TEXT", "tag")), structure(list(structure("contains", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument is\n", class = c("TEXT", "tag")), structure("is treated as regular expressions: only files which contain matches to\n", class = c("TEXT", "tag")), structure(list(structure("all", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" of these regular expressions are read.\n", class = c("TEXT", "tag")), structure("Thus, ", class = c("TEXT", "tag" )), structure(list(structure("readHumdrum('.*krn$', contains = \"EEE\")", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will only read kern files which contain matches\n", class = c("TEXT", "tag")), structure("to ", class = c("TEXT", "tag" )), structure(list(structure("\"EE\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("---which is kern for the E two octaves below middle C (or lower).", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("recursive", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("logical: If ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the final part of the search pattern (i.e., the file search) is searched for\n", class = c("TEXT", "tag")), structure("recursively through all sub directories.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("allowDuplicates", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure(list( structure("logical", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" of length one, indicating what should happen if multiple search patterns match the same files.\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag")), structure(list(structure("allowDuplicates = TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag")), structure("any such files are read multiple times, grouped into their respective corpora by the ", class = c("TEXT", "tag")), structure(list(structure("Label", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field.\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag" )), structure(list(structure("allowDuplicates = FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", any redundant files are only read into the corpus of the first pattern they\n", class = c("TEXT", "tag")), structure("match.", class = c("TEXT", "tag" ))), class = "tag")), class = c("tag_item", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("verbose", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("logical: If ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the names of matching files are printed before parsing begins. This is very\n", class = c("TEXT", "tag")), structure("useful as a check to make sure you aren't reading the wrong files!", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("tandems", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure(list( structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". This argument controls which, if any, tandem interpretations\n", class = c("TEXT", "tag")), structure("are parsed into their own fields. The default value is ", class = c("TEXT", "tag")), structure(list(structure("\"known\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("reference", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure(list( structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". This argument controls which, if any, reference records\n", class = c("TEXT", "tag")), structure("are parsed into their own fields. The default value is ", class = c("TEXT", "tag")), structure(list(structure("\"all\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag" )), structure("\n", class = c("TEXT", "tag"))), class = c("tag_arguments", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure("These functions find valid humdrum files on your local machine and read them into ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("findHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" does the work of finding and reading the text files into R.\n", class = c("TEXT", "tag")), structure(list(structure("readHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" utilizes ", class = c("TEXT", "tag")), structure(list(structure("findHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" to read files, then parses them to\n", class = c("TEXT", "tag")), structure("create a ", class = c("TEXT", "tag" )), structure(list(structure("humTable", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" and build\n", class = c("TEXT", "tag")), structure("a ", class = c("TEXT", "tag")), structure(list( structure("humdrumR", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumRclass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" data object around the table.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("REpath-patterns", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\"REpath-patterns\" are specified using ", class = c("TEXT", "tag")), structure(list(structure("...", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" arguments.\n", class = c("TEXT", "tag")), structure("In combination, all the ", class = c("TEXT", "tag")), structure(list(structure("...", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" arguments are used to search for file paths.\n", class = c("TEXT", "tag")), structure("Each part of the search path you specify (", class = c("TEXT", "tag")), structure(list(structure("\"dirpart/dirpart/filepart\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", etc) are matched as regular expressions\n", class = c("TEXT", "tag")), structure("against directories/files on your disc.\n", class = c("TEXT", "tag")), structure("Thus, we can say things like ", class = c("TEXT", "tag")), structure(list(structure("findHumdrum(\"../^A.*/.*krn$\")", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", which would\n", class = c("TEXT", "tag")), structure("match any kern files in any directory beginning with a capital ", class = c("TEXT", "tag")), structure(list(structure("\"A\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" in the\n", class = c("TEXT", "tag")), structure("directory above the current working directory.\n", class = c("TEXT", "tag")), structure("For conveniance, you can break the path across multiple arguments instead of using delimited strings: For example, the code\n", class = c("TEXT", "tag")), structure(list(structure("findHumdrum(\"..\", \"^A.*\", \".*krn$\")", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will give an identical result as the previous example\n", class = c("TEXT", "tag")), structure("(", class = c("TEXT", "tag")), structure(list( structure("findHumdrum(\"../^A.*/,*krn$\")", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag")), structure("This is useful when searching for more than one pattern (see next paragraph) in the same directory.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("If you want to search for ", class = c("TEXT", "tag")), structure(list(structure("more than one", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" pattern, you can input them as a character vector:\n", class = c("TEXT", "tag")), structure("For instance, ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum(c(\"mozart\", \"beethoven\")", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("---this command will search for\n", class = c("TEXT", "tag")), structure("filenames containing \"mozart\" OR \"beethoven.\"\n", class = c("TEXT", "tag")), structure("This works for directories too: ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum(c(\"Mozart\", \"Beethoven\"), \".*krn$\")", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will\n", class = c("TEXT", "tag")), structure("look for any kern files in directories containing \"Mozart\" OR \"Beethoven.\"\n", class = c("TEXT", "tag")), structure("If patterns are named, these names will show up as identifying patterns in the ", class = c("TEXT", "tag")), structure(list(structure("[humdrumR][humdrumR]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" object's\n", class = c("TEXT", "tag")), structure(list(structure("Label", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field. Unnamed patterns are simply labeled with numbers.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Normal (system appropriate) conventions (i.e., directories separated by ", class = c("TEXT", "tag")), structure(list(structure("\"/\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag")), structure(list(structure("'~'", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" at beginning to indicate home, ", class = c("TEXT", "tag")), structure(list(structure("\"..\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" to indicate directory above working directory, etc.)\n", class = c("TEXT", "tag")), structure("are followed.\n", class = c("TEXT", "tag")), structure("If a pattern contains a solo dot followed by a file sep---e.g., ", class = c("TEXT", "tag")), structure(list(structure("\"./\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("\"x/./y\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("---this is\n", class = c("TEXT", "tag")), structure("treated as the current directory, not a regular expression.\n", class = c("TEXT", "tag")), structure("If a pattern contains two dots---e.g., ", class = c("TEXT", "tag")), structure(list(structure("\"../\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("---this is treated as the directory above, not a regular expression.\n", class = c("TEXT", "tag")), structure("If you want to create a regular expression to match any directory, use ", class = c("TEXT", "tag")), structure(list(structure("\".*/\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("The regex pattern ", class = c("TEXT", "tag")), structure(list(structure("\"\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" matches any file (it is changed to ", class = c("TEXT", "tag")), structure(list(structure("\".*\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("). If you don't specifiy any ", class = c("TEXT", "tag")), structure(list(structure("...", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument,\n", class = c("TEXT", "tag")), structure(list(structure("findHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (or ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") will default to ", class = c("TEXT", "tag")), structure(list(structure("\".*\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" as well.\n", class = c("TEXT", "tag")), structure("Thus, ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum()", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will read any humdrum files in the working directory.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("(If two or more files in different directories share the same name, a unique name is created for\n", class = c("TEXT", "tag")), structure("each file by appending the names of the directories they occupy, recursively\n", class = c("TEXT", "tag")), structure("until the names are unique.)\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("If a single humdrum file has multiple pieces in it---meaning that all spine paths close with ", class = c("TEXT", "tag")), structure(list(structure("*-", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(", then\n", class = c("TEXT", "tag")), structure("open again with ", class = c("TEXT", "tag")), structure(list(structure("**", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("---then they are parsed separetely.\n", class = c("TEXT", "tag")), structure("They are distinguished in the ", class = c("TEXT", "tag")), structure(list(structure("Piece", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field.\n", class = c("TEXT", "tag")), structure("If there are no multi-piece files, ", class = c("TEXT", "tag")), structure(list(structure("Piece", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("File", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will be identical.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Validity", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("findHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" automatically ignore non-text files.\n", class = c("TEXT", "tag")), structure("Whatsmore, any files which contain humdrum syntax errors (checked by ", class = c("TEXT", "tag")), structure(list(structure("[validateHumdrum][validateHumdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(") are automatically\n", class = c("TEXT", "tag")), structure("skipped. If you want to see specifically what errors occured, call ", class = c("TEXT", "tag")), structure(list(structure("[validateHumdrum][validateHumdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("\n", class = c("TEXT", "tag")), structure("directly and its ", class = c("TEXT", "tag")), structure(list(structure("errorReport.path", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Tandem Interpretations", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag")), structure(list(structure("tandems", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument controls which tandem interpretations\n", class = c("TEXT", "tag")), structure("parsed into their own fields. This can be helpful to either save processing time and memory\n", class = c("TEXT", "tag")), structure("by ", class = c("TEXT", "tag" )), structure(list(structure("not", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" parsing interpretations you won't need, or to parse interpretations that\n", class = c("TEXT", "tag")), structure("humdrumR doesn't recognize.\n", class = c("TEXT", "tag")), structure("The \"known\" tandem interpretations that humdrumR recognizes are encoded in a build humdrumR\n", class = c("TEXT", "tag")), structure("table called ", class = c("TEXT", "tag")), structure(list(structure("knownInterpretations", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Each interpretation has a humdrumR name (\"Clef\", \"TimeSignature\", etc.) as well as a regular expression\n", class = c("TEXT", "tag")), structure("associated with it.\n", class = c("TEXT", "tag")), structure("The default value for the ", class = c("TEXT", "tag")), structure(list(structure("tandems", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument is ", class = c("TEXT", "tag")), structure(list(structure("\"known\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". If the ", class = c("TEXT", "tag")), structure(list(structure("tandems", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument\n", class = c("TEXT", "tag")), structure("contains ", class = c("TEXT", "tag")), structure(list(structure("\"known\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("all", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" tandem interpretations in the built-in ", class = c("TEXT", "tag")), structure(list(structure("knownInterpretations", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("table are parsed.\n", class = c("TEXT", "tag")), structure("Users may specify different interpretations to parse in two ways:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" character strings\n", class = c("TEXT", "tag")), structure("matching one of the name values from the ", class = c("TEXT", "tag")), structure(list(structure("Name", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" column of ", class = c("TEXT", "tag")), structure(list(structure("knownInterpretations", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("For instance, if you specify ", class = c("TEXT", "tag")), structure(list(structure("tandems = c('Clef', 'TimeSignature')", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", only clef (e.g., ", class = c("TEXT", "tag")), structure(list(structure("\"*clefG2\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("),\n", class = c("TEXT", "tag")), structure("and time signature (e.g., ", class = c("TEXT", "tag")), structure(list(structure("\"*M3/4\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") intepretations will be parsed.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" if the chracter string(s) in ", class = c("TEXT", "tag")), structure(list(structure("tandem", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" do not exactly match one of the names in\n", class = c("TEXT", "tag")), structure(list(structure("knownInterpretations$Name", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", they are treated as regular expressions and used to match\n", class = c("TEXT", "tag")), structure("tandem interpretations in the data. This allows users to parse non-standard tandem interpretations\n", class = c("TEXT", "tag")), structure("that humdrumR doesn't already know about.\n", class = c("TEXT", "tag"))), class = c("tag_enumerate", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("If any values in ", class = c("TEXT", "tag")), structure(list(structure("tandems", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" are named, these names will be used for resulting fields.\n", class = c("TEXT", "tag")), structure("If no matches to an given interpretation are found, no field is created for that interpretation.\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag" )), structure(list(structure("tandems = NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", then no tandem interpretations are parsed.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Reference Records", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("By default (", class = c("TEXT", "tag")), structure(list(structure("reference = \"all\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("), humdrumR reads all reference records in the data.\n", class = c("TEXT", "tag")), structure("The reference code for each record (e.g, the \"OTL\", in \"!!!OTL: xxx\") is used as the name of\n", class = c("TEXT", "tag")), structure("an associated field.\n", class = c("TEXT", "tag")), structure("(If a reference record has no reference code (i.e., it lacks a colon), the field is called \"Unkeyed.\")\n", class = c("TEXT", "tag")), structure("In large datasets with many reference records, the reference data can actually make up a large portion\n", class = c("TEXT", "tag")), structure("of the humdrum table, and eat up a lot of memory. In these cases, we might not want to read\n", class = c("TEXT", "tag")), structure("all (or any) reference records---we can instead read only the reference records that we are planning to use\n", class = c("TEXT", "tag")), structure("in our analyses (if any).\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag")), structure(list(structure("reference = NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", no reference records are parsed.\n", class = c("TEXT", "tag")), structure("Otherwise, the character values of ", class = c("TEXT", "tag")), structure(list(structure("reference", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" are treated as reference codes and only\n", class = c("TEXT", "tag")), structure("matching reference records are parsed.\n", class = c("TEXT", "tag")), structure("For instance, ", class = c("TEXT", "tag")), structure(list(structure("readHumdrum(_, reference = \"OTL\")", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" will ", class = c("TEXT", "tag")), structure(list(structure("only", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" parse OTL reference records.\n", class = c("TEXT", "tag")), structure("If the values of ", class = c("TEXT", "tag")), structure(list(structure("reference", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" are named, these names are used to name associated fields.\n", class = c("TEXT", "tag")), structure("Thus, by specifing ", class = c("TEXT", "tag")), structure(list(structure("reference = c(Title = 'OTL')", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", you can use \"OTL\" reference records to populate\n", class = c("TEXT", "tag")), structure("a field called \"Title\".\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("If there are more than one reference records with the same reference code,\n", class = c("TEXT", "tag")), structure("either explicitely numbered (e.g., \"!!!COM1:\", \"!!!COM2:\") all are read and rather than making two\n", class = c("TEXT", "tag")), structure("or more fields, a single field is created (\"COM\" in this) with the multiple values separated by \";\".\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Result", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("findHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" returns a \"fileFrame\" (", class = c("TEXT", "tag")), structure(list(structure("data.table", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("), listing all file names,\n", class = c("TEXT", "tag")), structure("the patterns they match, the directories they were found in, ", class = c("TEXT", "tag")), structure(list(structure("and", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" the raw text content of these files.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("readHumdrum", class = c("RCODE", "tag" ))), class = c("tag_code", "tag")), structure(" returns a fully parsed ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag")), structure("readHumdrum() # loads all valid humdrum files in the current directory.\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("readHumdrum(\".*krn$\") # loads all files ending with \"krn\" in the currect directory\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("readHumdrum(\"^Composers$/^Be|^Mo/.*/^Joined$/.*krn$\") \n", class = c("RCODE", "tag")), structure("# Goes inside the directory \"Composers\".\n", class = c("RCODE", "tag")), structure("# Inside \"Composers\" looks for directories that start with \"Be\" or \"Mo\".\n", class = c("RCODE", "tag")), structure("# If there are any \"Be|Mo\" matching directories within \"Composers\", matches all directories within them.\n", class = c("RCODE", "tag")), structure("# Within these directories, looks for directories called \"Joined\".\n", class = c("RCODE", "tag")), structure("# If there are any directories called \"Joined\", loads all files (if any) that end with \"krn\".\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("readHumdrum(\"^Composers$\", \"^Be|^Mo\", \".*\", \"^Joined$\", \".*krn$\")\n", class = c("RCODE", "tag")), structure("# exactly the same as the previous!\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("readHumdrum(\"^Composers$\", c(Beethoven = \"^Be\", Mozart = \"^Mo\"), \".*\", \"^Joined$\", \".*krn$\") \n", class = c("RCODE", "tag")), structure("# exactly the same as the previous, except now the two matching patterns (\"^Be\", or \"^Mo\") will be grouped\n", class = c("RCODE", "tag")), structure("# in the Label field as \"Beethoven\" and \"Mozart\" respectively.\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" ))), class = c("tag_examples", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), regexConstruction.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Regex.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("regexConstruction", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("regexConstruction", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("captureRE", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("captureUniq", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("orRE", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Making Regular Expressions", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("captureRE(strs, n = \"\")\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("captureUniq(strs, zero = TRUE)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("orRE(...)\n", class = c("RCODE", "tag" ))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" includes some helpful functions for creating new regular expressions which work with the\n", class = c("TEXT", "tag")), structure(list(structure("stringr", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" package.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("captureRE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will take a character vector and collapse it to a \"capture group.\"\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag" )), structure(list(structure("n", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument can be used to append a number tag, for instance ", class = c("TEXT", "tag")), structure(list(structure("'*'", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (zero or more) to the group.\n", class = c("TEXT", "tag")), structure("I.e., ", class = c("TEXT", "tag" )), structure(list(structure("captureRE(c(\"a\", \"b\", \"c\"), '*')", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will output ", class = c("TEXT", "tag")), structure(list(structure("\"[abc]*\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("captureUniq", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will make a similar capture group to ", class = c("TEXT", "tag")), structure(list(structure("captureRE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", but with an expression\n", class = c("TEXT", "tag")), structure("that makes sure that only 1 or more ", class = c("TEXT", "tag")), structure(list(structure("of the same character", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" repeats.\n", class = c("TEXT", "tag")), structure("For instance, ", class = c("TEXT", "tag")), structure(list(structure("captureUniq(c('a', 'b','c'))", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will return ", class = c("TEXT", "tag")), structure(list(structure("\"([abc])\\\\1*\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("---this expression will match\n", class = c("TEXT", "tag")), structure(list(structure("\"aaa\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("\"bb\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" but not ", class = c("TEXT", "tag")), structure(list(structure("\"aabb\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), rhythmDecompose.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/rhythmInterval.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmDecompose", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmDecompose", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Decompose durations in terms of other durations", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("rhythmDecompose(rhythmInterval, into = rint(c(1, 2, 4, 8, 16, 32)))\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Decompose durations in terms of other durations\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Other rhythm analysis tools: \n", class = c("TEXT", "tag")), structure(list(structure(list(structure("metricPosition", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("()", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("rhythmOffset", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("()", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythm analysis tools", class = c("TEXT", "tag"))), class = c("tag_concept", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), rhythmFunctions.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/rhythmInterval.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmFunctions", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmFunctions", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("recip", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("duration", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Manipulate pitch data", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("recip(\n", class = c("RCODE", "tag")), structure(" x,\n", class = c("RCODE", "tag" )), structure(" ...,\n", class = c("RCODE", "tag" )), structure(" Exclusive = NULL,\n", class = c("RCODE", "tag")), structure(" parseArgs = list(),\n", class = c("RCODE", "tag")), structure(" timeArgs = list(),\n", class = c("RCODE", "tag")), structure(" inPlace = FALSE,\n", class = c("RCODE", "tag")), structure(" memoize = TRUE,\n", class = c("RCODE", "tag")), structure(" deparse = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("duration(\n", class = c("RCODE", "tag")), structure(" x,\n", class = c("RCODE", "tag" )), structure(" ...,\n", class = c("RCODE", "tag" )), structure(" Exclusive = NULL,\n", class = c("RCODE", "tag")), structure(" parseArgs = list(),\n", class = c("RCODE", "tag")), structure(" timeArgs = list(),\n", class = c("RCODE", "tag")), structure(" inPlace = FALSE,\n", class = c("RCODE", "tag")), structure(" memoize = TRUE,\n", class = c("RCODE", "tag")), structure(" deparse = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" ))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Manipulate pitch data\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("rhythmInterval\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), rhythmInterval.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/rhythmInterval.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rint", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("as.character,rhythmInterval-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("as.double.rhythmInterval", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("is.rhythmInterval", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("is.numeric,rhythmInterval-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("order.rhythmInterval", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Compare,rhythmInterval,rhythmInterval-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Summary,rhythmInterval-method", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval.logical", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval.NULL", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval.numeric", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval.rational", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval.fraction", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval.integer", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval.character", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Representation of rhythmic information", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("rhythmInterval(x, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("rint(denominator, numerator = 1L)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("as.character", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(x)\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure(list( structure(list(structure("as.double", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x)\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("is.rhythmInterval(x)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("is.numeric", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(x)\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("order.rhythmInterval(\n", class = c("RCODE", "tag")), structure(" x,\n", class = c("RCODE", "tag" )), structure(" ...,\n", class = c("RCODE", "tag" )), structure(" na.last = TRUE,\n", class = c("RCODE", "tag")), structure(" decreasing = FALSE,\n", class = c("RCODE", "tag")), structure(" method = c(\"auto\", \"shell\", \"radix\")\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure(list( structure(list(structure("Compare", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("rhythmInterval,rhythmInterval", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(e1, e2)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("Summary", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_S4method", "tag")), structure("(x)\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("rhythmInterval(x, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("logical", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("`NULL`", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("numeric", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(n)\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure(list( structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("rational", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x)\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure(list( structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("fraction", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x)\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure(list( structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("integer", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x)\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure(list( structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("character", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(str, Exclusive = NULL, ..., multiDispatch = FALSE)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("This ", class = c("TEXT", "tag" )), structure(list(structure("S4", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" class is the core rhythm representation in the ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" package.\n", class = c("TEXT", "tag")), structure("The object is used to represent rhythmic durations\n", class = c("TEXT", "tag")), structure("and metric positions.\n", class = c("TEXT", "tag")), structure("Each duration is represented in\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Whole_note", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("whole note", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" units.\n", class = c("TEXT", "tag")), structure("Numerically, these whole note units are represented as a ratio\n", class = c("TEXT", "tag")), structure("between integers, held in the slots ", class = c("TEXT", "tag")), structure(list(structure("@Numerator", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("@Denominator", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("This allows use to represent any rational number with no loss of precision\n", class = c("TEXT", "tag")), structure("due to rounding errors and weak decimal expansions (like ", class = c("TEXT", "tag")), structure(list(structure("0.333333", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag")), structure("Rhythm intervals are similar to standard musical\n", class = c("TEXT", "tag")), structure("termoniology (i.e, \"three eighth-notes\" is the ratio (3/8).\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Slots", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure(list( structure("Numerator", class = c("RCODE", "tag" ))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("Integers", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure(list( structure("Octave", class = c("RCODE", "tag" ))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("Integers", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_describe", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Vectorization", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" inherits from the virtual class\n", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("This means you can apply normal vectorized commands to ", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s,\n", class = c("TEXT", "tag")), structure("and even put them in ", class = c("TEXT", "tag")), structure(list(structure(list(structure("base::data.frame()", class = c("TEXT", "tag"))), Rd_option = structure("base:data.frame", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Arithmetic", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" objects have arithmetic operations defined.\n", class = c("TEXT", "tag")), structure("Addition and subtraction are straightword and intuitive (i.e., (1/8) + (3/8) = (1/2)).\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Multiplication and division are slightly more complicated:\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Scalar_multiplication", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("scalar multiplication", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure("\n", class = c("TEXT", "tag")), structure("is defined ", class = c("TEXT", "tag")), structure(list(structure("for rational numbers", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(": (3/8) * 2 = (3/4)\n", class = c("TEXT", "tag")), structure("(the result is always a new ", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag")), structure("However, note that a ", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" cannot be multiplied by another\n", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("---afterall, what would a quarter-note times a quarter-note be?\n", class = c("TEXT", "tag")), structure("A ", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" can be divided by another ", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" to produce\n", class = c("TEXT", "tag")), structure("a real number: (1/2) / (1/4) = 2.\n", class = c("TEXT", "tag")), structure("Like other rational values in ", class = c("TEXT", "tag")), structure(list(structure("R", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" we can also do either\n", class = c("TEXT", "tag")), structure("``true'' (rational) division (using the ", class = c("TEXT", "tag")), structure(list(structure("/", class = c("TEXT", "tag"))), Rd_option = structure("base:Arithmetic", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" operator)\n", class = c("TEXT", "tag")), structure(list(structure("or", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Euclidean_division", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("Euclidean", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure("\n", class = c("TEXT", "tag")), structure("division (using the ", class = c("TEXT", "tag")), structure(list(structure("%%", class = c("TEXT", "tag"))), Rd_option = structure("base:Arithmetic", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" operator).\n", class = c("TEXT", "tag")), structure("Rational division (", class = c("TEXT", "tag")), structure(list(structure("/", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") of a `rhythmInterval` by another `rhythmInterval`\n", class = c("TEXT", "tag")), structure("results in a rational number. For instance, $(1/2) / (1/4) = 2$.\n", class = c("TEXT", "tag")), structure("Rational division of a `rhythmInterval` by a rational number results in a\n", class = c("TEXT", "tag")), structure("new `rhythmInterval`: $(1/2) / 2 = (1/4)$.\n", class = c("TEXT", "tag")), structure("Eucliean (a.k.a., integer) division can only be applied between `rhythmInterval`s\n", class = c("TEXT", "tag")), structure("resulting in an integer quotient---the remainder, which is a `rhythmInterval`,\n", class = c("TEXT", "tag")), structure("can be calculated with the ", class = c("TEXT", "tag")), structure(list(structure("%%", class = c("TEXT", "tag"))), Rd_option = structure("base:Arithmetic", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" operator.\n", class = c("TEXT", "tag")), structure("The remainder (a.k.a., ", class = c("TEXT", "tag")), structure(list(structure("modulo", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(") operator (`%%`) is especially\n", class = c("TEXT", "tag")), structure("useful, for instance in calculating metric positions.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Relational Operators", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s can be compared using the standard\n", class = c("TEXT", "tag")), structure(list(structure("relational operators", class = c("TEXT", "tag"))), Rd_option = structure("base:Comparison", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("---", class = c("TEXT", "tag")), structure(list(structure("==", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("!=", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("&gt;", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("&gt;=", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", etc.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("core rhythm representation", class = c("TEXT", "tag"))), class = c("LIST", "tag"))), class = c("tag_concept", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), rhythmOffset.Rd = structure(list(structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/rhythmInterval.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("rhythmOffset", class = c("VERB", "tag" ))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmOffset", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Calculate rhythmic \"offset\"", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("rhythmOffset(durations, start = 0, bars = NULL, tatum = 1, as = as.decimal)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("durations", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A vector of numeric values representing durations.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("start", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A duration value (coerced to same class as ", class = c("TEXT", "tag")), structure(list(structure("durations", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("), from which the\n", class = c("TEXT", "tag")), structure("offset begins.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("groups", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A vector of equal length as ", class = c("TEXT", "tag")), structure(list(structure("durations", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" representing a grouping factor,\n", class = c("TEXT", "tag")), structure("usable by ", class = c("TEXT", "tag" )), structure(list(structure("[base][tapply]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(". If ", class = c("TEXT", "tag")), structure(list(structure("!is.null(groups)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", offsets are calculated\n", class = c("TEXT", "tag")), structure("for duration values within each group. The ", class = c("TEXT", "tag")), structure(list(structure("start", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument is recycle to match\n", class = c("TEXT", "tag")), structure("the length of the number of groups, so a different start value can be applied to each group.\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag")), structure(list(structure("is.null(groups)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", offsets are calculated for the whole ", class = c("TEXT", "tag")), structure(list(structure("durations", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" vector, from the\n", class = c("TEXT", "tag")), structure("first ", class = c("TEXT", "tag" )), structure(list(structure("start", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" value.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_arguments", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure("Borrowing the term from ", class = c("TEXT", "tag")), structure(list(structure("music21", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", rhythmic \"offset\"\n", class = c("TEXT", "tag")), structure("refers to a duration of time since a starting point (usually, the beginning\n", class = c("TEXT", "tag")), structure("of a piece).\n", class = c("TEXT", "tag")), structure(list(structure("rhythmOffset", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" takes a vector of numbers representing durations\n", class = c("TEXT", "tag")), structure("(maybe ", class = c("TEXT", "tag" )), structure(list(structure("[rhythmInterval][rhythmInterval]s", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(", maybe other\n", class = c("TEXT", "tag")), structure("numeric values) and cummulatively sums them from a starting value.\n", class = c("TEXT", "tag")), structure("The output is a vector of durations of the same type as the input\n", class = c("TEXT", "tag")), structure("where each output value corresponds to the duration of time elapsed\n", class = c("TEXT", "tag")), structure("at that point.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Other rhythm analysis tools: \n", class = c("TEXT", "tag")), structure(list(structure(list(structure("metricPosition", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("()", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("rhythmDecompose", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("()", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythm analysis tools", class = c("TEXT", "tag"))), class = c("tag_concept", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), romanNumerals.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/diatonicSet.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("romanNumerals", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("romanNumerals", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Roman Numeral", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Roman numerals can be calculated for diatonicSets (keys) and\n", class = c("TEXT", "tag")), structure("for tertian sets (chords).\n", class = c("TEXT", "tag")), structure("The later case is the standard meaning of \"roman numeral.\"\n", class = c("TEXT", "tag")), structure("However, the former case is used as well, for instance\n", class = c("TEXT", "tag")), structure("to represent modulation schemes in\n", class = c("TEXT", "tag")), structure("analyses of classical music. For instance, modulate from I-V,\n", class = c("TEXT", "tag")), structure("the to vi/V.\n", class = c("TEXT", "tag")), structure("More importantly, many \"roman numerals\" in harmonic analyses\n", class = c("TEXT", "tag")), structure("implicitely combine tertian and diatonic roman numerals:\n", class = c("TEXT", "tag")), structure("in \"applied\" roman numerals.\n", class = c("TEXT", "tag")), structure("Given a roman numeral like \"V65/V\", the \"V65\" represents a\n", class = c("TEXT", "tag")), structure("chord while the \"/V\" represents a key.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), struct.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Vector.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("is.struct", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("is.struct(x)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Virtual class to help create atomic-vector-like composite data objects.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" defines a number of ", class = c("TEXT", "tag")), structure(list(structure(list(structure("http://adv-r.had.co.nz/S4.html", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("S4 classes", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" which are, underneath the surface, ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Composite_data_type", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("composite data types", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure("\n", class = c("TEXT", "tag")), structure("made up of collections of ", class = c("TEXT", "tag")), structure(list(structure("base-R atomic vectors", class = c("TEXT", "tag"))), Rd_option = structure("base:vector", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(", stuck together.\n", class = c("TEXT", "tag")), structure("The \"vectorized\" nature of R's atomic types is one of R's key strengths, so in ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" we try to A) mostly use the standard atomic types B)\n", class = c("TEXT", "tag")), structure("make all the new types we ", class = c("TEXT", "tag")), structure(list(structure("do", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" define act as much like atomic vectors as possible.\n", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is a ", class = c("TEXT", "tag")), structure(list(structure("virtual", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" S4 class which serves this purpose: creating composite atomic vectors which act (mostly) like base-R atomic vectors.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("As a \"virtual class\" ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s themselves don't really exist as independent objects, but the ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" class defines (abstractly) all the necessarry methods to treat a collection of\n", class = c("TEXT", "tag")), structure("atomic vectors as a single vector/matrix-like object---simply make your new subclass ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("inherit", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("and it is all taken care of. (To do this, specify ", class = c("TEXT", "tag")), structure(list(structure("contains = \"struct\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" in your call to ", class = c("TEXT", "tag")), structure(list(structure("setClass", class = c("TEXT", "tag"))), Rd_option = structure("methods:setClass", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".)\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Important ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" classes which inherit from ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" include:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("tonalInterval", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("diatonicSet", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("tertianSet", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Be warned, R's S4 object-system is limited in this regard: you can't really define S4 classes that act ", class = c("TEXT", "tag")), structure(list(structure("fully", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" like R atomics, as\n", class = c("TEXT", "tag")), structure("many of their features are hard-coded into R itself and can't be replicated.\n", class = c("TEXT", "tag")), structure("The most important limitation of ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" that you may encounter is that, though ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" classes work (ok) in ", class = c("TEXT", "tag")), structure(list(structure("data.frames", class = c("TEXT", "tag"))), Rd_option = structure("base:data.frame", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(",\n", class = c("TEXT", "tag" )), structure(list(structure("data.tables", class = c("TEXT", "tag"))), Rd_option = structure("data.table:data.table", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("tibbles", class = c("TEXT", "tag"))), Rd_option = structure("tibble:tibble", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" will either not work or give strange behaviors if you put ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s into them.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Slots", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure(list( structure("dim", class = c("RCODE", "tag"))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("Either ", class = c("TEXT", "tag")), structure(list(structure("NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or a non-negative ", class = c("TEXT", "tag")), structure(list(structure("integer-vector", class = c("TEXT", "tag"))), Rd_option = structure("base:integer", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" of ", class = c("TEXT", "tag")), structure(list(structure("length == 2L", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", representing the number of rows and columns respectively. Dimensions ", class = c("TEXT", "tag")), structure(list(structure("can", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" be zero.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure(list( structure("rownames", class = c("RCODE", "tag"))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("Either ", class = c("TEXT", "tag")), structure(list(structure("NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or a ", class = c("TEXT", "tag" )), structure(list(structure("integer", class = c("TEXT", "tag"))), Rd_option = structure("base:integer", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("/", class = c("TEXT", "tag")), structure(list(structure("character", class = c("TEXT", "tag"))), Rd_option = structure("base:character", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("-vector which is the same length as either\n", class = c("TEXT", "tag")), structure("A) if ", class = c("TEXT", "tag")), structure(list(structure("dim == NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the length of the ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" B) if ", class = c("TEXT", "tag")), structure(list(structure("dim != NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the number of rows in the ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure(list( structure("colnames", class = c("RCODE", "tag"))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("Either ", class = c("TEXT", "tag")), structure(list(structure("NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (it ", class = c("TEXT", "tag" )), structure(list(structure("must", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" be ", class = c("TEXT", "tag" )), structure(list(structure("NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" if ", class = c("TEXT", "tag" )), structure(list(structure("dim == NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") or a ", class = c("TEXT", "tag")), structure(list(structure("integer", class = c("TEXT", "tag"))), Rd_option = structure("base:integer", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("/", class = c("TEXT", "tag")), structure(list(structure("character", class = c("TEXT", "tag"))), Rd_option = structure("base:character", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("-vector of length equal to the number of columns in the ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_describe", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Behavior", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" subclasses (i.e., classes which inherit from ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") behave very similarly to normal ", class = c("TEXT", "tag")), structure(list(structure("R atomic vectors/matrices", class = c("TEXT", "tag"))), Rd_option = structure("base:vector", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("However, they do differ in a few respects, mostly in ways that are intended to avoid some of the quirky behaviors of R matrices:\n", class = c("TEXT", "tag")), structure("In general, the distinction between dimensionless vectors and dimensioned vectors (", class = c("TEXT", "tag")), structure(list(structure("matrices", class = c("TEXT", "tag"))), Rd_option = structure("base:matrix", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(") is slightly weaker in ", class = c("TEXT", "tag")), structure(list(structure("structs", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" than with normal R atomic vectors/matrices.\n", class = c("TEXT", "tag")), structure("Most importantly, dimensioned ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s won't drop their dimensions under various common operations (", class = c("TEXT", "tag")), structure(list(structure("c", class = c("TEXT", "tag"))), Rd_option = structure("base:c", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("[]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(", etc.), the way base-R matrices do.\n", class = c("TEXT", "tag")), structure("In general, it is easier to interact with a multi-column (matrix-)", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" in the same way as a dimensionless (vector-)", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("For example, if the struct has dimensions then ", class = c("TEXT", "tag")), structure(list(structure("length(struct) == nrow(struct)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", instead of ", class = c("TEXT", "tag")), structure(list(structure("length(matrix) == nrow(matrix) * ncol(matrix)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("---i.e., the \"height\"\n", class = c("TEXT", "tag")), structure("of the ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (the number of rows) is its length.\n", class = c("TEXT", "tag")), structure("Another big difference is in the behaviors of ", class = c("TEXT", "tag")), structure(list(structure("c", class = c("TEXT", "tag"))), Rd_option = structure("base:c", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(": ", class = c("TEXT", "tag")), structure(list(structure("c", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" doesn't always cause ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s to lose their dimensions and ", class = c("TEXT", "tag")), structure(list(structure("c", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" can be used to concatinated multi-column ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s,\n", class = c("TEXT", "tag")), structure("or even mixes of dimensionless and dimensioned ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s:\n", class = c("TEXT", "tag")), structure("If any ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" arguments to ", class = c("TEXT", "tag")), structure(list(structure("c", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" have dimensions, the ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s are concatinated via a call to ", class = c("TEXT", "tag")), structure(list(structure("rbind", class = c("TEXT", "tag"))), Rd_option = structure("base:cbind", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(", with any dimensionless vectors coerced to\n", class = c("TEXT", "tag")), structure("1-column matrices.\n", class = c("TEXT", "tag")), structure("Of course, the (resulting) number of columns must all be the same or an error will occur!\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Other differences:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s can have either no dimensions (", class = c("TEXT", "tag")), structure(list(structure("dim(struct) == NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") or two dimensions. Higher dimensional ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s are not supported (yet).\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("rowSums", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("colSums", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will coerce a dimensionless struct to a column matrix.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s always throw an error if you try to index them with a index value that is greater than the length/nrow of the ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("This is different than atomic vectors, which will pad the vector up to the length of the index you give---a sometimes useful but quirky behavior.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s with two dimensions have a ", class = c("TEXT", "tag")), structure(list(structure("cartesian", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" indexing argument.\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag")), structure(list(structure("cartesian = TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the ", class = c("TEXT", "tag")), structure(list(structure("i", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("j", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" arguments are treated as cartesian coordinates.\n", class = c("TEXT", "tag")), structure("(This behavior can be achieved with base R matrices (or ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s) by inputing a matrix with two columns.)\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Requirements", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("To work, ", class = c("TEXT", "tag" )), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" makes a few assumptions about your class.\n", class = c("TEXT", "tag")), structure("Your class must have one or more slots which are vectors, all of which are the same length.\n", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("'s indexing method will cause all of these vectors to be indexed as one.\n", class = c("TEXT", "tag")), structure("When you define a new subclass of ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", it will inherit a\n", class = c("TEXT", "tag")), structure(list(structure("validObject", class = c("TEXT", "tag"))), Rd_option = structure("methods:validObject", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" method which assures that all elements are the same dimension.\n", class = c("TEXT", "tag")), structure("Thus, if you are writing your own ", class = c("TEXT", "tag")), structure(list(structure("validObject", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" method (using ", class = c("TEXT", "tag")), structure(list(structure("setValidity", class = c("TEXT", "tag"))), Rd_option = structure("methods:validObject", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(")\n", class = c("TEXT", "tag")), structure("you just have to worry specifically about the validity of the information in your slots,\n", class = c("TEXT", "tag")), structure("not that the slots are all the same length.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Initialize", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("An initialize method which automatically makes all slots the same length is predefined\n", class = c("TEXT", "tag")), structure("for ", class = c("TEXT", "tag")), structure(list(structure("structs", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". If you want to make a more specialized ", class = c("TEXT", "tag")), structure(list(structure("initialize", class = c("TEXT", "tag"))), Rd_option = structure("methods:new", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" method,\n", class = c("TEXT", "tag")), structure("you can still take advantage of the inherited method by using ", class = c("TEXT", "tag")), structure(list(structure("callNextMethod", class = c("TEXT", "tag"))), Rd_option = structure("methods:NextMethod", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" at the\n", class = c("TEXT", "tag")), structure("beginning of your method.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Predefined methods", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("The main purpose of the ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" virtual class is that it defines many of the basic methods you need to manipulate subclass objects.\n", class = c("TEXT", "tag")), structure("Most importantly, ", class = c("TEXT", "tag")), structure(list(structure("indexing", class = c("TEXT", "tag"))), Rd_option = structure("base:Extract", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" methods are fully defined (that mimic base-R atomic vector/matrix indexing), as well as\n", class = c("TEXT", "tag")), structure("basic \"structural\" methods like ", class = c("TEXT", "tag")), structure(list(structure("(col/row)names", class = c("TEXT", "tag"))), Rd_option = structure("base:colnames", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("dim", class = c("TEXT", "tag"))), Rd_option = structure("base:dim", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("length", class = c("TEXT", "tag"))), Rd_option = structure("base:length", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("ncol, nrow", class = c("TEXT", "tag"))), Rd_option = structure("base:nrow", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(", etc.\n", class = c("TEXT", "tag")), structure("In addition:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" If you define ", class = c("TEXT", "tag")), structure(list(structure("&gt; and &gt;=", class = c("TEXT", "tag"))), Rd_option = structure("base:Comparison", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("&lt;", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("&lt;=", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will be automatically defined.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" If you define ", class = c("TEXT", "tag")), structure(list(structure("as.character", class = c("TEXT", "tag"))), Rd_option = structure("base:character", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" for your subclass, ", class = c("TEXT", "tag")), structure(list(structure("show", class = c("TEXT", "tag"))), Rd_option = structure("methods:show", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("format", class = c("TEXT", "tag"))), Rd_option = structure("base:format", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" methods are automatically defined.\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("What's more, default arithmetic methods for addition, subtraction, (scalar-integer) multiplication, and negation (", class = c("TEXT", "tag")), structure(list(structure("-x", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") are defined.\n", class = c("TEXT", "tag")), structure("The default addition behavior is that each numeric (", class = c("TEXT", "tag")), structure(list(structure("base::integer", class = c("TEXT", "tag"))), Rd_option = structure("base:integer", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("base::numeric", class = c("TEXT", "tag"))), Rd_option = structure("base:numeric", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(") slot from your subclasses will be added together.\n", class = c("TEXT", "tag")), structure("Thus, ", class = c("TEXT", "tag")), structure(list(structure("struct1 + struct2", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will extract each numeric/integer slot from each ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", add them together and create a new ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" from the result.\n", class = c("TEXT", "tag")), structure(list(structure("-struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will negate all numeric fields, and subtraction is simply defined as adding the negation.\n", class = c("TEXT", "tag")), structure("Since ", class = c("TEXT", "tag")), structure(list(structure("scalar", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" multiplication is defined, two ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s cannot be multiplied, but a struct can be multiplied by an integer (all numeric fields are multiplied by the integer(s)).\n", class = c("TEXT", "tag")), structure("If these definitions don't work for your subclass, you'll need to create your own, more specific, method!\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("RCODE", "tag")), structure("setClass('mynewsubclass', contains = 'struct', slots = c(X= 'numeric', Y = 'numeric'))\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("test &lt;- new('mynewsubclass', X = 1:10, Y = 10:1)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("# all of these should work:\n", class = c("RCODE", "tag")), structure("test[1:5]\n", class = c("RCODE", "tag")), structure("rev(test) == test\n", class = c("RCODE", "tag")), structure("cbind(test, test)\n", class = c("RCODE", "tag")), structure("c(test, test)\n", class = c("RCODE", "tag")), structure("test * 3\n", class = c("RCODE", "tag")), structure("test - test\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag"))), class = c("tag_examples", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Examples of ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" subclasses: ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("diatonicSet", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("tertianSet", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), tertianSet.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/tertianSet.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tertianSet", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tertianSet", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tset", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("is.tertianSet", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Tertian set", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("tertianSet(...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("tset(\n", class = c("RCODE", "tag" )), structure(" root = 0L,\n", class = c("RCODE", "tag")), structure(" signature = 0L,\n", class = c("RCODE", "tag")), structure(" alterations = 0L,\n", class = c("RCODE", "tag")), structure(" cardinality = 3L,\n", class = c("RCODE", "tag")), structure(" extension = NULL,\n", class = c("RCODE", "tag")), structure(" inversion = 0L\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("is.tertianSet(x)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure("tertianSet", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is one of ", class = c("TEXT", "tag")), structure(list(structure("humdrumR's", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumR", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag")), structure("types of tonal data, representing Western tertian harmonies.\n", class = c("TEXT", "tag")), structure(list(structure("tertianSet", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is a subclass of ", class = c("TEXT", "tag")), structure(list(structure("diatonicSet", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (and thence, ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure("The only structural addition, compared to ", class = c("TEXT", "tag")), structure(list(structure("diatonicSet", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", is the ", class = c("TEXT", "tag")), structure(list(structure("Extensions", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" slot.\n", class = c("TEXT", "tag")), structure("This slot indicates which tertian chord members are active in the chord.\n", class = c("TEXT", "tag")), structure("There are seven possible chord members:\n", class = c("TEXT", "tag")), structure("the root, third, fifth, seventh, ninth, eleventh, and thirteenth.\n", class = c("TEXT", "tag")), structure("Every possible combination of these seven degrees is represented by a single integer, corresponding\n", class = c("TEXT", "tag")), structure("to the 7-bit representation of on/offs on the seven degrees in reverse order (13, 11, 9, 7, 5, 3, 1).\n", class = c("TEXT", "tag")), structure("For example, the integer ", class = c("TEXT", "tag")), structure(list(structure("15", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" corresponds to a seventh chord: in binary, 15 is ", class = c("TEXT", "tag")), structure(list(structure("0001111", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("The initial three zeros indicate that the 13th, 11th, and 9th are ", class = c("TEXT", "tag")), structure(list(structure("not", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" part of the harmony, while the four ones\n", class = c("TEXT", "tag")), structure("indicate that the root, third, fifth, and seventh ", class = c("TEXT", "tag")), structure(list(structure("are", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" part of the harmony.\n", class = c("TEXT", "tag")), structure("Ultimately, adding or removing a chord degree from a harmony can be achieved by adding the power of\n", class = c("TEXT", "tag")), structure("two associated with that degree:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Root", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(": ", class = c("TEXT", "tag")), structure(list(structure(list(structure("\\pm 1", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(), class = c("tag_item", "tag" )), structure(" ", class = c("TEXT", "tag")), structure(list(structure("Third", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(": ", class = c("TEXT", "tag")), structure(list(structure(list(structure("\\pm 2", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Fifth", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(": ", class = c("TEXT", "tag")), structure(list(structure(list(structure("\\pm 4", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Seventh", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(": ", class = c("TEXT", "tag")), structure(list(structure(list(structure("\\pm 8", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Ninth", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(": ", class = c("TEXT", "tag")), structure(list(structure(list(structure("\\pm 16", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Eleventh", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(": ", class = c("TEXT", "tag")), structure(list(structure(list(structure("\\pm 32", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Thirteenth", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(": ", class = c("TEXT", "tag")), structure(list(structure(list(structure("\\pm 64", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tertianSet", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" has many specific methods defined for reading/writing harmonic information.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("diatonicSet humTonality\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), time.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/rhythmInterval.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("time", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("time", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("bpm2ms", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("ms2bpm", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Time transformations", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("bpm2ms(bpm)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("ms2bpm(ms)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Time transformations\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), tonalInterval.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/tonalInterval.R, R/rhythmInterval.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tint", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("is.tonalInterval", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tonalInterval.tonalInterval", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tonalInterval.logical", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tonalInterval.NULL", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tonalInterval.numeric", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tonalInterval.rational", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tonalInterval.fraction", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tonalInterval.integer", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tonalInterval.character", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("rhythmInterval.rhythmInterval", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Representation of tonal pitch information", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("tonalInterval(...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("tint(\n", class = c("RCODE", "tag" )), structure(" octave,\n", class = c("RCODE", "tag" )), structure(" LO5th = 0L,\n", class = c("RCODE", "tag")), structure(" cent = numeric(length(octave)),\n", class = c("RCODE", "tag")), structure(" partition = FALSE,\n", class = c("RCODE", "tag")), structure(" Key = NULL,\n", class = c("RCODE", "tag")), structure(" roundContour = floor\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("is.tonalInterval(x)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("tonalInterval(...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("tonalInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("tonalInterval", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("tonalInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("logical", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("tonalInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("`NULL`", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("tonalInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("numeric", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(\n", class = c("RCODE", "tag" )), structure(" x,\n", class = c("RCODE", "tag")), structure(" tonalHarmonic = 3,\n", class = c("RCODE", "tag")), structure(" centMargin = 10,\n", class = c("RCODE", "tag")), structure(" accidental.melodic = FALSE,\n", class = c("RCODE", "tag")), structure(" ...\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("tonalInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("rational", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x, tonalHarmonic = 3, accidental.melodic = FALSE, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("tonalInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("fraction", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x, tonalHarmonic = 3)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("tonalInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("integer", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(n, accidental.melodic = FALSE, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("tonalInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("character", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(str, Exclusive = NULL, ..., multiDispatch = FALSE)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure(list(structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("rhythmInterval", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_method", "tag")), structure("(x, ...)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag" )), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is the core tonal pitch representation in ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("TEXT", "tag"))), Rd_option = structure("=humdrumR", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure("A ", class = c("TEXT", "tag")), structure(list( structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is an abstract representation of tonal pitch, which can be translated to/from all standard \"concrete\" pitch representations:\n", class = c("TEXT", "tag")), structure("solfege, scientific pitch, semitones, frequencies, scale degrees, intervals, etc.\n", class = c("TEXT", "tag")), structure("For the most part, users should not need to interact with ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s directly---rather, ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s work behind the scene in numerous ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" pitch functions.\n", class = c("TEXT", "tag")), structure("See the ", class = c("TEXT", "tag")), structure(list(structure("pitchRepresentations", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("tonalTransformations", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" documentation for details of usage and functionality or the ", class = c("TEXT", "tag")), structure(list(structure("Tonality in humdrumR", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" vignette for\n", class = c("TEXT", "tag")), structure("a detailed explanation of the theory and specifics of ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag" )), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is a ", class = c("TEXT", "tag")), structure(list(structure(list(structure("http://adv-r.had.co.nz/S4.html", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("S4", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" subclass of ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("'s virtual class ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(", from which it inherits a lot of useful \"vector-like\" behaviors/functionality.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("The constructor function ", class = c("TEXT", "tag")), structure(list(structure("tint", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" can be used to create ", class = c("TEXT", "tag")), structure(list(structure("tonalIntervals", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" directly.\n", class = c("TEXT", "tag")), structure("The three arguments corespond to the three slots: ", class = c("TEXT", "tag")), structure(list(structure("octave", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("LO5th", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (Fifth), and ", class = c("TEXT", "tag")), structure(list(structure("cent", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("All inputs will be coerced to match in length.\n", class = c("TEXT", "tag")), structure("What's more, the ", class = c("TEXT", "tag")), structure(list(structure("octave", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument can be left blank, in which case the appropriate octave will automatically be computed\n", class = c("TEXT", "tag")), structure("to place the interval in the octave above middle-C.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("By default, the ", class = c("TEXT", "tag")), structure(list(structure("as.character", class = c("TEXT", "tag"))), Rd_option = structure("base:character", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" method, and thus (via ", class = c("TEXT", "tag")), structure(list(structure("struct", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(") the ", class = c("TEXT", "tag")), structure(list(structure("show", class = c("TEXT", "tag"))), Rd_option = structure("methods:show", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" method, for ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s call ", class = c("TEXT", "tag")), structure(list(structure("kern()", class = c("TEXT", "tag"))), Rd_option = structure("=pitchRepresentations", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(".\n", class = c("TEXT", "tag" )), structure("Thus, if you return a ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" on the command line (or call ", class = c("TEXT", "tag")), structure(list(structure("print", class = c("TEXT", "tag"))), Rd_option = structure("base:print", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" one one) you'll see the ", class = c("TEXT", "tag")), structure(list(structure("kern pitch", class = c("TEXT", "tag"))), Rd_option = structure("=pitchRepresentations", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" representation printed.\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Slots", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure(list( structure("Octave", class = c("RCODE", "tag" ))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("integers representing the octave offset.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure(list( structure("Fifth", class = c("RCODE", "tag" ))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("integers representing the \"line-of-fifths\" value.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure(list( structure("Cent", class = c("RCODE", "tag" ))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("numeric values representing cents (1200th of an octave).", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_describe", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Arithmetic", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("Technically, ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s are examples of algebraic ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Module_(mathematics)", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("modules over integers", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("This means that certain arithmetic operations are defined for ", class = c("TEXT", "tag")), structure(list(structure("tonalIntervals", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and can be called using standard arithmetic operators (", class = c("TEXT", "tag")), structure(list(structure("+", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("-", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", etc.):\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Addition: ", class = c("TEXT", "tag")), structure(list(structure("tonalIntervals", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" can be added together, acting exactly as you'd expect (i.e., ", class = c("TEXT", "tag")), structure(list(structure(list(structure("M3 + m3 = P5", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(").\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Subtraction: ", class = c("TEXT", "tag")), structure(list(structure("tonalIntervals", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" can be subtracted just as they are added. Also, they can be negated with a single ", class = c("TEXT", "tag")), structure(list(structure("-", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("operator (like ", class = c("TEXT", "tag")), structure(list(structure("-M3", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Multiplication: ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s can ", class = c("TEXT", "tag")), structure(list(structure("not", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" be multiplied together.\n", class = c("TEXT", "tag")), structure("However, ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Scalar_multiplication", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("scalar (integer) multiplication", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" is defined:\n", class = c("TEXT", "tag")), structure("thus, ", class = c("TEXT", "tag")), structure(list(structure("tonalIntervals", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" can be multiplied by integers to create new ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s: e.g., ", class = c("TEXT", "tag")), structure(list(structure(list(structure("M2 * 3L = A4", class = c("VERB", "tag"))), class = "tag")), class = c("tag_eqn", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Division: as the natural inverse of scale multiplication, ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Euclidean_division", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("Euclidean division", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure("\n", class = c("TEXT", "tag")), structure("is defined for ", class = c("TEXT", "tag")), structure(list(structure("tonalIntervals", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("---i.e., division by/into whole (integer) pieces, often with leftover \"remainders\" (modulo).\n", class = c("TEXT", "tag")), structure("In R, Euclidean division is achieved with the ", class = c("TEXT", "tag")), structure(list(structure("%/%", class = c("TEXT", "tag"))), Rd_option = structure("base:Arithmetic", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" operator---", class = c("TEXT", "tag")), structure(list(structure("not", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("/", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("---, with the associated ", class = c("TEXT", "tag")), structure(list(structure("%%", class = c("TEXT", "tag"))), Rd_option = structure("base:Arithmetic", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" used for the remainder/modulo.\n", class = c("TEXT", "tag")), structure("Two ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s can be divided to produced an integer; Conversely, a ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" can be divided by an integer to produce a ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Take note that the way ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" defines Euclidean division is based in ", class = c("TEXT", "tag")), structure(list(structure("tonal space", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure("---i.e., the line-of-fifths---not frequency or atonal-semitone space.\n", class = c("TEXT", "tag")), structure("For example, an augmented-fourth divided by a major-second ", class = c("TEXT", "tag")), structure(list(structure("is", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("3L", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", but a diminished-fifth divided by a major-second is ", class = c("TEXT", "tag")), structure(list(structure("not", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" 3L---", class = c("TEXT", "tag")), structure(list(structure("d5 %/% M2", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" equals ", class = c("TEXT", "tag")), structure(list(structure("-3L", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" with a remainder of ", class = c("TEXT", "tag")), structure(list(structure("P8", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (plus an octave)!\n", class = c("TEXT", "tag")), structure("The division algorithm works by applying standard Euclidean division to the ", class = c("TEXT", "tag")), structure(list(structure("@Fifth", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" slot (line-of-fifths tonal space), and shifting the ", class = c("TEXT", "tag")), structure(list(structure("@Octave", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" value in\n", class = c("TEXT", "tag")), structure("the remainder to the match the appropriate octave.\n", class = c("TEXT", "tag")), structure("This definition has the useful properties that ", class = c("TEXT", "tag")), structure(list(structure("specificinterval %% A1 = genericinterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("interval %% d2 = enharmonicinterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("Since basic data types can be parsed into ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (see below), ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will attempt to automatically ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Type_conversion", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("coerce", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure("\n", class = c("TEXT", "tag")), structure("data to tonalIntervals when asked to perform arithmetic.\n", class = c("TEXT", "tag")), structure("This means that arithmetic can be applied when one of the two arguments is a ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and the other is a coercable atomic.\n", class = c("TEXT", "tag")), structure("For instance, ", class = c("TEXT", "tag")), structure(list(structure("M3 + 2L", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will interpret ", class = c("TEXT", "tag")), structure(list(structure("2L", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" as two semitones and add a major-second to the major-third!\n", class = c("TEXT", "tag")), structure("The clever ", class = c("TEXT", "tag")), structure(list(structure("dispatch system", class = c("TEXT", "tag"))), Rd_option = structure("=regexDispatch", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" will even ignore character strings that are not recognized (see examples)!\n", class = c("TEXT", "tag")), structure("This is useful when combined with the \"Predifined Intervals\" (like ", class = c("TEXT", "tag")), structure(list(structure("M3", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("), described below.\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Relational Operators", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s can be compared using the standard ", class = c("TEXT", "tag")), structure(list(structure("relational operations", class = c("TEXT", "tag"))), Rd_option = structure("base:Comparison", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("---", class = c("TEXT", "tag")), structure(list(structure("==", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("!=", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("&gt;", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("&gt;=", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", etc.\n", class = c("TEXT", "tag")), structure("Two ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s are equal (according to ", class = c("TEXT", "tag")), structure(list(structure("==", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") only if all their slots (", class = c("TEXT", "tag")), structure(list(structure("Octave", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("Fifth", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", and ", class = c("TEXT", "tag")), structure(list(structure("Cent", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(")\n", class = c("TEXT", "tag")), structure("are exactly identical.\n", class = c("TEXT", "tag")), structure("Thus, enharmonic notes (like C# and Db) are ", class = c("TEXT", "tag")), structure(list(structure("not", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" equal.\n", class = c("TEXT", "tag")), structure("In contrast, ordinal comparisons (e.g., ", class = c("TEXT", "tag")), structure(list(structure("&gt;", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", ", class = c("TEXT", "tag")), structure(list(structure("&lt;=", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") between ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s are based on their semitone (equal temperament) size, so enharmonicity is irrelevant.\n", class = c("TEXT", "tag")), structure("Thus, ", class = c("TEXT", "tag")), structure(list(structure("m3 &gt;= A2", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("A2 &gt;= m3", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" are both ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", even though ", class = c("TEXT", "tag")), structure(list(structure("m3 == A2", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is not.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Predefined Intervals:", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" automatically exports a bunch of ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s, named by their musical interval representation.\n", class = c("TEXT", "tag")), structure("Every generic interval from 1 to 15 is combined with every interval quality ", class = c("TEXT", "tag")), structure(list(structure("dd", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (doubly diminished), ", class = c("TEXT", "tag")), structure(list(structure("d", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (diminished), ", class = c("TEXT", "tag")), structure(list(structure("m", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (minor), ", class = c("TEXT", "tag")), structure(list(structure("M", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (major), ", class = c("TEXT", "tag")), structure(list(structure("A", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (augumented)\n", class = c("TEXT", "tag")), structure(list(structure("AA", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (doubly augmented).\n", class = c("TEXT", "tag")), structure("Thus, after loading ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", you can type things like ", class = c("TEXT", "tag")), structure(list(structure("M3 + M3", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and get ", class = c("TEXT", "tag")), structure(list(structure("A5", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("In addition, the variables ", class = c("TEXT", "tag")), structure(list(structure("unison", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (", class = c("TEXT", "tag")), structure(list(structure("= P1 = tint(0, 0)", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("), ", class = c("TEXT", "tag")), structure(list(structure("pythagorean.comma", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (", class = c("TEXT", "tag")), structure(list(structure("= d2 = tint(-19,12)", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("), and ", class = c("TEXT", "tag")), structure(list(structure("octave", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (", class = c("TEXT", "tag")), structure(list(structure("tint(1, 0)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") are exported as well.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Parsing", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" includes a easy-to-use but powerful system for parsing pitch information into the ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" representation.\n", class = c("TEXT", "tag")), structure("Basic methods are defined for numeric values representing atonal pitch information:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("integer", class = c("TEXT", "tag"))), Rd_option = structure("base:integer", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" values are interpreted as semitones. Watch out! In R, you need to append an ", class = c("TEXT", "tag")), structure(list(structure("L", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" to a number to make it an explicit integer:\n", class = c("TEXT", "tag")), structure("For example, ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval(3L)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("numeric", class = c("TEXT", "tag"))), Rd_option = structure("base:numeric", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("/", class = c("TEXT", "tag" )), structure(list(structure(list(structure("decimal()", class = c("TEXT", "tag"))), Rd_option = structure("=decimal", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure(list(structure("rational()", class = c("TEXT", "tag"))), Rd_option = structure("=rational", Rd_tag = "TEXT"), class = c("tag_link", "tag"))), class = c("tag_code", "tag")), structure(" values are interpreted as frequency ratios, assuming a ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Pythagorean_tuning", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("Pythagorean tuning", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("For example, the value ", class = c("TEXT", "tag")), structure(list(structure("2.0", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will be interpreted as an octave (two to one ratio.)\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("However, the most useful tool for humdrum data is parsing pitch representations encoded in ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" tokens.\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" regex/exclusive parsing system is used to interpret character strings as tonalIntervals.\n", class = c("TEXT", "tag")), structure("This includes character tokens with pitch information embedded alongside other information, like ", class = c("TEXT", "tag")), structure(list(structure("\"4.ee", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" in a kern token.\n", class = c("TEXT", "tag")), structure("There are six regex-patterns that ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" known how to parse automatically:", class = c("TEXT", "tag")), structure(list(structure(list(structure("lcr", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure(" Representation ", class = c("TEXT", "tag")), structure(list(), class = c("tag_tab", "tag")), structure(" Exclusive ", class = c("TEXT", "tag")), structure(list(), class = c("tag_tab", "tag")), structure(" Example ", class = c("TEXT", "tag")), structure(list(), class = c("tag_cr", "tag")), structure("\n", class = c("TEXT", "tag")), structure(" Kern ", class = c("TEXT", "tag")), structure(list(), class = c("tag_tab", "tag")), structure(" **kern ", class = c("TEXT", "tag")), structure(list(), class = c("tag_tab", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("ee-", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(), class = c("tag_cr", "tag")), structure("\n", class = c("TEXT", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Scientific_pitch", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("Scientific Pitch", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(), class = c("tag_tab", "tag")), structure(" **pitch ", class = c("TEXT", "tag")), structure(list(), class = c("tag_tab", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Eb5", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(), class = c("tag_cr", "tag")), structure("\n", class = c("TEXT", "tag")), structure(" Interval ", class = c("TEXT", "tag")), structure(list(), class = c("tag_tab", "tag")), structure(" **hint/**mint/**int ", class = c("TEXT", "tag")), structure(list(), class = c("tag_tab", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("+m3", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(), class = c("tag_cr", "tag")), structure("\n", class = c("TEXT", "tag")), structure(" Scale degree ", class = c("TEXT", "tag")), structure(list(), class = c("tag_tab", "tag")), structure(" **deg ", class = c("TEXT", "tag")), structure(list(), class = c("tag_tab", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("b3", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(), class = c("tag_cr", "tag")), structure("\n", class = c("TEXT", "tag")), structure(" Solfege ", class = c("TEXT", "tag")), structure(list(), class = c("tag_tab", "tag")), structure(" **solfa ", class = c("TEXT", "tag")), structure(list(), class = c("tag_tab", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("me", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(), class = c("tag_cr", "tag")), structure("\n", class = c("TEXT", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://lilypond.org/doc/v2.22/Documentation/notation/pitches", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("Lilypond pitch", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(), class = c("tag_tab", "tag")), structure(" none ", class = c("TEXT", "tag")), structure(list(), class = c("tag_tab", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("ees'", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(), class = c("tag_cr", "tag")), structure("\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_tabular", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("If you call ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (or ", class = c("TEXT", "tag")), structure(list(structure("any function that uses tonalInterval as a parser", class = c("TEXT", "tag"))), Rd_option = structure("=pitch", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(") on a ", class = c("TEXT", "tag")), structure(list(structure("character", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" string,\n", class = c("TEXT", "tag")), structure("the regex-system will automatically (attempt) to interpret the tokens as on the pitch types above---if there is a conflict\n", class = c("TEXT", "tag")), structure("the representations are favored in the order they are presented in the table above.\n", class = c("TEXT", "tag")), structure("If a matching exclusive interpretation (see table above) is provided using the ", class = c("TEXT", "tag")), structure(list(structure("Exclusive", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument,\n", class = c("TEXT", "tag")), structure("this choice overrides the regex-dispatch.\n", class = c("TEXT", "tag")), structure("If there is no match, an NA ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is returned.\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Parsing with Options", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("The six tonal representations listed above function through a common parsing interface.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag")), structure("M3 &lt;- tint( , 4L)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("M2 &lt;- tint( , 2L)\n", class = c("RCODE", "tag")), structure("M9 &lt;- tint(-1L, 2L)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("M9 - M2 \n", class = c("RCODE", "tag")), structure("# = octave\n", class = c("RCODE", "tag")), structure("M9 - 2L\n", class = c("RCODE", "tag")), structure("# = octave\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("M3 %/% M2 \n", class = c("RCODE", "tag")), structure("# = 2\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("###\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag")), structure("cMajor &lt;- sort(tint( , -1:5))\n", class = c("RCODE", "tag")), structure("eMajor &lt;- cMajor + M3\n", class = c("RCODE", "tag")), structure("eMajor + 2L \n", class = c("RCODE", "tag")), structure("# f# g# a# b cc# dd# ee#\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("eMajor[4:5] - octave \n", class = c("RCODE", "tag")), structure("# = A B\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("\"4.ee\" + P5 \n", class = c("RCODE", "tag")), structure("# = \"4.bb\"\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("\n", class = c("RCODE", "tag"))), class = c("tag_examples", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Other ", class = c("TEXT", "tag" )), structure(list(structure("core pitch representation", class = c("TEXT", "tag"))), class = c("LIST", "tag")), structure(": \n", class = c("TEXT", "tag")), structure(list(structure(list(structure("LO5th", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("()", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("core pitch representation", class = c("TEXT", "tag"))), class = c("LIST", "tag"))), class = c("tag_concept", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), tonalTransformations.Rd = structure(list(structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/tonalInterval.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("tonalTransformations", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("tonalTransformations", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("invert", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Invert or transpose tonal intervals.", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("invert(tint, around, Key, ...)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Invert or transpose tonal intervals.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), transpose.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/tonalInterval.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("transpose", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("transpose", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Transpose pitches and keys", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("transpose(x, by, Key, to, real, relative, ...)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("x", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("The input pitch(es) to transpose. A ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or something intepretable as a ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("by", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or something intepretable as a ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("The input ", class = c("TEXT", "tag")), structure(list(structure("x", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is transposed by this interval.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Key", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A ", class = c("TEXT", "tag")), structure(list(structure("diatonicSet", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or something intepretable as a ", class = c("TEXT", "tag")), structure(list(structure("diatonicSet", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". For tonal and/or to transpositions,\n", class = c("TEXT", "tag")), structure("this is the \"from\" key. If this value is ", class = c("TEXT", "tag")), structure(list(structure("NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", it defaults to C major.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("to", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A ", class = c("TEXT", "tag")), structure(list(structure("diatonicSet", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or something intepretable as a ", class = c("TEXT", "tag")), structure(list(structure("diatonicSet", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". The input ", class = c("TEXT", "tag")), structure(list(structure("x", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is transposed\n", class = c("TEXT", "tag")), structure("to this key.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("real", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A logical. If ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (the default), transposition is real. If ", class = c("TEXT", "tag")), structure(list(structure("FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", transposition is tonal.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("relative", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A logical. If ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" transposition is relative. If ", class = c("TEXT", "tag")), structure(list(structure("FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (the default), transposition is parallel.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" ))), class = c("tag_arguments", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("This function ", class = c("TEXT", "tag")), structure(list(structure("transposes", class = c("TEXT", "tag"))), Rd_option = structure("=https://en.wikipedia.org/wiki/Transposition_(music)", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" pitches or keys\n", class = c("TEXT", "tag")), structure("by various intervals or to target keys.\n", class = c("TEXT", "tag")), structure("Inside the box, inputs and transpositions take place as ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s or ", class = c("TEXT", "tag")), structure(list(structure("diatonicSet", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("s,\n", class = c("TEXT", "tag")), structure("but any numeric or character string representation of pitches can be transposed as well.\n", class = c("TEXT", "tag")), structure("This function is incorporated directly into ", class = c("TEXT", "tag")), structure(list(structure("tonalTransform", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(", and thence, all ", class = c("TEXT", "tag")), structure(list(structure("pitch translation", class = c("TEXT", "tag"))), Rd_option = structure("=pitchRepresentations", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure("\n", class = c("TEXT", "tag")), structure("functions, so you probably won't call it directly very often.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure("There are two distinct types of transposition (real and tonal).\n", class = c("TEXT", "tag")), structure("There are also two different approaches to ", class = c("TEXT", "tag")), structure(list(structure("specifying", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" transpositions: \"to\" and \"by\".\n", class = c("TEXT", "tag")), structure("\"To\" transpositions can also be either ", class = c("TEXT", "tag")), structure(list(structure("parallel", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("relative", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_details", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Types of Transposition", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("There are two different types of transposition: ", class = c("TEXT", "tag")), structure(list(structure("real", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" transposition and ", class = c("TEXT", "tag")), structure(list(structure("tonal", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure(" transposition.\n", class = c("TEXT", "tag")), structure("In ", class = c("TEXT", "tag" )), structure(list(structure("real", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" transposition, all inputs are transposed by the same ", class = c("TEXT", "tag")), structure(list(structure("specific", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" interval.\n", class = c("TEXT", "tag")), structure("For example, the pitches ", class = c("TEXT", "tag")), structure(list(structure("{C D E F G}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" could be transposed up a major second to ", class = c("TEXT", "tag")), structure(list(structure("{C D E F# G}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("In ", class = c("TEXT", "tag" )), structure(list(structure("tonal", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" transposition, inputs are transposed by ", class = c("TEXT", "tag")), structure(list(structure("generic", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" intervals, within a key.\n", class = c("TEXT", "tag")), structure("For example, the sequence ", class = c("TEXT", "tag")), structure(list(structure("{C D E F G}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(", in the key of C major, could be translated up a generic second\n", class = c("TEXT", "tag")), structure("to ", class = c("TEXT", "tag" )), structure(list(structure("{D E F G A}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("To choose between real and tonal transposition, use the ", class = c("TEXT", "tag")), structure(list(structure("real", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument:\n", class = c("TEXT", "tag")), structure(list(structure("real = TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" for real transposition, ", class = c("TEXT", "tag")), structure(list(structure("real = FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" for tonal transposition.\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Alterations", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Tonal transposition is complicated by the presence of any alterations in the input pitches.\n", class = c("TEXT", "tag")), structure("For instance, if we are given the pitches ", class = c("TEXT", "tag")), structure(list(structure("{C F# G D# E}`` in the key of C major, how should they by tonally transposed up a second, within C major? There is not one obvious, correct answer answer, which can be easily identified. The algorithm implemented by ", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("humdrumR` is as follows:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Alterations/accidentals in the input are identified. (In this case, F# and D#).\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" The generic pitches are transposed within the key, resulting in ", class = c("TEXT", "tag")), structure(list(structure("{D G A E F}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Alterations in the input are added to the output ", class = c("TEXT", "tag")), structure(list(structure("unless", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" the resulting pitches are interpreted as a comma\n", class = c("TEXT", "tag")), structure("by a call to ", class = c("TEXT", "tag")), structure(list(structure("tintPartion", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(", with a given enharmonic wrap value (the default is ", class = c("TEXT", "tag")), structure(list(structure("12", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag")), structure("In this example, adding the first accidental results in ", class = c("TEXT", "tag")), structure(list(structure("{G#}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" which is not a comma.\n", class = c("TEXT", "tag")), structure("However, the second accidental results in ", class = c("TEXT", "tag")), structure(list(structure("{E#}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" which ", class = c("TEXT", "tag")), structure(list(structure("is", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" a comma away from the natural ", class = c("TEXT", "tag")), structure(list(structure("{F}", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Thus, this accidental is not added to the output, resulting in ", class = c("TEXT", "tag")), structure(list(structure("{E}", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", not ", class = c("TEXT", "tag")), structure(list(structure("{E#}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("The resulting output is ", class = c("TEXT", "tag")), structure(list(structure("{D G# A E F}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_enumerate", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("The size of ", class = c("TEXT", "tag")), structure(list(structure("enharmonicWrap", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" effectively determines how extreme accidentals are allowed.\n", class = c("TEXT", "tag")), structure("The default value, ", class = c("TEXT", "tag")), structure(list(structure("12", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", assures that no output notes are enharmonically equivalent to notes in the key.\n", class = c("TEXT", "tag")), structure("To further illustrate, here is the sequence ", class = c("TEXT", "tag")), structure(list(structure("{C F# G D# E, B- A A- G C# D, B D- C}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" transposed\n", class = c("TEXT", "tag")), structure("tonally within C major by all seven possible generic intervals, with ", class = c("TEXT", "tag")), structure(list(structure("enharmonicWrap = 12", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(":\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag" ))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Specifying Transpositions", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("There are two approaches to specifying transpositions, the ", class = c("TEXT", "tag")), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("to", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" arguments.\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag")), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument must be an interval, and the input is translated by that interval.\n", class = c("TEXT", "tag")), structure("If the ", class = c("TEXT", "tag")), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" interval is specific but ", class = c("TEXT", "tag")), structure(list(structure("real = FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the input is treated as a generic interval,\n", class = c("TEXT", "tag")), structure("and tranposition takes place within the key indicated by the ", class = c("TEXT", "tag")), structure(list(structure("Key", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("The ", class = c("TEXT", "tag" )), structure(list(structure("to", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument translates an input ", class = c("TEXT", "tag")), structure(list(structure("to", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" a desired key.\n", class = c("TEXT", "tag")), structure("For example, if the input is in the key of E major but we want it transposed to G major, we could say ", class = c("TEXT", "tag")), structure(list(structure("to = '*E:'", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag" )), structure(list(structure("real = TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", input is simply translated to the root of the ", class = c("TEXT", "tag")), structure(list(structure("to", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" key, with all the exact same intervals.\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag" )), structure(list(structure("real = FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the input is translated to the root of the new key, with its intervals changed to match the new key as well.\n", class = c("TEXT", "tag")), structure("In either case, the result depends on what the input's key is, which is indicated by the ", class = c("TEXT", "tag")), structure(list(structure("standard", class = c("TEXT", "tag"))), Rd_option = structure("=tonalTransform", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("Key", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument.\n", class = c("TEXT", "tag")), structure("The ", class = c("TEXT", "tag")), structure(list(structure("Key", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" arguments is like the \"from\" key.\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag" )), structure(list(structure("Key = NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the input key is interpreted as C major.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Consider the input notes ", class = c("TEXT", "tag")), structure(list(structure("{D B C A# B, D C# D E D}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" in the key of the G major.\n", class = c("TEXT", "tag")), structure("If we specify ", class = c("TEXT", "tag")), structure(list(structure("to = e:, real = TRUE", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(", the output will be ", class = c("TEXT", "tag")), structure(list(structure("{B G# A F## G#, B A# B C# B}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("(Notice that even though the ", class = c("TEXT", "tag")), structure(list(structure("to", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" key is minor, the output is still clearly in E major).\n", class = c("TEXT", "tag")), structure("If we specify ", class = c("TEXT", "tag")), structure(list(structure("to = e:, real = FALSE", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(", the output will instead be ", class = c("TEXT", "tag")), structure(list(structure("{B G A F# G, B A# B C B}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Building off the previous example, consider how the input ", class = c("TEXT", "tag")), structure(list(structure("key", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" matters as well.\n", class = c("TEXT", "tag")), structure("If we use the same input notes (", class = c("TEXT", "tag")), structure(list(structure("{D B C A# B, D C# D E D}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(") but the input ", class = c("TEXT", "tag")), structure(list(structure("Key", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is C major, then:\n", class = c("TEXT", "tag")), structure("If we specify ", class = c("TEXT", "tag")), structure(list(structure("to = e:, real = TRUE", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(", the output will be ", class = c("TEXT", "tag")), structure(list(structure("{F# D# E C## D#, F# E# F# G# F#}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("If we specify ", class = c("TEXT", "tag")), structure(list(structure("to = e:, real = FALSE", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(", the output will instead be ", class = c("TEXT", "tag")), structure(list(structure("{F# D E C# D, F# E F# G F#}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("If ", class = c("TEXT", "tag")), structure(list(structure("both", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("to", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" are specified, the ", class = c("TEXT", "tag")), structure(list(structure("to", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" transposition is applied first, followed by the ", class = c("TEXT", "tag")), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" transposition.\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag")), structure(list(structure("real = FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the ", class = c("TEXT", "tag")), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" transposition happens within the ", class = c("TEXT", "tag")), structure(list(structure("to", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" key, not the ", class = c("TEXT", "tag")), structure(list(structure("Key", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" key.\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Relative vs Parallel", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("When transposing to, we have diferent approaches about to determining the relationship between the\n", class = c("TEXT", "tag")), structure("\"from\" key (", class = c("TEXT", "tag")), structure(list(structure("Key", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument) and the \"to\" key (", class = c("TEXT", "tag")), structure(list(structure("to", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument).\n", class = c("TEXT", "tag")), structure("If we think of \"parallel\" relationships between keys, we match the roots of the keys regardless of modes.\n", class = c("TEXT", "tag")), structure("For instance, C major and C minor are parallel keys.\n", class = c("TEXT", "tag")), structure("If we instead think of \"relative\" relationships between keys, we match the modes of the keys, not the roots.\n", class = c("TEXT", "tag")), structure("For instance, C major and A minor are relative keys.\n", class = c("TEXT", "tag")), structure("This is similar to the distinction between \"la-based minor\" solfege (relative) vs \"fixed-do\" solfege (parallel).\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("When transposing using a ", class = c("TEXT", "tag")), structure(list(structure("to", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument, if ", class = c("TEXT", "tag")), structure(list(structure("relative = FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" the input key (", class = c("TEXT", "tag")), structure(list(structure("Key", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument) is transposed to match the ", class = c("TEXT", "tag")), structure(list(structure("root", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure("\n", class = c("TEXT", "tag")), structure("of the ", class = c("TEXT", "tag")), structure(list(structure("to", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument.\n", class = c("TEXT", "tag")), structure("For example, if the input key is G minor and the ", class = c("TEXT", "tag")), structure(list(structure("to`` key is C major, the output is transposed to G minor. However, if ", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("relative = TRUE", class = c("TEXT", "tag")), structure(list(structure("the input key is transposed to match the mode of the", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("to", class = c("TEXT", "tag")), structure(list(structure("key: A G minor input with a C major", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("to", class = c("TEXT", "tag")), structure(list(structure("would be translated to A minor, the parallel minor of the", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("to", class = c("TEXT", "tag")), structure(list(structure("key. If the", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("Key", class = c("TEXT", "tag")), structure(list(structure("(from key) and", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("to` (to key) arguments have the same mode, the parallel and relative transpositions\n", class = c("TEXT", "tag")), structure("are the same.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_subsection", "tag")), structure("\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Special Operators +-", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("As a note, real transposition ", class = c("TEXT", "tag")), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and interval can be achieved more concisely using the ", class = c("TEXT", "tag")), structure(list(structure("+", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("-", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" operators,\n", class = c("TEXT", "tag")), structure("as long as at least one side of the operators is an actual ", class = c("TEXT", "tag")), structure(list(structure("tonalInterval", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object.\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" preassigns all common tonalIntervals to objects in your global environment.\n", class = c("TEXT", "tag")), structure("Thus, you can type commands like ", class = c("TEXT", "tag")), structure(list(structure("\"c#\" + M2", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" to get ", class = c("TEXT", "tag")), structure(list(structure("d#", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", or ", class = c("TEXT", "tag")), structure(list(structure("c(\"C4\", \"E4\", \"C5\") - m6", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" to get ", class = c("TEXT", "tag")), structure(list(structure("\"E3\" \"G#3\" \"E4\"", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("TEXT", "tag")), structure("tonalTransformations\n", class = c("TEXT", "tag"))), class = c("tag_seealso", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), withinHumdrum.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Apply.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("withHumdrum", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("inHumdrum", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("humApply", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("with(in)Humdrum", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("withinHumdrum(humdrumR, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("withHumdrum(humdrumR, ..., drop = TRUE)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("inHumdrum(humdrumR, ...)\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("humApply(humdrumR, FUN, ..., within = TRUE, doplot = FALSE)\n", class = c("RCODE", "tag"))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("humdrumR", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A ", class = c("TEXT", "tag")), structure(list(structure("humdrumRclass", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(" data object.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("...", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("Any arguments which can be fed to\n", class = c("TEXT", "tag")), structure(list(structure("[humdrumR:with-in-Humdrum][with(in)Humdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" as formulae (except for\n", class = c("TEXT", "tag")), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expressions, which are replaced by the ", class = c("TEXT", "tag")), structure(list(structure("FUN", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument!).\n", class = c("TEXT", "tag")), structure("However, rather that writinging formula in the format ", class = c("TEXT", "tag")), structure(list(structure("Keyword ~ Expression", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag")), structure(list(structure("humApply", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" arguments should be written as normal ", class = c("TEXT", "tag")), structure(list(structure("R", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" arguments:\n", class = c("TEXT", "tag")), structure(list(structure("Keyword = Expression", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Unnamed arguments are ignored.\n", class = c("TEXT", "tag")), structure("#' @param within A logical. If ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (the default),\n", class = c("TEXT", "tag")), structure(list(structure("[humdrumR:with-in-Humdrum][withinHumdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" is used to apply the\n", class = c("TEXT", "tag")), structure("function---meaning that the output is reconstituted into a new field in the\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" object. If ", class = c("TEXT", "tag")), structure(list(structure("within == FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(",\n", class = c("TEXT", "tag")), structure(list(structure("[humdrumR:with-in-Humdrum][withHumdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" is used instead,\n", class = c("TEXT", "tag")), structure("which results in the function's output being returned inprocessed.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("drop", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("This argument is concetually similar to the ", class = c("TEXT", "tag")), structure(list(structure("drop", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument in R matrices and data.frames.\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag" )), structure(list(structure("drop = TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the output of ", class = c("TEXT", "tag")), structure(list(structure("withHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is simplified as much as possible (trying to return\n", class = c("TEXT", "tag")), structure("the \"raw\" vector, list, table, etc. within it). If ", class = c("TEXT", "tag")), structure(list(structure("drop = FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the result is ", class = c("TEXT", "tag")), structure(list(structure("always", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure("\n", class = c("TEXT", "tag")), structure("a ", class = c("TEXT", "tag" )), structure(list(structure("data.table", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". The default value (", class = c("TEXT", "tag")), structure(list(structure("drop = TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") is usually what we want because it is more\n", class = c("TEXT", "tag")), structure("intuitive, but in more complex code, it can be helpful to set ", class = c("TEXT", "tag")), structure(list(structure("drop = FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" so that\n", class = c("TEXT", "tag")), structure("the output is consistent.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("FUN", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("A function to apply to the ", class = c("TEXT", "tag")), structure(list(structure("humdrumR:humdrumR", class = c("TEXT", "tag"))), Rd_option = structure("=Active", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(list(structure("field(s) in the", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("humdrumR` object.", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("doplot", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("Boolean. If ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" the ", class = c("TEXT", "tag")), structure(list(structure("FUN", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument is treated\n", class = c("TEXT", "tag")), structure("as a ", class = c("TEXT", "tag")), structure(list(structure("doplot", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression by ", class = c("TEXT", "tag")), structure(list(structure("[humdrumR:with-in-Humdrum][with(in)Humdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(",\n", class = c("TEXT", "tag")), structure("so the result is ignored (for plotting or side-effects purposes).", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_item", "tag")), structure("\n", class = c("TEXT", "tag" ))), class = c("tag_arguments", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("From ", class = c("TEXT", "tag" )), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("inHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", a new humdrumR data object.\n", class = c("TEXT", "tag")), structure("From ", class = c("TEXT", "tag" )), structure(list(structure("withHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", whatever value is returned by expression.\n", class = c("TEXT", "tag"))), class = c("tag_value", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("Apply arbitrary expressions to fields within ", class = c("TEXT", "tag")), structure(list(structure("[S4class][humdrumRclass]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" data.\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("Overview", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("These functions are the primary means of working with\n", class = c("TEXT", "tag")), structure("humdrumR data. (They are analogous to the base functions\n", class = c("TEXT", "tag")), structure(list(structure("[base][with]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("[base][within]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("\n", class = c("TEXT", "tag")), structure("as applied to ", class = c("TEXT", "tag")), structure(list(structure("[base:data.frame][data.frames]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".)\n", class = c("TEXT", "tag")), structure("Specifically they allow you to evaluate arbitrary\n", class = c("TEXT", "tag")), structure("expressions involving fields in a humdrumR data object.\n", class = c("TEXT", "tag")), structure("They also includes a number of special evaluation options:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Evaluate an expression in only matching parts of the data.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Evaluate an expression separately in subsets of the data.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Evaluate an expression across windows in the data (e.g., ngrams, rolling windows).\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" Evaluate an expression which produces a plot, with particular plotting parameters set using ", class = c("TEXT", "tag")), structure(list(structure("[graphics][par]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = c("tag_itemize", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("The difference between ", class = c("TEXT", "tag")), structure(list(structure("withHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is\n", class = c("TEXT", "tag")), structure("analogous to the difference between ", class = c("TEXT", "tag")), structure(list(structure("[base][with]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("[base][within]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(structure("withHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" evaluates your expression(s) and then simply returns the result of\n", class = c("TEXT", "tag")), structure("the evaluation. ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" evaluates your expression(s) and then\n", class = c("TEXT", "tag")), structure("(attempts) to insert the results back into the humdrumR object, generating new\n", class = c("TEXT", "tag")), structure("fields called ", class = c("TEXT", "tag")), structure(list(structure("PipeX", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (see details).\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(structure("inHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is simply a short hand for ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure(list(structure("Formulae", class = c("RCODE", "tag"))), class = c("tag_code", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Every formula in the ", class = c("TEXT", "tag")), structure(list(structure("formulae", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument\n", class = c("TEXT", "tag")), structure("is treated as a ", class = c("TEXT", "tag")), structure(list(structure("Keyword ~ Expression(s)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("pairing. Multiple expressions can be input using multiple ", class = c("TEXT", "tag")), structure(list(structure("~", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" operators:\n", class = c("TEXT", "tag")), structure(list(structure("Keyword ~ Expression1 [~ Expression2 ~ ... ~ ExpressionN]", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("(the leftmost expression is treated as the keyword.)\n", class = c("TEXT", "tag")), structure("If there is no leftmost expression (i.e., ", class = c("TEXT", "tag")), structure(list(structure("~ Expression", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("), the Keyword\n", class = c("TEXT", "tag")), structure("defaults to \"", class = c("TEXT", "tag")), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\" The keyword expression must be a single, simple name/symbol, following\n", class = c("TEXT", "tag")), structure("standard R rules (i.e., \"", class = c("TEXT", "tag")), structure(list(structure(".foobar", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\" is acceptable but \"", class = c("TEXT", "tag")), structure(list(structure("3 + foobar", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\" is not).\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("Legal keywords, and their meanings are:\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" An expression to be evaluated within the ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data object (see \"Expression evaluation\").\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("doplot", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" An expression to be evaluated within the ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data object while ignoring the result of the expression (see \"Expression evaluation\" and \"Plotting\".\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" An expression used to break the data into groups, with the ", class = c("TEXT", "tag")), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression(s) evaluated\n", class = c("TEXT", "tag")), structure("separately in each group (see \"Partitioning\").\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("where", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" An expression indicating a subset of the data in which to evaluate the ", class = c("TEXT", "tag")), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression (see \"Partitioning\").\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("ngrams", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" A positive number ", class = c("TEXT", "tag")), structure(list(structure("n", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(". The expression is evaluated across overlapping length-", class = c("TEXT", "tag")), structure(list(structure("n", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" windows.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("recordtypes", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" A string or vector of characters drawn from ", class = c("TEXT", "tag")), structure(list(structure("c(\"D\", \"d\", \"I\", \"L\", \"M\",\"G\")", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". These characters\n", class = c("TEXT", "tag")), structure("correspond to types of humdrum records: ", class = c("TEXT", "tag")), structure(list(structure("D", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure("ata, null ", class = c("TEXT", "tag")), structure(list(structure("d", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure("ata, ", class = c("TEXT", "tag")), structure(list(structure("I", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure("nterpretations,\n", class = c("TEXT", "tag")), structure(list(structure("M", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure("easures, ", class = c("TEXT", "tag")), structure(list(structure("L", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure("ocal comments, and ", class = c("TEXT", "tag")), structure(list(structure("G", class = c("TEXT", "tag"))), class = c("tag_strong", "tag")), structure("lobal comments respectively. The expression\n", class = c("TEXT", "tag")), structure("is only evaluated on data drawn from the specified record types (defaults to ", class = c("TEXT", "tag")), structure(list(structure("\"D\"", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(").\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("pre", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" An expression to evaluate once before evaluating the do expression(s). Useful, for instance, for taking logs\n", class = c("TEXT", "tag")), structure("or opening a graphing window. The ", class = c("TEXT", "tag")), structure(list(structure("pre", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression is evaluated in the global environment.\n", class = c("TEXT", "tag")), structure(list(), class = c("tag_item", "tag")), structure(" ", class = c("TEXT", "tag" )), structure(list(structure("post", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" An expression evaluate once after evaluating the do expression(s). Always evaluated in the global environment.\n", class = c("TEXT", "tag"))), class = c("tag_enumerate", "tag")), structure("\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Expression evaluation", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("The right-hand side of any formula in the ", class = c("TEXT", "tag")), structure(list(structure("formulae", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument with the keyword ", class = c("TEXT", "tag")), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" or ", class = c("TEXT", "tag")), structure(list(structure("doplot", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("(or with no keyword specified) is evaluated within the ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data object.\n", class = c("TEXT", "tag")), structure("The expression can, thus, refer to any field in the humdrumR object (Record, Token, File, etc.).\n", class = c("TEXT", "tag")), structure("You can also include a ", class = c("TEXT", "tag")), structure(list(structure(".", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" anywhere in the expression, which will be\n", class = c("TEXT", "tag")), structure("interpreted as the humdrumR object's current ", class = c("TEXT", "tag")), structure(list(structure("[dest=humdrumR][Active]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("\n", class = c("TEXT", "tag")), structure("expression.", class = c("TEXT", "tag")), structure(list(structure("humdata &lt;- readHumdrum('directorywithdata/*.krn') # read some data\n", class = c("VERB", "tag")), structure("\n", class = c("VERB", "tag")), structure("withinHumdrum(humdata, ~getPitch(Token)) # The most basic pattern\n", class = c("VERB", "tag")), structure("withinHumdrum(humdata, ~getPitch(.)) # Same as previous (unless `Active` field has been changed))\n", class = c("VERB", "tag")), structure("\n", class = c("VERB", "tag")), structure("withinHumdrum(humdata, ~solfa(getPitch(Token), key = Key)) \n", class = c("VERB", "tag")), structure("# Assumes that the Key field was parsed during the call to `[readHumdrum][readHumdrum]`\n", class = c("VERB", "tag")), structure("\n", class = c("VERB", "tag")), structure("withinHumdrum(humdata, ~getSemits(Token) - mean(getSemits(Token))) \n", class = c("VERB", "tag")), structure("\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag" )), structure("If multiple ", class = c("TEXT", "tag")), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expressions are provided, they are each evaluated one at a time,\n", class = c("TEXT", "tag")), structure("with the result of each piped into the next. Other, non-", class = c("TEXT", "tag")), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", formulae (like ", class = c("TEXT", "tag")), structure(list(structure("by~", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" or\n", class = c("TEXT", "tag")), structure(list(structure("ngrams~", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(") are reused for each expression evaluated.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Partitioning", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("A ", class = c("TEXT", "tag")), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression is used to break the data into subsets, with the ", class = c("TEXT", "tag")), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression(s) evaluated\n", class = c("TEXT", "tag")), structure("separately within each subset. This works the similarly to the ", class = c("TEXT", "tag")), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument in\n", class = c("TEXT", "tag")), structure(list(structure("[data.table][data.table]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("s, the ", class = c("TEXT", "tag")), structure(list(structure("INDEX", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("argument of ", class = c("TEXT", "tag")), structure(list(structure("[base][tapply]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(", or the ", class = c("TEXT", "tag")), structure(list(structure("INDICES", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument of ", class = c("TEXT", "tag")), structure(list(structure("[base][by]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Each ", class = c("TEXT", "tag")), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression must evaluate, within the ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data object, to a vector (or a list of vectors\n", class = c("TEXT", "tag")), structure("of equal length) of categories to group the data by.\n", class = c("TEXT", "tag")), structure("Most commonly, the ", class = c("TEXT", "tag")), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression(s) are simply field(s) in the data:\n", class = c("TEXT", "tag")), structure("for instance,", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum(humdata,\n", class = c("VERB", "tag")), structure(" do ~ table(Token),\n", class = c("VERB", "tag")), structure(" by ~ File)\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag" )), structure("will apply the function ", class = c("TEXT", "tag")), structure(list(structure("[base][table]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" to the ", class = c("TEXT", "tag")), structure(list(structure("Token", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field\n", class = c("TEXT", "tag")), structure(list(structure("separately", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" for each file in the ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data.\n", class = c("TEXT", "tag")), structure("However, we can also use more complex expressions like", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum(humdata,\n", class = c("VERB", "tag")), structure(" do ~ table(Token), \n", class = c("VERB", "tag")), structure(" by ~ Spine &gt; 3 | Record \\%\\% 2 == 0)\n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag" )), structure("which will evaluate the do expression in two groups, one where either the spine number is\n", class = c("TEXT", "tag")), structure("three or less ", class = c("TEXT", "tag")), structure(list(structure("or", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" the record number is even, and another group where the opposite is true.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("If the ", class = c("TEXT", "tag")), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression evaluates to a list of grouping vectors,\n", class = c("TEXT", "tag")), structure("the ", class = c("TEXT", "tag")), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expressions are evaulated across every combination of categories in all the vectors.\n", class = c("TEXT", "tag")), structure("Thus,\n", class = c("TEXT", "tag")), structure("withinHumdrum(humdata,\n", class = c("TEXT", "tag")), structure("do ~ table(Token),\n", class = c("TEXT", "tag")), structure("by ~ list(File, Spine))\n", class = c("TEXT", "tag")), structure("will apply ", class = c("TEXT", "tag")), structure(list(structure("table", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" to ", class = c("TEXT", "tag")), structure(list(structure("Token", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" across each spine ", class = c("TEXT", "tag")), structure(list(structure("in", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" each file.\n", class = c("TEXT", "tag")), structure("As some ", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Syntactic_sugarsyntactic", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("syntactic sugar", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure(", if the\n", class = c("TEXT", "tag")), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression has more than two parts, all parts except\n", class = c("TEXT", "tag")), structure("the (leftmost) keyword part are combined in a list (i.e., ", class = c("TEXT", "tag")), structure(list(structure("by ~ File ~ Spine", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("becomes ", class = c("TEXT", "tag")), structure(list(structure("by ~ list(File, Spine)}", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Thus the previous example can also be written:\n", class = c("TEXT", "tag")), structure("withinHumdrum(humdata,\n", class = c("TEXT", "tag")), structure("do ~ table(Token),\n", class = c("TEXT", "tag")), structure("by ~ File ~ Spine)\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("A ", class = c("TEXT", "tag")), structure(list(structure("where", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression is used to identify a subset of the data and evaluate\n", class = c("TEXT", "tag")), structure("the ", class = c("TEXT", "tag")), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression(s) ", class = c("TEXT", "tag")), structure(list(structure("only", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" in that subset.\n", class = c("TEXT", "tag")), structure(list(structure("where", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expressions must evaluated, within the ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data object, to\n", class = c("TEXT", "tag")), structure("a single logical vector. The ", class = c("TEXT", "tag")), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression(s) are only evaluated where this logical\n", class = c("TEXT", "tag")), structure("vector is ", class = c("TEXT", "tag")), structure(list(structure("TRUE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("Wherever the ", class = c("TEXT", "tag")), structure(list(structure("where", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression evaluates to ", class = c("TEXT", "tag")), structure(list(structure("FALSE", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the original ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data is\n", class = c("TEXT", "tag")), structure("kept unchanged.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("If multiple partitioning formulae (i.e, ", class = c("TEXT", "tag")), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" and ", class = c("TEXT", "tag")), structure(list(structure("where", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(") expressions\n", class = c("TEXT", "tag")), structure("are evaluated recursively, in order from left to right. Thus if you specify\n", class = c("TEXT", "tag")), structure("withinHumdrum(humdata,\n", class = c("TEXT", "tag")), structure("do ~ sd(semits),\n", class = c("TEXT", "tag")), structure("by ~ File,\n", class = c("TEXT", "tag")), structure("where ~ semits &gt; mean(semits))\n", class = c("TEXT", "tag")), structure("a the standard deviation of the ", class = c("TEXT", "tag")), structure(list(structure("semits", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field will be calculated only in each file,\n", class = c("TEXT", "tag")), structure("but only where the ", class = c("TEXT", "tag")), structure(list(structure("semits", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field is greater than the mean ", class = c("TEXT", "tag")), structure(list(structure("semits", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" value\n", class = c("TEXT", "tag")), structure(list(structure("within that file", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(". Contrast this with this call:\n", class = c("TEXT", "tag")), structure("withinHumdrum(humdata,\n", class = c("TEXT", "tag")), structure("do ~ sd(semits)\n", class = c("TEXT", "tag")), structure("where ~ semits &gt; mean(semits),\n", class = c("TEXT", "tag")), structure("by ~ File)\n", class = c("TEXT", "tag")), structure("wherein the standard deviation of ", class = c("TEXT", "tag")), structure(list(structure("semits", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is, again, calculated for each file,\n", class = c("TEXT", "tag")), structure("but this time wherever the ", class = c("TEXT", "tag")), structure(list(structure("semits", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field is greater than the mean value ", class = c("TEXT", "tag")), structure(list(structure("across all the data", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(".\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Plotting", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("The ", class = c("TEXT", "tag" )), structure(list(structure("doplot", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" keyword behaves exactly like the ", class = c("TEXT", "tag")), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" keyword, except that the result of the\n", class = c("TEXT", "tag")), structure("evaluation is ignored. This is useful for plotting ", class = c("TEXT", "tag")), structure(list(structure("as well as", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" other side-effects (like writing to a file).\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag" )), structure(list(structure("doplot", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is used with ", class = c("TEXT", "tag")), structure(list(structure("withHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the function simply returns ", class = c("TEXT", "tag")), structure(list(structure("NULL", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (after executing the ", class = c("TEXT", "tag")), structure(list(structure("doplot", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("expression\n", class = c("TEXT", "tag")), structure("If ", class = c("TEXT", "tag" )), structure(list(structure("doplot", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is used with ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (or ", class = c("TEXT", "tag")), structure(list(structure("inHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("), the function simply returns the unaltered\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument.\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" also allows you to specify plotting options in line, without having to make a separate call\n", class = c("TEXT", "tag")), structure("to ", class = c("TEXT", "tag" )), structure(list(structure("[graphics][par]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(". Any ", class = c("TEXT", "tag")), structure(list(structure("[graphics][par]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" argument can be specified as a ", class = c("TEXT", "tag")), structure(list(structure("Keyword ~ Expression", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" pair\n", class = c("TEXT", "tag")), structure("in the ", class = c("TEXT", "tag")), structure(list(structure("formulae", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" argument. For instance, if you call a ", class = c("TEXT", "tag")), structure(list(structure("doplot", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression with a ", class = c("TEXT", "tag")), structure(list(structure("by", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression\n", class = c("TEXT", "tag")), structure("that creates four groups, R will create four plots---but you will only see the last one! Normally, you would need to\n", class = c("TEXT", "tag")), structure("call ", class = c("TEXT", "tag")), structure(list(structure("par(mfcol = c(2,2))", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" ", class = c("TEXT", "tag")), structure(list(structure("before", class = c("TEXT", "tag"))), class = c("tag_emph", "tag")), structure(" calling your plotting function. However, with ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" you can\n", class = c("TEXT", "tag")), structure("soecific ", class = c("TEXT", "tag")), structure(list(structure("mfcol = c(2,2)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" right in a ", class = c("TEXT", "tag")), structure(list(structure("formulae", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" formula:\n", class = c("TEXT", "tag")), structure("withinHumdrum(humdata,\n", class = c("TEXT", "tag")), structure("doplot ~ fooplot(.),\n", class = c("TEXT", "tag")), structure("by ~ list(Two, byTwo),\n", class = c("TEXT", "tag")), structure("mfcol ~ c(2, 2))\n", class = c("TEXT", "tag")), structure("The best part is ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will reset ", class = c("TEXT", "tag")), structure(list(structure("par", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" to it's previous state after ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" is done.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Tandem interpretations", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("The function ", class = c("TEXT", "tag")), structure(list(structure("[readHumdrum][readHumdrum]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" automatically parses\n", class = c("TEXT", "tag")), structure("tandem interpretations (that it recognizes) into\n", class = c("TEXT", "tag")), structure("their own fields in the resulting ", class = c("TEXT", "tag")), structure(list(structure("[humdrumR][humdrumRclass]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" data.\n", class = c("TEXT", "tag")), structure("For instance, data with a ", class = c("TEXT", "tag")), structure(list(structure("'*clefF4'", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will show\n", class = c("TEXT", "tag")), structure("up as a ", class = c("TEXT", "tag")), structure(list(structure("Clef", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field. However, users might read humdrum data with their\n", class = c("TEXT", "tag")), structure("own custom tandem interpretations that are not built into ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" includes the function ", class = c("TEXT", "tag")), structure(list(structure("[getTandem][getTandem]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" to help us\n", class = c("TEXT", "tag")), structure("extract arbitrary tandem intrpretation data.\n", class = c("TEXT", "tag")), structure("Luckily, ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" knows some\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Syntactic_sugarsyntactic", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("syntactic sugar", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure("\n", class = c("TEXT", "tag")), structure("which makes it easy to do this anywhere in our expressions, simply by putting a\n", class = c("TEXT", "tag")), structure("named object beginning with the symbol ", class = c("TEXT", "tag")), structure(list(structure("*", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(". Of course, R doesn't normally\n", class = c("TEXT", "tag")), structure("allow names to begin with symbols like ", class = c("TEXT", "tag")), structure(list(structure("*", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", but you can force it by\n", class = c("TEXT", "tag")), structure("placing grave symbols around the name ", class = c("TEXT", "tag")), structure(list(structure("*name", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(". If you do this in a ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure("\n", class = c("TEXT", "tag")), structure("expression, ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will treat this name as a\n", class = c("TEXT", "tag")), structure("regular expression and substitute a call ", class = c("TEXT", "tag")), structure(list(structure("getTandem(Tandem, 'regular expression')", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" in the expression.\n", class = c("TEXT", "tag")), structure("This means you can could do something like\n", class = c("TEXT", "tag")), structure("withinHumdrum(humdata,\n", class = c("TEXT", "tag")), structure("do ~ myFunction(Token, ", class = c("TEXT", "tag")), structure(list(structure("*mytandempattern", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure("))\n", class = c("TEXT", "tag")), structure("and ", class = c("TEXT", "tag")), structure(list(structure("myFunction", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will be called with the first argument being the\n", class = c("TEXT", "tag")), structure(list(structure("Token", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field, and the second argument being tandem interpretations\n", class = c("TEXT", "tag")), structure("which match ", class = c("TEXT", "tag")), structure(list(structure("'mytandempattern'", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" (extracted from the ", class = c("TEXT", "tag")), structure(list(structure("Tandem", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" field).\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Splatting", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("(\"Splatting\" refers to feeding a function a list/vector of arguments.)\n", class = c("TEXT", "tag")), structure("Sometimes we want to divide our data into pieces (a l\\'a ", class = c("TEXT", "tag")), structure(list(structure("partition", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" option), but\n", class = c("TEXT", "tag")), structure("rather than applying the same expression to each piece, we want to feed\n", class = c("TEXT", "tag")), structure("the separate pieces as separate arguments to the same function.\n", class = c("TEXT", "tag")), structure("In ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" you can use some\n", class = c("TEXT", "tag")), structure(list(structure(list(structure("https://en.wikipedia.org/wiki/Syntactic_sugarsyntactic", class = c("VERB", "tag"))), class = "tag"), structure(list(structure("syntactic sugar", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_href", "tag")), structure("\n", class = c("TEXT", "tag")), structure("to do just this, using the ", class = c("TEXT", "tag")), structure(list(structure("@", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" symbol in the format ", class = c("TEXT", "tag")), structure(list(structure("myFunction(TargetExpr@GroupingExpr)", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(".\n", class = c("TEXT", "tag")), structure("If we make this call\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("withinHumdrum(humdata,\n", class = c("TEXT", "tag")), structure("do ~ myFunction(Token@Spine))\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("and there are four spines\n", class = c("TEXT", "tag")), structure("this is how ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" will intepret the expression:\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("withinHumdrum(humData,\n", class = c("TEXT", "tag")), structure("do ~ myFunction(Token", class = c("TEXT", "tag")), structure(list(structure("Spine == 1", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(", # first argument when Spine == 1\n", class = c("TEXT", "tag")), structure("Token", class = c("TEXT", "tag")), structure(list(structure("Spine == 2", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(", # second argument when Spine == 2\n", class = c("TEXT", "tag")), structure("Token", class = c("TEXT", "tag")), structure(list(structure("Spine == 3", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure(", # etc.\n", class = c("TEXT", "tag")), structure("Token", class = c("TEXT", "tag")), structure(list(structure("Spine == 4", class = c("TEXT", "tag"))), class = c("tag_link", "tag")), structure("))\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Argument interpolation", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("Any named arguments to ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" are ", class = c("TEXT", "tag")), structure(list(structure("[humdrumR:interpolateArguments][interpolated]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(" into the\n", class = c("TEXT", "tag")), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expressions. This is useful if you've already created a list of formulas that you like, but would like\n", class = c("TEXT", "tag")), structure("to make small changes to a function call within the ", class = c("TEXT", "tag")), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expressions, without starting from scratch.\n", class = c("TEXT", "tag")), structure("Examples:", class = c("TEXT", "tag")), structure(list(structure("mycommand &lt;- c(do ~ mean(., na.rm = TRUE), by ~ Spine ~ File)\n", class = c("VERB", "tag")), structure("withinHumdrum(humdata,\n", class = c("VERB", "tag")), structure(" mycommand,\n", class = c("VERB", "tag")), structure(" na.rm = FALSE)\n", class = c("VERB", "tag")), structure("# mycommand is executed with na.rm changed to FALSE \n", class = c("VERB", "tag"))), class = c("tag_preformatted", "tag" )), structure("\n", class = c("TEXT", "tag" ))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure(list(structure("Piping", class = c("TEXT", "tag"))), class = "tag"), structure(list(structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag" )), structure("\n", class = c("TEXT", "tag")), structure("For calls to ", class = c("TEXT", "tag")), structure(list(structure("withinHumdrum", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the result of each ", class = c("TEXT", "tag")), structure(list(structure("do", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" expression\n", class = c("TEXT", "tag")), structure("is insterted back into the ", class = c("TEXT", "tag")), structure(list(structure("[humtable][humdrum table]", class = c("VERB", "tag"))), class = c("tag_verb", "tag")), structure(". The results\n", class = c("TEXT", "tag")), structure("are put into new field(s) labeled Pipe1, PipeX, ..., PipeN. If the results\n", class = c("TEXT", "tag")), structure("of the expression are shorter than the rows in the ", class = c("TEXT", "tag")), structure(list(structure("humtable", class = c("TEXT", "tag"))), Rd_option = structure("=humdrum table", Rd_tag = "TEXT"), class = c("tag_link", "tag")), structure(",\n", class = c("TEXT", "tag")), structure("or an ", class = c("TEXT", "tag")), structure(list(structure("object", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(", the humdrum table is shrunk to fit them.\n", class = c("TEXT", "tag"))), class = "tag")), class = c("tag_section", "tag")), structure("\n", class = c("TEXT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list( structure("\n", class = c("RCODE", "tag")), structure("humdata &lt;- readHumdrum('directorywithdata/*.krn')\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" )), structure("withinHumdrum(humdata, ~nchar(.)) # counts characters in each data token.\n", class = c("RCODE", "tag")), structure("withinHumdrum(humdata, ~table(.), by ~ Spine) # Tabulates data tokens in each Spine.\n", class = c("RCODE", "tag")), structure("\n", class = c("RCODE", "tag" ))), class = c("tag_examples", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag")), writeHumdrum.Rd = structure(list( structure("% Generated by roxygen2: do not edit by hand", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure("% Please edit documentation in R/Write.R", class = c("COMMENT", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("writeHumdrum", class = c("VERB", "tag"))), class = c("tag_name", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("writeHumdrum", class = c("VERB", "tag"))), class = c("tag_alias", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("Write ", class = c("TEXT", "tag")), structure(list(structure("humdrumR", class = c("RCODE", "tag"))), class = c("tag_code", "tag")), structure(" data to humdrum files.", class = c("TEXT", "tag"))), class = c("tag_title", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("RCODE", "tag")), structure("writeHumdrum(\n", class = c("RCODE", "tag")), structure(" humdrumR,\n", class = c("RCODE", "tag")), structure(" fieldname = NULL,\n", class = c("RCODE", "tag")), structure(" affix = \"_humdrumR\",\n", class = c("RCODE", "tag")), structure(" prefix = \"\",\n", class = c("RCODE", "tag")), structure(" rename = NULL,\n", class = c("RCODE", "tag")), structure(" extension = NULL,\n", class = c("RCODE", "tag")), structure(" directory = NULL,\n", class = c("RCODE", "tag")), structure(" EMD = paste0(\"Edited in humdrumR \", packageVersion(\"humdrumR\"), \" on \", Sys.date()),\n", class = c("RCODE", "tag")), structure(" overwrite = FALSE,\n", class = c("RCODE", "tag")), structure(" verbose = TRUE\n", class = c("RCODE", "tag")), structure(")\n", class = c("RCODE", "tag" ))), class = c("tag_usage", "tag")), structure("\n", class = c("TEXT", "tag")), structure(list(structure("\n", class = c("TEXT", "tag")), structure("----------NEEDS DOCUMENTATION------------\n", class = c("TEXT", "tag"))), class = c("tag_description", "tag")), structure("\n", class = c("TEXT", "tag"))), class = c("Rd", "tag"))), source = list( LO5th.Rd = "R/tonalInterval.R", REparser.Rd = "R/Regex.R", RegexFind.Rd = "R/Regex.R", chordTransformer.Rd = "R/tertianSet.R", decimal.Rd = "R/tools.R", diatonicSet.Rd = c("R/diatonicSet.R", "R/tertianSet.R"), fillThru.Rd = "R/tools.R", filterHumdrum.Rd = "R/Filter.R", getFields.Rd = "R/humdrumR-class.R", getTandem.Rd = "R/Apply.R", humActive.Rd = "R/humdrumR-class.R", humAssignment.Rd = "R/humdrumR-class.R", humCensus.Rd = "R/Summary.R", humCoercion.Rd = "R/humdrumR-class.R", humColumns.Rd = "R/humdrumR-class.R", humFormulae.Rd = "R/Formulae.R", humInterpretations.Rd = "R/Summary.R", humMerge.Rd = "R/humdrumR-class.R", humMeter.Rd = "R/rhythmInterval.R", humPipe.Rd = "R/Piping.R", humPrint.Rd = "R/humdrumR-class.R", humReference.Rd = "R/Summary.R", humShape.Rd = "R/humdrumR-class.R", humSize.Rd = "R/humdrumR-class.R", humSpines.Rd = "R/Summary.R", humSummary.Rd = "R/Summary.R", humTable.Rd = "R/humdrumR-class.R", humValidation.Rd = "R/Validation.R", humWindows.Rd = "R/Windows.R", humdrumDispatch.Rd = "R/Compose.R", humdrumPitch.Rd = "R/humdrumR-package.R", humdrumR.Rd = "R/humdrumR-package.R", humdrumRclass.Rd = c("R/humdrumR-class.R", "R/Filter.R" ), humdrumRroot.Rd = "R/humdrumR-package.R", interpolateArguments.Rd = "R/Apply.R", intervalCalculus.Rd = "R/tools.R", keyTransformer.Rd = "R/diatonicSet.R", lag.Rd = "R/tools.R", metricPosition.Rd = "R/rhythmInterval.R", pitchFunctions.Rd = "R/tonalInterval.R", plotRhythm.Rd = "R/Graphics.R", rational.Rd = "R/tools.R", readHumdrum.Rd = "R/Read.R", regexConstruction.Rd = "R/Regex.R", rhythmDecompose.Rd = "R/rhythmInterval.R", rhythmFunctions.Rd = "R/rhythmInterval.R", rhythmInterval.Rd = "R/rhythmInterval.R", rhythmOffset.Rd = "R/rhythmInterval.R", romanNumerals.Rd = "R/diatonicSet.R", struct.Rd = "R/Vector.R", tertianSet.Rd = "R/tertianSet.R", time.Rd = "R/rhythmInterval.R", tonalInterval.Rd = c("R/tonalInterval.R", "R/rhythmInterval.R"), tonalTransformations.Rd = "R/tonalInterval.R", transpose.Rd = "R/tonalInterval.R", withinHumdrum.Rd = "R/Apply.R", writeHumdrum.Rd = "R/Write.R"), keywords = list(character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), "datasets", character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), "internal", character(0), "datasets", character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0)), concepts = list("core pitch representation", character(0), character(0), character(0), "humdrumR numeric functions", character(0), character(0), character(0), character(0), character(0), character(0), character(0), "humdrum data summary functions", character(0), character(0), character(0), "humdrum data summary functions", character(0), character(0), character(0), character(0), character(0), character(0), character(0), "humdrum data summary functions", "humdrum data summary functions", character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), character(0), "rhythm analysis tools", character(0), character(0), "humdrumR numeric functions", character(0), character(0), "rhythm analysis tools", character(0), "core rhythm representation", "rhythm analysis tools", character(0), character(0), character(0), character(0), "core pitch representation", character(0), character(0), character(0), character(0)), internal = c(FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE )), class = c("tbl_df", "tbl", "data.frame"), row.names = c(NA, -57L)), tutorials = structure(list(name = character(0), file_out = character(0), title = character(0), pagetitle = character(0), url = character(0)), class = c("tbl_df", "tbl", "data.frame"), row.names = integer(0)), vignettes = structure(list( name = structure(c("GettingStarted", "HumdrumSyntax", "Intervals", "IntroForCoders", "KeysAndChord", "Overview", "PitchAndTonality", "ReadWrite", "RhythmAndMeter", "Validation" ), class = c("fs_path", "character")), file_in = structure(c("vignettes/GettingStarted.Rmd", "vignettes/HumdrumSyntax.Rmd", "vignettes/Intervals.Rmd", "vignettes/IntroForCoders.Rmd", "vignettes/KeysAndChord.Rmd", "vignettes/Overview.Rmd", "vignettes/PitchAndTonality.Rmd", "vignettes/ReadWrite.Rmd", "vignettes/RhythmAndMeter.Rmd", "vignettes/Validation.Rmd"), class = c("fs_path", "character" )), file_out = structure(c("articles/GettingStarted.html", "articles/HumdrumSyntax.html", "articles/Intervals.html", "articles/IntroForCoders.html", "articles/KeysAndChord.html", "articles/Overview.html", "articles/PitchAndTonality.html", "articles/ReadWrite.html", "articles/RhythmAndMeter.html", "articles/Validation.html"), class = c("fs_path", "character" )), title = c("Getting started with humdrumR", "The Humdrum Syntax", "Rhythm and Pitch Intervals", "HumdrumR for Coders", "Diatonic and Tertian Sets in humdrumR", "Overview of humdrumR", "Pitch and Tonality in humdrumR", "Reading and writing data with humdrumR", "Rhythm and Meter in humdrumR", "Validating Humdrum Data" ), description = c(NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, NA_character_, NA_character_), depth = c(1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L)), class = c("tbl_df", "tbl", "data.frame"), row.names = c(NA, -10L)), bs_version = 5L, prefix = ""), class = "pkgdown")), examples = base::quote(TRUE), run_dont_run = base::quote(FALSE), seed = base::quote(1014), lazy = base::quote(FALSE), override = base::quote(list()), install = base::quote(FALSE), preview = base::quote(FALSE), new_process = base::quote(FALSE), devel = base::quote(FALSE), crayon_enabled = base::quote(TRUE), crayon_colors = base::quote(256L), pkgdown_internet = base::quote(TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	      pkgdown::build_site(...)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	        build_site_local(pkg = pkg, examples = examples, run_dont_run = run_dont_run, seed = seed, lazy = lazy, override = override, preview = preview, devel = devel)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	          build_reference(pkg, lazy = lazy, examples = examples, run_dont_run = run_dont_run, seed = seed, override = override, preview = FALSE, devel = devel)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	            purrr::map(topics, build_reference_topic, pkg = pkg, lazy = lazy, examples_env = examples_env, run_dont_run = run_dont_run)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	              .f(.x[[i]], ...)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	                data_reference_topic(topic, pkg, examples_env = examples_env, run_dont_run = run_dont_run)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	                  run_examples(tags$tag_examples[[1]], env = if (is.null(examples_env)) NULL else new.env(parent = examples_env), topic = tools::file_path_sans_ext(topic$file_in), run_dont_run = run_dont_run)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	                    highlight_examples(code, topic, env = env)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	                      downlit::evaluate_and_highlight(code, fig_save = fig_save_topic, env = child_env(env), output_handler = evaluate::new_output_handler(value = pkgdown_print))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	                        evaluate::evaluate(code, child_env(env), new_device = TRUE, output_handler = output_handler)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	                          evaluate_call(expr, parsed$src[[i]], envir = envir, enclos = enclos, debug = debug, last = i == length(out), use_try = stop_on_error != 2L, keep_warning = keep_warning, keep_message = keep_message, output_handler = output_handler, include_timing = include_timing)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	                            eval(expr, envir, enclos)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	                              withinHumdrum(humdata, ~table(.), by ~ Spine)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	                                .withHumdrum(humdrumR, ..., withfunc = "withinHumdrum")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> 	                                  checkhumdrumR(humdrumR, withfunc)</span>
<span class="r-err co"><span class="r-pr">#&gt;</span> <span class="error">Error:</span> In the call withinHumdrum(humdrumR = _), the argument humdrumR must be a humdrumR object.</span>
<span class="r-in"></span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p></p><p>Developed by <a href="http://fathermckenzie.net/" class="external-link">Nathaniel Condit-Schultz</a>.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.2.</p>
</div>

    </footer></div>

  

  

  </body></html>

