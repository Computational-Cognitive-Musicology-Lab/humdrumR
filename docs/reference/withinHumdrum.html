<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="description" content="Evaluate arbitrary expressions using the fields within humdrumR data,
while employing split/apply/combine, windowing, and other analysis options."><title>with(in)Humdrum — withinHumdrum • humdrumR</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.1.0/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.1.0/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- bootstrap-toc --><script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="with(in)Humdrum — withinHumdrum"><meta property="og:description" content="Evaluate arbitrary expressions using the fields within humdrumR data,
while employing split/apply/combine, windowing, and other analysis options."><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-dark navbar-expand-lg bg-primary"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">humdrumR</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.5.3.0000</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <h6 class="dropdown-header" data-toc-skip>Basics</h6>
    <a class="dropdown-item" href="../articles/GettingStarted.html">Getting started with humdrumR</a>
    <a class="dropdown-item" href="../articles/IntroForCoders.html">HumdrumR for coders</a>
    <div class="dropdown-divider"></div>
    <h6 class="dropdown-header" data-toc-skip>R/Humdrum background</h6>
    <a class="dropdown-item" href="../articles/HumdrumSyntax.html">The humdrum syntax</a>
    <a class="dropdown-item" href="../articles/RPrimer.html">An R primer for humdrumR users</a>
    <div class="dropdown-divider"></div>
    <h6 class="dropdown-header" data-toc-skip>Data prep</h6>
    <a class="dropdown-item" href="../articles/ReadWrite.html">Reading and writing data</a>
    <a class="dropdown-item" href="../articles/Reshaping.html">Shaping humdrum data</a>
    <a class="dropdown-item" href="../articles/Filtering.html">Filtering humdrum data</a>
    <div class="dropdown-divider"></div>
    <h6 class="dropdown-header" data-toc-skip>Analysis</h6>
    <a class="dropdown-item" href="../articles/Summary.html">Getting to know your data</a>
    <a class="dropdown-item" href="../articles/WorkingWithData.html">Working with humdrum data</a>
    <div class="dropdown-divider"></div>
    <h6 class="dropdown-header" data-toc-skip>Musical tools</h6>
    <a class="dropdown-item" href="../articles/PitchAndTonality.html">Pitch and tonality in humdrumR</a>
    <a class="dropdown-item" href="../articles/RhythmAndMeter.html">Time, rhythm, and meter in humdrumR</a>
    <a class="dropdown-item" href="../articles/KeysAndChord.html">Diatonic and tertian sets in humdrumR</a>
  </div>
</li>
      </ul><form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off"></form>

      <ul class="navbar-nav"><li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul></div>

    
  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="" class="logo" alt=""><h1>with(in)Humdrum</h1>
      <small class="dont-index">Source: <a href="https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/blob/HEAD/R/Within.R" class="external-link"><code>R/Within.R</code></a></small>
      <div class="d-none name"><code>withinHumdrum.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>Evaluate arbitrary expressions using the fields within <a href="humdrumRclass.html">humdrumR</a> data,
while employing split/apply/combine, windowing, and other analysis options.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="co"># S3 method for humdrumR</span>
<span class="fu">with</span><span class="op">(</span>
  <span class="va">data</span>,
  <span class="va">...</span>,
  dataTypes <span class="op">=</span> <span class="st">"D"</span>,
  expandPaths <span class="op">=</span> <span class="cn">FALSE</span>,
  drop <span class="op">=</span> <span class="cn">TRUE</span>,
  variables <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">)</span>
<span class="op">)</span>

<span class="co"># S3 method for humdrumR</span>
<span class="fu">within</span><span class="op">(</span><span class="va">data</span>, <span class="va">...</span>, dataTypes <span class="op">=</span> <span class="st">"D"</span>, expandPaths <span class="op">=</span> <span class="cn">FALSE</span>, variables <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>
    <dl><dt>data</dt>
<dd><p><em><strong>HumdrumR data.</strong></em></p>
<p>Must be a <a href="humdrumRclass.html">humdrumR data object</a>.</p></dd>
<dt>...</dt>
<dd><p><em><strong>Any number of expressions to evaluate.</strong></em></p>
<p>Unnamed expressions are interpreted as the "main" <em>within-expressions</em>.
Possible <em>evaluation control arguments</em> include <code>by</code>, <code>subset</code>, and <code>windows</code>.
Other evaluation options can be achieved with <code>recycle</code> or <code>side</code> arguments.</p></dd>
<dt>dataTypes</dt>
<dd><p><em><strong>Which types of humdrum records to include.</strong></em></p>
<p>Defaults to <code>"D"</code>.</p>
<p>Must be a single <code>character</code> string. Legal values are <code>'G', 'L', 'I', 'M', 'D', 'd'</code>
or any combination of these (e.g., <code>"LIM"</code>).
(See the <a href="humTable.html">humdrum table</a> documentation <strong>Fields</strong> section for explanation.)</p></dd>
<dt>drop</dt>
<dd><p><em><strong>Whether to return a simplified data structure.</strong></em></p>
<p>Defaults to <code>TRUE</code>.</p>
<p>Must be a singleton <code>logical</code> value: an on/off switch.</p>
<p>This argument is conceptually similar to the <code>drop</code> argument in R matrices.
If <code>drop = TRUE</code>, the output of <code>with.humdrumR</code> is simplified as much as possible (trying to return
the "raw" vector, list, table, etc. within it). If <code>drop = FALSE</code>, the result is <em>always</em>
a <code>data.table</code>. The default value (<code>drop = TRUE</code>) is usually what we want because it is more
intuitive, but in more complex code, it can be helpful to set <code>drop = FALSE</code> so that
the output is consistent.</p></dd>
<dt>variables</dt>
<dd><p><em><strong>A named <code>list</code> of values, which are interpolated into the within-expression(s) wherever a variable name matches a named from the list.</strong></em></p>
<p>Defaults to <code><a href="https://rdrr.io/r/base/list.html" class="external-link">list()</a></code>.</p>
<p>Must be <code>list</code>.</p></dd>
</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    <p>From <code>within.humdrumR</code>  a new humdrumR data object.
From <code>with.humdrumR</code>, whatever value is returned by the expression or, if <code>drop = TRUE</code>,
a <code>data.table</code>.</p>
    </div>
    <div class="section level2">
    <h2 id="overview">Overview<a class="anchor" aria-label="anchor" href="#overview"></a></h2>
    


<p>These functions are the primary means of working with
humdrumR data. They are analogous to the base-R
<a href="https://rdrr.io/r/base/with.html" class="external-link">with and within</a>
methods for <a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frames</a>.
Specifically they allow you to evaluate arbitrary
expressions using the fields of a <a href="humdrumRclass.html">humdrumR data object</a>.
This means that you can drop "inside" your <a href="humdrumRclass.html">humdrumR data object</a> and run whatever commands
you want using the fields of the <a href="humTable.html">humdrum data table</a>,
while keeping the data safely "encapsulated" within the humdrum object---at least, until you <em>want</em>
to pull it out.</p>
<p>The difference between <code>with.humdrumR</code> and <code>within.humdrumR</code> is
analogous to the difference between <code><a href="https://rdrr.io/r/base/with.html" class="external-link">base::with()</a></code> and <code><a href="https://rdrr.io/r/base/with.html" class="external-link">base::within()</a></code>.
<code>with.humdrumR</code> evaluates your expression(s) and then simply returns the result of
the evaluation. <code>within.humdrumR</code> evaluates your expression(s) and then
inserts the results back into the humdrumR object, generating new
fields called <code>ResultX</code> (see details).</p>
<p>In addition, <code>with</code> and <code>within</code> offer a number of powerful options that make working with
humdrum data easier:
<em>evaluation control arguments</em> can be used to control
how your expressions are evaluated.
You can evaluate expressions...</p><ul><li><p>In a subset of the data using <code>subset</code>...</p><ul><li><p>either ignoring the rest of the data or evaluating a <em>different</em> expression in the other part.</p></li>
</ul></li>
<li><p>Separately in different subsets of the data, which are then recombined (split-apply-combine) using <code>by</code>.</p></li>
<li><p>Across windows in the data (e.g., ngrams, rolling windows).</p></li>
<li><p>Which produces a plot, with particular <a href="https://rdrr.io/r/graphics/par.html" class="external-link">plotting parameters</a>, and/or without
returning anything using <code>sidefx</code>.</p></li>
<li><p>"Fill" short results to match the original field size using <code>fill</code>.</p></li>
<li><p>Only in certain record types (defaulting only data records) using <code>dataTypes</code>.</p></li>
</ul><p>These arguments are specified as named arguments to <code>with</code>/<code>within</code> calls.
Even though they aren't formal arguments, they are <a href="partialMatching.html">partially matched</a>,
so if write <code>grou</code> instead of <code>groupby</code>, you won't get an error!
In some cases, you can specify more than one of the same type of control argument (details below).</p>
    </div>
    <div class="section level2">
    <h2 id="expression-evaluation">Expression evaluation<a class="anchor" aria-label="anchor" href="#expression-evaluation"></a></h2>
    


<p>An "expression" is a legal bit of R code, like <code>2 + 2</code> or <code>x - mean(x)</code>.
Each call to <code>with</code>/<code>within.humdrumR</code> must have at least one expression to evaluate.
We will refer to these as "within-expressions."
These expressions are passed to <code>with</code>/<code>within.humdrumR</code> as unnamed arguments: for example,
<code>with(humData, myExpressionHere)</code>.</p>
<p>Within expressions are evaluated within the <code>humdrumR</code> object's humdrum table,
which means the expression can refer fields in the humdrumR object by name (<code>Record</code>, <code>Token</code>, <code>File</code>, etc.)
just like any other variables.
Since all the fields in a humdrum object are vectors of the same length, within expressions are easily
(and generally should be) vectorized.
Note that the within-expression value is only evaluated over data-points/records that match the type
indicated in the <code>dataTypes</code> argument.
By default, only non-null data tokens (<code>"D"</code>) are used.</p>
<p>If multiple within-expressions are provided, each expression is evaluated in order (left to right).
Each expression can refer to the results of the last expression (as <code>.</code>), or
to variables defined in previous expressions.</p>
<p>A number of special <a href="https://en.wikipedia.org/wiki/Syntactic_sugarsyntactic" class="external-link">syntactic sugars</a>
can be used in within expressions.</p><ul><li><p>The <code>.</code> placeholder.</p></li>
<li><p>Side effects</p></li>
<li><p>Recycled ("filled") results</p></li>
<li><p>Lagged vectors</p></li>
<li><p>etc.</p></li>
</ul><p>Each of these is explained below.</p><div class="section">
<h3 id="the-placeholder">The . placeholder<a class="anchor" aria-label="anchor" href="#the-placeholder"></a></h3>


<p>The <code>.</code> variable can be used as a special placeholder in within expressions.
In the first within expression, <code>.</code> is interpreted as the humdrumR object's
current <a href="humActive.html">active expression</a>.
If multiple within expressions are given, beyond the first expression,  <code>.</code> refers to result of
the <em>previous</em> expression.
For example, if <code>Token</code> is the <a href="humActive.html">active expression</a>, then:</p><div class="sourceCode"><pre><code><span class="fu"><a href="../reference/withinHumdrum.html">with</a></span><span class="op">(</span><span class="va">humData</span>, <span class="fu"><a href="https://rdrr.io/r/base/nchar.html" class="external-link">nchar</a></span><span class="op">(</span><span class="va">.</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">.</span><span class="op">)</span>, <span class="va">.</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span></code></pre></div>

<p>would return the same result as:</p><div class="sourceCode"><pre><code><span class="fu"><a href="../reference/withinHumdrum.html">with</a></span><span class="op">(</span><span class="va">humData</span>, <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nchar.html" class="external-link">nchar</a></span><span class="op">(</span><span class="va">Token</span><span class="op">)</span><span class="op">)</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span></code></pre></div>

</div>

<div class="section">
<h3 id="side-effects-">Side effects:<a class="anchor" aria-label="anchor" href="#side-effects-"></a></h3>


<p>In some cases, you want to evaluate a within-expression for its
"<a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)" class="external-link">side effect</a>";
This means that the expression <em>does</em> something you want (the "side effect") but doesn't actually
evaluate to (return) a result that you want.
The most common "side effect" is creating a plot.
Other examples might be printing text to the console using <code><a href="https://rdrr.io/r/base/cat.html" class="external-link">base::cat()</a></code> or <code><a href="https://rdrr.io/r/base/print.html" class="external-link">base::print()</a></code>, or
writing to a file.</p>
<p>Side effects can be achieved by naming your expression <code>sidefx</code> or <code>fx</code>---as usual,
these arguments can be <a href="partialMatching.html">partially matched</a>, so <code>side</code> also works, and is commonly used.
Side-effect expressions are executed, but their result (if any) is ignored.
This means that if you call something like <code>newData &lt;- within(humData, side = plot(x))</code>, the plot is made
but the result (<code>newData</code>) is identical to <code>humData</code>.</p>
<p>Side-effects can also be used in combination with other within expressions.
Their result is ignored, and <em>not</em> fed to the next expression as <code>.</code>.
For example the command</p><div class="sourceCode"><pre><code><span class="fu"><a href="../reference/withinHumdrum.html">with</a></span><span class="op">(</span><span class="va">humData</span>, <span class="fu"><a href="https://rdrr.io/r/base/nchar.html" class="external-link">nchar</a></span><span class="op">(</span><span class="va">Token</span><span class="op">)</span>, side <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/graphics/hist.html" class="external-link">hist</a></span><span class="op">(</span><span class="va">.</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">.</span><span class="op">)</span><span class="op">)</span></code></pre></div>

<p>creates a histogram of <code>nchar(Token)</code> and also returns the mean of <code>nchar(Token)</code>.
(Note that variables explicitly assigned in a <code>side</code> call <em>are</em> visible in later calls,
which is confusing, so don't do it!)</p>
</div>

<div class="section">
<h3 id="recycling-filling-results-">Recycling ("filling") results:<a class="anchor" aria-label="anchor" href="#recycling-filling-results-"></a></h3>


<p>The result of your within expression may be shorter than the input vectors (<a href="humTable.html">humtable fields</a>).
However, in some calls to <code>within.humdrumR</code> in particular, you'd like to return a single number and
recycle it to "fill" the original data field.
In other words, you'd like the output (result) of your expression to be repeated until it matches the
length of the input field(s).
You could do this manually be using the <code><a href="https://rdrr.io/r/base/rep.html" class="external-link">base::rep()</a></code> function, but <code>with</code>/<code>within.humdrumR</code> provide a
syntactic sugar for this:
You can name your expression <code>recycle</code> or <code>fill</code> (<a href="partialMatching.html">partially matched</a>),
which will cause the result to be recycled.
All this does is take <code>yourExpression(field, ...)</code> and wrap it in
<code>rep(yourExpression(field, ...), length.out = length(field))</code>.</p>
</div>

<div class="section">
<h3 id="lagged-vectors">Lagged vectors<a class="anchor" aria-label="anchor" href="#lagged-vectors"></a></h3>


<p>We very often want to work with "<a href="lag.html">lagged</a>" vectors of data.
For example, we want to look at the relationship between a vector and the previous values of the
same vector---e.g., the vector offset or "lagged" by one index.
The <code>humdrumR</code> <code><a href="lag.html">lag()</a></code> function is useful for this, as it gives us several options for lagging vectors,
always keeping them the same length so vectorization is never hindered.
<code>with</code> and <code>within.humdrumR</code> give us a very convenient short cut to using <code>lag</code>.
In a within-expression, any vector can be indexed with an <code>integer</code> argument named <code>lag</code> (case insensitive),
causing it to be lagged by that integer.
(A vector indexed with <code>lag = 0</code> returns the unchanged vector.)
For example, the following two calls are the same:</p><div class="sourceCode"><pre><code><span class="fu"><a href="../reference/withinHumdrum.html">with</a></span><span class="op">(</span><span class="va">humData</span>, <span class="va">Token</span><span class="op">[</span>lag <span class="op">=</span> <span class="fl">1</span><span class="op">]</span><span class="op">)</span>
<span class="fu"><a href="../reference/withinHumdrum.html">with</a></span><span class="op">(</span><span class="va">humData</span>, <span class="fu"><a href="../reference/lag.html">lag</a></span><span class="op">(</span><span class="va">Token</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span></code></pre></div>

<p>If the <code>lag</code> index has <em>multiple</em> values and the indexed object appears within a higher function call,
each lag is inserted as a <em>separate</em> argument to that call.
Thus, <em>these</em> two calls are also the same:</p><div class="sourceCode"><pre><code>with(humData, table(Token[lag = 1:2])

with(humData, table(lag(Token, 1), lag(Token, 2))
</code></pre></div>

<p><code><a href="lag.html">lag()</a></code> is a function with a <code>groupby</code> argument, which <code>with</code>/<code>within.humdrumR</code>
will automatically feed the fields <code>list(File, Spine, Path)</code>.
This is the default "melodic" behavior in most music.
If you'd like to turn this off, you need to override it by adding your own
<code>groupby</code> argument to the lagged index, like <code>Token[lag = 1, groupby = list(...)]</code>.</p>
<p>Using lagged vectors, since they are vectorized, is the fastest (computationally) and easiest way of working with n-grams.
For example, if you want to create character-string 5-grams of your data, you could call:</p><div class="sourceCode"><pre><code><span class="fu"><a href="../reference/withinHumdrum.html">with</a></span><span class="op">(</span><span class="va">humData</span>, <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste</a></span><span class="op">(</span><span class="va">Token</span><span class="op">[</span>lag <span class="op">=</span> <span class="fl">0</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span>, sep <span class="op">=</span> <span class="st">'-'</span><span class="op">)</span><span class="op">)</span></code></pre></div>

<p>Note that, since <code>with</code>/<code>within.humdrumR</code> passes <code>groupby = list(File, Spine, Path)</code>
to <code><a href="lag.html">lag()</a></code>, these are true "melodic" n-grams, only created within spine-paths within each file.</p>
</div>

    </div>
    <div class="section level2">
    <h2 id="results">Results<a class="anchor" aria-label="anchor" href="#results"></a></h2>
    


<p>The difference between <code>with.humdrumR</code> and <code>within.humdrumR</code> is in what they do with the results
of the evaluated within-expression(s).</p><div class="section">
<h3 id="within">Within<a class="anchor" aria-label="anchor" href="#within"></a></h3>


<p>For calls to <code>within.humdrumR</code>, the result of the final within-expression
is inserted back into the <code>[humtable][humdrum table]</code>.
Most results should be <code>atomic</code> vectors, though <code>list</code>s can also be placed as fields.
If results are shorter than the input fields of the humtable
they are padded with null values to fill the same length as the input.
Non-vector results (<code>object</code>s) and tables are put into lists, and treated like any other list.
In the result, data/record-types that are not indicated by the <code>dataTypes</code> argument are also
returned padded as null values.</p>
<p>If you don't explicitly name the result of your within-expression, it is put into a new field labeled
<code>ResultX</code>, where <code>X</code> is the lowest number of "ResultX" fields that is not already taken.
You can explicitly name the result field with a top-level assignment in the expression.
For example, <code>within(data, Semits &lt;- semits(Token))</code> will put the result of
<code>semits(Token)</code> into a new field called <code>Semits</code>.
In fact, if you assign the results of multiple within-expressions,
each result that is the same length as the last result will be put into a new field.
Thus, you can create multiple new fields in a single call:
for example,</p><div class="sourceCode"><pre><code><span class="fu"><a href="../reference/withinHumdrum.html">within</a></span><span class="op">(</span><span class="va">humData</span>, 
       <span class="va">Semits</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/semits.html">semits</a></span><span class="op">(</span><span class="va">Token</span><span class="op">)</span>,
       <span class="va">Recip</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/recip.html">recip</a></span><span class="op">(</span><span class="va">Token</span><span class="op">)</span><span class="op">)</span></code></pre></div>

<p>creates <em>two</em> new fields, <code>Semits</code> <em>and</em> <code>Recip</code>.
(As explained above, the second within-expression could also refer to the <code>Semits</code> variable
created in the previous expression.)</p>
</div>

<div class="section">
<h3 id="with">With<a class="anchor" aria-label="anchor" href="#with"></a></h3>


<p>For calls to <code>with.humdrumR</code>, the result is simply returned as is.
This is what you want when you want to get out of the <a href="humdrumRclass.html">humdrumR object</a> and drop back
into "normal" R, often in the last stages of an analysis.</p>
<p><code>with.humdrumR</code> has a <code>drop</code> argument, which defaults to <code>TRUE</code>.
If <code>drop = FALSE</code>, the result is returned in a <code>data.table()</code>.
The column names of this results table are generated as described in the previous section:
i.e., defaulting to <code>ResultX</code> but allowing explicit naming with through one or more
explicit assignments in the within-expressions.
In addition, if <code>subset</code> or <code>groupby</code> arguments are used, columns are included which indicate
the value of the evaluated <code>subset</code>/<code>groupby</code> factor for each row.</p>
</div>

    </div>
    <div class="section level2">
    <h2 id="partitioning-data">Partitioning data<a class="anchor" aria-label="anchor" href="#partitioning-data"></a></h2>
    


<p><code>groupby</code> (e.g., <code>by</code>) and <code>subset</code> expression control arguments all you to evaluate
your within-expressions within specific subsets of the data.
A <code>subset</code> argument can be used to evaluate your within-expression only within a subset of the data.
A <code>groupby</code> argument breaks the data into groups,
evaluating the within-expression(s) <em>separately</em> within each group.
The results of the grouped evaluations are then returned in a list (<code>with</code>) or recombined
into the original data <code>within</code>---this is a form of the "split-apply-combine" routine that is
key to <code>R</code> data analysis.</p>
<p><code>subset</code> and <code>groupby</code> arguments are themselves arbitrary expressions which are evaluated within
the [humdrum table][humTable], so they can (and usually do) refer to fields in the table.
Any <code>with</code>/<code>within.humdrumR</code> call can include zero, one, <em>or more</em> <code>subset</code> and/or <code>groupby</code> arguments,
including combinations of both.
If more than one <code>subset</code>/<code>groupy</code> by argument is included, they are evaluated in order (left to right),
<em>recursively</em>: each one evaluated within the partition(s) established by the previous expression.
The normal <em>within</em> expression(s) are then, all evaluated within the partition(s) established by the
last  <code>subset</code>/<code>groupby</code> argument.
The "Advanced" partitioning section below explores this in more detail.</p><div class="section">
<h3 id="apply-in-subset-">Apply in subset:<a class="anchor" aria-label="anchor" href="#apply-in-subset-"></a></h3>


<p>A <code>subset</code> argument is an arbitrary expression which identifies a subset of the humdrum data.
<code>subset</code> expressions must evaluate to
a single logical vector,
The <code>subset</code> result, if short, will be automatically recycled to the full length of the [humdrum table][humTable].
The within expression(s) are only evaluated where the <code>subset</code> argument(s) return <code>TRUE</code>.</p>
<p>In a call to <code>with</code>, only the result evaluated where <code>subset == TRUE</code> is returned.
However, in a call to <code>within</code>, we must decide what to
do with rest of the data: the <a href="https://en.wikipedia.org/wiki/Complement_(set_theory)" class="external-link">complement</a>
of the subset.
By default, <code>within</code> pads the returned values with null data
where ever <code>subset == FALSE</code> (in the complement).
So if you, for example, run the command <code>within(humData, kern(Token), subset = Spine == 1)</code>
the new field created by <code>within</code> will be filled with <code>kern</code> data where <code>Spine == 1</code>,
but the remaining spines (if any) will all by null.</p>
<p>If you want to explicitly control what is put into the complement
part of a new field, you can specifying alternate
within-expression(s) to evaluate where <code>subset == FALSE</code>.
These must be named <code>complement</code>, or the aliases
<code>rest</code> or <code>otherwise</code> (these are all [partially matched][partialMatching]).
A <code>complement</code> expression can only be specified in combination with a <code>subset</code> argument,
and must be <em>in addition</em> to a normal within-expression.
The idea is that you evaluate the "normal" within-expression where <code>subset == TRUE</code>, <em>or else</em>
you specify evaluate the <code>complement</code> expression.
The results of Complement expressions are always recycled to fill the whole complement (see the "recycle")</p>
<p>A common use case for a <code>complement</code> expression is to use the within expression to change the data in one spine
but return the data unchanged in other spines.
For example, we could specify <code>within(humData, kern(Token), subset = Spine == 1, complement = Token)</code>.
Spine 1 will (as before) have <code>kern</code> applied to it.
However, instead of return a new field with null values in the other spine(s),
this call will return the original (unaltered) values from the <code>Token</code> field in the other spines.</p>
</div>

<div class="section">
<h3 id="group-by-">Group by:<a class="anchor" aria-label="anchor" href="#group-by-"></a></h3>


<p>A <code>groupby</code> expression (use <code>by</code> for short) partitions your data exhaustively into
(possibly non-contiguous) groups, and evaluates your within-expression(s) <em>separately</em>
within each group.
This works the similarly to the <code>by</code> argument in
<code>[data.table][data.table]</code>s, the <code>INDEX</code>
argument of <code>[base][tapply]</code>, or the <code>INDICES</code> argument of <code>[base][by]</code>.
Each <code>groupby</code> expression must evaluate, within the <code>humdrumR</code> data object, to a vector (or a list of vectors
of equal length) to group the data by.
Each unique combination of values across these vectors becomes one group.</p>
<p>Most commonly, the <code>groupby</code> expression(s) are simply field(s) in the data:
for instance,</p><div class="sourceCode"><pre><code><span class="fu"><a href="../reference/withinHumdrum.html">with</a></span><span class="op">(</span><span class="va">humdata</span>,
     <span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">Token</span><span class="op">)</span>,
     by <span class="op">=</span> <span class="va">File</span><span class="op">)</span></code></pre></div>

<p>will apply the function <code>[base][table]</code> to the <code>Token</code> field
<em>separately</em> for each file in the <code>humdrumR</code> data.
However, we can also use more complex expressions like</p><div class="sourceCode"><pre><code>with(humdata,
     table(Token), 
     by = Spine &gt; 3 | Record \%\% 2 == 0)
</code></pre></div>

<p>which will evaluate the do expression in two groups, one where either the spine number is
three or less <em>or</em> the record number is even, and another group where the opposite is true.</p>
<p>If the <code>groupby</code> expression evaluates to a list of grouping vectors,
the within expressions are evaluated across every combination of categories across all the vectors.
Thus,</p><div class="sourceCode"><pre><code><span class="fu"><a href="../reference/withinHumdrum.html">with</a></span><span class="op">(</span><span class="va">humdata</span>, 
     <span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">Token</span><span class="op">)</span>,
     by <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">File</span>, <span class="va">Spine</span><span class="op">)</span><span class="op">)</span></code></pre></div>

<p>will apply <code>table</code> to <code>Token</code> across each spine <em>in</em> each file.</p>
</div>

<div class="section">
<h3 id="advanced-partitioning-">Advanced partitioning:<a class="anchor" aria-label="anchor" href="#advanced-partitioning-"></a></h3>


<p>If multiple <code>groupby</code> or <code>subset</code> expressions, or combinations of the two, are specified,
each is evaluated recursively, in order from left to right.
If <code>subset</code> is specified after <code>groupby</code>, the <code>subset</code> expression is evaluated within each <code>groupby</code> group
If <code>groupby</code> is specified after <code>subset</code>, the grouping <code>by</code> expression is evaluated only where <code>subset == TRUE</code>.
Thus, if you specify</p><div class="sourceCode"><pre><code>within(humdata,
         sd(Semits),
         by = File, 
         subset = Semits &gt; mean(Semits))
```

the standard deviation of the `semits` field will be calculated in each file,
but only where the `semits` field is greater than the mean `semits` value
*within that file*. Contrast this with this call:

```
within(humdata,
         sd(Semits)
         subset = Semits &gt; mean(Semits), 
         by = File) 
```

wherein the standard deviation of `semits` is, again, calculated for each file,
but this time wherever the `semits` field is greater than the mean value *across all the data*.


[humTable]: R:humTable
[humTable]: R:humTable
[complement]: R:complement
[partialMatching]: R:partialMatching
[data.table]: R:data.table
[tapply]: R:tapply
[by]: R:by
[table]: R:table
</code></pre></div>

</div>

    </div>
    <div class="section level2">
    <h2 id="windowing-data">Windowing data<a class="anchor" aria-label="anchor" href="#windowing-data"></a></h2>
    


<p>XXXX</p>
    </div>
    <div class="section level2">
    <h2 id="plotting-parameters">Plotting parameters<a class="anchor" aria-label="anchor" href="#plotting-parameters"></a></h2>
    


<p>As mentioned above, plots in within-expressions should (often) be called using the <code>sidefx</code> argument name.
When plotting, <code>with</code>/<code>within.humdrumR</code> also allows you to specify plotting options inline,
without having to make a separate call
to <code><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par()</a></code>. Any <code><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par()</a></code> argument can be specified by providing a named list to the <code>graphics</code> keyword.
For example, we can set the plot margins with the <code>mar</code> argument:</p><div class="sourceCode"><pre><code><span class="fu"><a href="../reference/withinHumdrum.html">within</a></span><span class="op">(</span><span class="va">data</span>, 
       side <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sort.html" class="external-link">sort</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">Token</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>, 
       graphics <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>mar <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">4</span>, <span class="fl">4</span>, <span class="fl">4</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></code></pre></div>

<p>The best part is <code>with</code>/<code>within.humdrumR</code> will reset <code>par</code> to it's previous state after its done.</p>
<p>You can also use the syntactic sugar, <code>graphics(parargs = ...)</code>:</p><div class="sourceCode"><pre><code><span class="fu"><a href="../reference/withinHumdrum.html">within</a></span><span class="op">(</span><span class="va">data</span>,
       side <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sort.html" class="external-link">sort</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nchar.html" class="external-link">nchar</a></span><span class="op">(</span><span class="va">Token</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>,
       <span class="fu"><a href="https://rdrr.io/r/graphics/graphics-package.html" class="external-link">graphics</a></span><span class="op">(</span>mar <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">4</span>, <span class="fl">4</span>, <span class="fl">4</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></code></pre></div>

    </div>
    <div class="section level2">
    <h2 id="splatting">Splatting<a class="anchor" aria-label="anchor" href="#splatting"></a></h2>
    


<p>("Splatting" refers to feeding a function a list/vector of arguments.)
Sometimes we want to divide our data into pieces (a l\'a <code>partition</code> option), but
rather than applying the same expression to each piece, we want to feed
the separate pieces as separate arguments to the same function.
In <code>with</code>/<code>within.humdrumR</code> you can use some
<a href="https://en.wikipedia.org/wiki/Syntactic_sugarsyntactic" class="external-link">syntactic sugar</a>
to do just this.
We can index any field in our call with a <code>splat</code> argument, which must be a <code>Field %in% x</code>.
For example,</p><div class="sourceCode"><pre><code><span class="fu"><a href="../reference/withinHumdrum.html">within</a></span><span class="op">(</span><span class="va">humdata</span>, <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">Token</span><span class="op">[</span>splat <span class="op">=</span> <span class="va">Spine</span> <span class="op"><a href="https://rdrr.io/pkg/bit64/man/bit64S3.html" class="external-link">%in%</a></span> <span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">]</span><span class="op">)</span><span class="op">)</span></code></pre></div>

<p>In this call, the <code>Token</code> field will be divided into two groups, one where <code>Spine == 1</code> and the other where
<code>Spine == 2</code>; the first group (<code>Spine == 1</code>) will be used as the first argument to <code>list</code>, and the second group
(<code>Spine == 2</code>) as the second argument.
Thus, <code>within</code> translates the previous expression to this:</p><div class="sourceCode"><pre><code><span class="fu"><a href="../reference/withinHumdrum.html">within</a></span><span class="op">(</span><span class="va">humdata</span>,
       <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">Token</span><span class="op">[</span><span class="va">Spine</span> <span class="op">==</span> <span class="fl">1</span><span class="op">]</span>, <span class="va">Token</span><span class="op">[</span><span class="va">Spine</span> <span class="op">==</span> <span class="fl">2</span><span class="op">]</span><span class="op">)</span><span class="op">)</span></code></pre></div>

    </div>
    <div class="section level2">
    <h2 id="n-grams">N grams<a class="anchor" aria-label="anchor" href="#n-grams"></a></h2>
    


<p>XXXX</p>
    </div>
    <div class="section level2">
    <h2 id="advanced-scripting">Advanced scripting<a class="anchor" aria-label="anchor" href="#advanced-scripting"></a></h2>
    


<p><code>with.humdrumR</code> and <code>within.humdrumR</code> use
<a href="http://adv-r.had.co.nz/Computing-on-the-language.html" class="external-link">non-standard evaluation</a>
of their expressions.
This is very useful on the command line or in a script running one command at a time.
However, if you want to more advanced scripting non-standard evaluation can be a problem.
For example, if you to loop through a list of within-expressions
or reuse a common combination coor arguments many times.</p>
<p>Fortunately, R has <em>formula</em>, which are a way of capturing ("quoting") expressions into a
concrete object that you can manipulate. Better yet, <code>with</code>/<code>within.humdrumR</code> will
interpret formulae passed to them as arguments.
Basically, the right-hand side of any formula is interpreted as an
expression to evaluate.
If a formula is passed as a unnamed argument to <code>with</code>/<code>within</code>, the left-hand side
of the formula (if any) is treated as the argument name.
If you name a formula argument that has a left-hand side, the left-hand side is ignored.</p><div class="sourceCode"><pre><code><span class="fu"><a href="../reference/withinHumdrum.html">with</a></span><span class="op">(</span><span class="va">humdrumR</span>, <span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">Token</span><span class="op">)</span>, by <span class="op">=</span> <span class="va">Spine</span><span class="op">)</span>
<span class="fu"><a href="../reference/withinHumdrum.html">with</a></span><span class="op">(</span><span class="va">humdrumR</span>, <span class="op">~</span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">Token</span><span class="op">)</span>, <span class="va">by</span> <span class="op">~</span> <span class="va">Spine</span><span class="op">)</span></code></pre></div>

<p>This approach would allows us to, same <code>~table(Token)</code> or <code>by ~ Spine</code> as variables,
allowing us to do things like:</p><div class="sourceCode"><pre><code><span class="va">tabler</span> <span class="op">&lt;-</span> <span class="op">~</span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">.</span><span class="op">)</span>
<span class="va">byspine</span> <span class="op">&lt;-</span> <span class="va">by</span> <span class="op">~</span> <span class="va">Spine</span>

<span class="fu"><a href="../reference/withinHumdrum.html">with</a></span><span class="op">(</span><span class="va">humData</span>, <span class="va">tabler</span>, <span class="va">byspine</span><span class="op">)</span></code></pre></div>

<p>We can even make lists and loop through them:</p><div class="sourceCode"><pre><code><span class="va">bys</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">~</span> <span class="va">Spine</span>, <span class="op">~</span> <span class="va">File</span>, <span class="op">~</span> <span class="va">COM</span><span class="op">)</span>

<span class="kw">for</span> <span class="op">(</span><span class="va">b</span> <span class="kw">in</span> <span class="va">bys</span><span class="op">)</span> <span class="fu"><a href="../reference/withinHumdrum.html">with</a></span><span class="op">(</span><span class="va">humData</span>, <span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">.</span><span class="op">)</span>, by <span class="op">=</span> <span class="va">b</span><span class="op">)</span></code></pre></div>
<div class="section">
<h3 id="variables">Variables<a class="anchor" aria-label="anchor" href="#variables"></a></h3>


<p>Another useful scripting option is to include free variables in your
within-expressions, which can then be fed in using the <code>variables</code> argument.
<code>variables</code> must be a named list.
Variables in the within-expression which match a name of from the <code>variables</code>
list have that value interpolated.
This allows us, for example, to run commands like:</p><div class="sourceCode"><pre><code><span class="va">nums</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">3</span>, <span class="fl">4</span>, <span class="fl">5</span><span class="op">)</span>
<span class="va">expression</span> <span class="op">&lt;-</span> <span class="op">~</span><span class="va">.</span><span class="op">^</span><span class="va">N</span>

<span class="kw">for</span> <span class="op">(</span><span class="va">n</span> <span class="kw">in</span> <span class="va">nums</span><span class="op">)</span> <span class="fu"><a href="../reference/withinHumdrum.html">with</a></span><span class="op">(</span><span class="va">humData</span>, <span class="va">expression</span>, variables <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>N <span class="op">=</span> <span class="va">n</span><span class="op">)</span><span class="op">)</span></code></pre></div>

<p>Each time <code>with</code> is called, the <code>N</code> in <code>.^N</code> is replaced by the current value of <code>n</code>.</p>
</div>

    </div>

  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p></p><p>Developed by Nathaniel Condit-Schultz, Claire Arthur.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a>
2.0.2.</p>
</div>

    </footer></div>

  

  

  </body></html>

