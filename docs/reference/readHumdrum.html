<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="description" content="findHumdrum does the work of finding and reading valid text files into R.
readHumdrum utilizes findHumdrum to read files, then parses them to
create a humdrumR data object."><title>Find and read humdrum files into R — knownInterpretations • humdrumR</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.1.0/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.1.0/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- bootstrap-toc --><script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Find and read humdrum files into R — knownInterpretations"><meta property="og:description" content="findHumdrum does the work of finding and reading valid text files into R.
readHumdrum utilizes findHumdrum to read files, then parses them to
create a humdrumR data object."><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-dark navbar-expand-lg bg-primary"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">humdrumR</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.4.0.9000</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <h6 class="dropdown-header" data-toc-skip>Basics</h6>
    <a class="dropdown-item" href="../articles/Overview.html">Overview of humdrumR</a>
    <a class="dropdown-item" href="../articles/GettingStarted.html">Getting started with humdrumR</a>
    <a class="dropdown-item" href="../articles/IntroForCoders.html">HumdrumR for coders</a>
    <div class="dropdown-divider"></div>
    <h6 class="dropdown-header" data-toc-skip>R/Humdrum background</h6>
    <a class="dropdown-item" href="../articles/HumdrumSyntax.html">The humdrum syntax</a>
    <a class="dropdown-item" href="../articles/RPrimer.html">An R primer for humdrumR users</a>
    <div class="dropdown-divider"></div>
    <h6 class="dropdown-header" data-toc-skip>Data prep</h6>
    <a class="dropdown-item" href="../articles/ReadWrite.html">Reading and writing data</a>
    <a class="dropdown-item" href="../articles/Validation.html">Validating humdrum data</a>
    <a class="dropdown-item" href="../articles/Reshaping.html">Shaping humdrum data</a>
    <a class="dropdown-item" href="../articles/Filtering.html">Filtering humdrum data</a>
    <div class="dropdown-divider"></div>
    <h6 class="dropdown-header" data-toc-skip>Analysis</h6>
    <a class="dropdown-item" href="../articles/Summary.html">Summarizing humdrum data sets</a>
    <a class="dropdown-item" href="../articles/WorkingWithData.html">Working with humdrum data</a>
    <div class="dropdown-divider"></div>
    <h6 class="dropdown-header" data-toc-skip>Musical tools</h6>
    <a class="dropdown-item" href="../articles/PitchAndTonality.html">Pitch and tonality in humdrumR</a>
    <a class="dropdown-item" href="../articles/RhythmAndMeter.html">Rhythm and meter in humdrumR</a>
    <a class="dropdown-item" href="../articles/KeysAndChord.html">Diatonic and tertian sets in humdrumR</a>
  </div>
</li>
      </ul><form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off"></form>

      <ul class="navbar-nav"><li class="nav-item">
  <a class="nav-link" href="https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul></div>

    
  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="" class="logo" alt=""><h1>Find and read humdrum files into R</h1>
      <small class="dont-index">Source: <a href="https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/blob/HEAD/R/Interpretations.R"><code>R/Interpretations.R</code></a>, <a href="https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/blob/HEAD/R/Read.R"><code>R/Read.R</code></a></small>
      <div class="d-none name"><code>readHumdrum.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p><code>findHumdrum</code> does the work of finding and reading valid text files into <code>R</code>.
<code>readHumdrum</code> utilizes <code>findHumdrum</code> to read files, then parses them to
create a <a href="humdrumRclass.html">humdrumR data object</a>.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="va">knownInterpretations</span>

<span class="fu">findHumdrum</span><span class="op">(</span>
  <span class="va">...</span>,
  contains <span class="op">=</span> <span class="cn">NULL</span>,
  recursive <span class="op">=</span> <span class="cn">FALSE</span>,
  allowDuplicates <span class="op">=</span> <span class="cn">FALSE</span>,
  verbose <span class="op">=</span> <span class="cn">FALSE</span>
<span class="op">)</span>

<span class="fu">readHumdrum</span><span class="op">(</span>
  <span class="va">...</span>,
  recursive <span class="op">=</span> <span class="cn">FALSE</span>,
  contains <span class="op">=</span> <span class="cn">NULL</span>,
  allowDuplicates <span class="op">=</span> <span class="cn">FALSE</span>,
  verbose <span class="op">=</span> <span class="cn">FALSE</span>,
  tandems <span class="op">=</span> <span class="st">"known"</span>,
  reference <span class="op">=</span> <span class="st">"all"</span>
<span class="op">)</span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="format">Format<a class="anchor" aria-label="anchor" href="#format"></a></h2>
    


    </div>
    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>
    <dl><dt>...</dt>
<dd><p><code>character</code>: One or more regex search patterns used to identify files on the local machine. read.
For details: see the "Regex file-path matching" section below.</p></dd>
<dt>contains</dt>
<dd><p>(<code>character</code>) If <code>!is.null(contains)</code>, the <code>contains</code> argument is
is treated as regular expressions: only files which contain matches to
<em>all</em> of these regular expressions are matched.</p></dd>
<dt>recursive</dt>
<dd><p>(<code>logical</code>, <code>length == 1</code>) If <code>TRUE</code>, the final part of
the search pattern (i.e., the file search) is searched for
recursively through all sub directories.</p></dd>
<dt>allowDuplicates</dt>
<dd><p>(<code>logical</code>, <code>length == 1</code>) Indicates what should happen if multiple
search patterns match the same files. If <code>allowDuplicates = TRUE</code>,
any such files are read multiple times, grouped into their respective corpora by the <code>Label</code> field.
If <code>allowDuplicates = FALSE</code>, any redundant files are only read into the corpus of the first pattern they
match.</p></dd>
<dt>verbose</dt>
<dd><p>(<code>logical</code>, <code>length == 1)</code> If <code>TRUE</code>, the names of matching files are
printed before parsing begins. This is very
useful as a check to make sure you aren't reading the wrong files!</p></dd>
<dt>tandems</dt>
<dd><p>(<code>character</code>) This argument controls which, if any, tandem interpretations
are parsed into their own fields. The default value is <code>"known"</code>.</p></dd>
<dt>reference</dt>
<dd><p>(<code>character</code>) This argument controls which, if any, reference records
are parsed into their own fields. The default value is <code>"all"</code>.</p></dd>
</dl></div>
    <div class="section level2">
    <h2 id="details">Details<a class="anchor" aria-label="anchor" href="#details"></a></h2>
    <p><code>findHumdrum</code> searches for matching files (details in next section) on your machine and returns a "file info" <code>data.table</code>.
The file-info table has one row for each matched file, and six columns:</p><ul><li><p><code>Filepath</code> (<code>character</code>): The complete file path.</p></li>
<li><p><code>Pattern</code> (<code>character</code>): The search pattern (details below) which matched the file.</p></li>
<li><p><code>Label</code> (<code>character</code>): The "subcorpora" label identified with the search pattern. (Used as the <code>Label</code> field
in a <a href="humTable.html">humdrum table</a>.)</p></li>
<li><p><code>Files</code> (<code>character</code>): The file contents themselves, in a single string.</p></li>
<li><p><code>FileLines</code> (<code>list</code> of <code>character</code>): The file contents themselves, divided into lines.</p></li>
<li><p><code>File</code> (<code>integer</code>): A integer enumerating the files. (Used as the <code>File</code> field in a <a href="humTable.html">humdrum table</a>.)
If two or more files in different directories share the same name, a unique name is created for
each file by appending the names of the directories they occupy, recursively
until the names are unique.</p></li>
</ul><p><code>readHumdrum</code> uses <code>findHumdrum</code> to identify humdrum files, then parses each file
and assembles them all into a <a href="humTable.html">humdrum table</a> which is in turn wrapped in
a <a href="humdrumRclass.html">humdrumR data object</a> (the final output).
The output's <code>Filepath</code>, <code>File</code>, and <code>Label</code> fields are taken directly from <code>findHumdrum</code>'s "file info" table.
If a single humdrum file has multiple pieces in it---meaning that all spine paths close with <code>*-</code>, then
open again with <code>**</code>---then they are parsed separately, and labeled separately in the <code>Piece</code> field.
If there are no multi-piece files, the <code>Piece</code> and <code>File</code> will be identical.</p><div class="section">
<h3 id="validity">Validity<a class="anchor" aria-label="anchor" href="#validity"></a></h3>


<p><code>findHumdrum</code> and <code>readHumdrum</code> automatically ignore non-text files and
files that contain humdrum syntax errors.
When calling either command, messages will print in the terminal informing you about invalid files, if any.
Validity checking is performed by the separate <code><a href="validateHumdrum.html">validateHumdrum()</a></code> function.
If you want to see specifically what errors occurred, call <code><a href="validateHumdrum.html">validateHumdrum()</a></code>
directly.</p>
</div>

    </div>
    <div class="section level2">
    <h2 id="regex-file-path-matching">Regex file-path matching<a class="anchor" aria-label="anchor" href="#regex-file-path-matching"></a></h2>
    


<p>Files on your local machine can be concisely identified using
regular-expression
pattern matching.
To find/read humdrum files,
one or more <code>character</code> search patterns must be specified as <code>...</code> arguments;
A search pattern is a file-path like string, with strings separated by zero or more delimiters
(<code>/</code> or <code>\</code>, depending on your operating system).
Each delimited part of the string to the left of a delimiter (if any) is treated as a regular expression
matched against <em>directories</em>, recursively.
The right-most part of the string (or the whole string if there are no delimiters), is matched
as a regular expression against <em>files</em> in the matched directories.
The left-most directory pattern (if any) can be either relative (to <code>R</code>'s <a href="https://rdrr.io/r/base/getwd.html" class="external-link">working directory</a>) or absolute.
(Unix-like systems can use <code>~</code> for home. All systems use <code>.</code> for the current working directory
and <code>..</code> for its parent.
These special keys are <em>not</em> treated like regular expressions.)</p>
<p>Let's consider some examples:</p><ul><li><p>With no delimiters (relative):</p><ul><li><p><code>readHumdrum('.*krn$')</code> will match all files in the current working directory which match the <code>.*krn$</code> regex.
(This would be all files ending the <code>krn</code>.)</p></li>
</ul></li>
<li><p>With one directory pattern (relative):</p><ul><li><p><code>readHumdrum('[A-G]/.*krn$')</code> will first match any subdirectories of the working directory which match the <code>[A-G]</code> regex.
If there are any such directories, it will then search the files in <em>all</em> of these matching directories for matches to <code>.*krn$</code>.</p></li>
</ul></li>
<li><p>Two directory patterns (absolute):</p><ul><li><p>On Unix-like systems <code>readHumdrum('~/[A-G]/.*krn$')</code> will perform the same search as above, but in the
<em>home</em> directory (<code>~</code>) instead of the <code>R</code> working directory.</p></li>
</ul></li>
<li><p>With two directory patterns (relative):</p><ul><li><p><code>readHumdrum('^Krn$/[A-G]/.*krn$')</code> will first match the directory <code>Krn</code> in the working directory,
search all the subdirectories of <code>Krn</code> for matches to <code>[A-G]</code>.
Finally, if there are any matching directories, they will <em>all</em> be searched for files matching <code>.*krn$</code>.</p></li>
<li><p>Note that the pattern <code>"^Krn$"</code> is needed to match exactly the <code>Krn</code> directory, and no other directory.
If used <code>"Krn"</code> instead, <em>any</em> directory containing the string <code>Krn</code> would be matched; for example, <code>NoKrn</code> would be a match.</p></li>
</ul></li>
</ul><p>If you provide multiple <code>...</code> arguments, they are pasted together (left-to-right), separated by the system delimiter,
to create a single complete regex search pattern.
Thus, <code>readHumdrum('^Krn$', '[A-G]', '.*krn$')</code> is identical to <code>readHumdrum('^Krn$/[A-G]/.*krn$')</code>.</p>
<p>If you don't specify <em>any</em> <code>...</code> arguments,
<code>findHumdrum</code> (or <code>readHumdrum</code>) will default to <code>""</code>, the empty regex pattern <code>""</code> which matches any file.
Thus, <code>readHumdrum()</code> will read any humdrum files in the <a href="https://rdrr.io/r/base/getwd.html" class="external-link">working directory</a>.</p><div class="section">
<h3 id="multiple-patterns">Multiple patterns<a class="anchor" aria-label="anchor" href="#multiple-patterns"></a></h3>


<p>If you want to search for <em>more than one</em> pattern, you can input them as a <code>character</code> vector:
For instance, <code>readHumdrum(c("Mozart", "Beethoven"))</code> will search for files
(in the working directory) matching the regexes <code>Mozart</code> <strong>OR</strong> <code>Beethoven</code>.
This works for directories too: <code>readHumdrum(c('Mozart/.*krn', 'Beethoven/.*krn'))</code> will
search for files matching <code>.*krn</code> in directories matching <code>Mozart</code> or <code>Beethoven</code>.
For this sort of call, it can be convenient to break the search across arguments:
<code>readHumdrum(c("Mozart", "Beethoven"), ".*krn")</code> will give the same result.
When the multiple <code>...</code> arguments are appended, every possible combination of arguments is
used to create search patterns.
Thus, a call like <code>readHumdrum(c('[A-G]', '[a-g]), c('Mozart', 'Beethoven'), '.*krn')</code> will search all the following
patterns:</p><ul><li><p><code>[A-G]/Mozart/.*krn</code></p></li>
<li><p><code>[a-g]/Mozart/.*krn</code></p></li>
<li><p><code>[A-G]/Beethoven/.*krn</code></p></li>
<li><p><code>[a-g]/Beethoven/.*krn</code></p></li>
</ul><p>When reading humdrum data, we refer to files matched from different regex patterns to be "subcorpora" of the total corpus.
The last search above would create a dataset with four subcorpora, which are tracked in the <a href="humdrumRclass.html">humdrumR object's</a>
<code>Label</code> field.
By default, subcorpora are simply numbered: <code>"_1"</code>, <code>"_2"</code>, etc.
However, if pattern arguments are named, these names will show up in the <code>Label</code> field instead.</p>
</div>

<div class="section">
<h3 id="filter-files-by-content">Filter files by content<a class="anchor" aria-label="anchor" href="#filter-files-by-content"></a></h3>


<p>The <code>contains</code> argument can be a <code>character</code> vector of regular expressions
to search in the <em>contents</em> of matched files (as opposed to matching the file name/path).
Is <code>contains</code> is not <code>NULL</code> (which is the default),
<code>humdrumR</code> searches all files matched by the regex search pattern(s) for
any matches to the <code>contains</code> regexes.
Files which match <strong>all</strong> the <code>contains</code> regexes are read, others are discarded.</p>
<p>For example, the command <code>readHumdrum(./.*krn$, contains = c('[Ee]-', '[Aa]-'))</code> will
read all <code>krn</code>-extension files in the working directory which contain E-flat <em>and</em> a A-flat tokens.</p>
</div>

    </div>
    <div class="section level2">
    <h2 id="tandem-interpretations">Tandem Interpretations<a class="anchor" aria-label="anchor" href="#tandem-interpretations"></a></h2>
    


<p>All tandem interpretations in a humdrum dataset are summarized in the <a href="humTable.html">humdrum table's</a>
<code>Tandem</code> field, which is described in detail <a href="extractTandem.html">here</a>.
In addition, certain "known" tandem interpretations are parsed into their <em>own</em> fields automatically.
For example, <code>*clefG4</code> and "<code>*clefF2</code> are parsed into a <code>Clef</code> field,
while <code>*k[b-]</code> is parsed into a <code>KeySignature</code> field.
The "known" tandem interpretations that <code>humdrumR</code> recognizes are encoded in a built-in
table called <code>knownInterpretations</code>, which contains five <code>character</code> columns:</p><ul><li><p><code>Name</code>: A code name <code>humdrumR</code> uses (e.g., <code>Clef</code> or <code>TimeSignatue</code>).</p></li>
<li><p><code>Exclusive</code>: Zero or more (comma-separated) exclusive interpretations associated with the tandem interpretation.</p></li>
<li><p><code>RE</code>: A regular expression which matches instances of the tandem interpretation.</p></li>
<li><p><code>Pretty</code>: A readable shorthand of the tandem interpretation's pattern.</p></li>
<li><p><code>Type</code>: One of three types: <code>"Tandem"</code>, <code>"Exclusive"</code>, or <code>"Atomic"</code>.</p></li>
</ul><p>The <code>tandems</code> argument to <code>readHumdrum</code> controls which tandem interpretations are
parsed into their own fields. This can be helpful to either save processing time and memory
by <em>not</em> parsing interpretations you won't need, or to parse interpretations that
<code>humdrumR</code> doesn't recognize.
The default value for the <code>tandems</code> argument is <code>"known"</code>. If the <code>tandems</code> argument
contains <code>"known"</code> <em>all</em> tandem interpretations in the built-in <code>knownInterpretations</code>
table are parsed.
If you want to limit the number of interpretations that are parsed,
you may explicitly indicate known interpretations to parse by giving their <code>Name</code> (matching
<code>knownInterprations$Name</code>) in the <code>tandems</code> argument.
For instance, if you specify <code>tandems = c('Clef', 'TimeSignature')</code>, only clef (e.g., <code>"*clefG2"</code>),
and time signature (e.g., <code>"*M3/4"</code>) interpretations will be parsed.</p>
<p>If you want to parse novel interpreations that aren't known to <code>humdrumR</code>,
you can alternatively specify an arbitrary regular expressions in the <code>tandem</code> argument.
(So long as they don't exactly match a <code>Name</code> from <code>knownInterpretations</code>.)
These regular expressions are matched against the <a href="extractTandem.html">Tandem field</a>
and used to generate new fields for the <a href="humTable.html">humdrum table</a>.
If any values in <code>tandems</code> are named, these names will be used for the resulting fields.
If no matches to an given interpretation are found, no field is created for that interpretation.
If <code>tandems = NULL</code>, then no tandem interpretations are parsed.</p>
    </div>
    <div class="section level2">
    <h2 id="reference-records">Reference Records<a class="anchor" aria-label="anchor" href="#reference-records"></a></h2>
    


<p>By default (<code>reference = "all"</code>), humdrumR reads all reference records in the data.
The reference code for each record (e.g, the <code>"OTL"</code>, in <code>"!!!OTL: xxx"</code>) is used as the name of
an associated field.
If a reference record has no reference code (i.e., it lacks a colon), the field is called <code>"Unkeyed."</code>
If there are more than one reference records with the same reference code,
either explicitly numbered (e.g., <code>"!!!COM1:"</code>, <code>"!!!COM2:"</code>) or not,
a single field is created (<code>COM</code> in this case) with the multiple values separated by <code>";"</code>.</p><div class="section">
<h3 id="controlling-reference-parsing">Controlling reference parsing<a class="anchor" aria-label="anchor" href="#controlling-reference-parsing"></a></h3>


<p>The <code>reference</code> argument can be used to control which reference codes are parsed by <code>readHumdrum</code>,
and/or rename their resulting fields.
Unless <code>reference == "all"</code>, only referene codes specifically indicated in <code>reference</code> are parsed;
For example, <code>readHumdrum(_, reference = "OTL")</code> will <em>only</em> parse OTL reference records.
By naming the values of <code>reference</code>, the resulting field name can be controled:
If we specify <code>reference = c(Title = 'OTL')</code>, the <code>OTL</code> reference records will be placed in
a field called <code>Title</code>.
If <code>reference = NULL</code>, no reference records are parsed.</p>
<p>In large datasets with many reference records, the reference data can actually make up a large portion
of the humdrum table, using up a lot of memory. In these cases, simply
not reading reference records (<code>reference = NULL</code>) or selectively reading only the reference records
that we are planning to use in our analyses can be quick and easy way to reduce memory consumption.</p>
</div>

    </div>
    <div class="section level2">
    <h2 id="spines-and-paths">Spines and Paths<a class="anchor" aria-label="anchor" href="#spines-and-paths"></a></h2>
    


<p>At first glance, humdrum data looks like a simple two-dimensional, tab-delineated table structure.
However, the <a href="http://www.humdrum.org/guide/ch05/" class="external-link">humdrum syntax</a> is bit more complicated than that.
Wheres as two-dimensional table has stable "columns",
humdrum data has "<em>spines</em>":
"Spines" <em>can</em> be a single column, or they may (at any time) split into multiple "spine <em>paths</em>",
which can in turn split again, using the <code>"*^"</code> interpretation token. The reverse can happen as well,
with two or more paths merging into a single spine, using the <code>"v"</code> token.
Thus the humdrum syntax is actually a flexible tree structure; As spines split and merge, the total number of "columns"
can change during a piece.
A related issue is that a "corpus" (collection) of humdrum files may have varying numbers of spines/columns between pieces.
Finally, <em>global</em> comment records are also a special case, as that are always a single value, even though
they are interspersed with multi-spine <em>local</em> records.)</p>
<p>To make parsing and manipulating humdrum data data simpler,
<code>readHumdrum</code> assumes a slightly restricted version of the humdrum syntax:
namely, that spines which appear at the beginning of a file (headed with exclusive interpretations
like <code>"**kern"</code>) can never merge into each other.
Spine merges (<code>"*v"</code>) can only happen within spine paths that originally split off the same spine, which means
that a humdrum file read into <code>humdrumR</code>
must not end with fewer columns than it starts.
This extra-strict specification of spine paths in the humdrum syntax is, fortunately, something that has been
informally followed in most humdrum data sets.</p>
<p>Our strict spine-path definition makes parsing humdrum data into a uniform structure possible:
Within a piece, the spines which appear at the beginning of the piece are the "true" spines throughout the piece, numbered
from left to right, starting from <code>1</code>.
For each <em>local</em> token, the value in the <code>Spine</code> field is an integer indicating which of these
"true" spines it belongs to---global tokens have a <code>NA</code> value in their <code>Spine</code> field, because they do not belong to any spine.
Any spine path splits (<code>"*^"</code>) from the main spines form <strong>spine paths</strong>.
Every spine's paths are numbered in the <code>Path</code> field, from right to left, starting from <code>0</code>.
A spine with no splits will have all <code>0</code>s in its <code>Path</code> field.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"></span>
<span class="r-in"><span class="fu">readHumdrum</span><span class="op">(</span><span class="op">)</span> <span class="co"># loads all valid humdrum files in the current directory.</span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Finding and reading files...</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> 	REpath-pattern '' matches 101 text files in 1 directory.</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> 101 files read from disk.</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Validating 101 files...</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> 22,798 errors in 101 files...</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> zero valid files.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NULL</span>
<span class="r-in"></span>
<span class="r-in"><span class="fu">readHumdrum</span><span class="op">(</span><span class="st">".*krn$"</span><span class="op">)</span> <span class="co"># loads all files ending with "krn" in the currect directory</span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Finding and reading files...</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> 	REpath-pattern '.*krn$' matches 0 text files in 1 directory.</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Zero files read from disk.</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> No files to validate.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NULL</span>
<span class="r-in"></span>
<span class="r-in"><span class="fu">readHumdrum</span><span class="op">(</span><span class="st">"^Composers$/^Be|^Mo/.*/^Joined$/.*krn$"</span><span class="op">)</span> </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Finding and reading files...</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> 	REpath-pattern '^Composers$/^Be|^Mo/.*/^Joined$/.*krn$' matches 0 text files in 0 directories.</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Zero files read from disk.</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> No files to validate.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NULL</span>
<span class="r-in"><span class="co"># Goes inside the directory "Composers".</span></span>
<span class="r-in"><span class="co"># Inside "Composers" looks for directories that start with "Be" or "Mo".</span></span>
<span class="r-in"><span class="co"># If there are any "Be|Mo" matching directories within "Composers", matches all directories within them.</span></span>
<span class="r-in"><span class="co"># Within these directories, looks for directories called "Joined".</span></span>
<span class="r-in"><span class="co"># If there are any directories called "Joined", loads all files (if any) that end with "krn".</span></span>
<span class="r-in"></span>
<span class="r-in"><span class="fu">readHumdrum</span><span class="op">(</span><span class="st">"^Composers$"</span>, <span class="st">"^Be|^Mo"</span>, <span class="st">".*"</span>, <span class="st">"^Joined$"</span>, <span class="st">".*krn$"</span><span class="op">)</span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Finding and reading files...</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> 	REpath-pattern '^Composers$/^Be|^Mo/.*/^Joined$/.*krn$' matches 0 text files in 0 directories.</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Zero files read from disk.</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> No files to validate.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NULL</span>
<span class="r-in"><span class="co"># exactly the same as the previous!</span></span>
<span class="r-in"></span>
<span class="r-in"><span class="fu">readHumdrum</span><span class="op">(</span><span class="st">"^Composers$"</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span>Beethoven <span class="op">=</span> <span class="st">"^Be"</span>, Mozart <span class="op">=</span> <span class="st">"^Mo"</span><span class="op">)</span>, <span class="st">".*"</span>, <span class="st">"^Joined$"</span>, <span class="st">".*krn$"</span><span class="op">)</span> </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Finding and reading files...</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> 	REpath-pattern Beethoven = '^Composers$/^Be/.*/^Joined$/.*krn$' matches 0 text files in 0 directories.	REpath-pattern Mozart = '^Composers$/^Mo/.*/^Joined$/.*krn$' matches 0 text files in 0 directories.</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Zero files read from disk.</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> No files to validate.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NULL</span>
<span class="r-in"><span class="co"># exactly the same as the previous, except now the two matching patterns ("^Be", or "^Mo") will be grouped</span></span>
<span class="r-in"><span class="co"># in the Label field as "Beethoven" and "Mozart" respectively.</span></span>
<span class="r-in"></span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p></p><p>Developed by Nathaniel Condit-Schultz, Claire Arthur.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a>
2.0.2.</p>
</div>

    </footer></div>

  

  

  </body></html>

