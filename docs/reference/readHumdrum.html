<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="description" content="These functions find valid humdrum files on your local machine and read them into humdrumR."><title>Find and read humdrum files into R — knownInterpretations • humdrumR</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.1.0/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.1.0/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- bootstrap-toc --><script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Find and read humdrum files into R — knownInterpretations"><meta property="og:description" content="These functions find valid humdrum files on your local machine and read them into humdrumR."><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-dark navbar-expand-lg bg-primary"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">humdrumR</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.4.0.9000</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <h6 class="dropdown-header" data-toc-skip>Basics</h6>
    <a class="dropdown-item" href="../articles/GettingStarted.html">Getting started with humdrumR</a>
    <a class="dropdown-item" href="../articles/IntroForCoders.html">HumdrumR for coders</a>
    <div class="dropdown-divider"></div>
    <h6 class="dropdown-header" data-toc-skip>R/Humdrum background</h6>
    <a class="dropdown-item" href="../articles/HumdrumSyntax.html">The humdrum syntax</a>
    <a class="dropdown-item" href="../articles/RPrimer.html">An R primer for humdrumR users</a>
    <div class="dropdown-divider"></div>
    <h6 class="dropdown-header" data-toc-skip>Data prep</h6>
    <a class="dropdown-item" href="../articles/ReadWrite.html">Reading and writing data</a>
    <a class="dropdown-item" href="../articles/Reshaping.html">Shaping humdrum data</a>
    <a class="dropdown-item" href="../articles/Filtering.html">Filtering humdrum data</a>
    <div class="dropdown-divider"></div>
    <h6 class="dropdown-header" data-toc-skip>Analysis</h6>
    <a class="dropdown-item" href="../articles/Summary.html">Getting to know your data</a>
    <a class="dropdown-item" href="../articles/WorkingWithData.html">Working with humdrum data</a>
    <div class="dropdown-divider"></div>
    <h6 class="dropdown-header" data-toc-skip>Musical tools</h6>
    <a class="dropdown-item" href="../articles/PitchAndTonality.html">Pitch and tonality in humdrumR</a>
    <a class="dropdown-item" href="../articles/RhythmAndMeter.html">Rhythm and meter in humdrumR</a>
    <a class="dropdown-item" href="../articles/KeysAndChord.html">Diatonic and tertian sets in humdrumR</a>
  </div>
</li>
      </ul><form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off"></form>

      <ul class="navbar-nav"><li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul></div>

    
  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="" class="logo" alt=""><h1>Find and read humdrum files into R</h1>
      <small class="dont-index">Source: <a href="https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/blob/HEAD/R/Interpretations.R" class="external-link"><code>R/Interpretations.R</code></a>, <a href="https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR/blob/HEAD/R/Read.R" class="external-link"><code>R/Read.R</code></a></small>
      <div class="d-none name"><code>readHumdrum.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>These functions find valid humdrum files on your local machine and read them into <code>humdrumR</code>.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="va">knownInterpretations</span>

<span class="fu">findHumdrum</span><span class="op">(</span>
  <span class="va">...</span>,
  contains <span class="op">=</span> <span class="cn">NULL</span>,
  recursive <span class="op">=</span> <span class="cn">FALSE</span>,
  allowDuplicates <span class="op">=</span> <span class="cn">FALSE</span>,
  verbose <span class="op">=</span> <span class="cn">FALSE</span>
<span class="op">)</span>

<span class="fu">readHumdrum</span><span class="op">(</span>
  <span class="va">...</span>,
  recursive <span class="op">=</span> <span class="cn">FALSE</span>,
  contains <span class="op">=</span> <span class="cn">NULL</span>,
  allowDuplicates <span class="op">=</span> <span class="cn">FALSE</span>,
  verbose <span class="op">=</span> <span class="cn">FALSE</span>,
  tandems <span class="op">=</span> <span class="st">"known"</span>,
  reference <span class="op">=</span> <span class="st">"all"</span>
<span class="op">)</span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="format">Format<a class="anchor" aria-label="anchor" href="#format"></a></h2>
    


    </div>
    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>
    <dl><dt>...</dt>
<dd><p>character: One or more patterns used to identify files to read.
For details: see the "REpath-patterns" section below.</p></dd>
<dt>contains</dt>
<dd><p><code>character</code>. If <code>!is.null(contains)</code>, the <code>contains</code> argument is
is treated as regular expressions: only files which contain matches to
<em>all</em> of these regular expressions are read.
Thus, <code>readHumdrum('.*krn$', contains = "EEE")</code> will only read kern files which contain matches
to <code>"EE"</code>---which is kern for the E two octaves below middle C (or lower).</p></dd>
<dt>recursive</dt>
<dd><p>logical: If <code>TRUE</code>, the final part of the search pattern (i.e., the file search) is searched for
recursively through all sub directories.</p></dd>
<dt>allowDuplicates</dt>
<dd><p><code>logical</code> of length one, indicating what should happen if multiple search patterns match the same files.
If <code>allowDuplicates = TRUE</code>,
any such files are read multiple times, grouped into their respective corpora by the <code>Label</code> field.
If <code>allowDuplicates = FALSE</code>, any redundant files are only read into the corpus of the first pattern they
match.</p></dd>
<dt>verbose</dt>
<dd><p>logical: If <code>TRUE</code>, the names of matching files are printed before parsing begins. This is very
useful as a check to make sure you aren't reading the wrong files!</p></dd>
<dt>tandems</dt>
<dd><p><code>character</code>. This argument controls which, if any, tandem interpretations
are parsed into their own fields. The default value is <code>"known"</code>.</p></dd>
<dt>reference</dt>
<dd><p><code>character</code>. This argument controls which, if any, reference records
are parsed into their own fields. The default value is <code>"all"</code>.</p></dd>
</dl></div>
    <div class="section level2">
    <h2 id="details">Details<a class="anchor" aria-label="anchor" href="#details"></a></h2>
    <p><code>findHumdrum</code> does the work of finding and reading the text files into <code>R</code>.
<code>readHumdrum</code> utilizes <code>findHumdrum</code> to read files, then parses them to
create a <a href="humTable.html">humdrum table</a> and build
a <a href="humdrumRclass.html">humdrumR data object</a> around the table.</p>
    </div>
    <div class="section level2">
    <h2 id="repath-patterns">REpath-patterns<a class="anchor" aria-label="anchor" href="#repath-patterns"></a></h2>
    


<p>"REpath-patterns" are specified using <code>...</code> arguments.
In combination, all the <code>...</code> arguments are used to search for file paths.
Each part of the search path you specify (<code>"dirpart/dirpart/filepart"</code>, etc) are matched as regular expressions
against directories/files on your disc.
Thus, we can say things like <code>findHumdrum("../^A.*/.*krn$")</code>, which would
match any kern files in any directory beginning with a capital <code>"A"</code> in the
directory above the current working directory.
For conveniance, you can break the path across multiple arguments instead of using delimited strings: For example, the code
<code>findHumdrum("..", "^A.*", ".*krn$")</code> will give an identical result as the previous example
(<code>findHumdrum("../^A.*/,*krn$")</code>).
This is useful when searching for more than one pattern (see next paragraph) in the same directory.</p>
<p>If you want to search for <em>more than one</em> pattern, you can input them as a character vector:
For instance, <code>readHumdrum(c("mozart", "beethoven")</code>---this command will search for
filenames containing "mozart" OR "beethoven."
This works for directories too: <code>readHumdrum(c("Mozart", "Beethoven"), ".*krn$")</code> will
look for any kern files in directories containing "Mozart" OR "Beethoven."
If patterns are named, these names will show up as identifying patterns in the <code>[humdrumR][humdrumR]</code> object's
<code>Label</code> field. Unnamed patterns are simply labeled with numbers.
We refer to files matched from regex patterns to be "subcorpora" of the total corpus.</p>
<p>Normal (system appropriate) conventions (i.e., directories separated by <code>"/"</code>,
<code>'~'</code> at beginning to indicate home, <code>".."</code> to indicate directory above working directory, etc.)
are followed.
If a pattern contains a solo dot followed by a file sep---e.g., <code>"./"</code>, <code>"x/./y"</code>---this is
treated as the current directory, not a regular expression.
If a pattern contains two dots---e.g., <code>"../"</code>---this is treated as the directory above, not a regular expression.
If you want to create a regular expression to match any directory, use <code>".*/"</code>.</p>
<p>The regex pattern <code>""</code> matches any file (it is changed to <code>".*"</code>). If you don't specifiy any <code>...</code> argument,
<code>findHumdrum</code> (or <code>readHumdrum</code>) will default to <code>".*"</code> as well.
Thus, <code>readHumdrum()</code> will read any humdrum files in the working directory.</p>
<p>(If two or more files in different directories share the same name, a unique name is created for
each file by appending the names of the directories they occupy, recursively
until the names are unique.)</p>
<p>If a single humdrum file has multiple pieces in it---meaning that all spine paths close with <code>*-</code>, then
open again with <code>**</code>---then they are parsed separately.
They are distinguished in the <code>Piece</code> field.
If there are no multi-piece files, <code>Piece</code> and <code>File</code> will be identical.</p>
    </div>
    <div class="section level2">
    <h2 id="validity">Validity<a class="anchor" aria-label="anchor" href="#validity"></a></h2>
    


<p><code>findHumdrum</code> and <code>readHumdrum</code> automatically ignore non-text files.
What's more, any files which contain humdrum syntax errors (checked by <code><a href="validateHumdrum.html">validateHumdrum()</a></code>) are automatically
skipped. If you want to see specifically what errors occurred, call <code><a href="validateHumdrum.html">validateHumdrum()</a></code>
directly and use its <code>errorReport.path</code> argument.</p>
    </div>
    <div class="section level2">
    <h2 id="tandem-interpretations">Tandem Interpretations<a class="anchor" aria-label="anchor" href="#tandem-interpretations"></a></h2>
    


<p>All tandem interpretations in a humdrum dataset are summarized in the <a href="humTable.html">humdrum table's</a>
<code>Tandem</code> field, which is described in detail <a href="extractTandem.html">here</a>.
In addition, certain "known" tandem interpretations are parsed into their <em>own</em> fields automatically.
For example, <code>*clefG4</code> and "<code>*clefF2</code> are parsed as <code>Clef</code> data, while <code>*k[b-]</code> is parsed as a <code>KeySignature</code>.
The "known" tandem interpretations that <code>humdrumR</code> recognizes are encoded in a built-in
table called <code>knownInterpretations</code>.
Each interpretation has a humdrumR name (<code>"Clef"</code>, <code>"TimeSignature"</code>, etc.) as well as a regular expression
associated with it.</p>
<p>The <code>tandems</code> argument to <code>readHumdrum</code> controls which tandem interpretations are
parsed into their own fields. This can be helpful to either save processing time and memory
by <em>not</em> parsing interpretations you won't need, or to parse interpretations that
humdrumR doesn't recognize.
The default value for the <code>tandems</code> argument is <code>"known"</code>. If the <code>tandems</code> argument
contains <code>"known"</code> <em>all</em> tandem interpretations in the built-in <code>knownInterpretations</code>
table are parsed.
Users may specify different interpretations to parse in two ways:</p><ol><li><p>character strings
matching one of the name values from the <code>Name</code> column of <code>knownInterpretations</code>.
For instance, if you specify <code>tandems = c('Clef', 'TimeSignature')</code>, only clef (e.g., <code>"*clefG2"</code>),
and time signature (e.g., <code>"*M3/4"</code>) intepretations will be parsed.</p></li>
<li><p>if the character string(s) in <code>tandem</code> do not exactly match one of the names in
<code>knownInterpretations$Name</code>, they are treated as regular expressions and used to match
tandem interpretations in the data. This allows users to parse non-standard tandem interpretations
that humdrumR doesn't already know about.</p></li>
</ol><p>If any values in <code>tandems</code> are named, these names will be used for resulting fields.
If no matches to an given interpretation are found, no field is created for that interpretation.
If <code>tandems = NULL</code>, then no tandem interpretations are parsed.</p>
    </div>
    <div class="section level2">
    <h2 id="reference-records">Reference Records<a class="anchor" aria-label="anchor" href="#reference-records"></a></h2>
    


<p>By default (<code>reference = "all"</code>), humdrumR reads all reference records in the data.
The reference code for each record (e.g, the "OTL", in "!!!OTL: xxx") is used as the name of
an associated field.
(If a reference record has no reference code (i.e., it lacks a colon), the field is called "Unkeyed.")
In large datasets with many reference records, the reference data can actually make up a large portion
of the humdrum table, and eat up a lot of memory. In these cases, we might not want to read
all (or any) reference records---we can instead read only the reference records that we are planning to use
in our analyses (if any).
If <code>reference = NULL</code>, no reference records are parsed.
Otherwise, the character values of <code>reference</code> are treated as reference codes and only
matching reference records are parsed.
For instance, <code>readHumdrum(_, reference = "OTL")</code> will <em>only</em> parse OTL reference records.
If the values of <code>reference</code> are named, these names are used to name associated fields.
Thus, by specifing <code>reference = c(Title = 'OTL')</code>, you can use "OTL" reference records to populate
a field called "Title".</p>
<p>If there are more than one reference records with the same reference code,
either explicitely numbered (e.g., "!!!COM1:", "!!!COM2:") all are read and rather than making two
or more fields, a single field is created ("COM" in this) with the multiple values separated by ";".</p>
    </div>
    <div class="section level2">
    <h2 id="spines-and-paths">Spines and Paths<a class="anchor" aria-label="anchor" href="#spines-and-paths"></a></h2>
    


<p>In the <a href="http://www.humdrum.org/guide/ch05/" class="external-link">humdrum syntax</a>, data is placed in "spines,"
which are not the same as "columns" in a spreadsheet. A "column" refers to a
tab-delineated group of values.
"Spines" can be a single column, or they may (at any time) split into multiple columns,
which can in turn split again, using the <code>"*^"</code> interpretation token. The reverse can happen as well,
with two or more columns merging into a single column, using the <code>"v"</code> token.
This means that, while humdrum data at first glance looks like a simple two-dimensional table,
it is actually a flexible tree structure. As spines split and merge, the total number of columns
can change during a piece, creating a "ragged" edge.
Another similar issue is that a corpus of humdrum files may have varying numbers of spines/columns, between pieces.
("Global" comment/reference records are also a special case, as that are always a single value, even if interspersed with
multi-column local records.)
<code>readHumdrum</code> assumes a slightly more strict version of the humdrum syntax:
that all the spines which appear at the beginning of a file (headed with exclusive interpretations
like <code>"**kern"</code>) can never merge into each other. Thus, a humdrum file read into <code>humdrumR</code>
must not end with fewer columns than it starts.
Spine merges (<code>"*v"</code>) can only happen within spine paths that originally split off the same spine.
This extra-strict specification of spine paths in the humdrum syntax is, fortunately, something that has been
informally followed in most humdrum datasets.</p>
<p>Our strict spine-path definition makes everything work fairly simply:
Within a piece, the spines which appear at the beginning of the piece are the "true" spines throughout the piece, numbered
from left to right, starting from <code>1L</code>.
For each local token, the value in the <code>Spine</code> field is an integer indicating which of these
"true" spines it belongs to---global tokens have a <code>NA</code> value in their <code>Spine</code> field, because they do not belong to any spine.
Any spine path splits (<code>"*^"</code>) from the main spines form <strong>spine paths</strong>.
Every spine's paths are numbered in the <code>Path</code> field, from right to left, starting from <code>0L</code>.
A spine with no splits will have all <code>0L</code>s in its <code>Path</code> field.</p>
    </div>
    <div class="section level2">
    <h2 id="result">Result<a class="anchor" aria-label="anchor" href="#result"></a></h2>
    


<p><code>findHumdrum</code> returns a "fileFrame" (<code>data.table</code>), listing all file names,
the patterns they match, the directories they were found in, <em>and</em> the raw text content of these files.</p>
<p><code>readHumdrum</code> returns a fully parsed <a href="humdrumRclass.html">humdrumR object</a>.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"></span>
<span class="r-in"><span class="fu">readHumdrum</span><span class="op">(</span><span class="op">)</span> <span class="co"># loads all valid humdrum files in the current directory.</span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Finding and reading files...</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> 	REpath-pattern '.*' matches 123 text files in 1 directory.</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> 123 files read from disk.</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Validating 123 files...</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> 27,106 errors in 123 files...</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> zero valid files.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NULL</span>
<span class="r-in"></span>
<span class="r-in"><span class="fu">readHumdrum</span><span class="op">(</span><span class="st">".*krn$"</span><span class="op">)</span> <span class="co"># loads all files ending with "krn" in the currect directory</span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Finding and reading files...</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> 	REpath-pattern '.*krn$' matches 0 text files in 1 directory.</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Zero files read from disk.</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> No files to validate.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NULL</span>
<span class="r-in"></span>
<span class="r-in"><span class="fu">readHumdrum</span><span class="op">(</span><span class="st">"^Composers$/^Be|^Mo/.*/^Joined$/.*krn$"</span><span class="op">)</span> </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Finding and reading files...</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> 	REpath-pattern '^Composers$/^Be|^Mo/.*/^Joined$/.*krn$' matches 0 text files in 0 directories.</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Zero files read from disk.</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> No files to validate.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NULL</span>
<span class="r-in"><span class="co"># Goes inside the directory "Composers".</span></span>
<span class="r-in"><span class="co"># Inside "Composers" looks for directories that start with "Be" or "Mo".</span></span>
<span class="r-in"><span class="co"># If there are any "Be|Mo" matching directories within "Composers", matches all directories within them.</span></span>
<span class="r-in"><span class="co"># Within these directories, looks for directories called "Joined".</span></span>
<span class="r-in"><span class="co"># If there are any directories called "Joined", loads all files (if any) that end with "krn".</span></span>
<span class="r-in"></span>
<span class="r-in"><span class="fu">readHumdrum</span><span class="op">(</span><span class="st">"^Composers$"</span>, <span class="st">"^Be|^Mo"</span>, <span class="st">".*"</span>, <span class="st">"^Joined$"</span>, <span class="st">".*krn$"</span><span class="op">)</span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Finding and reading files...</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> 	REpath-pattern '^Composers$/^Be|^Mo/.*/^Joined$/.*krn$' matches 0 text files in 0 directories.</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Zero files read from disk.</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> No files to validate.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NULL</span>
<span class="r-in"><span class="co"># exactly the same as the previous!</span></span>
<span class="r-in"></span>
<span class="r-in"><span class="fu">readHumdrum</span><span class="op">(</span><span class="st">"^Composers$"</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span>Beethoven <span class="op">=</span> <span class="st">"^Be"</span>, Mozart <span class="op">=</span> <span class="st">"^Mo"</span><span class="op">)</span>, <span class="st">".*"</span>, <span class="st">"^Joined$"</span>, <span class="st">".*krn$"</span><span class="op">)</span> </span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Finding and reading files...</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> 	REpath-pattern Beethoven = '^Composers$/^Be/.*/^Joined$/.*krn$' matches 0 text files in 0 directories.	REpath-pattern Mozart = '^Composers$/^Mo/.*/^Joined$/.*krn$' matches 0 text files in 0 directories.</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> Zero files read from disk.</span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> No files to validate.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> NULL</span>
<span class="r-in"><span class="co"># exactly the same as the previous, except now the two matching patterns ("^Be", or "^Mo") will be grouped</span></span>
<span class="r-in"><span class="co"># in the Label field as "Beethoven" and "Mozart" respectively.</span></span>
<span class="r-in"></span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p></p><p>Developed by Nathaniel Condit-Schultz, Claire Arthur.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a>
2.0.2.</p>
</div>

    </footer></div>

  

  

  </body></html>

