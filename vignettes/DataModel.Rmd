---
title: "The humdrumR Data Model"
author: "Nathaniel Condit-Schultz"
date:   "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{The humdrumR Data Model}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r, include = FALSE}
source('vignette_header.R')

```

# The Data Model

To really make use of `r hm`, you need to understand a bit about how humdrum data is represented in the `r hm` package: the `r hm` "**data model**."

The essential thing to understand is how it maps between the [humdrum data syntax](https://humdrum.org) and a R data.table.

![](images/DataModelDiagram.png){width=600px}

To fully understand this, you should start with at least a basic understanding of the humdrum syntax! 
Read about the syntax at [humdrum.org](humdrum.org) or check out [our vignette](HumdrumSyntax.html "The Humdrum Syntax") on the topic.

## data.frames

Data.frames are essential to R.
A data.frame is simply a two-dimensional table of named columns.
Each column is either a vector or list of values, all of which are the same length.

`r Hm` makes use of a popular extension of base-R data.frames, the [data.table](https://cran.r-project.org/web/packages/data.table/index.html).


In `r hm`, *every* single, individual token in a collection of humdrum-syntax text files is given its own row in a data.frame.
For example, consider this simple, humdrum-syntax file:


```{r echo=FALSE, results='none'}

ex1 <- readLines('examples/BasicExample.krn')

rest <- ex1[-1]
tokens <- c(ex1[1], unlist(strsplit(rest, split = '\t| ')))

##
ex1df <- as.data.frame(t(stringi::stri_list2matrix(strsplit(rest, '\t'))), stringsAsFactors = FALSE)

cat(' ', sep = '', ex1[1], '\n')
apply(format.data.frame(ex1df, justify = 'left', width = 30), 1, 
      function(x) cat(' ', x, sep = '', '\n')) 


```

This file contains `r humdrumR:::num2print(length(tokens))` individual tokens.
To illustrate, here I'll print the same file, but with *each* token bracketed by `<` and `>`:

```{r echo = FALSE}

printquoted <- function(ex) {
quoted <- ex
    quoted[] <- lapply(quoted,
                   function(col) {
                       col <- strsplit(col, split = ' ')
                       col <- lapply(col,  function(x) paste0('<', x, '>'))
                       sapply(col, paste, collapse = ' ')
                       
                   })


cat('<', ex1[1], '>', '\n', sep ='')
apply(format.data.frame(quoted, justify = 'left', width = 30), 1, 
      function(x) cat(x, sep = '', '\n'))
    invisible(NULL)
}

printquoted(ex1df)

```

So what happens when `r hm` reads this file?
(This file is bundled with `r hm` in the `"humdrumRroot/examples"` directory.)

```{r}

example1 <- readHumdrum('examples/BasicExample.krn')

example1
```

We see the same thing we saw earlier, when we were reading real humdrum data from the `"HumdrumData"` folder.
But what's under the hood?
We can tell `r hm` that we'd like to see the underlying humdrum table by changing `r hm`'s print options using the `humdrumR()` command.
Specifically, we can set `view = "table"`:



```{r}

humdrumR(view = 'table')
example1

```


Use `humdrumR(view = 'humdrum')` to switch back to the humdrum-data view:

```{r}
humdrumR('humdrum')
example1

```

Since `view` is the first argument of `humdrumR()`, you can just type:

```{r}
humdrumR("table")
```

Ah, now we see that there is one row for *each and every* token.
There are columns indicating which `File`, `Spine`, and `Record` each token comes from.
In `r hm`, we refer to these columns as **fields**.
However, there are actually many more columns/fields in our table!---`r hm` is just showing us a few.
To learn what fields are in a `r hm` object, use the `fields` command:

```{r}
fields(example1)
```

We see that there are `r humdrumR:::num2print(length(example1))` fields (columns), and that they are divided into five types of fields: 

+ Data fields
+ Structure fields
+ Interpretation fields
+ Form fields
+ Reference fields

(A good place to read the details about what all the columns means is the *humdrum table* documentation you can get by calling `?humTable`.)


Let's go back to the Bach chorales dataset we loaded earlier (we saved it as `chorales`):

```{r}
fields(chorales)

```

The `chorales` corpus has `r nrow(fields(chorales))` fields!---all the same fields as `example1`, but some additional ones.
These additional fields are interpretation and reference records that didn't appear in our toy `example1`.

----

### Main Fields

The most important fields that are always present in a `r hm` humtable are 1) the `Token` field which contains the original `character` tokens read from the humdrum data; and 2) the "Structural" fields which tell us where in the original humdrum data each token came from.
The "Structural" fields are what allow `r hm` to (re)construct the original humdrum data---translating between the humdrum-table (`data.table`) and the plain-text humdrum syntax.

What if we want to see some of these other fields?
We can use the `select()` command to pick which fields we view:

```{r}

chorales |> select(Token, Spine, COM, Bar)

```

We can also see all fields of a particular type, by specifying one of the types that the [fields()] function 
showed us: for example, `"Data"`, `"Structure"`, or `"Reference"`.

```{r}
chorales |> select('Structure')

```


We can fully *extract* any field from our `r hm` data using the `$` operator: Just call your `r hm` data object with `$` and the name of a field.


```{r}

example1$Spine
example1$Record

example1$Type

example1$Filename

```

The "record types" are:

+ `"G"`: global comment (including reference records)
+ `"L"`: local comment
+ `"I"`: interpretation
+ `"M"`: measure (i.e., barlines)
+ `"D"`: (non-null) data token
+ `"d"`: null data token (`"."`)




### Stops

In humdrum syntax, multiple tokens can be placed "in the same place" (i.e., same record, same spine) by simply separating them with spaces.
(This is most commonly used to represent chords in `**kern` data.)
In `r hm`, we call these "Stops"---as always, **every** humdrum token, including stops, get their own row in a `r hm` humtable.
Thus, we need the `Stop` field to tell us which stop a token came from!
In much data, all/most tokens are simply `Stop == 1` (the first position), but if there are more than one tokens in the same record/spine, they will be numbered ascending from one:

Let's look at an example to make sense of this!
Let's start by looking at our humdrum-data view.

```{r}
humdrumR('humdrum')
stops <- readHumdrum('examples/Stops.krn')

stops
```


Here we have a file with chords in the second spine: individual note tokens separated by spaces.
Now, we can switch back to table view:

```{r}
humdrumR('table')
stops

```

You can see that each note of the chords gets its own row, numbered `1`, `2`, and `3` in the `Stop` field!



### Paths



Some humdrum data contains "spine paths"---places where a single spine splits into two.
`r hm` treats spine paths as "subspines" of the main spine which they split from, each one numbered in the `Path` field.
The starting path (leftmost) is numbered path `0`---in datasets with no spine paths, the `Path` field will be all zeros.
Other paths are numbered with higher integers.

Let's look at a simple example:

```{r}

humdrumR('humdrum')
paths1 <- readHumdrum('examples/Paths.krn')

paths1

humdrumR('table')

paths1

```


Here is a more complex example:

```{r}

paths2 <- readHumdrum('examples/Paths2.krn')

paths2





```

Notice that `r hm` prints paths in a way that is more readable than reading humdrum syntax directly:
paths are "shifted" over into columns that align.
This is an option to the function `as.matrix.humdrumR()`.

