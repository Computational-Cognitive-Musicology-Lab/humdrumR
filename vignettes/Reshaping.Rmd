---
title: "Reshaping Humdrum Data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Validating Humdrum Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = ""
)
```

```{r setup, message=FALSE, echo = FALSE}
library(humdrumR)
```


One of the great strengths of the [humdrum syntax](HumdrumSyntax.html "Intro to the humdrum syntax") is its flexibility---there are lots of ways you can structure your data to conveniently represent musical information.
However, when it comes time analyze data, we typically want to "reshape" our data into a particular format that is ideal for analysis.

We must determine, given our data *and* our particular research question, what constitutes a *single data observation*. 
We want each data observation, or data point, to correspond to one row in our humdrum table.
In order to shape our data, there are three steps we might need to do to our data:

1. Removing information we don't want.
2. Pasting together or aligning information that is currently separated.
3. Splitting apart information that is bundled together.


Consider the following small humdrum file:

```{r echo = TRUE}
setwd(humdrumRroot)
example <- readHumdrum('examples/Reshaping_example.hum')
example

```

This file contains seven different pieces of information!
There are two voices, alto and soprano;
Each voice has its rhythm *and* pitch information encoded in its `**kern` spine, plus lyrical information in the next `**silbe` spine.
In addition, the `**harm` spine indicates the harmony accompanying the vocal parts.

# Filtering Data

The first step might to remove data we don't need.
For example, if we are studying tonality, we might simply want to ignore the lyric data.
These easiest way to do this is to index out spines we don't want, either using numeric indices

```{r}
example[[ , c(1,3,5)]]
```


or by exclusive interpretation:

```{r}
example[[ , c('**kern', '**harm')]]

```


# Pasting/Aligning

## Folding

### Lyrics

The next step might be to align/combine information that is currently separated.
For example, the `**silbe` (lyric) data associates each syllable with exactly one note
in the adjacent `**kern` spine.
We might want to align this information, by "folding" the syllable information into a new field.

The most powerful way to to this is with the family of functions for "[folding][foldHumdrum()]" data.
"Folding" means taking information from one spine, path, or stop, and moving it into a new data field 
"on top of" another spine.
This means taking, for example, the data in Spine 2 and putting in a new field in Spine 1.

We can do this directly using [foldHumdrum()]: use the `fold` argument to indicate which spine to fold, and the `onto` argument to indicate which spine to move it onto.

```{r}
foldHumdrum(example, fold = 2, onto = 1)

```

Notice that the second spine has disappeared, and now there is a new field called `Pipe1`, in the first (`onto`) spine,
but containing the data from the old Spine 2.

An even easier way to do this, is based directly on the exclusive interpretations we want to fold.
We can do this using [foldExclusive()]:

```{r}
foldExclusive(example, 'silbe', 'kern')
```

Notice that [foldExclusive()] automatically folded both `**sible` spines onto their respective `**kern` spines, and have them a new field name.


### Harmonic Interval

Lots of humdrum files have multiple spines of `**kern`.
In some cases, we might want to tabulate rhythms or pitches across all spines.
However, if our research question concerns harmonic intervals (combinations of pitches happening at the same time)
we might want to fold the various `**kern` spines on top of each other.
We can do this using [foldHumdrum()] as well:

```{r}

kernonly <- example[[ , '**kern']]

foldHumdrum(kernonly, 2, 1) -> kernonly$Spine2

```

We could now cross tabulate the two spines of data:

```{r}

withHumdrum(kernonly, ~table(Token, Spine2))

```

