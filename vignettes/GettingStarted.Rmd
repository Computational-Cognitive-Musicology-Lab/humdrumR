---
title: "Getting started with humdrumR"
author: "Nathaniel Condit-Schultz"
date:   "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting started with humdrumR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r, include = FALSE}
source('vignette_header.R')

```


Welcome to "Getting started with `r hm`"!
This document will introduce you the basics of `r hm`, so that you can start doing simple analyses of humdrum data.
(If you aren't sure what `r hm` is or what it can do, checkout the [Overview of humdrumR](Overview.html "Overview of humdrumR") before trying to get started.)
This tutorial is aimed at novice or even non-programmers---if you are already a strong coder and want to move things a long a little faster, checkout the [humdrumR for coders](IntroForCoders.html "humdrumR for coders") tutorial instead.

This vignette closely parallels information in `r hm`'s code documentation;
within an R session, you can find more concise versions of the material in this document by calling:

```{r}
library(humdrumR)

?humdrumR

```

```{r, echo = FALSE}
humdrumR(syntaxHighlight = FALSE)

```

## Quick Start

Let's just dive right in!
First, make sure `r hm` is installed: [how to install humdrumR](https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR "Getting humdrumR from github").  
Open an R session and load the `r hm` library using the command `library(humdrumR)`---now you are ready to rock!

`r Hm` comes packaged with a small number of humdrum data files just for you to play around with.
These files are stored in the directory where your computer installed `r hm`, in a subdirectory called "HumdrumData".
You can move your R session to this folder using R's "set working directory" command: `setwd(humdrumRroot)`.
Once you're in the humdrumR directory, you can use the base R `dir` function to see what humdrum data is available to you.

```{r}
library(humdrumR)

setwd(humdrumRroot)

dir('HumdrumData')

```


It looks like there are `r humdrumR:::num2print(length(dir('HumdrumData')))` folders of humdrum data available to you.
Using `dir` again, we can look inside one: let's start with the 'BachChorales' folder.

```{r}

dir('HumdrumData/BachChorales')

```


There are `r humdrumR:::num2print(length(dir('HumdrumData/BachChorales')))` files in the folder, named "chor001.krn", "chor002.krn", etc.
These are plain humdrum text files, using the `**kern` interpretation to represent ten chorales by J.S. Bach.
Take a minute to find the files in your computer's finder/explorer and open them up with a simple text editor.
One of the core philosophies of `r hm` is that we maintain a direct, transparent relationship with our symbolic data---so always take the time to look at your data! 
You can also do this within Rstudio's "Files" pane---in fact, Rstudio will make things extra easy for you because you can (within the Files pane) click "More" > "Go To Working Directory" to quickly find the files.




### Reading humdrum data

Now that we've found some humdrum data to look at, let's read it into `r hm`.
We can do this using `r hm`'s `readHumdrum()` command.
Try this:

```{r}

readHumdrum('HumdrumData/BachChorales/chor001.krn') -> chor1

```

This command does two things:

1. The `readHumdrum()` function will read the "chor001.krn" file into R and create a `r hm` data object from it.
2. This new object will be saved to a variable called `chor1`. (The name 'chor1' is just a name I chose---you are welcome to give it a different name if you want.)

Once we've created our `chor1` object (or whatever you chose to call it), we can take a quick look at what it is by just typing its name on the command line and pressing enter:

```{r}

chor1

```

(In R, when you enter something on the command line, R "prints" it out for you to read.)
The print-out you see shows you the name of the file, the contents of the file, and some stuff about "Data fields" that you will learn about soon.

Cool! Still, looking at a single humdrum file is not really that exciting. 
The whole point of using computers is working with large amounts of data.
Luckily, `r hm` makes this very easy.
Check out this next command:

```{r}

readHumdrum('HumdrumData/BachChorales/chor0') -> chorales
```

Notice that all I've changed is that instead of writing `'chor001.krn'`, I wrote `'chor0'`.
When we feed the string `'chor0'` to `readHumdrum`, it won't just look for a file called "chor0"; it will read *any* file in that folder whose name *contains* the sub-string "chor0"---which in this case is all ten files!
Try printing the new `chorales` object to see how it is different:

```{r}

chorales

```

Wow! We've now got a "humdrumR corpus of `r humdrumR:::num2print(length(chorales)) ` pieces"---and that's nothing: `readHumdrum()` will work just as well reading hundreds or thousands of files!
Notice that when you print a `r hm` object, `r hm` shows you the beginning of the first file and the end of the last file, as well as telling you how many files there are in total.


---

> `readHumdrum()` has a number of other cool options which you can read about in more detail in our [humdrumR read/write tutorial](ReadWrite.html "Reading and writing data with humdrumR").


# Counting Things

The most fundamental practice in computational musicology is simply counting things!
To count the contents of data, we can use the `tally()` function.

```{r}
chorales |> 
  tally() 

```

That's quite a mess! What have we done?
When we pass or humdrumR data object (`chorales`) to `tally()`, tally counted all the unique data tokens (ignoring non-data tokens, like barline and interpretations).
There are a lot of unique tokens in this data, so it's not super helpful.
Maybe we'd like to look at just the twenty most common tokens in the `chorales`?
We can use `sort()` and `tail()`:


```{r echo=-1}
chorales |> tally() |> sort() |> tail(n = 1) -> most

chorales |> 
  tally() |>
  sort() |>
  tail(n = 20)

```

Ah, that's more promising! We see that most common token is a quarter-note E4 (`4e`), which occurs `r humdrumR:::num2print(most)` times.

## Separating pitch and rhythm

To make our tallies more useful, we might want to tally only the pitch or rhythm part of the `**kern` data.
We can do that using `r hm`'s suit of [pitch](https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchFunctions.html) and [rhythm](https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rhythmFunctions.html) functions.
For example, let's try the `pitch()` function:


```{r}
chorales |> 
  pitch()

```

Ah, the `**kern` tokens have been translated to scientific pitch, and the non-pitch information has been deleted!
Let's pass that to tally:

```{r}
chorales |>
  pitch() |>
  tally()


```

Pretty cool, but maybe we'd like to ignore octave information right now:
We can use the `simple` argument to get *simple* pitch information (no octave) and make a bar plot:

```{r}
chorales |>
  pitch(simple = TRUE) |>
  tally() |>
  draw()

```

Instead of pitch, we could do the same sort of tallying of rhythm information:

```{r}

chorales |>
  notehead() |>
  tally() |>
  draw()

```

## Filtering

Sometimes, we might only want to look at a subset of our data.
For example, maybe we want to tally the notes used by the soprano voice.
In these chorales, the soprano voice is always in the fourth spine.
We can use the `filter()` function to indicate a subset we'd like to study:

```{r}

chorales |> 
  pitch(simple = TRUE) |> 
  filter(Spine == 4) |>
  tally()

```

Let's try something even cooler.
Notice that, in the chorale data, there are tandem interpretations that look like `*G:` and `*E:`.
These are indications of the key.
Anytime you read humdrum data that has these key interpretations, `r hm` will read them into a "field" called `Key`.
We can tell `r hm` to show us the `Key` field (or any other field) by using `select()`:

```{r}
chorales |>
  select(Key)

```

We can even tally the `Key` field to see what keys are present:

```{r}

chorales |> 
  select(Key) |>
  tally()
```

There are (apparently) `r humdrumR:::num2print(chorales |> with(sum(Key == 'G:'), dataTypes = 'Dd'))` notes where the key is G major!
What if we only want to tabulate notes in that key?

```{r}

chorales |>
  select(Token) |>
  filter(Key == 'G:') |>
  pitch(simple = TRUE) |>
  tally()

```

Guess what? There are a bunch more "fields" hidden in your `r hm` data object that you can use...and you can make your own!
Try using the `fields()` function to see what fields are available---any of the fields you see can be selected with `select()`.
Also, check out the [HumdrumR Data Model](HumdrumR's data model DataModel.html) vignette to dig into the details of what these "fields" really are.

# Multiple fields

What if we want to study rhythm and pitch (or key, or anything else) at the same time?
Using the approach we've been using so far, we can only really look at one piece of information at a time.
However, if we string some of our previous commands together we can make some magic:

```{r}
chorales |>
  pitch(simple = TRUE) |>
  select(Token) |>
  recip() -> chorales

chorales

```

We called `pitch()` like before, but then we selected `Token`---"Token" is the default data field in `r hm`---the original tokens from your data files you read.
By calling `select(Token)` we sort of "reset" our selection to the original data.
We can then call `recip()` to get the rhythm data, and then we assign (`->`) the data back to replace the `chorales` variable---this "saves" what we've done.
The result is we now have a dataset with *three* "data fields": `r humdrumR:::harvard(fields(chorales, 'Data')$Name, 'and')`.
We can select any of these three:

```{r}

chorales |> select(Pitch)
chorales |> select(Recip)

chorales |> select(Pitch, Recip)

```

We can "see" that all three of these data fields are present in our data, at your finger tips.


```{r}
chorales |> 
  select(Pitch, Recip) |>
  tally()

```



```{r}
chorales |> 
  select(Pitch, Recip) |>
  tally() |> 
  draw()

```

# More Complex Expressions 

So far we've worked with our `r hm` data by applying functions like `pitch()`, `notehead()`, and `tally()` to it.
We've also seen that we can use `select()` to select which fields in the data to apply our functions to.
For more complex analyses, or when working with non-`r hm` functions, you'll find that this approach won't be enough!
We might want to write code that manipulates multiple fields in our data more freely.

These simplest way is by piping our data to the `mutate()` function, which takes a `r hm` object and an expression on its right side.


```{r}

chorales |>
  mutate(Spine + File)

chorales |>
  mutate(nchar(Token))

chorales |>
  mutate(paste0(Token, Record))

```

Each expression is evaluated, and the result is put back in the same place in the humdrum data!
You'll also notice that in the printout, we see new data fields corresponding to each expression we evaluated.

If you want, you can pick your own names by using `=` within the `mutate` call.
For instance, lets use `r hm`'s `semits` function (see the [humdrum pitch](PitchAndTonality.html) vignette) to calculate the semitone value for each pitch in the chorales:

```{r}

chorales |> 
  mutate(semits(Token))


```

It worked!
Lets do it again, but save the result in a new field, which we will call `Semits`---of course, you could give it any name you want, or just let it use the default name.

```{r}

chorales |> 
  select(Token) |>
  mutate(Semits = semits(Token)) -> chorales

chorales

```

There is now a new Data field in our humdrum table, called `Semits`.
Meanwhile, the original `Token` field is still there, safely unchanged!
Just like before, we can use `select()` operator to look at our fields:

```{r}

chorales |> select(Token)

chorales |> select(Semits)

```

Whats more, we can use the `Semits` field *just* like any other field:

```{r}

chorales |>
  mutate(paste0(Token, ' = ', Semits))



```




# What next?

You've gotten started, but there is much more to learn!
To keep learning check out the other articles on the [humdrumR webpage](https://computational-cognitive-musicology-lab.github.io/humdrumR/).
If you want to continue along the path we've started here, the next articles to check out are probably 
[Getting to know your data](Summary.html "Getting to know your data"),
[Filtering humdrum data](Filtering.html "Filtering humdrum data"), and 
[Working with humdrum data](WorkingWithData.html "Working with humdrum data").
Since most musicological analysis involves pitch or rhythm, you'll probably want to learn about
relevant ideas from the [Pitch and tonality](PitchAndTonality.html "Pitch and tonality in humdrumR")
and [Rhythm and meter](RhythmAndMeter.html "Rhythm and meter in humdrumR") articles.

If the humdrum data you are working with is complex---e.g., including multiple different exclusive interpretations,
spine paths, or multi-stops---you'll probably find you need to check out the [Shaping humdrum data](Reshaping.html "Shaping humdrum data") article, which will
give you tools to deal with with more complex humdrum data sets.



