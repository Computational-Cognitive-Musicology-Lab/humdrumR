---
title: "Getting started with humdrumR"
author: "Nathaniel Condit-Schultz"
date:   "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting started with humdrumR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r, include = FALSE}
source('vignette_header.R')

```


Welcome to "Getting started with `r hm`"!
This document will introduce you the basics of `r hm`, so that you can start doing simple analyses of humdrum data.
(If you aren't sure what `r hm` is or what it can do, checkout the [Overview of humdrumR](Overview.html "Overview of humdrumR") before trying to get started.)
This tutorial is aimed at novice or even non-programmers---if you are already a strong coder and want to move things a long a little faster, checkout the [humdrumR for coders](IntroForCoders.html "humdrumR for coders") tutorial instead.

This vignette closely parallels information in `r hm`'s code documentation;
within an R session, you can find more concise versions of the material in this document by calling:

```{r}
library(humdrumR)

?humdrumR

```

```{r, echo = FALSE}
humdrumR(syntaxHighlight = FALSE)

```

## Quick Start

Let's just dive right in!
First, make sure `r hm` is installed: [how to install humdrumR](https://github.com/Computational-Cognitive-Musicology-Lab/humdrumR "Getting humdrumR from github").  
Open an R session and load the `r hm` library using the command `library(humdrumR)`---now you are ready to rock!

`r Hm` comes packaged with a small number of humdrum data files just for you to play around with.
These files are stored in the directory where your computer installed `r hm`, in a subfolder called "HumdrumData".
You can move your R session to this folder using R's "set working directory command": `setwd(humdrumRroot)`.
Once you're in the humdrumR directory, you can use the base R `dir` function to see what humdrum data is available to you.

```{r}
library(humdrumR)

setwd(humdrumRroot)

dir('HumdrumData')

```


It looks like there are `r humdrumR:::num2word(length(dir('HumdrumData')))` folders of humdrum data available to you.
Using `dir` again, we can look inside one: let's start with the 'BachChorales' folder.

```{r}

dir('HumdrumData/BachChorales')

```


There are `r humdrumR:::num2word(length(dir('HumdrumData/BachChorales')))` files in the folder, named "chor001.krn", "chor002.krn", etc.
These are simple plain humdrum text files, using the `**kern` interpretation to represent ten chorales by J.S. Bach.
Take a minute to find the files in your computer's finder/explorer and open them up with a simple text editor.
One of the core philosophies of `r hm` is that we maintain a direct, transparent relationship with our symbolic data---so always take the time to look at your data! 
You can also do this within Rstudio's "Files" pane---in fact, Rstudio will make things extra easy for you because you can (within the Files pane) click "More" > "Go To Working Directory" to quickly find the files.




### Reading humdrum data

Now that we've found some humdrum data to look at, let's read it into `r hm`.
We can do this using `r hm`'s `readHumdrum` command.
Try this:

```{r}

readHumdrum('HumdrumData/BachChorales/chor001.krn') -> chor1

```

This command does two things:

1. The `readHumdrum` function will read the "chor001.krn" file into R and create a `r hm` data object from it.
2. This new object will be saved to a variable called `chor1`. (The name 'chor1' is just a name I chose---you are welcome to give it a different name if you want.)

Once we've created our `chor1` object (or whatever you chose to call it), we can take a quick look at what it is by just typing its name on the command line and pressing enter:

```{r}

chor1

```

(In R, when you enter something on the command line, R "prints" it out for you to read.)
The print-out you see shows you the name of the file, the contents of the file, and some stuff about "Data fields" that you will learn about soon.

Cool! Still, looking at a single humdrum file is not really that exciting. 
The whole point of using computers is working with large amounts of data.
Luckily, `r hm` makes this very easy.
Check out this next command:

```{r}

readHumdrum('HumdrumData/BachChorales/chor0') -> chorales
```

Notice that all I've changed is that instead of writing `'chor001.krn'`, I wrote `'chor0'`.
When we feed the string `'chor0'` to `readHumdrum`, it won't just look for a file called "chor0"; it will read *any* file in that folder whose name contains the substring "chor0"---which in this case is all ten files!
Try printing the new `chorales` object to see how it is different.

```{r}

chorales

```

Wow! We've now got a "humdrumR corpus of `r humdrumR:::num2word(length(chorales)) ` pieces"---and that's nothing: `readHumdrum` will work just as well reading hundreds or thousands of files!
Notice that when you print a `r hm` object, `r hm` shows you the beginning of the first file and the end of the last file, as well as telling you how many files there are in total.


---

`readHumdrum` has a number of other cool options which you can read about in more detail in our [humdrumR read/write tutorial](ReadWrite.html "Reading and writing data with humdrumR").


# Counting Things

The most fundamental analysis in computational musicology, is simply to count things!
To count the contents of data, we can use the `tally()` function.

```{r}
chorales |> 
  tally() 

```

That's quite a mess! What have we done?
When we passes or humdrumR data object (`chorales`) to `tally()`, tally counted all the unique data tokens (ignoring non-data tokens, like barline and interpretations).
There are a lot of unique tokens in this data, so it's not super helpful.
Maybe we'd like to look at just the twenty most common tokens in the `chorales`?
We can use `sort()` and `tail()`:


```{r echo=-1}
chorales |>  tally() |> sort() |> tail(n = 1) -> most

chorales |> 
  tally() |>
  sort() |>
  tail(n = 20)

```

Ah, that's more promising! We see that most common token is a quarter-note E4 (`4e`), which occurs `r most` times.

## Separating pitch and rhythm

To make our tallies more useful, we might want to tally only the pitch of rhythm part of the `**kern` data.
We can do that using `r hm`'s suit of [pitch](https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/pitchFunctions.html) and [rhythm](https://computational-cognitive-musicology-lab.github.io/humdrumR/reference/rhythmFunctions.html) functions.
For example, let's try the `pitch()` function:


```{r}
chorales |> 
  pitch()

```

Ah, the `**kern` tokens have been translated to scientific pitch, and the non-pitch information has been deleted!
Let's pass that to tally:

```{r}
chorales |>
  pitch() |>
  tally()


```

Pretty cool, but maybe we'd like to ignore octave right now:
We can use the `simple` argument to get *simple* pitch information (no octave) and make a barplot:

```{r}
chorales |>
  pitch(simple = TRUE) |>
  tally() |>
  draw()

```

Instead of pitch, we could do the same sort of tallying of rhythm information:

```{r}

chorales |>
  notehead() |>
  tally() |>
  draw()

```

## Filtering

Sometimes, we might only want to look at a subset of our data.
For example, maybe we want to tally the notes used by the soprano voice.
In these chorales, the soprano voice is always in the fourth spine.
We can use the `filter()` function to indicate a subset we'd like to study:

```{r}

chorales |> 
  pitch(simple = TRUE) |> 
  filter(Spine == 4) |>
  tally()

```

Let's try something even cooler.
Notice that, in the chorale data, there are tandem interpretations that look like `*G:` and `*E:`.
These are indications of the key.
Anytime you read humdrum data that has these key interpretations, `r hm` will read them into a "field" called `Key`.
We can tell `r hm` to show us the `Key` field (or any other field) by using `select()`:

```{r}
chorales |>
  select(Key)

chorales |> 
  select(Key) |>
  tally()
```

We can even tally the `Key` field to see what keys are present.
There are (apparently) 1160 notes when the key is G major!
What if we only want to tabulate notes in the key that key?

```{r}

chorales |>
  select(Token) |>
  filter(Key == 'G:') |>
  pitch(simple = TRUE) |>
  tally()

```

Guess what? There are a bunch more "fields" hidden in your humdrumR data object that you can use...and you can make your own!
Try using the `fields()` function to see what fields are available---any of the fields you see can be selected with `select()`.
Also, check out the [HumdrumR Data Model](HumdrumR's data model DataModel.html) vignette to dig into the details of what these "fields" really are.

# Digging in Deeper

What if we want to study rhythm and pitch (or key, or anything else) at the same time?
Using the approach we've been using so far, we can only really look at one piece of information at a time.
However, if we string some of our previous commands together we can make some magic:

```{r}
chorales |>
  pitch(simple = TRUE) |>
  select(Token) |>
  recip() -> chorales

chorales

```

We called `pitch()` like before, but then we selected `Token`---"Token" is the default data field in `r hm`---the original tokens from your data files you read.
By calling `select(Token)` we sort of "reset" our selection to the original data.
We can then call `recip()` to get the rhythm data, and then we assign (`->`) the dataset back to replace the `chorales` variable---this "saves" what we've done.
The result is we now have a dataset with *three* "data fields": `r humdrumR:::harvard(fields(chorales, 'Data')$Name, 'and')`.
We can select any of these three:

```{r}

chorales |> select(Pitch)
chorales |> select(Recip)

chorales |> select(Pitch, Recip)

```

We can "see" that all three of these data fields are present in our data, at your finger tips.


```{r}
chorales |> 
  select(Pitch, Recip) |>
  tally()

```

# The Data Model

To really make use of `r hm`, you need to understand a bit about how humdrum data is represented in the `r hm` package: the `r hm` "**data model**."

The essential thing to understand is how it maps between the [humdrum data syntax](https://humdrum.org) and a R data.table.

![](images/DataModelDiagram.png){width=600px}

To fully understand this, you should start with at least a basic understanding of the humdrum syntax! 
Read about the syntax at [humdrum.org](humdrum.org) or check out [our vignette](HumdrumSyntax.html "The Humdrum Syntax") on the topic.

## data.frames

Data.frames are essential to R.
A data.frame is simply a two-dimensional table of named columns.
Each column is either a vector or list of values, all of which are the same length.

`r Hm` makes use of a popular extension of base-R data.frames, the [data.table](https://cran.r-project.org/web/packages/data.table/index.html).


In `r hm`, *every* single, individual token in a collection of humdrum-syntax text files is given its own row in a data.frame.
For example, consider this simple, humdrum-syntax file:


```{r echo=FALSE, results='none'}

ex1 <- readLines('examples/BasicExample.krn')

rest <- ex1[-1]
tokens <- c(ex1[1], unlist(strsplit(rest, split = '\t| ')))

##
ex1df <- as.data.frame(t(stringi::stri_list2matrix(strsplit(rest, '\t'))), stringsAsFactors = FALSE)

cat(' ', sep = '', ex1[1], '\n')
apply(format.data.frame(ex1df, justify = 'left', width = 30), 1, 
      function(x) cat(' ', x, sep = '', '\n')) 


```

This file contains `r humdrumR:::num2word(length(tokens))` individual tokens.
To illustrate, here I'll print the same file, but with *each* token bracketed by `<` and `>`:

```{r echo = FALSE}

printquoted <- function(ex) {
quoted <- ex
    quoted[] <- lapply(quoted,
                   function(col) {
                       col <- strsplit(col, split = ' ')
                       col <- lapply(col,  function(x) paste0('<', x, '>'))
                       sapply(col, paste, collapse = ' ')
                       
                   })


cat('<', ex1[1], '>', '\n', sep ='')
apply(format.data.frame(quoted, justify = 'left', width = 30), 1, 
      function(x) cat(x, sep = '', '\n'))
    invisible(NULL)
}

printquoted(ex1df)

```

So what happens when `r hm` reads this file?
(This file is bundled with `r hm` in the `"humdrumRroot/examples"` directory.)

```{r}

example1 <- readHumdrum('examples/BasicExample.krn')

example1
```

We see the same thing we saw earlier, when we were reading real humdrum data from the `"HumdrumData"` folder.
But what's under the hood?
We can tell `r hm` that we'd like to see the underlying humdrum table by changing `r hm`'s print options using the `humdrumR()` command.
Specifically, we can set `view = "table"`:



```{r}

humdrumR(view = 'table')
example1

```


Use `humdrumR(view = 'humdrum')` to switch back to the humdrum-data view:

```{r}
humdrumR('humdrum')
example1

```

Since `view` is the first argument of `humdrumR()`, you can just type:

```{r}
humdrumR("table")
```

Ah, now we see that there is one row for *each and every* token.
There are columns indicating which `File`, `Spine`, and `Record` each token comes from.
In `r hm`, we refer to these columns as **fields**.
However, there are actually many more columns/fields in our table!---`r hm` is just showing us a few.
To learn what fields are in a `r hm` object, use the `fields` command:

```{r}
fields(example1)
```

We see that there are `r humdrumR:::num2word(length(example1))` fields (columns), and that they are divided into five types of fields: 

+ Data fields
+ Structure fields
+ Interpretation fields
+ Form fields
+ Reference fields

(A good place to read the details about what all the columns means is the *humdrum table* documentation you can get by calling `?humTable`.)


Let's go back to the Bach chorales dataset we loaded earlier (we saved it as `chorales`):

```{r}
fields(chorales)

```

The `chorales` corpus has `r nrow(fields(chorales))` fields!---all the same fields as `example1`, but some additional ones.
These additional fields are interpretation and reference records that didn't appear in our toy `example1`.

----

### Main Fields

The most important fields that are always present in a `r hm` humtable are 1) the `Token` field which contains the original `character` tokens read from the humdrum data; and 2) the "Structural" fields which tell us where in the original humdrum data each token came from.
The "Structural" fields are what allow `r hm` to (re)construct the original humdrum data---translating between the humdrum-table (`data.table`) and the plain-text humdrum syntax.

What if we want to see some of these other fields?
We can use the `select()` command to pick which fields we view:

```{r}

chorales |> select(Token, Spine, COM, Bar)

```

We can also see all fields of a particular type, by specifying one of the types that the [fields()] function 
showed us: for example, `"Data"`, `"Structure"`, or `"Reference"`.

```{r}
chorales |> select(Structure)

```


We can fully *extract* any field from our `r hm` data using the `$` operator: Just call your `r hm` data object with `$` and the name of a field.


```{r}

example1$Spine
example1$Record

example1$Type

example1$Filename

```

The "record types" are:

+ `"G"`: global comment (including reference records)
+ `"L"`: local comment
+ `"I"`: interpretation
+ `"M"`: measure (i.e., barlines)
+ `"D"`: (non-null) data token
+ `"d"`: null data token (`"."`)




### Stops

In humdrum syntax, multiple tokens can be placed "in the same place" (i.e., same record, same spine) by simply separating them with spaces.
(This is most commonly used to represent chords in `**kern` data.)
In `r hm`, we call these "Stops"---as always, **every** humdrum token, including stops, get their own row in a `r hm` humtable.
Thus, we need the `Stop` field to tell us which stop a token came from!
In much data, all/most tokens are simply `Stop == 1` (the first position), but if there are more than one tokens in the same record/spine, they will be numbered ascending from one:

Let's look at an example to make sense of this!
Let's start by looking at our humdrum-data view.

```{r}
humdrumR('humdrum')
stops <- readHumdrum('examples/Stops.krn')

stops
```


Here we have a file with chords in the second spine: individual note tokens separated by spaces.
Now, we can switch back to table view:

```{r}
humdrumR('table')
stops

```

You can see that each note of the chords gets its own row, numbered `1`, `2`, and `3` in the `Stop` field!



### Paths



Some humdrum data contains "spine paths"---places where a single spine splits into two.
`r hm` treats spine paths as "subspines" of the main spine which they split from, each one numbered in the `Path` field.
The starting path (leftmost) is numbered path `0`---in datasets with no spine paths, the `Path` field will be all zeros.
Other paths are numbered with higher integers.

Let's look at a simple example:

```{r}

humdrumR('humdrum')
paths1 <- readHumdrum('examples/Paths.krn')

paths1

humdrumR('table')

paths1

```


Here is a more complex example:

```{r}

paths2 <- readHumdrum('examples/Paths2.krn')

paths2





```

Notice that `r hm` prints paths in a way that is more readable than reading humdrum syntax directly:
paths are "shifted" over into columns that align.
This is an option to the function `as.matrix.humdrumR()`.




# Doing Stuff!

Ok, we've now seen how to read and inspect `r hm` data.
We've also got some idea of what the humdrum data looks like under the surface: the humdrum table.
What can we do with it?

When you create a `r hm` corpus object, using `readHumdrum`, this object encapsulates a humdrum-table (`data.table`) object, which is where the data is really stored.
We've already seen that you can view the humdrum table directly by calling `humdrumR('table')`.
However, what the `r hm` object does is give us some convenient ways of working with that table.


The main thing `r hm` does is allow us to work with the fields of our humdrum-tables in way that is convenient and powerful.
First, we create special R "*expressions*" that refer to the humdrum-table's fields.
For instance, I can write things like:

+ `Spine + File`
+ `nchar(Token)`
+ `paste0(Token, Record)`


However, we can tell `r hm` to evaluate these expressions using the fields of our humdrum tables.
These simplest way is by piping our data to the `mutate()` function, which takes a `r hm` object and an expression on its right side.


```{r}

chorales |>
  mutate(Spine + File)

chorales |>
  mutate(nchar(Token))

chorales |>
  mutate(paste0(Token, Record))

```

Each expression is evaluated, and the result is put back in the same place in the humdrum data!
You'll also notice that in the printout, we see new `Data` fields corresponding to each expression we evaluated.

If you want, you can pick your own names by using `=` within the `mutate` call.
For instance, lets use `r hm`'s `semits` function (see the [humdrum pitch](PitchAndTonality.html) vignette) to calculate the semitone value for each pitch in the chorales:

```{r}

chorales |> 
  mutate(semits(Token))


```

It worked!
Lets do it again, but save the result in a new field, which we will call `Semits`---of course, you could give it any name you want, or just let it use the default name.

```{r}

chorales |> 
  mutate(Semits = semits(Token)) -> chorales

chorales

```

There is now a new Data field in our humdrum table, called `Semits`.
Meanwhile, the original `Token` field is still there, safely unchanged!
Just like before, we can use `select()` operator to look at our fields:

```{r}

chorales |> select(Token)

chorales |> select(Semits)

```

Whats more, we can use the `Semits` field *just* like any other field:

```{r}

chorales |>
  mutate(paste0(Token, ' = ', Semits))



```



## Counting stuff

The most basic step in computational musicology is...counting things!
A simple function for tallying (counting) the elements of vectors is called `tally()`.
In this case, we don't want to "mutate" our data to create a new field; rather, we want to tally the data and 
get the result.
To "pull out" data from a `r hm` object, use the `pull()` function:

```{r}

chorales |>
  pull(tally(Token))



```

We get a count of every unique data token in the dataset.
That's a little messy.
Let's use `r hm`'s `kern()` function to extract just the simple pitch information, and tabulate that instead:

```{r}

chorales |>
  pull(kern(Token, simple = TRUE)) |>
  tally()


```

Much easier to read...but a plot would be even better.
R has a good basic function called `barplot()`:


```{r}

chorales |>
  pull(kern(Token, simple = TRUE)) |>
  tally() |>
  barplot()


```

Remember our `Semits` field that we made earlier?
Maybe we'd like to see a histogram of those values---let's use R's `hist()` function:


```{r}

chorales |>
  pull(Semits) |>
  hist()



```

# What next?

You've gotten started, but there is much more to learn!
To keep learning check out the other articles on the [humdrumR webpage](https://computational-cognitive-musicology-lab.github.io/humdrumR/).
If you want to continue along the path we've started here, the next articles to check out are probably 
[Getting to know your data](Summary.html "Getting to know your data"),
[Filtering humdrum data](Filtering.html "Filtering humdrum data"), and 
[Working with humdrum data](WorkingWithData.html "Working with humdrum data").
Since most musicological analysis involves pitch or rhythm, you'll probably want to learn about
relevant ideas from the [Pitch and tonality](PitchAndTonality.html "Pitch and tonality in humdrumR")
and [Rhythm and meter](RhythmAndMeter.html "Rhythm and meter in humdrumR") articles.

If the humdrum data you are working with is complex---e.g., including multiple different exclusive interpretations,
spine paths, or multi-stops---you'll probably find you need to check out the [Shaping humdrum data](Reshaping.html "Shaping humdrum data") article, which will
give you tools to deal with with more complex humdrum data sets.



