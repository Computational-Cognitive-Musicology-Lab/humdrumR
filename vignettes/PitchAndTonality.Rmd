---
title: Pitch and tonality in humdrumR
author: "Nathaniel Condit-Schultz"
date:   "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Pitch and tonality in humdrumR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE, message=FALSE, echo = FALSE }
knitr::opts_chunk$set(
  collapse = TRUE, message = FALSE,
  comment = ">\t")
hm <- "humdrum$_{\\mathbb{R}}$"
Hm <- "Humdrum$_{\\mathbb{R}}$"
library(humdrumR)
par(mar=c(1,1,1,1))

pitchFunctions <- humdrumR:::pitchFunctions
```


As a computational musicology toolkit, `r hm`'s tools for analyzing and manipulating pitch data are just about the most important tools in the toolbox.
For the most part, `r hm`'s pitch tools are focused on the Western system of tonality, and tools for representing pitches in a tonal context are the focus of *this* vignette---we also have standard tools for looking at pitch from a Western, 12-tone atonal setting as well.


# Pitches and Intervals


`r Hm` defines a suite of pitch functions, like `kern`, `solfa`, `interval`, and `semits`.
These functions all work in essentially the same way: they take in an input argument and output pitch information in their own particular format.
For example,

```{r}

input <- c('4.c', '8d', '4e', '2.g')

kern(input)
interval(input)
semits(input)
solfa(input)

```


Notice that the functions all recognize the pitch part of these input tokens, ignoring the non-pitch (rhythm) information.
If you want to keep the non-pitch part of your tokens, use the `inPlace` argument:

```{r}

input <- c('4.c', '8d', '4e', '2.g')

kern(input, inPlace = TRUE)
interval(input, inPlace = TRUE)
semits(input, inPlace = TRUE)
solfa(input, inPlace = TRUE)

```


The cool thing is that each of these functions can read any of the other function's output.
So you can do things like:

```{r}


kern('Cb6')

pitch("eee-")

pitch(-4) # semio

kern('-4')

solfa('A#6')

semits('Ab3')



```



----

The complete list of basic pitch functions is: 

```{r results = 'asis', echo = FALSE}

pfs <- rapply(humdrumR:::pitchFunctions, 
                \(func) paste0('    + `', 
                                ifelse(humdrumR:::.names(func) == '', func, paste0(humdrumR:::.names(func))), 
                                '`', ifelse(humdrumR:::.names(func) == '', '', paste0(' (', func, ')'))), how = 'list')

pfs <- lapply(pfs, \(top) Map(\(name, pf) paste(c(paste0('  + *', name, ' pitch representations*'), pf), collapse = '\n'), names(top), top))

pfs <- Map(\(name, l) paste(c(paste0('+ **', name, ' pitch representations**'), unlist(l)), collapse ='\n'), names(pfs), pfs)
cat(unlist(pfs), sep = '\n')


```


#### Documentation

The global documentation for *all* the pitch functions can be seen by calling `?pitchFunctions`.
You can also call documentation for any individual function, like `?kern`.

# Pitch arguments

## Generic and Simple pitch

All pitch functions accept logical (`TRUE`/`FALSE`) `generic` and `simple` arguments.

### Simple vs Compound

By default, most pitch functions complete full pitch information, including octave information ("[compound intervals](https://en.wikipedia.org/wiki/Interval_(music)#Simple_and_compound)").
However, if you specify `simple = TRUE`, the octave information is discarded, leaving only the simple part of the pitch
information. 
(You can alternately specify `compound = FALSE`).

```{r}

input <- c('c', 'dd#', 'G', 'GG', 'GGG-')

rbind(kern(input, simple = FALSE), kern(input, simple = TRUE))
rbind(interval(input, simple = FALSE), interval(input, simple = TRUE))
rbind(semits(input, compound = TRUE), semits(input, compound = FALSE))
rbind(solfa(input, compound = TRUE), solfa(input, compound = FALSE))

```

## Generic vs Specific

By default, most pitch functions complete full pitch information, including [specific tonal information](https://en.wikipedia.org/wiki/Generic_and_specific_intervals).
"Specific" pitch information is usually specified by [accidentals](https://en.wikipedia.org/wiki/Accidental_(music))
or quality labels.
If we specify `generic = TRUE` (or `specific = FALSE`), accidentals or qualities are not printed.
In the case of pitch representations without excplicit accidentals/qualities (like solfege), the generic version of the
pitch is printed.

```{r}

input <- c('c', 'd#', 'e', 'f#', 'g')

rbind(kern(input, generic = FALSE), kern(input, generic = TRUE))
rbind(interval(input, generic = FALSE), interval(input, generic = TRUE))
rbind(semits(input, specific = TRUE), semits(input, specific = FALSE))
rbind(solfa(input, specific = TRUE), solfa(input, specific = FALSE))


```


